<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    
    <title>nju520.me</title>
    
    <link>http://localhost:4000</link>
    <description>nju520's Blog</description>
    <language>en-uk</language>
    <managingEditor> nju520</managingEditor>
    <atom:link href="rss" rel="self" type="application/rss+xml" />
    
<item>
  <title>谈谈 DSL 以及 DSL 的应用（以 CocoaPods 为例）</title>
  <link>//dsl</link>
  <author>nju520</author>
  <pubDate>2016-10-03T15:45:45+08:00</pubDate>
  <guid>//dsl</guid>
  <description><![CDATA[
  <blockquote>
  <p>最近在公司做了一次有关 DSL 在 iOS 开发中的应用的分享，这篇文章会简单介绍这次分享的内容。</p>

  <p>因为 DSL 以及 DSL 的界定本身就是一个比较模糊的概念，所以难免有与他人观点意见相左的地方，如果有不同的意见，我们可以具体讨论。</p>
</blockquote>

<p>这次文章的题目虽然是谈谈 DSL 以及 DSL 的应用，不过文章中主要侧重点仍然是 DSL，会简单介绍 DSL 在 iOS 开发中（CocoaPods）是如何应用的。</p>

<h2 id="没有银弹">没有银弹？</h2>

<p>1987 年，IBM 大型电脑之父 Fred Brooks 发表了一篇关于软件工程中的论文 <a href="No Silver Bullet—Essence and Accidents of Software Engineering">No Silver Bullet—Essence and Accidents of Software Engineering</a> 文中主要围绕这么一个观点：没有任何一种技术或者方法能使软件工程的生产力在十年之内提高十倍。</p>

<blockquote>
  <p>There is no single development, in either technology or management technique, which by itself promises even one order-of-magnitude improvement within a decade in productivity, in reliability, in simplicity.</p>
</blockquote>

<p>时至今日，我们暂且不谈银弹在软件工程中是否存在（<del>这句话在老板或者项目经理要求加快项目进度时，还是十分好用的</del>），作为一个开发者也不是很关心这种抽象的理论，我们更关心的是开发效率能否有实质的提升。</p>

<p><img src="https://img.nju520.me/2016-10-03-silver-bullet.jpg-1000width" alt="silver-bullet" /></p>

<p>而今天要介绍的 DSL 就可以真正的提升生产力，减少不必要的工作，在一些领域帮助我们更快的实现需求。</p>

<h2 id="dsl-是什么">DSL 是什么？</h2>

<blockquote>
  <p>笔者是在两年以前，在大一的一次分享上听到 DSL 这个词的，但是当时并没有对这个名词有多深的理解与认识，听过也就忘记了，但是最近做的一些开源项目让我重新想起了 DSL，也是这次分享题目的由来。</p>
</blockquote>

<p>DSL 其实是 Domain Specific Language 的缩写，中文翻译为<em>领域特定语言</em>（下简称 DSL）；而与 DSL 相对的就是 GPL，这里的 GPL 并不是我们知道的开源许可证，而是 General Purpose Language 的简称，即<em>通用编程语言</em>，也就是我们非常熟悉的 Objective-C、Java、Python 以及 C 语言等等。</p>

<p><a href="https://en.wikipedia.org/wiki/Domain-specific_language">Wikipedia</a> 对于 DSL 的定义还是比较简单的：</p>

<blockquote>
  <p>A specialized computer language designed for a specific task.</p>

  <p>为了解决某一类任务而专门设计的计算机语言。</p>
</blockquote>

<p>与 GPL 相对，DSL 与传统意义上的通用编程语言 C、Python 以及 Haskell 完全不同。通用的计算机编程语言是可以用来编写任意计算机程序的，并且能表达任何的<strong>可被计算</strong>的逻辑，同时也是 <a href="https://en.wikipedia.org/wiki/Turing_completeness">图灵完备</a> 的。</p>

<blockquote>
  <p>这一小节中的 DSL 指外部 DSL，下一节中会介绍 <a href="#embedded-dsl嵌入式-dsl">内部 DSL/嵌入式 DSL</a></p>
</blockquote>

<p>但是在里所说的 DSL 并不是图灵完备的，它们的<strong>表达能力有限</strong>，只是在特定领域解决特定任务的。</p>

<blockquote>
  <p>A computer programming language of limited expressiveness focused on a particular domain.</p>
</blockquote>

<p>另一个世界级软件开发大师 Martin Fowler 对于领域特定语言的定义在笔者看来就更加具体了，<strong>DSL 通过在表达能力上做的妥协换取在某一领域内的高效</strong>。</p>

<p>而有限的表达能力就成为了 GPL 和 DSL 之间的一条界限。</p>

<h3 id="几个栗子">几个栗子</h3>

<p>最常见的 DSL 包括 Regex 以及 HTML &amp; CSS，在这里会对这几个例子进行简单介绍</p>

<ul>
  <li>Regex
    <ul>
      <li>正则表达式仅仅指定了字符串的 pattern，其引擎就会根据 pattern 判断当前字符串跟正则表达式是否匹配。
  <img src="https://img.nju520.me/2016-10-03-regex.jpg-1000width" alt="regex" /></li>
    </ul>
  </li>
  <li>SQL
    <ul>
      <li>SQL 语句在使用时也并没有真正的执行，我们输入的 SQL 语句最终还要交给数据库来进行处理，数据库会从 SQL 语句中<strong>读取</strong>有用的信息，然后从数据库中返回使用者期望的结果。</li>
    </ul>
  </li>
  <li>HTML &amp; CSS
    <ul>
      <li>HTML 和 CSS 只是对 Web 界面的结构语义和样式进行描述，虽然它们在构建网站时非常重要，但是它们并非是一种编程语言，正相反，我们可以认为 HTML 和 CSS 是在 Web 中的领域特定语言。</li>
    </ul>
  </li>
</ul>

<h3 id="features">Features</h3>

<p>上面的几个🌰明显的缩小了通用编程语言的概念，但是它们确实在自己领域表现地非常出色，因为这些 DSL 就是根据某一个特定领域的特点塑造的；而通用编程语言相比领域特定语言，在设计时是为了解决更加抽象的问题，而关注点并不只是在某一个领域。</p>

<p>上面的几个例子有着一些共同的特点：</p>

<ul>
  <li>没有计算和执行的概念；</li>
  <li>其本身并不需要直接表示计算；</li>
  <li>使用时只需要声明规则、事实以及某些元素之间的层级和关系；</li>
</ul>

<p>虽然了解了 DSL 以及 DSL 的一些特性，但是，到目前为止，我们对于如何构建一个 DSL 仍然不是很清楚。</p>

<h3 id="构建-dsl">构建 DSL</h3>

<p>DSL 的构建与编程语言其实比较类似，想想我们在重新实现编程语言时，需要做那些事情；实现编程语言的过程可以简化为定义语法与语义，然后实现编译器或者解释器的过程，而 DSL 的实现与它也非常类似，我们也需要对 DSL 进行语法与语义上的设计。</p>

<p><img src="https://img.nju520.me/2016-10-03-compiler.png-1000width" alt="compile" /></p>

<p>总结下来，实现 DSL 总共有这么两个需要完成的工作：</p>

<ol>
  <li>设计语法和语义，定义 DSL 中的元素是什么样的，元素代表什么意思</li>
  <li>实现 parser，对 DSL 解析，最终通过解释器来执行</li>
</ol>

<p>以 HTML 为例，HTML 中所有的元素都是包含在尖括号 <code>&lt;&gt;</code> 中的，尖括号中不同的元素代表了不同的标签，而这些标签会被浏览器<strong>解析</strong>成 DOM 树，再经过一系列的过程调用 Native 的图形 API 进行绘制。</p>

<p><img src="https://img.nju520.me/2016-10-03-dom-tree.png-1000width" alt="dom-tree" /></p>

<p>再比如，我们使用下面这种方式对一个模型进行定义，实现一个 ORM 领域的 DSL：</p>

<pre><code class="language-ruby">define :article do
  attr :name
  attr :content
  attr :upvotes, :int

  has_many :comments
end
</code></pre>

<p>在上面的 DSL 中，使用 <code>define</code> 来定义一个新的模型，使用 <code>attr</code> 来为模型添加属性，使用 <code>has_many</code> 建立数据模型中的一对多关系；我们可以使用 DSL 对这段“字符串”进行解析，然后交给代码生成器来生成代码。</p>

<pre><code class="language-swift">public struct Article {
    public var title: String
    public var content: String
    public var createdAt: Date

    public init(title: String, content: String, createdAt: Date)

    static public func new(title: String, content: String, createdAt: Date) -&gt; Article
    static public func create(title: String, content: String, createdAt: Date) -&gt; Article?
    ...
}
</code></pre>

<p>这里创建的 DSL 中的元素数量非常少，只有 <code>define</code> <code>attr</code> 以及 <code>has_many</code> 等几个关键字，但是通过这几个关键字就可以完成在模型层需要表达的绝大部分语义。</p>

<h3 id="设计原则和妥协">设计原则和妥协</h3>

<p>DSL 最大的设计原则就是<strong>简单</strong>，通过简化语言中的元素，降低使用者的负担；无论是 Regex、SQL 还是 HTML 以及 CSS，其说明文档往往只有几页，非常易于学习和掌握。但是，由此带来的问题就是，DSL 中缺乏抽象的概念，比如：模块化、变量以及方法等。</p>

<blockquote>
  <p>抽象的概念并不是某个领域所关注的问题，就像 Regex 并不需要有模块、变量以及方法等概念。</p>
</blockquote>

<p>由于抽象能力的缺乏，在我们的项目规模变得越来越大时，DSL 往往满足不了开发者的需求；我们仍然需要编程语言中的模块化等概念对 DSL 进行补充，以此解决 DSL 并不是真正编程语言的问题。</p>

<p><img src="https://img.nju520.me/2016-10-03-css-sass.jpg-1000width" alt="css-sass" /></p>

<p>在当今的 Web 前端项目中，我们在开发大规模项目时往往不会直接手写 CSS 文件，而是会使用 Sass 或者 Less 为 CSS 带来更强大的抽象能力，比如嵌套规则，变量，混合以及继承等特性。</p>

<pre><code class="language-css">nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}
</code></pre>

<p>也就是说，在使用 DSL 的项目规模逐渐变大时，开发者会通过增加抽象能力的方式，对已有的 DSL 进行拓展；但是这种扩展往往需要重新实现通用编程语言中的特性，所以一般情况下都是比较复杂的。</p>

<h2 id="embedded-dsl嵌入式-dsl">Embedded DSL（嵌入式 DSL）</h2>

<p>那么，是否有一种其它的方法为 DSL 快速添加抽象能力呢？而这也就是这一小节的主题，嵌入式 DSL。</p>

<p>在上一节讲到的 DSL 其实可以被称为外部 DSL；而这里即将谈到的嵌入式 DSL 也有一个别名，内部 DSL。</p>

<p>这两者最大的区别就是，内部 DSL 的实现往往是嵌入一些编程语言的，比如 iOS 的依赖管理组件 CocoaPods 和 Android 的主流编译工具 Gradle，前者的实现是基于 Ruby 语言的一些特性，而后者基于 Groovy。</p>

<p><img src="https://img.nju520.me/2016-10-03-cocoapods.png-1000width" alt="cocoapods" /></p>

<p>CocoaPods 以及其它的嵌入式 DSL 使用了宿主语言（host language）的抽象能力，并且省去了实现复杂语法分析器（Parser）的过程，并不需要重新实现模块、变量等特性。</p>

<p>嵌入式 DSL 的产生其实模糊了框架和 DSL 的边界，不过这两者看起来也没有什么比较明显的区别；不过，DSL 一般会使用宿主语言的特性进行创造，在设计 DSL 时，也不会考虑宿主语言中有哪些 API 以及方法，而框架一般都是对语言中的 API 进行组合和再包装。</p>

<blockquote>
  <p>我们没有必要争论哪些是框架，哪些是 DSL，因为这些争论并没有什么意义。</p>
</blockquote>

<h3 id="rails-和-embedded-dsl">Rails 和 Embedded DSL</h3>

<p>最出名也最成功的嵌入式 DSL 应该就是 Ruby on Rails 了，虽然对于 Rails 是否是 DSL 有争议，不过 Rails 为 Web 应用的创建提供大量的内置的支撑，使我们在开发 Web 应用时变得非常容易。</p>

<p><img src="https://img.nju520.me/2016-10-03-rails.jpeg" alt="rails" /></p>

<h2 id="ruby-dsl-和-ios">Ruby、 DSL 和 iOS</h2>

<blockquote>
  <p>为了保证这篇文章的完整性，这一小节中有的一些内容都出自上一篇文章 <a href="https://github.com/nju520/iOS-Source-Code-Analyze/blob/master/contents/CocoaPods/CocoaPods%20都做了什么？.md">CocoaPods 都做了什么？</a>。</p>
</blockquote>

<p>笔者同时作为 iOS 和 Rails 开发者接触了非常多的 DSL，而在 iOS 开发中最常见的 DSL 就是 CocoaPods 了，而这里我们以 CocoaPods 为例，介绍如何使用 Ruby 创造一个嵌入式 DSL。</p>

<h3 id="why-ruby">Why Ruby？</h3>

<p>看到这里有人可能会问了，为什么使用 Ruby 创造嵌入式 DSL，而不是使用 C、Java、Python 等等语言呢，这里大概有四个原因：</p>

<ul>
  <li>一切皆对象的特性减少了语言中的元素，不存在基本类型、操作符；</li>
  <li>向 Ruby 方法中传入代码块非常方便；</li>
  <li>作为解释执行的语言，eval 模糊了数据和代码的边界；</li>
  <li>不对代码的格式进行约束，同时一些约定减少了代码中的噪音。</li>
</ul>

<h4 id="一切皆对象">一切皆对象</h4>

<p>在许多语言，比如 Java 中，数字与其他的基本类型都不是对象，而在 Ruby 中所有的元素，包括基本类型都是对象，同时也不存在运算符的概念，所谓的 <code>1 + 1</code>，其实只是 <code>1.+(1)</code> 的语法糖而已。</p>

<p>得益于一切皆对象的概念，在 Ruby 中，你可以向任意的对象发送 <code>methods</code> 消息，在运行时自省，所以笔者在每次忘记方法时，都会直接用 <code>methods</code> 来“查阅文档”：</p>

<pre><code class="language-ruby">2.3.1 :003 &gt; 1.methods
 =&gt; [:%, :&amp;, :*, :+, :-, :/, :&lt;, :&gt;, :^, :|, :~, :-@, :**, :&lt;=&gt;, :&lt;&lt;, :&gt;&gt;, :&lt;=, :&gt;=, :==, :===, :[], :inspect, :size, :succ, :to_s, :to_f, :div, :divmod, :fdiv, :modulo, ...]
</code></pre>

<p>比如在这里向对象 <code>1</code> 调用 <code>methods</code> 就会返回它能响应的所有方法。</p>

<p>一切皆对象不仅减少了语言中类型的数量，消灭了基本数据类型与对象之间的边界；这一概念同时也简化了组成语言的元素，这样 Ruby 中只有对象和方法，这两个概念，极大降低了这门语言的复杂度：</p>

<ul>
  <li>使用对象存储状态</li>
  <li>对象之间通过方法通信</li>
</ul>

<h4 id="block">block</h4>

<p>Ruby 对函数式编程范式的支持是通过 block，这里的 block 和 Objective-C 中的 block 有些不同。</p>

<p>首先 Ruby 中的 block 也是一种对象，即 <code>Proc</code> 类的实例，也就是所有的 block 都是 first-class 的，可以作为参数传递，返回。</p>

<p>下面的代码演示了两种向 Ruby 方法中传入代码块的方式：</p>

<pre><code class="language-ruby">def twice(&amp;proc)
	2.times { proc.call() } if proc
end

def twice
	2.times { yield } if block_given?
end
</code></pre>

<p><code>yield</code> 会调用外部传入的 block，<code>block_given?</code> 用于判断当前方法是否传入了 <code>block</code>。</p>

<pre><code class="language-ruby">twice do
	puts "Hello"
end

twice { puts "hello" }
</code></pre>

<p>向 <code>twice</code> 方法传入 block 也非常简单，使用 <code>do</code>、<code>end</code> 或者 <code>{</code>、<code>}</code> 就可以向任何的 Ruby 方法中传入代码块。</p>

<h4 id="eval">eval</h4>

<p>早在几十年前的 Lisp 语言就有了 <code>eval</code> 这个方法，这个方法会将字符串当做代码来执行，也就是说 <code>eval</code> 模糊了代码与数据之间的边界。</p>

<pre><code class="language-ruby">&gt; eval "1 + 2 * 3"
 =&gt; 7
</code></pre>

<p>有了 <code>eval</code> 方法，我们就获得了更加强大的动态能力，在运行时，使用字符串来改变控制流程，执行代码并可以直接利用当前语言的解释器；而不需要去手动解析字符串然后执行代码。</p>

<h4 id="格式和约定">格式和约定</h4>

<p>编写 Ruby 脚本时并不需要像 Python 一样对代码的格式有着严格的规定，没有对空行、Tab 的要求，完全可以想怎么写就怎么写，这样极大的增加了 DSL 设计的可能性。</p>

<p>同时，在一般情况下，Ruby 在方法调用时并不需要添加括号：</p>

<pre><code class="language-ruby">puts "Wello World!"
puts("Hello World!")
</code></pre>

<p>这样减少了 DSL 中的噪音，能够帮助我们更加关心语法以及语义上的设计，降低了使用者出错的可能性。</p>

<p>最后，Ruby 中存在一种特殊的数据格式 <code>Symbol</code>：</p>

<pre><code class="language-ruby">&gt; :symbol.to_s
 =&gt; "symbol"
&gt; "symbol".to_sym
 =&gt; :symbol
</code></pre>

<p>Symbol 可以通过 Ruby 中内置的方法与字符串之间无缝转换。那么作为一种字符串的替代品，它的使用也能够降低使用者出错的成本并提升使用体验，我们并不需要去写两边加上引号的字符串，只需要以 <code>:</code> 开头就能创建一个 Symbol 对象。</p>

<h3 id="podfile-是什么">Podfile 是什么</h3>

<p>对 Ruby 有了一些了解之后，我们就可以再看一下使用 CocoaPods 的工程中的 Podfile 到底是什么了：</p>

<pre><code class="language-ruby">source 'https://github.com/CocoaPods/Specs.git'

target 'Demo' do
	pod 'Mantle', '~&gt; 1.5.1'
	...
end
</code></pre>

<blockquote>
  <p>如果不了解 iOS 开发后者没有使用过 CocoaPods，笔者在这里简单介绍一下这个文件中的一些信息。</p>

  <p><code>source</code> 可以看作是存储依赖元信息（包括依赖的对应的  GitHub 地址）的源地址；</p>

  <p><code>target</code> 表示需要添加依赖的工程的名字；</p>

  <p><code>pod</code> 表示依赖，<code>Mantle</code> 为依赖的框架，后面是版本号。</p>
</blockquote>

<p>上面是一个使用 Podfile 定义依赖的一个例子，不过 Podfile 对约束的描述其实是这样的：</p>

<pre><code class="language-ruby">source('https://github.com/CocoaPods/Specs.git')

target('Demo') do
	pod('Mantle', '~&gt; 1.5.1')
	...
end
</code></pre>

<p>Podfile 中对于约束的描述，其实都可以看作是代码的简写，在解析时会当做 Ruby 代码来执行。</p>

<h3 id="简单搞个-embedded-dsl">简单搞个 Embedded DSL</h3>

<p>使用 Ruby 实现嵌入式 DSL 一般需要三个步骤，这里以 CocoaPods 为例进行简单介绍：</p>

<ul>
  <li>创建一个 Podfile 中“代码”执行的上下文，也就是一些方法；</li>
  <li>读取 Podfile 中的内容到脚本中；</li>
  <li>使用 <code>eval</code> 在上下文中执行 Podfile 中的“代码”；</li>
</ul>

<h4 id="原理">原理</h4>

<p>CocoaPods 对于 DSL 的实现基本上就是我们创建一个 DSL 的过程，定义一系列必要的方法，比如 <code>source</code>、<code>pod</code> 等等，创造一个执行的上下文；然后去读存储 DSL 的文件，并且使用 <code>eval</code> 执行。</p>

<p><strong>信息的传递一般都是通过参数</strong>来进行的，比如：</p>

<pre><code class="language-ruby">source 'https://github.com/CocoaPods/Specs.git'
</code></pre>

<p><code>source</code> 方法的参数就是依赖元信息 <code>Specs</code> 的 Git 地址，在 <code>eval</code> 执行时就会被读取到 CocoaPods 中，然后进行分析。</p>

<h4 id="实现">实现</h4>

<p>下面是一个非常常见的 Podfile 内容：</p>

<pre><code class="language-ruby">source 'http://source.git'
platform :ios, '8.0'

target 'Demo' do
    pod 'AFNetworking'
    pod 'SDWebImage'
    pod 'Masonry'
    pod "Typeset"
    pod 'BlocksKit'
    pod 'Mantle'
    pod 'IQKeyboardManager'
    pod 'IQDropDownTextField'
end
</code></pre>

<p>因为这里的 <code>source</code>、<code>platform</code>、<code>target</code> 以及 <code>pod</code> 都是方法，所以在这里我们需要构建一个包含上述方法的上下文：</p>

<pre><code class="language-ruby"># eval_pod.rb
$hash_value = {}

def source(url)
end

def target(target)
end

def platform(platform, version)
end

def pod(pod)
end
</code></pre>

<p>使用一个全局变量 <code>hash_value</code> 存储 Podfile 中指定的依赖，并且构建了一个 Podfile 解析脚本的骨架；我们先不去完善这些方法的实现细节，先尝试一下读取 Podfile 中的内容并执行 <code>eval</code> 看看会不会有问题。</p>

<p>在 <code>eval_pod.rb</code> 文件的最下面加入这几行代码：</p>

<pre><code class="language-ruby">content = File.read './Podfile'
eval content
p $hash_value
</code></pre>

<p>这里读取了 Podfile 文件中的内容，并把其中的内容当做字符串执行，最后打印 <code>hash_value</code> 的值。</p>

<pre><code class="language-bash">$ ruby eval_pod.rb
</code></pre>

<p>运行这段 Ruby 代码虽然并没有什么输出，但是并没有报出任何的错误，接下来我们就可以完善这些方法了：</p>

<pre><code class="language-ruby">def source(url)
    $hash_value['source'] = url
end

def target(target)
    targets = $hash_value['targets']
    targets = [] if targets == nil
    targets &lt;&lt; target
    $hash_value['targets'] = targets
    yield if block_given?
end

def platform(platform, version)
end

def pod(pod)
    pods = $hash_value['pods']
    pods = [] if pods == nil
    pods &lt;&lt; pod
    $hash_value['pods'] = pods
end
</code></pre>

<p>在添加了这些方法的实现之后，再次运行脚本就会得到 Podfile 中的依赖信息了，不过这里的实现非常简单的，很多情况都没有处理：</p>

<pre><code class="language-bash">$ ruby eval_pod.rb
{"source"=&gt;"http://source.git", "targets"=&gt;["Demo"], "pods"=&gt;["AFNetworking", "SDWebImage", "Masonry", "Typeset", "BlocksKit", "Mantle", "IQKeyboardManager", "IQDropDownTextField"]}
</code></pre>

<p>不过使用 Ruby 构建一个嵌入式 DSL 的过程大概就是这样，使用语言内建的特性来进行创作，创造出一个在使用时看起来并不像代码的 DSL。</p>

<h2 id="写在后面">写在后面</h2>

<p>在最后，笔者想说的是，当我们在某一个领域经常需要解决重复性问题时，可以考虑实现一个 DSL 专门用来解决这些类似的问题。</p>

<p>而使用嵌入式 DSL 来解决这些问题是一个非常好的办法，我们并不需要重新实现解释器，也可以利用宿主语言的抽象能力。</p>

<p>同时，在嵌入式 DSL 扩展了 DSL 的范畴之后，不要纠结于某些东西到底是框架还是领域特定语言，这些都不重要，重要的是，在遇到了某些问题时，我们能否跳出来，使用文中介绍的方法减轻我们的工作量。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="No Silver Bullet—Essence and Accidents of Software Engineering">No Silver Bullet—Essence and Accidents of Software Engineering</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Domain-specific_language">Domain-specific language</a></li>
  <li><a href="http://martinfowler.com/bliki/DomainSpecificLanguage.html">DomainSpecificLanguage</a></li>
  <li><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm">How browsers work</a></li>
</ul>

<h2 id="其它">其它</h2>

<blockquote>
  <p>GitHub Repo：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://nju520.me/dsl</p>
</blockquote>

  ]]></description>
</item>

<item>
  <title>CocoaPods 都做了什么？</title>
  <link>//cocoapods</link>
  <author>nju520</author>
  <pubDate>2016-09-26T14:19:06+08:00</pubDate>
  <guid>//cocoapods</guid>
  <description><![CDATA[
  <p>稍有 iOS 开发经验的人应该都是用过 CocoaPods，而对于 CI、CD 有了解的同学也都知道 Fastlane。而这两个在 iOS 开发中非常便捷的第三方库都是使用 Ruby 来编写的，这是为什么？</p>

<p>先抛开这个话题不谈，我们来看一下 CocoaPods 和 Fastlane 是如何使用的，首先是 CocoaPods，在每一个工程使用 CocoaPods 的工程中都有一个 Podfile：</p>

<pre><code class="language-ruby">source 'https://github.com/CocoaPods/Specs.git'

target 'Demo' do
	pod 'Mantle', '~&gt; 1.5.1'
	pod 'SDWebImage', '~&gt; 3.7.1'
	pod 'BlocksKit', '~&gt; 2.2.5'
	pod 'SSKeychain', '~&gt; 1.2.3'
	pod 'UMengAnalytics', '~&gt; 3.1.8'
	pod 'UMengFeedback', '~&gt; 1.4.2'
	pod 'Masonry', '~&gt; 0.5.3'
	pod 'AFNetworking', '~&gt; 2.4.1'
	pod 'Aspects', '~&gt; 1.4.1'
end
</code></pre>

<p>这是一个使用 Podfile 定义依赖的一个例子，不过 Podfile 对约束的描述其实是这样的：</p>

<pre><code class="language-ruby">source('https://github.com/CocoaPods/Specs.git')

target('Demo') do
	pod('Mantle', '~&gt; 1.5.1')
	...
end
</code></pre>

<blockquote>
  <p>Ruby 代码在调用方法时可以省略括号。</p>
</blockquote>

<p>Podfile 中对于约束的描述，其实都可以看作是对代码简写，上面的代码在解析时可以当做 Ruby 代码来执行。</p>

<p>Fastlane 中的代码 Fastfile 也是类似的：</p>

<pre><code class="language-ruby">lane :beta do
  increment_build_number
  cocoapods
  match
  testflight
  sh "./customScript.sh"
  slack
end
</code></pre>

<p>使用描述性的”代码“编写脚本，如果没有接触或者使用过 Ruby 的人很难相信上面的这些文本是代码的。</p>

<h2 id="ruby-概述">Ruby 概述</h2>

<p>在介绍 CocoaPods 的实现之前，我们需要对 Ruby 的一些特性有一个简单的了解，在向身边的朋友“传教”的时候，我往往都会用优雅这个词来形容这门语言<del>（手动微笑）</del>。</p>

<p>除了优雅之外，Ruby 的语法具有强大的表现力，并且其使用非常灵活，能快速实现我们的需求，这里简单介绍一下 Ruby 中的一些特性。</p>

<h3 id="一切皆对象">一切皆对象</h3>

<p>在许多语言，比如 Java 中，数字与其他的基本类型都不是对象，而在 Ruby 中所有的元素，包括基本类型都是对象，同时也不存在运算符的概念，所谓的 <code>1 + 1</code>，其实只是 <code>1.+(1)</code> 的语法糖而已。</p>

<p>得益于一切皆对象的概念，在 Ruby 中，你可以向任意的对象发送 <code>methods</code> 消息，在运行时自省，所以笔者在每次忘记方法时，都会直接用 <code>methods</code> 来“查文档”：</p>

<pre><code class="language-ruby">2.3.1 :003 &gt; 1.methods
 =&gt; [:%, :&amp;, :*, :+, :-, :/, :&lt;, :&gt;, :^, :|, :~, :-@, :**, :&lt;=&gt;, :&lt;&lt;, :&gt;&gt;, :&lt;=, :&gt;=, :==, :===, :[], :inspect, :size, :succ, :to_s, :to_f, :div, :divmod, :fdiv, :modulo, :abs, :magnitude, :zero?, :odd?, :even?, :bit_length, :to_int, :to_i, :next, :upto, :chr, :ord, :integer?, :floor, :ceil, :round, :truncate, :downto, :times, :pred, :to_r, :numerator, :denominator, :rationalize, :gcd, :lcm, :gcdlcm, :+@, :eql?, :singleton_method_added, :coerce, :i, :remainder, :real?, :nonzero?, :step, :positive?, :negative?, :quo, :arg, :rectangular, :rect, :polar, :real, :imaginary, :imag, :abs2, :angle, :phase, :conjugate, :conj, :to_c, :between?, :instance_of?, :public_send, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :private_methods, :kind_of?, :instance_variables, :tap, :is_a?, :extend, :define_singleton_method, :to_enum, :enum_for, :=~, :!~, :respond_to?, :freeze, :display, :send, :object_id, :method, :public_method, :singleton_method, :nil?, :hash, :class, :singleton_class, :clone, :dup, :itself, :taint, :tainted?, :untaint, :untrust, :trust, :untrusted?, :methods, :protected_methods, :frozen?, :public_methods, :singleton_methods, :!, :!=, :__send__, :equal?, :instance_eval, :instance_exec, :__id__]
</code></pre>

<p>比如在这里向对象 <code>1</code> 调用 <code>methods</code> 就会返回它能响应的所有方法。</p>

<p>一切皆对象不仅减少了语言中类型的不一致，消灭了基本数据类型与对象之间的边界；这一概念同时也简化了语言中的组成元素，这样 Ruby 中只有对象和方法，这两个概念，这也降低了我们理解这门语言的复杂度：</p>

<ul>
  <li>使用对象存储状态</li>
  <li>对象之间通过方法通信</li>
</ul>

<h3 id="block">block</h3>

<p>Ruby 对函数式编程范式的支持是通过 block，这里的 block 和 Objective-C 中的 block 有些不同。</p>

<p>首先 Ruby 中的 block 也是一种对象，所有的 Block 都是 Proc 类的实例，也就是所有的 block 都是 first-class 的，可以作为参数传递，返回。</p>

<pre><code class="language-ruby">def twice(&amp;proc)
	2.times { proc.call() } if proc
end

def twice
	2.times { yield } if block_given?
end
</code></pre>

<blockquote>
  <p><code>yield</code> 会调用外部传入的 block，<code>block_given?</code> 用于判断当前方法是否传入了 <code>block</code>。</p>
</blockquote>

<p>在这个方法调用时，是这样的：</p>

<pre><code class="language-ruby">twice do
	puts "Hello"
end
</code></pre>

<h3 id="eval">eval</h3>

<p>最后一个需要介绍的特性就是 <code>eval</code> 了，早在几十年前的 Lisp 语言就有了 <code>eval</code> 这个方法，这个方法会将字符串当做代码来执行，也就是说 <code>eval</code> 模糊了代码与数据之间的边界。</p>

<pre><code class="language-ruby">&gt; eval "1 + 2 * 3"
 =&gt; 7
</code></pre>

<p>有了 <code>eval</code> 方法，我们就获得了更加强大的动态能力，在运行时，使用字符串来改变控制流程，执行代码；而不需要去手动解析输入、生成语法树。</p>

<h3 id="手动解析-podfile">手动解析 Podfile</h3>

<p>在我们对 Ruby 这门语言有了一个简单的了解之后，就可以开始写一个简易的解析 Podfile 的脚本了。</p>

<p>在这里，我们以一个非常简单的 Podfile 为例，使用 Ruby 脚本解析 Podfile 中指定的依赖：</p>

<pre><code class="language-ruby">source 'http://source.git'
platform :ios, '8.0'

target 'Demo' do
    pod 'AFNetworking'
    pod 'SDWebImage'
    pod 'Masonry'
    pod "Typeset"
    pod 'BlocksKit'
    pod 'Mantle'
    pod 'IQKeyboardManager'
    pod 'IQDropDownTextField'
end
</code></pre>

<p>因为这里的 <code>source</code>、<code>platform</code>、<code>target</code> 以及 <code>pod</code> 都是方法，所以在这里我们需要构建一个包含上述方法的上下文：</p>

<pre><code class="language-ruby"># eval_pod.rb
$hash_value = {}

def source(url)
end

def target(target)
end

def platform(platform, version)
end

def pod(pod)
end
</code></pre>

<p>使用一个全局变量 <code>hash_value</code> 存储 Podfile 中指定的依赖，并且构建了一个 Podfile 解析脚本的骨架；我们先不去完善这些方法的实现细节，先尝试一下读取 Podfile 中的内容并执行会不会有什么问题。</p>

<p>在 <code>eval_pod.rb</code> 文件的最下面加入这几行代码：</p>

<pre><code class="language-ruby">content = File.read './Podfile'
eval content
p $hash_value
</code></pre>

<p>这里读取了 Podfile 文件中的内容，并把其中的内容当做字符串执行，最后打印 <code>hash_value</code> 的值。</p>

<pre><code class="language-ruby">$ ruby eval_pod.rb
</code></pre>

<p>运行这段 Ruby 代码虽然并没有什么输出，但是并没有报出任何的错误，接下来我们就可以完善这些方法了：</p>

<pre><code class="language-ruby">def source(url)
    $hash_value['source'] = url
end

def target(target)
    targets = $hash_value['targets']
    targets = [] if targets == nil
    targets &lt;&lt; target
    $hash_value['targets'] = targets
    yield if block_given?
end

def platform(platform, version)
end

def pod(pod)
    pods = $hash_value['pods']
    pods = [] if pods == nil
    pods &lt;&lt; pod
    $hash_value['pods'] = pods
end
</code></pre>

<p>在添加了这些方法的实现之后，再次运行脚本就会得到 Podfile 中的依赖信息了，不过这里的实现非常简单的，很多情况都没有处理：</p>

<pre><code class="language-ruby">$ ruby eval_pod.rb
{"source"=&gt;"http://source.git", "targets"=&gt;["Demo"], "pods"=&gt;["AFNetworking", "SDWebImage", "Masonry", "Typeset", "BlocksKit", "Mantle", "IQKeyboardManager", "IQDropDownTextField"]}
</code></pre>

<p>CocoaPods 中对于 Podfile 的解析与这里的实现其实差不多，接下来就进入了 CocoaPods 的实现部分了。</p>

<h2 id="cocoapods-的实现">CocoaPods 的实现</h2>

<p>在上面简单介绍了 Ruby 的一些语法以及如何解析 Podfile 之后，我们开始深入了解一下 CocoaPods 是如何管理 iOS 项目的依赖，也就是 <code>pod install</code> 到底做了些什么。</p>

<h3 id="pod-install-的过程">Pod install 的过程</h3>

<p><code>pod install</code> 这个命令到底做了什么？首先，在 CocoaPods 中，所有的命令都会由 <code>Command</code> 类派发到将对应的类，而真正执行 <code>pod install</code> 的类就是 <code>Install</code>：</p>

<pre><code class="language-ruby">module Pod
  class Command
	class Install &lt; Command
	  def run
		verify_podfile_exists!
		installer = installer_for_config
		installer.repo_update = repo_update?(:default =&gt; false)
		installer.update = false
		installer.install!
	  end
	end
  end
end
</code></pre>

<p>这里面会从配置类的实例 <code>config</code> 中获取一个 <code>Installer</code> 的实例，然后执行 <code>install!</code> 方法，这里的 <code>installer</code> 有一个 <code>update</code> 属性，而这也就是 <code>pod install</code> 和 <code>update</code> 之间最大的区别，<strong>其中后者会无视已有的 Podfile.lock 文件，重新对依赖进行分析</strong>：</p>

<pre><code class="language-ruby">module Pod
  class Command
	class Update &lt; Command
	  def run
		...

		installer = installer_for_config
		installer.repo_update = repo_update?(:default =&gt; true)
		installer.update = true
		installer.install!
	  end
	end
  end
end
</code></pre>

<h3 id="podfile-的解析">Podfile 的解析</h3>

<p>Podfile 中依赖的解析其实是与我们在手动解析 Podfile 章节所介绍的差不多，整个过程主要都是由 <strong>CocoaPods-Core</strong> 这个模块来完成的，而这个过程早在 <code>installer_for_config</code> 中就已经开始了：</p>

<pre><code class="language-ruby">def installer_for_config
  Installer.new(config.sandbox, config.podfile, config.lockfile)
end
</code></pre>

<p>这个方法会从 <code>config.podfile</code> 中取出一个 <code>Podfile</code> 类的实例：</p>

<pre><code class="language-ruby">def podfile
  @podfile ||= Podfile.from_file(podfile_path) if podfile_path
end
</code></pre>

<p>类方法 <code>Podfile.from_file</code> 就定义在 CocoaPods-Core 这个库中，用于分析 Podfile 中定义的依赖，这个方法会根据 Podfile 不同的类型选择不同的调用路径：</p>

<pre><code class="language-ruby">Podfile.from_file
`-- Podfile.from_ruby
	|-- File.open
	`-- eval
</code></pre>

<p><code>from_ruby</code> 类方法就会像我们在前面做的解析 Podfile 的方法一样，从文件中读取数据，然后使用 <code>eval</code> 直接将文件中的内容当做 Ruby 代码来执行。</p>

<pre><code class="language-ruby">def self.from_ruby(path, contents = nil)
  contents ||= File.open(path, 'r:utf-8', &amp;:read)

  podfile = Podfile.new(path) do
	begin
	  eval(contents, nil, path.to_s)
	rescue Exception =&gt; e
	  message = "Invalid `#{path.basename}` file: #{e.message}"
	  raise DSLError.new(message, path, e, contents)
	end
  end
  podfile
end
</code></pre>

<p>在 Podfile 这个类的顶部，我们使用 Ruby 的 <code>Mixin</code> 的语法来混入 Podfile 中代码执行所需要的上下文：</p>

<pre><code class="language-ruby">include Pod::Podfile::DSL
</code></pre>

<p>Podfile 中的所有你见到的方法都是定义在 <code>DSL</code> 这个模块下面的：</p>

<pre><code class="language-ruby">module Pod
  class Podfile
	module DSL
	  def pod(name = nil, *requirements) end
	  def target(name, options = nil) end
	  def platform(name, target = nil) end
	  def inhibit_all_warnings! end
	  def use_frameworks!(flag = true) end
	  def source(source) end
	  ...
	end
  end
end
</code></pre>

<p>这里定义了很多 Podfile 中使用的方法，当使用 <code>eval</code> 执行文件中的代码时，就会执行这个模块里的方法，在这里简单看一下其中几个方法的实现，比如说 <code>source</code> 方法：</p>

<pre><code class="language-ruby">def source(source)
  hash_sources = get_hash_value('sources') || []
  hash_sources &lt;&lt; source
  set_hash_value('sources', hash_sources.uniq)
end
</code></pre>

<p>该方法会将新的 <code>source</code> 加入已有的源数组中，然后更新原有的 <code>sources</code> 对应的值。</p>

<p>稍微复杂一些的是 <code>target</code> 方法：</p>

<pre><code class="language-ruby">def target(name, options = nil)
  if options
	raise Informative, "Unsupported options `#{options}` for " \
	  "target `#{name}`."
  end

  parent = current_target_definition
  definition = TargetDefinition.new(name, parent)
  self.current_target_definition = definition
  yield if block_given?
ensure
  self.current_target_definition = parent
end
</code></pre>

<p>这个方法会创建一个 <code>TargetDefinition</code> 类的实例，然后将当前环境系的 <code>target_definition</code> 设置成这个刚刚创建的实例。这样，之后使用 <code>pod</code> 定义的依赖都会填充到当前的 <code>TargetDefinition</code> 中：</p>

<pre><code class="language-ruby">def pod(name = nil, *requirements)
  unless name
	raise StandardError, 'A dependency requires a name.'
  end

  current_target_definition.store_pod(name, *requirements)
end
</code></pre>

<p>当 <code>pod</code> 方法被调用时，会执行 <code>store_pod</code> 将依赖存储到当前 <code>target</code> 中的 <code>dependencies</code> 数组中：</p>

<pre><code class="language-ruby">def store_pod(name, *requirements)
  return if parse_subspecs(name, requirements)
  parse_inhibit_warnings(name, requirements)
  parse_configuration_whitelist(name, requirements)

  if requirements &amp;&amp; !requirements.empty?
	pod = { name =&gt; requirements }
  else
	pod = name
  end

  get_hash_value('dependencies', []) &lt;&lt; pod
  nil
end
</code></pre>

<p>总结一下，CocoaPods 对 Podfile 的解析与我们在前面做的手动解析 Podfile 的原理差不多，构建一个包含一些方法的上下文，然后直接执行 <code>eval</code> 方法将文件的内容当做代码来执行，这样只要 Podfile 中的数据是符合规范的，那么解析 Podfile 就是非常简单容易的。</p>

<h3 id="安装依赖的过程">安装依赖的过程</h3>

<p>Podfile 被解析后的内容会被转化成一个 <code>Podfile</code> 类的实例，而 <code>Installer</code> 的实例方法 <code>install!</code> 就会使用这些信息安装当前工程的依赖，而整个安装依赖的过程大约有四个部分：</p>

<ul>
  <li>解析 Podfile 中的依赖</li>
  <li>下载依赖</li>
  <li>创建 <code>Pods.xcodeproj</code> 工程</li>
  <li>集成 workspace</li>
</ul>

<pre><code class="language-ruby">def install!
  resolve_dependencies
  download_dependencies
  generate_pods_project
  integrate_user_project
end
</code></pre>

<p>在上面的 <code>install</code> 方法调用的 <code>resolve_dependencies</code> 会创建一个 <code>Analyzer</code> 类的实例，在这个方法中，你会看到一些非常熟悉的字符串：</p>

<pre><code class="language-ruby">def resolve_dependencies
  analyzer = create_analyzer

  plugin_sources = run_source_provider_hooks
  analyzer.sources.insert(0, *plugin_sources)

  UI.section 'Updating local specs repositories' do
	analyzer.update_repositories
  end if repo_update?

  UI.section 'Analyzing dependencies' do
	analyze(analyzer)
	validate_build_configurations
	clean_sandbox
  end
end
</code></pre>

<p>在使用 CocoaPods 中经常出现的 <code>Updating local specs repositories</code> 以及 <code>Analyzing dependencies</code> 就是从这里输出到终端的，该方法不仅负责对本地所有 PodSpec 文件的更新，还会对当前 <code>Podfile</code> 中的依赖进行分析：</p>

<pre><code class="language-ruby">def analyze(analyzer = create_analyzer)
  analyzer.update = update
  @analysis_result = analyzer.analyze
  @aggregate_targets = analyzer.result.targets
end
</code></pre>

<p><code>analyzer.analyze</code> 方法最终会调用 <code>Resolver</code> 的实例方法 <code>resolve</code>：</p>

<pre><code class="language-ruby">def resolve
  dependencies = podfile.target_definition_list.flat_map do |target|
	target.dependencies.each do |dep|
	  @platforms_by_dependency[dep].push(target.platform).uniq! if target.platform
	end
  end
  @activated = Molinillo::Resolver.new(self, self).resolve(dependencies, locked_dependencies)
  specs_by_target
rescue Molinillo::ResolverError =&gt; e
  handle_resolver_error(e)
end
</code></pre>

<p>这里的 <code>Molinillo::Resolver</code> 就是用于解决依赖关系的类。</p>

<h4 id="解决依赖关系resolve-dependencies">解决依赖关系（Resolve Dependencies）</h4>

<p>CocoaPods 为了解决 Podfile 中声明的依赖关系，使用了一个叫做 <a href="https://github.com/CocoaPods/Molinillo/blob/master/ARCHITECTURE.md">Milinillo</a> 的依赖关系解决算法；但是，笔者在 Google 上并没有找到与这个算法相关的其他信息，推测是 CocoaPods 为了解决 iOS 中的依赖关系创造的算法。</p>

<p>Milinillo 算法的核心是 <a href="https://en.wikipedia.org/wiki/Backtracking">回溯（Backtracking）</a> 以及 <a href="https://en.wikipedia.org/wiki/Look-ahead_(backtracking)">向前检查（forward check）</a>，整个过程会追踪栈中的两个状态（依赖和可能性）。</p>

<p>在这里并不想陷入对这个算法执行过程的分析之中，如果有兴趣可以看一下仓库中的 <a href="https://github.com/CocoaPods/Molinillo/blob/master/ARCHITECTURE.md">ARCHITECTURE.md</a> 文件，其中比较详细的解释了 Milinillo 算法的工作原理，并对其功能执行过程有一个比较详细的介绍。</p>

<p><code>Molinillo::Resolver</code> 方法会返回一个依赖图，其内容大概是这样的：</p>

<pre><code class="language-ruby">Molinillo::DependencyGraph:[
	Molinillo::DependencyGraph::Vertex:AFNetworking(#&lt;Pod::Specification name="AFNetworking"&gt;),
	Molinillo::DependencyGraph::Vertex:SDWebImage(#&lt;Pod::Specification name="SDWebImage"&gt;),
	Molinillo::DependencyGraph::Vertex:Masonry(#&lt;Pod::Specification name="Masonry"&gt;),
	Molinillo::DependencyGraph::Vertex:Typeset(#&lt;Pod::Specification name="Typeset"&gt;),
	Molinillo::DependencyGraph::Vertex:CCTabBarController(#&lt;Pod::Specification name="CCTabBarController"&gt;),
	Molinillo::DependencyGraph::Vertex:BlocksKit(#&lt;Pod::Specification name="BlocksKit"&gt;),
	Molinillo::DependencyGraph::Vertex:Mantle(#&lt;Pod::Specification name="Mantle"&gt;),
	...
]
</code></pre>

<p>这个依赖图是由一个结点数组组成的，在 CocoaPods 拿到了这个依赖图之后，会在 <code>specs_by_target</code> 中按照 <code>Target</code> 将所有的 <code>Specification</code> 分组：</p>

<pre><code class="language-ruby">{
	#&lt;Pod::Podfile::TargetDefinition label=Pods&gt;=&gt;[],
	#&lt;Pod::Podfile::TargetDefinition label=Pods-Demo&gt;=&gt;[
		#&lt;Pod::Specification name="AFNetworking"&gt;,
		#&lt;Pod::Specification name="AFNetworking/NSURLSession"&gt;,
		#&lt;Pod::Specification name="AFNetworking/Reachability"&gt;,
		#&lt;Pod::Specification name="AFNetworking/Security"&gt;,
		#&lt;Pod::Specification name="AFNetworking/Serialization"&gt;,
		#&lt;Pod::Specification name="AFNetworking/UIKit"&gt;,
		#&lt;Pod::Specification name="BlocksKit/Core"&gt;,
		#&lt;Pod::Specification name="BlocksKit/DynamicDelegate"&gt;,
		#&lt;Pod::Specification name="BlocksKit/MessageUI"&gt;,
		#&lt;Pod::Specification name="BlocksKit/UIKit"&gt;,
		#&lt;Pod::Specification name="CCTabBarController"&gt;,
		#&lt;Pod::Specification name="CategoryCluster"&gt;,
		...
	]
}
</code></pre>

<p>而这些 <code>Specification</code> 就包含了当前工程依赖的所有第三方框架，其中包含了名字、版本、源等信息，用于依赖的下载。</p>

<h4 id="下载依赖">下载依赖</h4>

<p>在依赖关系解决返回了一系列 <code>Specification</code> 对象之后，就到了 Pod install 的第二部分，下载依赖：</p>

<pre><code class="language-ruby">def install_pod_sources
  @installed_specs = []
  pods_to_install = sandbox_state.added | sandbox_state.changed
  title_options = { :verbose_prefix =&gt; '-&gt; '.green }
  root_specs.sort_by(&amp;:name).each do |spec|
	if pods_to_install.include?(spec.name)
	  if sandbox_state.changed.include?(spec.name) &amp;&amp; sandbox.manifest
		previous = sandbox.manifest.version(spec.name)
		title = "Installing #{spec.name} #{spec.version} (was #{previous})"
	  else
		title = "Installing #{spec}"
	  end
	  UI.titled_section(title.green, title_options) do
		install_source_of_pod(spec.name)
	  end
	else
	  UI.titled_section("Using #{spec}", title_options) do
		create_pod_installer(spec.name)
	  end
	end
  end
end
</code></pre>

<p>在这个方法中你会看到更多熟悉的提示，CocoaPods 会使用沙盒（sandbox）存储已有依赖的数据，在更新现有的依赖时，会根据依赖的不同状态显示出不同的提示信息：</p>

<pre><code class="language-ruby">-&gt; Using AFNetworking (3.1.0)

-&gt; Using AKPickerView (0.2.7)

-&gt; Using BlocksKit (2.2.5) was (2.2.4)

-&gt; Installing MBProgressHUD (1.0.0)
...
</code></pre>

<p>虽然这里的提示会有三种，但是 CocoaPods 只会根据不同的状态分别调用两种方法：</p>

<ul>
  <li><code>install_source_of_pod</code></li>
  <li><code>create_pod_installer</code></li>
</ul>

<p><code>create_pod_installer</code> 方法只会创建一个 <code>PodSourceInstaller</code> 的实例，然后加入 <code>pod_installers</code> 数组中，因为依赖的版本没有改变，所以不需要重新下载，而另一个方法的 <code>install_source_of_pod</code> 的调用栈非常庞大：</p>

<pre><code class="language-ruby">installer.install_source_of_pod
|-- create_pod_installer
|	`-- PodSourceInstaller.new
`-- podSourceInstaller.install!
	`-- download_source
	   `-- Downloader.download
		   `-- Downloader.download_request
			   `-- Downloader.download_source
				   |-- Downloader.for_target
				   |   |-- Downloader.class_for_options
				   |   `-- Git/HTTP/Mercurial/Subversion.new
				   |-- Git/HTTP/Mercurial/Subversion.download
				   `-- Git/HTTP/Mercurial/Subversion.download!
					   `-- Git.clone
</code></pre>

<p>在调用栈的末端 <code>Downloader.download_source</code> 中执行了另一个 CocoaPods 组件 <strong>CocoaPods-Download</strong> 中的方法：</p>

<pre><code class="language-ruby">def self.download_source(target, params)
  FileUtils.rm_rf(target)
  downloader = Downloader.for_target(target, params)
  downloader.download
  target.mkpath

  if downloader.options_specific?
	params
  else
	downloader.checkout_options
  end
end
</code></pre>

<p>方法中调用的 <code>for_target</code> 根据不同的源会创建一个下载器，因为依赖可能通过不同的协议或者方式进行下载，比如说 Git/HTTP/SVN 等等，组件 CocoaPods-Downloader 就会根据 Podfile 中依赖的参数选项使用不同的方法下载依赖。</p>

<p>大部分的依赖都会被下载到 <code>~/Library/Caches/CocoaPods/Pods/Release/</code> 这个文件夹中，然后从这个这里复制到项目工程目录下的 <code>./Pods</code> 中，这也就完成了整个 CocoaPods 的下载流程。</p>

<h4 id="生成-podsxcodeproj">生成 Pods.xcodeproj</h4>

<p>CocoaPods 通过组件 CocoaPods-Downloader 已经成功将所有的依赖下载到了当前工程中，这里会将所有的依赖打包到 <code>Pods.xcodeproj</code> 中：</p>

<pre><code class="language-ruby">def generate_pods_project(generator = create_generator)
  UI.section 'Generating Pods project' do
	generator.generate!
	@pods_project = generator.project
	run_podfile_post_install_hooks
	generator.write
	generator.share_development_pod_schemes
	write_lockfiles
  end
end
</code></pre>

<p><code>generate_pods_project</code> 中会执行 <code>PodsProjectGenerator</code> 的实例方法 <code>generate!</code>：</p>

<pre><code class="language-ruby">def generate!
  prepare
  install_file_references
  install_libraries
  set_target_dependencies
end
</code></pre>

<p>这个方法做了几件小事：</p>

<ul>
  <li>生成 <code>Pods.xcodeproj</code> 工程</li>
  <li>将依赖中的文件加入工程</li>
  <li>将依赖中的 Library 加入工程</li>
  <li>设置目标依赖（Target Dependencies）</li>
</ul>

<p>这几件事情都离不开 CocoaPods 的另外一个组件 Xcodeproj，这是一个可以操作一个 Xcode 工程中的 Group 以及文件的组件，我们都知道对 Xcode 工程的修改大多数情况下都是对一个名叫 <code>project.pbxproj</code> 的文件进行修改，而 Xcodeproj 这个组件就是 CocoaPods 团队开发的用于操作这个文件的第三方库。</p>

<h4 id="生成-workspace">生成 workspace</h4>

<p>最后的这一部分与生成 <code>Pods.xcodeproj</code> 的过程有一些相似，这里使用的类是 <code>UserProjectIntegrator</code>，调用方法 <code>integrate!</code> 时，就会开始集成工程所需要的 Target：</p>

<pre><code class="language-ruby">def integrate!
  create_workspace
  integrate_user_targets
  warn_about_xcconfig_overrides
  save_projects
end
</code></pre>

<p>对于这一部分的代码，也不是很想展开来细谈，简单介绍一下这里的代码都做了什么，首先会通过 <code>Xcodeproj::Workspace</code> 创建一个 workspace，之后会获取所有要集成的 Target 实例，调用它们的 <code>integrate!</code> 方法：</p>

<pre><code class="language-ruby">def integrate!
  UI.section(integration_message) do
	XCConfigIntegrator.integrate(target, native_targets)

	add_pods_library
	add_embed_frameworks_script_phase
	remove_embed_frameworks_script_phase_from_embedded_targets
	add_copy_resources_script_phase
	add_check_manifest_lock_script_phase
  end
end
</code></pre>

<p>方法将每一个 Target 加入到了工程，使用 Xcodeproj 修改 <code>Copy Resource Script Phrase</code> 等设置，保存 <code>project.pbxproj</code>，整个 Pod install 的过程就结束了。</p>

<h2 id="总结">总结</h2>

<p>最后想说的是 pod install 和 pod update 区别还是比较大的，每次在执行 pod install 或者 update 时最后都会生成或者修改 <code>Podfile.lock</code> 文件，其中前者并不会修改 <code>Podfile.lock</code> 中<strong>显示指定</strong>的版本，而后者会会无视该文件的内容，尝试将所有的 pod 更新到最新版。</p>

<p>CocoaPods 工程的代码虽然非常多，不过代码的逻辑非常清晰，整个管理并下载依赖的过程非常符合直觉以及逻辑。</p>

<h2 id="其它">其它</h2>

<blockquote>
  <p>Github Repo：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://nju520.me/cocoapods</p>
</blockquote>

  ]]></description>
</item>


  </channel>
</rss>
