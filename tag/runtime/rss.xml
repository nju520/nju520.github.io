<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    
    <title>nju520.me</title>
    
    <link>http://localhost:4000</link>
    <description>nju520's Blog</description>
    <language>en-uk</language>
    <managingEditor> nju520</managingEditor>
    <atom:link href="rss" rel="self" type="application/rss+xml" />
    
<item>
  <title>谈元编程与表达能力</title>
  <link>//metaprogramming</link>
  <author>nju520</author>
  <pubDate>2017-12-10T00:00:00+08:00</pubDate>
  <guid>//metaprogramming</guid>
  <description><![CDATA[
  <p>在这篇文章中，作者会介绍不同的编程语言如何增强自身的表达能力，在写这篇文章的时候其实就已经想到这可能不是一篇有着较多受众和读者的文章。不过作者仍然想跟各位读者分享一下对不同编程语言的理解，同时也对自己的知识体系进行简单的总结。</p>

<p><img src="https://img.nju520.me/2017-12-10-metaprogramming.png" alt="metaprogramming" /></p>

<p>当我们刚刚开始学习和了解编程这门手艺或者说技巧时，一切的知识与概念看起来都非常有趣，随着学习的深入和对语言的逐渐了解，我们可能会发现原来看起来无所不能的编程语言成为了我们的限制，尤其是在我们想要使用一些<strong>元编程</strong>技巧的时候，你会发现有时候语言限制了我们的能力，我们只能一遍一遍地写重复的代码来解决本可以轻松搞定的问题。</p>

<h2 id="元编程">元编程</h2>

<p>元编程（Metaprogramming）是计算机编程中一个非常重要、有趣的概念，<a href="https://en.wikipedia.org/wiki/Metaprogramming">维基百科</a> 上将元编程描述成一种计算机程序可以<strong>将代码看待成数据</strong>的能力。</p>

<blockquote>
  <p>Metaprogramming is a programming technique in which computer programs have the ability to treat programs as their data.</p>
</blockquote>

<p>如果能够将代码看做数据，那么代码就可以像数据一样在运行时被修改、更新和替换；元编程赋予了编程语言更加强大的表达能力，能够让我们将一些计算过程从运行时挪到编译时、通过编译期间的展开生成代码或者允许程序在运行时改变自身的行为。</p>

<p><img src="https://img.nju520.me/2017-12-10-metaprogramming-usage.png" alt="metaprogramming-usage" /></p>

<p>总而言之，<strong>元编程其实是一种使用代码生成代码的方式</strong>，无论是编译期间生成代码，还是在运行时改变代码的行为都是『生成代码』的一种，下面的代码其实就可以看作一种最简单的元编程技巧：</p>

<pre><code class="language-c">int main() {
    for(int i = 0; i &lt; 10; i++) {
        char *echo = (char*)malloc(6 * sizeof(char));
        sprintf(echo, "echo %d", i);
        system(echo);
    }
    return 0;
}
</code></pre>

<p>这里的代码其实等价于执行了以下的 shell 脚本，也可以说这里使用了 C 语言的代码生成来生成 shell 脚本：</p>

<pre><code class="language-shell">echo 0
echo 1
...
echo 9
</code></pre>

<h2 id="编译时和运行时">编译时和运行时</h2>

<p>现代的编程语言大都会为我们提供不同的元编程能力，从总体来看，根据『生成代码』的时机不同，我们将元编程能力分为两种类型，其中一种是编译期间的元编程，例如：宏和模板；另一种是运行期间的元编程，也就是运行时，它赋予了编程语言在运行期间修改行为的能力，当然也有一些特性既可以在编译期实现，也可以在运行期间实现。</p>

<p><img src="https://img.nju520.me/2017-12-10-compile-and-execute.png" alt="compile-and-execute" /></p>

<p>不同的语言对于泛型就有不一样的实现，Java 的泛型就是在编译期间实现的，它的泛型其实是伪泛型，在编译期间所有的泛型就会被编译器擦除（type erasure），生成的 Java 字节码是不包含任何的泛型信息的，但是 C# 对于泛型就有着不同的实现了，它的泛型类型在运行时进行替换，为实例化的对象保留了泛型的类型信息。</p>

<blockquote>
  <p>C++ 的模板其实与这里讨论的泛型有些类似，它会为每一个具体类型生成一份独立的代码，而 Java 的泛型只会生成一份经过类型擦除后的代码，总而言之 C++ 的模板完全是在编译期间实现的，而 Java 的泛型是编译期间和运行期间协作产生的；模板和泛型虽然非常类似，但是在这里提到的模板大都特指 C++ 的模板，而泛型这一概念其实包含了 C++ 的模板。</p>
</blockquote>

<p>虽然泛型和模板为各种编程语言提供了非常强大的表达能力，但是在这篇文章中，我们会介绍另外两种元编程能力：<em>宏</em>和<em>运行时</em>，前者是在编译期间完成的，而后者是在代码运行期间才发生的。</p>

<h2 id="宏macro">宏（Macro）</h2>

<p>宏是很多编程语言具有的特性之一，它是一个将输入的字符串映射成其他字符串的过程，这个映射的过程也被我们称作宏展开。</p>

<p><img src="https://img.nju520.me/2017-12-10-macro-expansion.png" alt="macro-expansion" /></p>

<p>宏其实就是一个在编译期间中定义的展开过程，通过预先定义好的宏，我们可以使用少量的代码完成更多的逻辑和工作，能够减少应用程序中大量的重复代码。</p>

<p>很多编程语言，尤其是编译型语言都实现了宏这个特性，包括 C、Elixir 和 Rust，然而这些语言却使用了不同的方式来实现宏；我们在这里会介绍两种不同的宏，一种是基于文本替换的宏，另一种是基于语法的宏。</p>

<p><img src="https://img.nju520.me/2017-12-10-different-kinds-of-macros.png" alt="different-kinds-of-macros" /></p>

<p>C、C++ 等语言使用基于文本替换的宏，而类似于 Elixir、Rust 等语言的宏系统其实都是基于语法树和语法元素的，它的实现会比前者复杂很多，应用也更加广泛。</p>

<p>在这一节的剩余部分，我们会分别介绍 C、Elixir 和 Rust 三种不同的编程语言实现的宏系统，它们的使用方法、适用范围和优缺点。</p>

<h3 id="c">C</h3>

<p>作者相信很多工程师入门使用的编程语言其实都是 C 语言，而 C 语言的宏系统看起来还是相对比较简单的，虽然在实际使用时会遇到很多非常诡异的问题。C 语言的宏使用的就是文本替换的方式，所有的宏其实并不是通过编译器展开的，而是由预编译器来处理的。</p>

<p><img src="https://img.nju520.me/2017-12-10-preprocessor.png" alt="preprocesso" /></p>

<p>编译器 GCC 根据『长相』将 C 语言中的宏分为两种，其中的一种宏与编程语言中定义变量非常类似：</p>

<pre><code class="language-c">#define BUFFER_SIZE 1024

char *foo = (char *)malloc(BUFFER_SIZE);
char *foo = (char *)malloc(1024);
</code></pre>

<p>这些宏的定义就是一个简单的标识符，它们会在预编译的阶段被预编译器替换成定义后半部分出现的<strong>字符</strong>，这种宏定义其实比较类似于变量的声明，我们经常会使用这种宏定义替代一些无意义的数字，能够让程序变得更容易理解。</p>

<p>另一种宏定义就比较像对函数的定义了，与其他 C 语言的函数一样，这种宏在定义时也会包含一些宏的参数：</p>

<pre><code class="language-c">#define plus(a, b) a + b
#define multiply(a, b) a * b
</code></pre>

<p>通过在宏的定义中引入参数，宏定义的内部就可以直接使用对应的标识符引入外界传入的参数，在定义之后我们就可以像使用函数一样使用它们：</p>

<pre><code class="language-c">#define plus(a, b) a + b
#define multiply(a, b) a * b

int main(int argc, const char * argv[]) {
    printf("%d", plus(1, 2));       // =&gt; 3
    printf("%d", multiply(3, 2));   // =&gt; 6
    return 0;
}
</code></pre>

<p>上面使用宏的代码与下面的代码是完全等价的，在预编译阶段之后，上面的代码就会被替换成下面的代码，也就是编译器其实是不负责宏展开的过程：</p>

<pre><code class="language-c">int main(int argc, const char * argv[]) {
    printf("%d", 1 + 2);    // =&gt; 3
    printf("%d", 3 * 2);    // =&gt; 6
    return 0;
}
</code></pre>

<p>宏的作用其实非常强大，基于文本替换的宏能做到很多函数无法做到的事情，比如使用宏根据传入的参数创建类并声明新的方法：</p>

<pre><code class="language-c">#define pickerify(KLASS, PROPERTY) interface \
    KLASS (Night_ ## PROPERTY ## _Picker) \
    @property (nonatomic, copy, setter = dk_set ## PROPERTY ## Picker:) DKColorPicker dk_ ## PROPERTY ## Picker; \
    @end \
    @implementation \
    KLASS (Night_ ## PROPERTY ## _Picker) \
    - (DKColorPicker)dk_ ## PROPERTY ## Picker { \
        return objc_getAssociatedObject(self, @selector(dk_ ## PROPERTY ## Picker)); \
    } \
    - (void)dk_set ## PROPERTY ## Picker:(DKColorPicker)picker { \
        objc_setAssociatedObject(self, @selector(dk_ ## PROPERTY ## Picker), picker, OBJC_ASSOCIATION_COPY_NONATOMIC); \
        [self setValue:picker(self.dk_manager.themeVersion) forKeyPath:@keypath(self, PROPERTY)];\
        NSMutableDictionary *pickers = [self valueForKeyPath:@"pickers"];\
        [pickers setValue:[picker copy] forKey:_DKSetterWithPROPERTYerty(@#PROPERTY)]; \
    } \
    @end

@pickerify(Button, backgroundColor);
</code></pre>

<p>上面的代码是我在一个 iOS 的开源库 <a href="https://github.com/nju520/DKNightVersion/blob/master/DKNightVersion/DKNightVersion.h#L57-L72">DKNightVersion</a> 中使用的代码，通过宏的文本替换功能，我们在这里创建了类、属性并且定义了属性的 getter/setter 方法，然而使用者对此其实是一无所知的。</p>

<p>C 语言中的宏只是提供了一些文本替换的功能再加上一些高级的 API，虽然它非常强大，但是强大的事物都是一把双刃剑，再加上 C 语言的宏从实现原理上就有一些无法避免的缺陷，所以在使用时还是要非常小心。</p>

<p>由于预处理器只是对宏进行替换，并没有做任何的语法检查，所以在宏出现问题时，编译器的报错往往会让我们摸不到头脑，不知道哪里出现了问题，还需要脑内对宏进行展开分析出现错误的原因；除此之外，类似于 <code>multiply(1+2, 3)</code> 的展开问题导致人和机器对于同一段代码的理解偏差，作者相信也广为人知了；更高级一些的<strong>分号吞噬</strong>、<strong>参数的重复调用</strong>以及<strong>递归引用时不会递归展开</strong>等问题其实在这里也不想多谈。</p>

<pre><code class="language-c">multiply(1+2, 3) // #=&gt; 1+2 * 3
</code></pre>

<h4 id="卫生宏">卫生宏</h4>

<p>然而 C 语言宏的实现导致的另一个问题却是非常严重的：</p>

<pre><code class="language-c">#define inc(i) do { int a = 0; ++i; } while(0)

int main(int argc, const char * argv[]) {
    int a = 4, b = 8;
    inc(a);
    inc(b);
    printf("%d, %d\n", a, b); // =&gt; 4, 9 !!
    return 0;
}
</code></pre>

<blockquote>
  <p>这一小节与卫生宏有关的 C 语言代码取自 <a href="https://en.wikipedia.org/wiki/Hygienic_macro">Hygienic macro</a> 中的代码示例。</p>
</blockquote>

<p>上述代码中的 <code>printf</code> 函数理应打印出 <code>5, 9</code> 然而却打印出了 <code>4, 9</code>，我们来将上述代码中使用宏的部分展开来看一下：</p>

<pre><code class="language-c">int main(int argc, const char * argv[]) {
    int a = 4, b = 8;
    do { int a = 0; ++a; } while(0);
    do { int a = 0; ++b; } while(0);
    printf("%d, %d\n", a, b); // =&gt; 4, 9 !!
    return 0;
}
</code></pre>

<p>这里的 <code>a = 0</code> 按照逻辑应该不发挥任何的作用，但是在这里却覆盖了上下文中 <code>a</code> 变量的值，导致父作用域中变量 <code>a</code> 的值并没有 <code>+1</code>，这其实就是因为 C 语言中实现的宏不是<em>卫生宏</em>（Hygiene macro）。</p>

<p>作者认为卫生宏（Hygiene macro）是一个非常让人困惑的翻译，它其实指一些<strong>在宏展开之后不会意外捕获上下文中标识符的宏</strong>，从定义中我们就可以看到 C 语言中的宏明显不是卫生宏，而接下来要介绍的两种语言的宏系统就实现了卫生宏。</p>

<h3 id="elixir">Elixir</h3>

<p>Elixir 是一门动态的函数式编程语言，它被设计用来构建可扩展、可维护的应用，所有的 Elixir 代码最终都会被编译成二进制文件运行在 Erlang 的虚拟机 Beam 上，构建在 Erlang 上的 Elixir 也继承了很多 Erlang 的优秀特性。然而在这篇文章中并不会展开介绍 Elixir 语言以及它的某些特点和应用，我们只想了解 Elixir 中的宏系统是如何使用和实现的。</p>

<p><img src="https://img.nju520.me/2017-12-10-elixir-logo.png" alt="elixir-logo" /></p>

<p>宏是 Elixir 具有强大表达能力的一个重要原因，通过内置的宏系统可以减少系统中非常多的重复代码，我们可以使用 <code>defmacro</code> 定义一个宏来实现 <code>unless</code> 关键字：</p>

<pre><code class="language-elixir">defmodule Unless do
  defmacro macro_unless(clause, do: expression) do
    quote do
      if(!unquote(clause), do: unquote(expression))
    end
  end
end
</code></pre>

<p>这里的 <code>quote</code> 和 <code>unquote</code> 是宏系统中最重要的两个函数，你可以从字面上理解 <code>quote</code> 其实就是在一段代码的两侧加上双引号，让这段代码变成字符串，而 <code>unquote</code> 会将传入的多个参数的文本<strong>原封不动</strong>的插入到相应的位置，你可以理解为 <code>unquote</code> 只是将 <code>clause</code> 和 <code>expression</code> 代表的字符串当做了返回值。</p>

<pre><code class="language-elixir">Unless.macro_unless true, do: IO.puts "this should never be printed"
</code></pre>

<p>上面的 Elixir 代码在真正执行之前会被替换成一个使用 <code>if</code> 的表达式，我们可以使用下面的方法获得宏展开之后的代码：</p>

<pre><code class="language-elixir">iex&gt; expr = quote do: Unless.macro_unless true, do: IO.puts "this should never be printed"
iex&gt; expr |&gt; Macro.expand_once(__ENV__) |&gt; Macro.to_string |&gt; IO.puts
if(!true) do
  IO.puts("this should never be printed")
end
:ok
</code></pre>

<p>当我们为 <code>quote</code> 函数传入一个表达式的时候，它会将当前的表达式转换成一个抽象语法树：</p>

<pre><code class="language-elixir">{{:., [], [{:__aliases__, [alias: false], [:Unless]}, :macro_unless]}, [],
 [true,
  [do: {{:., [], [{:__aliases__, [alias: false], [:IO]}, :puts]}, [],
    ["this should never be printed"]}]]}
</code></pre>

<p>在 Elixir 中，抽象语法数是可以直接通过下面的 <code>Code.eval_quoted</code> 方法运行：</p>

<pre><code class="language-elixir">iex&gt; Code.eval_quoted [expr]
** (CompileError) nofile:1: you must require Unless before invoking the macro Unless.macro_unless/2
    (elixir) src/elixir_dispatch.erl:97: :elixir_dispatch.dispatch_require/6
    (elixir) lib/code.ex:213: Code.eval_quoted/3
iex&gt; Code.eval_quoted [quote(do: require Unless), expr]
{[Unless, nil], []}
</code></pre>

<p>我们只运行当前的语法树，我们会发现当前的代码由于 <code>Unless</code> 模块没有加载导致宏找不到报错，所以我们在执行 <code>Unless.macro_unless</code> 之前需要先 <code>require</code> 对应的模块。</p>

<p><img src="https://img.nju520.me/2017-12-10-elixir-macro.png" alt="elixir-macro" /></p>

<p>在最开始对当前的宏进行定义时，我们就会发现宏其实输入的是一些语法元素，实现内部也通过 <code>quote</code> 和 <code>unquote</code> 方法对当前的语法树进行修改，最后返回新的语法树：</p>

<pre><code class="language-elixir">defmacro macro_unless(clause, do: expression) do
  quote do
    if(!unquote(clause), do: unquote(expression))
  end
end

iex&gt; expr = quote do: Unless.macro_unless true, do: IO.puts "this should never be printed"
{{:., [], [{:__aliases__, [alias: false], [:Unless]}, :macro_unless]}, [],
 [true,
  [do: {{:., [], [{:__aliases__, [alias: false], [:IO]}, :puts]}, [],
    ["this should never be printed"]}]]}

iex&gt; Macro.expand_once expr, __ENV__
{:if, [context: Unless, import: Kernel],
 [{:!, [context: Unless, import: Kernel], [true]},
  [do: {{:., [],
     [{:__aliases__, [alias: false, counter: -576460752303422687], [:IO]},
      :puts]}, [], ["this should never be printed"]}]]}
</code></pre>

<p>Elixir 中的宏相比于 C 语言中的宏更强大，这是因为它不是对代码中的文本直接进行替换，它能够为我们直接提供操作 Elixir 抽象语法树的能力，让我们能够参与到 Elixir 的编译过程，影响编译的结果；除此之外，Elixir 中的宏还是卫生宏（Hygiene Macro），宏中定义的参数并不会影响当前代码执行的上下文。</p>

<pre><code class="language-elixir">defmodule Example do
  defmacro hygienic do
    quote do
      val = 1
    end
  end
end

iex&gt; val = 42
42
iex&gt; Example.hygienic
1
iex&gt; val
42
</code></pre>

<p>在上述代码中，虽然宏内部的变量与当前环境上下文中的变量重名了，但是宏内部的变量并没有影响上下文中 <code>val</code> 变量的变化，所以 Elixir 中宏系统是『卫生的』，如果我们真的想要改变上下文中的变量，可以使用 <code>var!</code> 来做这件事情：</p>

<pre><code class="language-elixir">defmodule Example do
  defmacro unhygienic do
    quote do
      var!(val) = 2
    end
  end
end

iex&gt; val = 42
42
iex&gt; Example.unhygienic
2
iex&gt; val
2
</code></pre>

<p>相比于使用文本替换的 C 语言宏，Elixir 的宏系统解决了很多问题，例如：卫生宏，不仅如此，Elixir 的宏还允许我们修改当前的代码中的语法树，提供了更加强大的表达能力。</p>

<h3 id="rust">Rust</h3>

<p>Elixir 的宏系统其实已经足够强大了，不止避免了基于文本替换的宏带来的各种问题，我们还可以直接使用宏操作上下文的语法树，作者在一段时间内都觉得 Elixir 的宏系统是接触到的最强大的宏系统，直到开始学习 <a href="https://www.rust-lang.org/en-US/">Rust</a> 才发现更复杂的宏系统。</p>

<p><img src="https://img.nju520.me/2017-12-10-rust-logo.png" alt="rust-logo" /></p>

<p>Rust 是一门非常有趣的编程语言，它是一门有着极高的性能的系统级的编程语言，能够避免当前应用中发生的段错误并且保证线程安全和内存安全，但是这些都不是我们今天想要关注的事情，与 Elixir 一样，在这篇文章中我们仅仅关心 Rust 的宏系统到底是什么样的：</p>

<pre><code class="language-rust">macro_rules! foo {
    (x =&gt; $e:expr) =&gt; (println!("mode X: {}", $e));
    (y =&gt; $e:expr) =&gt; (println!("mode Y: {}", $e));
}
</code></pre>

<p>上面的 Rust 代码定义了一个名为 <code>foo</code> 的宏，我们在代码中需要使用 <code>foo!</code> 来调用上面定义的宏：</p>

<pre><code class="language-rust">fn main() {
    foo!(y =&gt; 3); // =&gt; mode Y: 3
}
</code></pre>

<p>上述的宏 <code>foo</code> 的主体部分其实会将传入的<strong>语法元素</strong>与宏中的条件进行模式匹配，如果匹配到了，就会返回条件右侧的表达式，到这里其实与 Elixir 的宏系统没有太大的区别，Rust 宏相比 Elixir 更强大主要在于其提供了更加灵活的匹配系统，在宏 <code>foo</code> 的定义中使用的 <code>$e:expr</code> 就会匹配一个表达式并将表达式绑定到 <code>$e</code> 这个上下文的变量中，除此之外，在 Rust 中我们还可以组合使用以下的匹配符：</p>

<p><img src="https://img.nju520.me/2017-12-10-rust-macro-matcher-and-example.png" alt="rust-macro-matcher-and-example" /></p>

<p>为了实现功能更强大的宏系统，Rust 的宏还提供了重复操作符和递归宏的功能，结合这两个宏系统的特性，我们能直接使用宏构建一个生成 HTML 的 DSL：</p>

<pre><code class="language-rust">macro_rules! write_html {
    ($w:expr, ) =&gt; (());

    ($w:expr, $e:tt) =&gt; (write!($w, "{}", $e));

    ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) =&gt; {{
        write!($w, "&lt;{}&gt;", stringify!($tag));
        write_html!($w, $($inner)*);
        write!($w, "&lt;/{}&gt;", stringify!($tag));
        write_html!($w, $($rest)*);
    }};
}
</code></pre>

<p>在上述的 <code>write_html</code> 宏中，我们总共有三个匹配条件，其中前两个是宏的终止条件，第一个条件不会做任何的操作，第二个条件会将匹配到的 Token 树求值并写回到传入的字符串引用 <code>$w</code> 中，最后的条件就是最有意思的部分了，在这里我们使用了形如的 <code>$(...)*</code> 语法来<strong>匹配零个或多个相同的语法元素</strong>，例如 <code>$($inner:tt)*</code> 就是匹配零个以上的 Token 树（tt）；在右侧的代码中递归调用了 <code>write_html</code> 宏并分别传入 <code>$($inner)*</code> 和 <code>$($rest)*</code> 两个参数，这样我们的 <code>write_html</code> 就能够解析 DSL 了。</p>

<p>有了 <code>write_html</code> 宏，我们就可以直接使用形如 <code>html[head[title["Macros guide"]]</code> 的代码返回如下所示的 HTML：</p>

<pre><code class="language-html">&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;&lt;/html&gt;
</code></pre>

<blockquote>
  <p>这一节中提供的与 Rust 宏相关的例子都取自 <a href="https://doc.rust-lang.org/book/first-edition/macros.html">官方文档</a> 中对宏的介绍这一部分内容。</p>
</blockquote>

<p>Rust 的宏系统其实是基于一篇 1986 年的论文 <a href="https://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a> 实现的，如果想要深入了解 Rust 的宏系统可以阅读这篇论文；Rust 的宏系统确实非常完备也足够强大，能够做很多我们使用 C 语言宏时无法做到的事情，极大地提高了语言的表达能力。</p>

<h2 id="运行时runtime">运行时（Runtime）</h2>

<p>宏是一种能在程序执行的预编译或者编译期间改变代码行为的能力，通过编译期的处理过程赋予编程语言元编程能力；而运行时，顾名思义一般是指<strong>面向对象</strong>的编程语言在程序运行的某一个时间的上下文，在这里我们想要介绍的运行时可以理解为<strong>能够在运行期间改变对象行为的机制</strong>。</p>

<p><img src="https://img.nju520.me/2017-12-10-phases.png" alt="phases" /></p>

<p>当相应的行为在当前对象上没有被找到时，运行时会提供一个改变当前对象行为的入口，在篇文章中提到的运行时不是广义上的运行时系统，它特指<strong>面向对象语言在方法决议的过程中为外界提供的入口，让工程师提供的代码也能参与到当前的方法决议和信息发送的过程</strong>。</p>

<p>在这一节中，我们将介绍的两个使用了运行时的面向对象编程语言 Objective-C 和 Ruby，它们有着相似的消息发送的流程，但是由于 OOP 模型实现的不同导致方法调用的过程稍微有一些差别；除此之外，由于 Objective-C 是需要通过编译器编译成二进制文件才能执行的，而 Ruby 可以直接被各种解释器运行，所以两者的元编程能力也会受到这一差别的影响，我们会在下面展开进行介绍。</p>

<h3 id="objective-c">Objective-C</h3>

<p>Objective-C 是一种通用的面向对象编程语言，它将 Smalltalk 消息发送的语法引入了 C 语言；ObjC 语言的面向对象模型其实都是运行在 ObjC Runtime 上的，整个运行时也为 ObjC 提供了方法查找的策略。</p>

<p><img src="https://img.nju520.me/2017-12-10-objc-class-hierachy.png" alt="objc-class-hierachy" /></p>

<p>如上图所示，我们有一个 <code>Dog</code> 类的实例，当我们执行了 <code>dog.wtf</code> 方法时，运行时会先向右再向上的方式在整个继承链中查找相应的方法是否存在，如果当前方法在整个继承链中都完全不存在就会进入<strong>动态方法决议</strong>和<strong>消息转发</strong>的过程。</p>

<p><img src="https://img.nju520.me/2017-12-10-objc-message-resolution-and-forwarding.png" alt="objc-message-resolution-and-forwarding" /></p>

<blockquote>
  <p>上述图片取自 <a href="https://hwbnju.com/racdelegateproxy">从代理到 RACSignal</a>，使用时对图片中的颜色以及字号稍作修改。</p>
</blockquote>

<p>当 ObjC 的运行时在方法查找的过程中已经查找到了上帝类 <code>NSObject</code> 时，仍然没有找到方法的实现就会进入上面的流程，先执行的 <code>+resolveInstanceMethod:</code> 方法就是一个可以为当前的类添加方法的入口：</p>

<pre><code class="language-objc">void dynamicMethodIMP(id self, SEL _cmd) { }

+ (BOOL)resolveInstanceMethod:(SEL)aSEL {
    if (aSEL == @selector(resolveThisMethodDynamically)) {
          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:");
          return YES;
    }
    return [super resolveInstanceMethod:aSel];
}
</code></pre>

<p>在这里可以通过 <code>class_addMethod</code> 动态的为当前的类添加新的方法和对应的实现，如果错过了这个入口，我们就进入了消息转发的流程；在这里，我们有两种选择，一种情况是通过 <code>-forwardTargetForSelector:</code> 将当前方法的调用直接转发到其他方法上，另一种就是组合 <code>-methodSignatureForSelector:</code> 和 <code>-forwardInvocation:</code> 两个方法，直接执行一个 <code>NSInvocation</code> 对象。</p>

<pre><code class="language-objc">- (void)forwardInvocation:(NSInvocation *)anInvocation {
    if ([someOtherObject respondsToSelector:[anInvocation selector]]) {
        [anInvocation invokeWithTarget:someOtherObject];
    } else {
        [super forwardInvocation:anInvocation];
    }
}
</code></pre>

<p><code>-forwardTargetForSelector:</code> 方法只能简单地将方法直接转发给其他的对象，但是在 <code>-forwardInvocation:</code> 中我们可以得到一个 <code>NSInvocation</code> 实例，可以自由地选择需要执行哪些方法，并修改当前方法调用的上下文，包括：方法名、参数和目标对象。</p>

<p>虽然 Objective-C 的运行时系统能够为我们提供动态方法决议的功能，也就是某一个方法在编译期间哪怕不存在，我们也可以在运行时进行调用，这虽然听起来很不错，在很多时候我们都可以通过 <code>-performSelector:</code> 调用<strong>编译器看起来不存的方法</strong>，但是作为一门执行之前需要编译的语言，如果我们在 <code>+resolveInstanceMethod:</code> 中确实动态实现了一些方法，但是编译器在编译期间对这一切都毫不知情。</p>

<pre><code class="language-objectivec">void dynamicMethodIMP(id self, SEL _cmd) { }
+ (BOOL)resolveInstanceMethod:(SEL)aSEL {
    NSString *selector = NSStringFromSelector(aSEL);
    if ([selector hasPrefix:@"find"]) {
          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:");
          return YES;
    }
    return [super resolveInstanceMethod:aSel];
}

- (void)func {
    [self findFoo];
    [self findBar];
    [self find];
}
</code></pre>

<p>从 <code>-func</code> 中调用的三个以 <code>find</code> 开头的方法其实会在运行期间添加到当前类上，但是编译器在编译期间对此一无所知，所以它会提示编译错误，在编译期间将可以运行的代码拦截了下来，这样的代码如果跳过编译器检查，直接运行是不会出问题的，但是代码的执行必须通过编译器编译，这一过程是无法跳过的。</p>

<p><img src="https://img.nju520.me/2017-12-10-objc-compile-and-execute.png" alt="objc-compile-and-execute" /></p>

<p>我们只能通过 <code>-performSelector:</code> 方法绕过编译器的检查，不过使用 <code>-performSelector:</code> 会为代码添加非常多的噪音：</p>

<pre><code class="language-objectivec">- (void)func {
    [self performSelector:@selector(findFoo)];
    [self performSelector:@selector(findBar)];
    [self performSelector:@selector(find)];
}
</code></pre>

<p>所以虽然 Objective-C 通过运行时提供了比较强大的元编程能力，但是由于代码执行时需要经过编译器的检查，所以在很多时候我们都没有办法直接发挥运行时为我们带来的好处，需要通过其他的方式完成方法的调用。</p>

<h3 id="ruby">Ruby</h3>

<p>除了 Objective-C 之外，Ruby 也提供了一些相似的运行时修改行为的特性，它能够在运行时修改自身特性的功能还是建立在它的 OOP 模型之上；Ruby 提供了一些在运行期间能够改变自身行为的入口和 API 可以帮助我们快速为当前的类添加方法或者实例变量。</p>

<p><img src="https://img.nju520.me/2017-12-10-ruby-class-hierachy.png" alt="ruby-class-hierachy" /></p>

<p>当我们调用 <code>Dog</code> 实例的一个方法时，Ruby 会先找到当前对象的类，然后在由 <code>superclass</code> 构成的链上查找并调用相应的方法，这是 OOP 中非常常见的，<strong>向右再向上</strong>的方法查找过程。</p>

<p>与 Objective-C 几乎相同，Ruby 也提供了类似与 <code>+resolveInstanceMethod:</code> 的方法，如果方法在整个继承链上都完全不存在时，就会调用 <code>#method_missing</code> 方法，并传入与这次方法调用有关的参数：</p>

<pre><code class="language-ruby">def method_missing(method, *args, &amp;block)
end
</code></pre>

<p>传入的参数包括方法的符号，调用原方法时传入的参数和 block，在这里我们就可以为当前的类添加方法了：</p>

<pre><code class="language-ruby">class Dog
  def method_missing(m, *args, &amp;block)
    if m.to_s.start_with? 'find'
      define_singleton_method(m) do |*args|
        puts "#{m}, #{args}"
      end
      send(m, *args, &amp;block)
    else
      super
    end
  end
end
</code></pre>

<p>通过 Ruby 提供的一些 API，例如 <code>define_method</code>、<code>define_singleton_method</code> 我们可以直接在运行期间快速改变对象的行为，在使用时也非常简单：</p>

<pre><code class="language-ruby">pry(main)&gt; d = Dog.new
=&gt; #&lt;Dog:0x007fe31e3f87a8&gt;
pry(main)&gt; d.find_by_name "dog"
find_by_name, ["dog"]
=&gt; nil
pry(main)&gt; d.find_by_name "dog", "another_dog"
find_by_name, ["dog", "another_dog"]
=&gt; nil
</code></pre>

<p>当我们调用以 <code>find</code> 开头的实例方法时，由于在当前实例的类以及父类上没有实现，所以就会进入 <code>#method_missing</code> 方法并为<strong>当前实例</strong>定义新的方法 <code>#find_by_name</code>。</p>

<blockquote>
  <p>注意：当前的 <code>#find_by_name</code> 方法只是定义在当前实例上的，存储在当前实例的单类上。</p>
</blockquote>

<p>由于 Ruby 是脚本语言，解释器在脚本执行之前不会对代码进行检查，所以哪怕在未执行期间并不存在的 <code>#find_by_name</code> 方法也不会导致解释器报错，在运行期间通过 <code>#define_singleton_method</code> 动态地
定义了新的 <code>#find_by_name</code> 方法修改了对象的行为，达到了为对象批量添加相似功能的目的。</p>

<h2 id="总结">总结</h2>

<p>在文章中介绍的两种不同的元编程能力，宏系统和运行时，前者通过预先定义好的一些宏规则，在预编译和编译期间对代码进行展开和替换，而后者提供了在运行期间改变代码行为的能力，两种方式的本质都是通过少量的代码生成一些非常相似的代码和逻辑，能够增强编程语言的表达能力并减少开发者的工作量。</p>

<p>无论是宏还是运行时其实都是简化程序中代码的一种手段，归根结底就是一种使用代码生成代码的思想，如果我们能够掌握这种元编程的思想并在编程中熟练的运用就能够很好地解决程序中一些诡异的问题，还能消灭重复的代码，提高我们运用以及掌控编程语言的能力，能够极大地增强编程语言的表达能力，所以元编程确实是一种非常重要并且需要学习的思想。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://en.m.wikipedia.org/wiki/Metaprogramming">Metaprogramming</a></li>
  <li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/differences-between-cpp-templates-and-csharp-generics">C++ 模板和 C# 泛型之间的区别（C# 编程指南）</a></li>
  <li><a href="https://www.zhihu.com/question/33304378">C++ 模板和 Java 泛型有什么异同？</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Macro_(computer_science)">Macro (computer science)</a></li>
  <li><a href="https://elixir-lang.org/getting-started/meta/macros.html">Macros · Elixir Doc</a></li>
  <li><a href="https://gcc.gnu.org/onlinedocs/cpp/Macros.html">Macros · GCC</a></li>
  <li><a href="http://hbprotoss.github.io/posts/cyu-yan-hong-de-te-shu-yong-fa-he-ji-ge-keng.html">C 语言宏的特殊用法和几个坑</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Hygienic_macro">Hygienic macro</a></li>
  <li><a href="https://elixirschool.com/en/lessons/advanced/metaprogramming/">Metaprogramming · ElixirSchool</a></li>
  <li><a href="https://doc.rust-lang.org/book/first-edition/macros.html">Macros · Rust Doc</a></li>
  <li><a href="https://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a></li>
  <li><a href="https://www.rust-lang.org/en-US/">Rust</a></li>
  <li><a href="https://hwbnju.com/message">从源代码看 ObjC 中消息的发送</a></li>
  <li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtDynamicResolution.html">Dynamic Method Resolution</a></li>
  <li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1">Message Forwarding</a></li>
  <li><a href="https://hwbnju.com/racdelegateproxy">从代理到 RACSignal</a></li>
  <li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1418500-resolveinstancemethod">resolveInstanceMethod(_:)</a></li>
  <li><a href="http://rubylearning.com/satishtalim/ruby_method_missing.html">Ruby Method Missing</a></li>
  <li><a href="https://www.leighhalliday.com/ruby-metaprogramming-method-missing">Ruby Metaprogramming - Method Missing</a></li>
</ul>


  ]]></description>
</item>

<item>
  <title>iOS 中的 block 是如何持有对象的</title>
  <link>//block-retain-object</link>
  <author>nju520</author>
  <pubDate>2016-08-09T22:02:56+08:00</pubDate>
  <guid>//block-retain-object</guid>
  <description><![CDATA[
  <blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<p>Block 是 Objective-C 中笔者最喜欢的特性，它为 Objective-C 这门语言提供了强大的函数式编程能力，而最近苹果推出的很多新的 API 都已经开始原生的支持 block 语法，可见它在 Objective-C 中变得越来越重要。</p>

<p>这篇文章并不会详细介绍 block 在内存中到底是以什么形式存在的，主要会介绍 block 是如何持有并且释放对象的。文章中的代码都出自 Facebook 开源的<strong>用于检测循环引用</strong>的框架 <a href="https://github.com/facebook/FBRetainCycleDetector">FBRetainCycleDetector</a>，这是分析该框架文章中的最后一篇，也是笔者觉得最有意思的一部分。</p>

<blockquote>
  <p>如果你希望了解 FBRetainCycleDetector 的原理可以阅读<a href="https://github.com/nju520/iOS-Source-Code-Analyze/blob/master/FBRetainCycleDetector/如何在%20iOS%20中解决循环引用的问题.md">如何在 iOS 中解决循环引用的问题</a>以及后续文章。</p>
</blockquote>

<h2 id="为什么会谈到-block">为什么会谈到 block</h2>

<p>可能很多读者会有这样的疑问，本文既然是对 <code>FBRetainCycleDetector</code> 解析的文章，为什么会提到 block？原因其实很简单，因为在 iOS 开发中大多数的循环引用都是因为 block 使用不当导致的，由于 block 会 retain 它持有的对象，这样就很容易造成循环引用，最终导致内存泄露。</p>

<p>在 <code>FBRetainCycleDetector</code> 中存在这样一个类 <code>FBObjectiveCBlock</code>，这个类的 <code>- allRetainedObjects</code> 方法就会返回所有 block 持有的强引用，这也是文章需要关注的重点。</p>

<pre><code class="language-objectivec">- (NSSet *)allRetainedObjects {
	NSMutableArray *results = [[[super allRetainedObjects] allObjects] mutableCopy];

	__attribute__((objc_precise_lifetime)) id anObject = self.object;

	void *blockObjectReference = (__bridge void *)anObject;
	NSArray *allRetainedReferences = FBGetBlockStrongReferences(blockObjectReference);

	for (id object in allRetainedReferences) {
		FBObjectiveCGraphElement *element = FBWrapObjectGraphElement(self, object, self.configuration);
		if (element) {
			[results addObject:element];
		}
	}

	return [NSSet setWithArray:results];
}
</code></pre>

<p>这部分代码中的大部分都不重要，只是在开头调用父类方法，在最后将获取的对象包装成一个系列 <code>FBObjectiveCGraphElement</code>，最后返回一个数组，也就是当前对象 block 持有的全部强引用了。</p>

<h2 id="block-是什么">Block 是什么？</h2>

<p>对 block 稍微有了解的人都知道，block 其实是一个结构体，其结构大概是这样的：</p>

<pre><code class="language-objectivec">struct BlockLiteral {
	void *isa;
	int flags;
	int reserved;
	void (*invoke)(void *, ...);
	struct BlockDescriptor *descriptor;
};

struct BlockDescriptor {
	unsigned long int reserved;
	unsigned long int size;
	void (*copy_helper)(void *dst, void *src);
	void (*dispose_helper)(void *src);
	const char *signature;
};
</code></pre>

<p>在 <code>BlockLiteral</code> 结构体中有一个 <code>isa</code> 指针，而对 <code>isa</code>了解的人也都知道，这里的 <code>isa</code> 其实指向了一个类，每一个 block 指向的类可能是 <code>__NSGlobalBlock__</code>、<code>__NSMallocBlock__</code> 或者 <code>__NSStackBlock__</code>，但是这些 block，它们继承自一个共同的父类，也就是 <code>NSBlock</code>，我们可以使用下面的代码来获取这个类：</p>

<pre><code class="language-objectivec">static Class _BlockClass() {
	static dispatch_once_t onceToken;
	static Class blockClass;
	dispatch_once(&amp;onceToken, ^{
		void (^testBlock)() = [^{} copy];
		blockClass = [testBlock class];
		while(class_getSuperclass(blockClass) &amp;&amp; class_getSuperclass(blockClass) != [NSObject class]) {
			blockClass = class_getSuperclass(blockClass);
		}
		[testBlock release];
	});
	return blockClass;
}
</code></pre>

<p>Objective-C 中的三种 block <code>__NSMallocBlock__</code>、<code>__NSStackBlock__</code> 和 <code>__NSGlobalBlock__</code> 会在下面的情况下出现：</p>

<p><img src="/content/images/2016/08/block-table.png" alt="" /></p>

<ul>
  <li>在 ARC 中，捕获外部了变量的 block 的类会是 <code>__NSMallocBlock__</code> 或者 <code>__NSStackBlock__</code>，如果 block 被赋值给了某个变量在这个过程中会执行 <code>_Block_copy</code> 将原有的 <code>__NSStackBlock__</code> 变成 <code>__NSMallocBlock__</code>；但是如果 block 没有被赋值给某个变量，那它的类型就是 <code>__NSStackBlock__</code>；没有捕获外部变量的 block 的类会是 <code>__NSGlobalBlock__</code> 即不在堆上，也不在栈上，它类似 C 语言函数一样会在代码段中。</li>
  <li>在非 ARC 中，捕获了外部变量的 block 的类会是 <code>__NSStackBlock__</code>，放置在栈上，没有捕获外部变量的 block 时与 ARC 环境下情况相同。</li>
</ul>

<p>如果我们不断打印一个 block 的 <code>superclass</code> 的话最后就会在继承链中找到 <code>NSBlock</code> 的身影：</p>

<p><img src="https://img.nju520.me/2016-08-05-block-superclass.png-1000width" alt="block-superclass" /></p>

<p>然后可以通过这种办法来判断当前对象是不是 block：</p>

<pre><code class="language-objectivec">BOOL FBObjectIsBlock(void *object) {
	Class blockClass = _BlockClass();

	Class candidate = object_getClass((__bridge id)object);
	return [candidate isSubclassOfClass:blockClass];
}
</code></pre>

<h2 id="block-如何持有对象">Block 如何持有对象</h2>

<p>在这一小节，我们将讨论 block 是<strong>如何持有对象</strong>的，我们会通过对 FBRetainCycleDetector 的源代码进行分析最后尽量详尽地回答这一问题。</p>

<p>重新回到文章开头提到的 <code>- allRetainedObjects</code> 方法：</p>

<pre><code class="language-objectivec">- (NSSet *)allRetainedObjects {
	NSMutableArray *results = [[[super allRetainedObjects] allObjects] mutableCopy];

	__attribute__((objc_precise_lifetime)) id anObject = self.object;

	void *blockObjectReference = (__bridge void *)anObject;
	NSArray *allRetainedReferences = FBGetBlockStrongReferences(blockObjectReference);

	for (id object in allRetainedReferences) {
		FBObjectiveCGraphElement *element = FBWrapObjectGraphElement(self, object, self.configuration);
		if (element) {
			[results addObject:element];
		}
	}

	return [NSSet setWithArray:results];
}
</code></pre>

<p>通过函数的符号我们也能够猜测出，上述方法中通过 <code>FBGetBlockStrongReferences</code> 获取 block 持有的所有强引用：</p>

<pre><code class="language-objectivec">NSArray *FBGetBlockStrongReferences(void *block) {
	if (!FBObjectIsBlock(block)) {
		return nil;
	}

	NSMutableArray *results = [NSMutableArray new];

	void **blockReference = block;
	NSIndexSet *strongLayout = _GetBlockStrongLayout(block);
	[strongLayout enumerateIndexesUsingBlock:^(NSUInteger idx, BOOL *stop) {
		void **reference = &amp;blockReference[idx];

		if (reference &amp;&amp; (*reference)) {
			id object = (id)(*reference);

			if (object) {
				[results addObject:object];
			}
		}
	}];

	return [results autorelease];
}
</code></pre>

<p>而 <code>FBGetBlockStrongReferences</code> 是对另一个私有函数 <code>_GetBlockStrongLayout</code> 的封装，也是实现最有意思的部分。</p>

<h3 id="几个必要的概念">几个必要的概念</h3>

<p>在具体介绍 <code>_GetBlockStrongLayout</code> 函数的源代码之前，我希望先对其原理有一个简单的介绍，便于各位读者的理解；在这里有三个概念需要介绍，首先是 block 持有的对象都存在的位置。</p>

<h4 id="如何持有对象">如何持有对象</h4>

<p>在文章的上面曾经出现过 block 的结构体，不知道各位读者是否还有印象：</p>

<pre><code class="language-objectivec">struct BlockLiteral {
	void *isa;
	int flags;
	int reserved;
	void (*invoke)(void *, ...);
	struct BlockDescriptor *descriptor;
	// imported variables
};
</code></pre>

<p>在每个 block 结构体的下面就会存放当前 block 持有的所有对象，无论强弱。我们可以做一个小实验来验证这个观点，我们在程序中声明这样一个 block：</p>

<pre><code class="language-objectivec">NSObject *firstObject = [NSObject new];
__attribute__((objc_precise_lifetime)) NSObject *object = [NSObject new];
__weak NSObject *secondObject = object;
NSObject *thirdObject = [NSObject new];

__unused void (^block)() = ^{
	__unused NSObject *first = firstObject;
	__unused NSObject *second = secondObject;
	__unused NSObject *third = thirdObject;
};
</code></pre>

<p>然后在代码中打一个断点：</p>

<p><img src="https://img.nju520.me/2016-08-05-block-capture-var-layout.png-1000width" alt="block-capture-var-layout" /></p>

<blockquote>
  <p>上面代码中 block 由于被变量引用，执行了 <code>_Block_copy</code>，所以其类型为 <code>__NSMallocBlock__</code>，没有被变量引用的 block 都是 <code>__NSStackBlock__</code>。</p>
</blockquote>

<ol>
  <li>首先打印 block 变量的大小，因为 block 变量其实只是一个指向结构体的指针，所以大小为 8，而结构体的大小为 32；</li>
  <li>以 block 的地址为基址，偏移 32，得到一个指针</li>
  <li>使用 <code>$3[0]</code> <code>$3[1]</code> <code>$3[2]</code> 依次打印地址为 <code>0x1001023b0</code> <code>0x1001023b8</code> <code>0x1001023c0</code> 的内容，可以发现它们就是 block 捕获的全部引用，前两个是强引用，最后的是弱引用</li>
</ol>

<p>这可以得出一个结论：block 将其捕获的引用存放在结构体的下面，但是为什么这里的顺序并不是按照引用的顺序呢？接下来增加几个变量，再做另一次实验：</p>

<p><img src="https://img.nju520.me/2016-08-05-block-capture-strong-weak-order.png-1000width" alt="block-capture-strong-weak-orde" /></p>

<p>在代码中多加入了几个对象之后，block 对持有的对象的布局的顺序依然是<strong>强引用在前、弱引用在后</strong>，我们不妨做一个假设：<strong>block 会将强引用的对象排放在弱引用对象的前面</strong>。但是这个假设能够帮助我们在<strong>只有 block 但是没有上下文信息的情况下</strong>区分哪些是强引用么？我觉得并不能，因为我们没有办法知道它们之间的分界线到底在哪里。</p>

<h4 id="dispose_helper">dispose_helper</h4>

<p>第二个需要介绍的是 <code>dispose_helper</code>，这是 <code>BlockDescriptor</code> 结构体中的一个指针：</p>

<pre><code class="language-objectivec">struct BlockDescriptor {
	unsigned long int reserved;                // NULL
	unsigned long int size;
	// optional helper functions
	void (*copy_helper)(void *dst, void *src); // IFF (1&lt;&lt;25)
	void (*dispose_helper)(void *src);         // IFF (1&lt;&lt;25)
	const char *signature;                     // IFF (1&lt;&lt;30)
};
</code></pre>

<p>上面的结构体中有两个函数指针，<code>copy_helper</code> 用于 block 的拷贝，<code>dispose_helper</code> 用于 block 的 <code>dispose</code> 也就是 block 在析构的时候会调用这个函数指针，销毁自己持有的对象，而这个原理也是区别强弱引用的关键，因为在 <code>dispose_helper</code> 会对强引用发送 <code>release</code> 消息，对弱引用不会做任何的处理。</p>

<h4 id="fbblockstrongrelationdetector">FBBlockStrongRelationDetector</h4>

<p>最后就是用于从 <code>dispose_helper</code> 接收消息的类 <code>FBBlockStrongRelationDetector</code> 了；它的实例在接受 <code>release</code> 消息时，并不会真正的释放，只会将标记 <code>_strong</code> 为 YES：</p>

<pre><code class="language-objectivec">- (oneway void)release {
	_strong = YES;
}

- (oneway void)trueRelease {
	[super release];
}
</code></pre>

<p>只有真正执行 <code>trueRelease</code> 的时候才会向对象发送 <code>release</code> 消息。</p>

<p>因为这个文件覆写了 <code>release</code> 方法，所以要在非 ARC 下编译：</p>

<pre><code class="language-objectivec">#if __has_feature(objc_arc)
#error This file must be compiled with MRR. Use -fno-objc-arc flag.
#endif
</code></pre>

<p>如果 block 持有了另一个 block 对象，<code>FBBlockStrongRelationDetector</code> 也可以将自身 fake 成为一个假的 block 防止在接收到关于 block 释放的消息时发生 crash：</p>

<pre><code class="language-objectivec">struct _block_byref_block;
@interface FBBlockStrongRelationDetector : NSObject {
	// __block fakery
	void *forwarding;
	int flags;   //refcount;
	int size;
	void (*byref_keep)(struct _block_byref_block *dst, struct _block_byref_block *src);
	void (*byref_dispose)(struct _block_byref_block *);
	void *captured[16];
}
</code></pre>

<p>该类的实例在初始化时，会设置 <code>forwarding</code>、<code>byref_keep</code> 和 <code>byref_dispose</code>，后两个方法的实现都是空的，只是为了防止 crash：</p>

<pre><code class="language-objectivec">+ (id)alloc {
	FBBlockStrongRelationDetector *obj = [super alloc];

	// Setting up block fakery
	obj-&gt;forwarding = obj;
	obj-&gt;byref_keep = byref_keep_nop;
	obj-&gt;byref_dispose = byref_dispose_nop;

	return obj;
}

static void byref_keep_nop(struct _block_byref_block *dst, struct _block_byref_block *src) {}
static void byref_dispose_nop(struct _block_byref_block *param) {}
</code></pre>

<h3 id="获取-block-强引用的对象">获取 block 强引用的对象</h3>

<p>到现在为止，获取 block 强引用对象所需要的知识都介绍完了，接下来可以对私有方法 <code>_GetBlockStrongLayout</code> 进行分析了：</p>

<pre><code class="language-objectivec">static NSIndexSet *_GetBlockStrongLayout(void *block) {
	struct BlockLiteral *blockLiteral = block;

	if ((blockLiteral-&gt;flags &amp; BLOCK_HAS_CTOR)
		|| !(blockLiteral-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE)) {
		return nil;
	}

	...
}
</code></pre>

<ul>
  <li>如果 block 有 Cpp 的构造器/析构器，说明它<strong>持有的对象很有可能没有按照指针大小对齐</strong>，我们很难检测到所有的对象</li>
  <li>如果 block 没有 <code>dispose</code> 函数，说明它无法 <code>retain</code> 对象，也就是说我们也没有办法测试其强引用了哪些对象</li>
</ul>

<pre><code class="language-objectivec">static NSIndexSet *_GetBlockStrongLayout(void *block) {
	...
	void (*dispose_helper)(void *src) = blockLiteral-&gt;descriptor-&gt;dispose_helper;
	const size_t ptrSize = sizeof(void *);
	const size_t elements = (blockLiteral-&gt;descriptor-&gt;size + ptrSize - 1) / ptrSize;

	void *obj[elements];
	void *detectors[elements];

	for (size_t i = 0; i &lt; elements; ++i) {
		FBBlockStrongRelationDetector *detector = [FBBlockStrongRelationDetector new];
		obj[i] = detectors[i] = detector;
	}

	@autoreleasepool {
		dispose_helper(obj);
	}
	...
}
</code></pre>

<ol>
  <li>从 <code>BlockDescriptor</code> 取出 <code>dispose_helper</code> 以及 <code>size</code>（block 持有的所有对象的大小）</li>
  <li>通过 <code>(blockLiteral-&gt;descriptor-&gt;size + ptrSize - 1) / ptrSize</code> 向上取整，获取 block 持有的指针的数量</li>
  <li>初始化两个包含 <code>elements</code> 个 <code>FBBlockStrongRelationDetector</code> 实例的数组，其中第一个数组用于传入 <code>dispose_helper</code>，第二个数组用于检测 <code>_strong</code> 是否被标记为 <code>YES</code></li>
  <li>在自动释放池中执行 <code>dispose_helper(obj)</code>，释放 block 持有的对象</li>
</ol>

<pre><code class="language-objectivec">static NSIndexSet *_GetBlockStrongLayout(void *block) {
	...
	NSMutableIndexSet *layout = [NSMutableIndexSet indexSet];

	for (size_t i = 0; i &lt; elements; ++i) {
		FBBlockStrongRelationDetector *detector = (FBBlockStrongRelationDetector *)(detectors[i]);
		if (detector.isStrong) {
			[layout addIndex:i];
		}

		[detector trueRelease];
	}

	return layout;
}
</code></pre>

<p>因为 <code>dispose_helper</code> 只会调用 <code>release</code> 方法，但是这并不会导致我们的 <code>FBBlockStrongRelationDetector</code> 实例被释放掉，反而会标记 <code>_string</code> 属性，在这里我们只需要判断这个属性的真假，将对应索引加入数组，最后再调用 <code>trueRelease</code> 真正的释放对象。</p>

<p>我们可以执行下面的代码，分析其工作过程：</p>

<pre><code class="language-objectivec">NSObject *firstObject = [NSObject new];
__attribute__((objc_precise_lifetime)) NSObject *object = [NSObject new];
__weak NSObject *secondObject = object;
NSObject *thirdObject = [NSObject new];

__unused void (^block)() = ^{
	__unused NSObject *first = firstObject;
	__unused NSObject *second = secondObject;
	__unused NSObject *third = thirdObject;
};

FBRetainCycleDetector *detector = [FBRetainCycleDetector new];
[detector addCandidate:block];
[detector findRetainCycles];
</code></pre>

<p>在 <code>dispose_helper</code> 调用之前：</p>

<p><img src="https://img.nju520.me/2016-08-05-before-dispose-helper.jpeg" alt="before-dispose-helpe" /></p>

<p><code>obj</code> 数组中的每一个位置都存储了 <code>FBBlockStrongRelationDetector</code> 的实例，但是在 <code>dispose_helper</code> 调用之后：</p>

<p><img src="https://img.nju520.me/2016-08-05-after-dispose-helper.png-1000width" alt="after-dispose-helpe" /></p>

<p>索引为 4 和 5 处的实例已经被清空了，这里对应的 <code>FBBlockStrongRelationDetector</code> 实例的 <code>strong</code> 已经被标记为 <code>YES</code>、加入到数组中并返回；最后也就获取了所有强引用的索引，同时得到了 block 强引用的对象。</p>

<h2 id="总结">总结</h2>

<p>其实最开始笔者对这个 <code>dispose_helper</code> 实现的机制并不是特别的肯定，只是有一个猜测，但是在询问了 <code>FBBlockStrongRelationDetector</code> 的作者之后，才确定 <code>dispose_helper</code> 确实会负责向所有捕获的变量发送 <code>release</code> 消息，如果有兴趣可以看这个 <a href="https://github.com/facebook/FBRetainCycleDetector/issues/15">issue</a>。这部分的代码其实最开始源于 mikeash 大神的 <a href="https://github.com/mikeash/Circle">Circle</a>，不过对于他是如何发现这一点的，笔者并不清楚，如果各位有相关的资料或者合理的解释，可以随时联系我。</p>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>


  ]]></description>
</item>

<item>
  <title>对象是如何初始化的（iOS）</title>
  <link>//object-init</link>
  <author>nju520</author>
  <pubDate>2016-08-07T12:09:48+08:00</pubDate>
  <guid>//object-init</guid>
  <description><![CDATA[
  <blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<p>在之前，我们已经讨论了非常多的问题了，关于 objc 源代码系列的文章也快结束了，其实关于对象是如何初始化的这篇文章本来是我要写的第一篇文章，但是由于有很多前置内容不得不说，所以留到了这里。</p>

<p><code>+ alloc</code> 和 <code>- init</code> 这一对我们在 iOS 开发中每天都要用到的初始化方法一直困扰着我, 于是笔者仔细研究了一下 objc 源码中 <code>NSObject</code> 如何进行初始化。</p>

<p>在具体分析对象的初始化过程之前，我想先放出结论，以免文章中的细枝末节对读者的理解有所影响；整个对象的初始化过程其实只是<strong>为一个分配内存空间，并且初始化 isa_t 结构体的过程</strong>。</p>

<h2 id="alloc-方法分析">alloc 方法分析</h2>

<p>先来看一下 <code>+ alloc</code> 方法的调用栈(在调用栈中省略了很多不必要的方法的调用):open</p>

<pre><code class="language-objectivec">id _objc_rootAlloc(Class cls)
└── static id callAlloc(Class cls, bool checkNil, bool allocWithZone=false)
    └── id class_createInstance(Class cls, size_t extraBytes)
    	└── id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct, size_t *outAllocatedSize)
            ├── size_t instanceSize(size_t extraBytes)
            ├── void	*calloc(size_t, size_t)
            └── inline void objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)
</code></pre>

<p>这个调用栈中的方法涉及了多个文件中的代码，在下面的章节中会对调用的方法逐步进行分析，如果这个调用栈让你觉得很头疼，也不是什么问题。</p>

<h3 id="alloc-的实现">alloc 的实现</h3>

<pre><code class="language-objectivec">+ (id)alloc {
    return _objc_rootAlloc(self);
}
</code></pre>

<p><code>alloc</code> 方法的实现真的是非常的简单, 它直接调用了另一个私有方法 <code>id _objc_rootAlloc(Class cls)</code></p>

<pre><code class="language-objectivec">id _objc_rootAlloc(Class cls) {
    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);
}
</code></pre>

<p>这就是上帝类 <code>NSObject</code> 对 <code>callAlloc</code> 的实现，我们省略了非常多的代码，展示了最常见的执行路径：</p>

<pre><code class="language-objectivec">static id callAlloc(Class cls, bool checkNil, bool allocWithZone=false) {
    id obj = class_createInstance(cls, 0);
    return obj;
}

id class_createInstance(Class cls, size_t extraBytes) {
    return _class_createInstanceFromZone(cls, extraBytes, nil);
}
</code></pre>

<p>对象初始化中最重要的操作都在 <code>_class_createInstanceFromZone</code> 方法中执行：</p>

<pre><code class="language-objectivec">static id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct = true, size_t *outAllocatedSize = nil) {
    size_t size = cls-&gt;instanceSize(extraBytes);

    id obj = (id)calloc(1, size);
    if (!obj) return nil;
    obj-&gt;initInstanceIsa(cls, hasCxxDtor);

    return obj;
}
</code></pre>

<h3 id="对象的大小">对象的大小</h3>

<p>在使用 <code>calloc</code> 为对象分配一块内存空间之前，我们要先获取对象在内存的大小：</p>

<pre><code class="language-objectivec">size_t instanceSize(size_t extraBytes) {
    size_t size = alignedInstanceSize() + extraBytes;
    if (size &lt; 16) size = 16;
    return size;
}

uint32_t alignedInstanceSize() {
    return word_align(unalignedInstanceSize());
}

uint32_t unalignedInstanceSize() {
    assert(isRealized());
    return data()-&gt;ro-&gt;instanceSize;
}
</code></pre>

<p>实例大小 <code>instanceSize</code> 会存储在类的 <code>isa_t</code> 结构体中，然后经过对齐最后返回。</p>

<blockquote>
  <p>Core Foundation 需要所有的对象的大小都必须大于或等于 16 字节。</p>
</blockquote>

<p>在获取对象大小之后，直接调用 <code>calloc</code> 函数就可以为对象分配内存空间了。</p>

<h3 id="isa-的初始化">isa 的初始化</h3>

<p>在对象的初始化过程中除了使用 <code>calloc</code> 来分配内存之外，还需要根据类初始化 <code>isa_t</code> 结构体：</p>

<pre><code class="language-objectivec">inline void objc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor) {
    if (!indexed) {
        isa.cls = cls;
    } else {
        isa.bits = ISA_MAGIC_VALUE;
        isa.has_cxx_dtor = hasCxxDtor;
        isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;
    }
}
</code></pre>

<p>上面的代码只是对 <code>isa_t</code> 结构体进行初始化而已：</p>

<pre><code class="language-objectivec">union isa_t {
   isa_t() { }
   isa_t(uintptr_t value) : bits(value) { }

   Class cls;
   uintptr_t bits;

   struct {
       uintptr_t indexed           : 1;
       uintptr_t has_assoc         : 1;
       uintptr_t has_cxx_dtor      : 1;
       uintptr_t shiftcls          : 44;
       uintptr_t magic             : 6;
       uintptr_t weakly_referenced : 1;
       uintptr_t deallocating      : 1;
       uintptr_t has_sidetable_rc  : 1;
       uintptr_t extra_rc          : 8;
   };
};
</code></pre>

<blockquote>
  <p>在这里并不想过多介绍关于 <code>isa_t</code> 结构体的内容，你可以看<a href="https://github.com/nju520/iOS-Source-Code-Analyze/blob/master/objc/从%20NSObject%20的初始化了解%20isa.md">从 NSObject 的初始化了解 isa</a> 了解你想知道的关于 <code>isa_t</code> 的全部内容。</p>
</blockquote>

<h2 id="init-方法">init 方法</h2>

<p><code>NSObject</code> 的 <code>- init</code> 方法只是调用了 <code>_objc_rootInit</code> 并返回了当前对象：</p>

<pre><code class="language-objectivec">- (id)init {
    return _objc_rootInit(self);
}

id _objc_rootInit(id obj) {
    return obj;
}
</code></pre>

<h2 id="总结">总结</h2>

<p>在 iOS 中一个对象的初始化过程很符合直觉，只是分配内存空间、然后初始化 <code>isa_t</code> 结构体，其实现也并不复杂，这篇文章也是这个系列文章中较为简单并且简短的一篇。</p>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

</blockquote>


  ]]></description>
</item>

<item>
  <title>关联对象 AssociatedObject 完全解析</title>
  <link>//ao</link>
  <author>nju520</author>
  <pubDate>2016-06-08T19:19:33+08:00</pubDate>
  <guid>//ao</guid>
  <description><![CDATA[
  <blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<p>我们在 iOS 开发中经常需要使用分类（Category），为已经存在的类添加属性的需求，但是使用 <code>@property</code> 并不能在分类中<strong>正确</strong>创建实例变量和存取方法。</p>

<p>不过，通过 Objective-C 运行时中的关联对象，也就是 Associated Object，我们可以实现上述需求。</p>

<h2 id="写在前面">写在前面</h2>

<p>这篇文章包含了两方面的内容：</p>

<ul>
  <li><a href="#关联对象的应用">使用关联对象为已经存在的类中添加属性</a></li>
  <li><a href="#关联对象的实现">关联对象在底层 Objective-C 中的实现</a></li>
</ul>

<blockquote>
  <p>注：如果你刚刚入门 iOS 开发，笔者相信了解第一部分的内容会对你的日常开发中有所帮助，不过第二部分的内容可能有些难以理解。</p>

  <p>如果你对关联对象的使用非常熟悉，可以直接跳过第一部分的内容，从<a href="#关联对象的实现">这里</a>开始深入了解其底层实现。</p>
</blockquote>

<h2 id="关联对象的应用">关联对象的应用</h2>

<p>关于关联对象的使用相信已经成为了一个老生常谈的问题了，不过为了保证这篇文章的完整性，笔者还是会在这里为各位介绍这部分的内容的。</p>

<h3 id="分类中的-property">分类中的 @property</h3>

<p><code>@property</code> 可以说是一个 Objective-C 编程中的“宏”，它有<a href="https://zh.wikipedia.org/zh/元编程">元编程</a>的思想。</p>

<pre><code class="language-objectivec">@interface DKObject : NSObject

@property (nonatomic, strong) NSString *property;

@end
</code></pre>

<p>在使用上述代码时会做三件事：</p>

<ul>
  <li>生成实例变量 <code>_property</code></li>
  <li>生成 <code>getter</code> 方法 <code>- property</code></li>
  <li>生成 <code>setter</code> 方法 <code>- setProperty:</code></li>
</ul>

<pre><code class="language-objectivec">@implementation DKObject {
    NSString *_property;
}

- (NSString *)property {
    return _property;
}

- (void)setProperty:(NSString *)property {
    _property = property;
}

@end
</code></pre>

<p>这些代码都是编译器为我们生成的，虽然你看不到它，但是它确实在这里，我们既然可以在类中使用 <code>@property</code> 生成一个属性，那么为什么在分类中不可以呢？</p>

<p>我们来做一个小实验：创建一个 <code>DKObject</code> 的分类 <code>Category</code>，并添加一个属性 <code>categoryProperty</code>：</p>

<pre><code class="language-objectivec">@interface DKObject (Category)

@property (nonatomic, strong) NSString *categoryProperty;

@end
</code></pre>

<p>看起来还是很不错的，不过 Build 一下这个 Demo，会发现有这么一个警告：</p>

<p><img src="https://img.nju520.me/2016-06-08-objc-ao-warning-category-property.png-1000width" alt="objc-ao-warning-category-property" /></p>

<p>在这里的警告告诉我们 <code>categoryProperty</code> 属性的存取方法需要自己手动去实现，或者使用 <code>@dynamic</code> 在运行时实现这些方法。</p>

<p>换句话说，分类中的 <code>@property</code> 并没有为我们生成实例变量以及存取方法，而需要我们手动实现。</p>

<h3 id="使用关联对象">使用关联对象</h3>

<p>Q：我们为什么要使用关联对象？</p>

<p>A：因为在分类中 <code>@property</code> 并不会自动生成实例变量以及存取方法，所以<strong>一般使用关联对象为已经存在的类添加『属性』</strong>。</p>

<p>上一小节的内容已经给了我们需要使用关联对象的理由。在这里，我们会介绍 ObjC 运行时为我们提供的与关联对象有关的 API，并在分类中实现一个<strong>伪属性</strong>：</p>

<pre><code class="language-objectivec">#import "DKObject+Category.h"
#import &lt;objc/runtime.h&gt;

@implementation DKObject (Category)

- (NSString *)categoryProperty {
    return objc_getAssociatedObject(self, _cmd);
}

- (void)setCategoryProperty:(NSString *)categoryProperty {
    objc_setAssociatedObject(self, @selector(categoryProperty), categoryProperty, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

@end
</code></pre>

<blockquote>
  <p>这里的 <code>_cmd</code> 代指当前方法的选择子，也就是 <code>@selector(categoryProperty)</code>。</p>
</blockquote>

<p>我们使用了两个方法 <code>objc_getAssociatedObject</code> 以及 <code>objc_setAssociatedObject</code> 来模拟『属性』的存取方法，而使用关联对象模拟实例变量。</p>

<p>在这里有必要解释两个问题：</p>

<ol>
  <li>为什么向方法中传入 <code>@selector(categoryProperty)</code>？</li>
  <li><code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> 是干什么的？</li>
</ol>

<p>关于第一个问题，我们需要看一下这两个方法的原型：</p>

<pre><code class="language-objectivec">id objc_getAssociatedObject(id object, const void *key);
void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);
</code></pre>

<p><code>@selector(categoryProperty)</code> 也就是参数中的 <code>key</code>，其实可以使用静态指针 <code>static void *</code> 类型的参数来代替，不过在这里，笔者强烈推荐使用 <code>@selector(categoryProperty)</code> 作为 <code>key</code> 传入。因为这种方法省略了声明参数的代码，并且能很好地保证 <code>key</code> 的唯一性。</p>

<p><code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> 又是什么呢？如果我们使用 <code>Command</code> 加左键查看它的定义：</p>

<pre><code class="language-objectivec">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {
    OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */
    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object.
                                            *   The association is not made atomically. */
    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied.
                                            *   The association is not made atomically. */
    OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.
                                            *   The association is made atomically. */
    OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.
                                            *   The association is made atomically. */
};
</code></pre>

<p>从这里的注释我们能看到很多东西，也就是说不同的 <code>objc_AssociationPolicy</code> 对应了不通的属性修饰符：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">objc_AssociationPolicy</th>
      <th style="text-align: center">modifier</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">OBJC_ASSOCIATION_ASSIGN</td>
      <td style="text-align: center">assign</td>
    </tr>
    <tr>
      <td style="text-align: left">OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
      <td style="text-align: center">nonatomic, strong</td>
    </tr>
    <tr>
      <td style="text-align: left">OBJC_ASSOCIATION_COPY_NONATOMIC</td>
      <td style="text-align: center">nonatomic, copy</td>
    </tr>
    <tr>
      <td style="text-align: left">OBJC_ASSOCIATION_RETAIN</td>
      <td style="text-align: center">atomic, strong</td>
    </tr>
    <tr>
      <td style="text-align: left">OBJC_ASSOCIATION_COPY</td>
      <td style="text-align: center">atomic, copy</td>
    </tr>
  </tbody>
</table>

<p>而我们在代码中实现的属性 <code>categoryProperty</code> 就相当于使用了 <code>nonatomic</code> 和 <code>strong</code> 修饰符。</p>

<blockquote>
  <p>关于属性修饰符的区别，并不是这篇文章的主要内容，如果你需要了解它们的区别，<a href="https://google.com">Google</a> 是一个很好的选择。</p>
</blockquote>

<p>到这里，我们已经完成了对关联对象应用的介绍，再来回顾一下小节的内容。</p>

<p>@property` 其实有元编程的思想，它能够为我们自动生成<strong>实例变量以及存取方法</strong>，而这三者构成了属性这个类似于语法糖的概念，为我们提供了更便利的点语法来访问属性：</p>

<pre><code class="language-objectivec">self.property &lt;=&gt; [self property]
self.property = value &lt;=&gt; [self setProperty:value]
</code></pre>

<p>在分类中，因为类的实例变量的布局已经固定，使用 <code>@property</code> 已经<strong>无法向固定的布局中添加新的实例变量（这样做可能会覆盖子类的实例变量）</strong>，所以我们需要<strong>使用关联对象以及两个方法来模拟构成属性的三个要素</strong>。</p>

<blockquote>
  <p>如果你是一个 iOS 开发方面的新手，我相信这篇文章的前半部分对已经足够使用了，不过，如果你还对关联对象的实现非常感兴趣，也可以尝试阅读下面的内容。</p>
</blockquote>

<h2 id="关联对象的实现">关联对象的实现</h2>

<blockquote>
  <p>探索关联对象的实现一直是我想要做的一件事情，直到最近，我才有足够的时间来完成这篇文章，希望能够对各位读者有所帮助。</p>
</blockquote>

<p>这一部分会从三个 objc 运行时的方法为入口来对关联对象的实现一探究竟，其中两个方法是上一部分使用到的方法：</p>

<pre><code class="language-objectivec">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);
id objc_getAssociatedObject(id object, const void *key);
void objc_removeAssociatedObjects(id object);
</code></pre>

<p>三个方法的作用分别是：</p>

<ul>
  <li>以键值对形式添加关联对象</li>
  <li>根据 <code>key</code> 获取关联对象</li>
  <li>移除所有关联对象</li>
</ul>

<p>而接下来的内容自然就是围绕这三个方法进行的，我们会对它们的实现进行分析。</p>

<h3 id="objc_setassociatedobject">objc_setAssociatedObject</h3>

<p>首先是 <code>objc_setAssociatedObject</code> 方法，这个方法的调用栈并不复杂：</p>

<pre><code class="language-objectivec">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)
└── void objc_setAssociatedObject_non_gc(id object, const void *key, id value, objc_AssociationPolicy policy)
    └── void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy)
</code></pre>

<p>调用栈中的 <code>_object_set_associative_reference</code> 方法实际完成了设置关联对象的任务：</p>

<pre><code class="language-objectivec">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {
    ObjcAssociation old_association(0, nil);
    id new_value = value ? acquireValue(value, policy) : nil;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;associations(manager.associations());
        ObjectAssociationMap *refs = i-&gt;second;
        ...
    }
    if (old_association.hasValue()) ReleaseValue()(old_association);
}
</code></pre>

<blockquote>
  <p>在这里的实现省略了大多的实现代码，而且忽略了很多逻辑上的顺序，不过不要在意这里的代码能否执行。</p>
</blockquote>

<p>我们需要注意其中的几个类和数据结构，因为在具体分析这个方法的实现之前，我们需要了解其中它们的作用：</p>

<ul>
  <li><code>AssociationsManager</code></li>
  <li><code>AssociationsHashMap</code></li>
  <li><code>ObjcAssociationMap</code></li>
  <li><code>ObjcAssociation</code></li>
</ul>

<h4 id="associationsmanager">AssociationsManager</h4>

<p><code>AssociationsManager</code> 在源代码中的定义是这样的：</p>

<pre><code class="language-objectivec">class AssociationsManager {
    static spinlock_t _lock;
    static AssociationsHashMap *_map;
public:
    AssociationsManager()   { _lock.lock(); }
    ~AssociationsManager()  { _lock.unlock(); }

    AssociationsHashMap &amp;associations() {
        if (_map == NULL)
            _map = new AssociationsHashMap();
        return *_map;
    }
};

spinlock_t AssociationsManager::_lock;
AssociationsHashMap *AssociationsManager::_map = NULL;
</code></pre>

<p>它维护了 <code>spinlock_t</code> 和 <code>AssociationsHashMap</code> 的单例，初始化它的时候会调用 <code>lock.lock()</code> 方法，在析构时会调用 <code>lock.unlock()</code>，而 <code>associations</code> 方法用于取得一个全局的 <code>AssociationsHashMap</code> 单例。</p>

<p>也就是说 <code>AssociationsManager</code> 通过持有一个<a href="https://en.wikipedia.org/wiki/Spinlock">自旋锁</a> <code>spinlock_t</code> 保证对 <code>AssociationsHashMap</code> 的操作是线程安全的，即<strong>每次只会有一个线程对 AssociationsHashMap 进行操作</strong>。</p>

<h4 id="如何存储-objcassociation">如何存储 ObjcAssociation</h4>

<p><code>ObjcAssociation</code> 就是真正的关联对象的类，上面的所有数据结构只是为了更好的存储它。</p>

<p>首先，<code>AssociationsHashMap</code> 用与保存从对象的 <code>disguised_ptr_t</code> 到 <code>ObjectAssociationMap</code> 的映射：</p>

<pre><code class="language-objectivec">class AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; {
public:
    void *operator new(size_t n) { return ::malloc(n); }
    void operator delete(void *ptr) { ::free(ptr); }
};
</code></pre>

<p>而 <code>ObjectAssociationMap</code> 则保存了从 <code>key</code> 到关联对象 <code>ObjcAssociation</code> 的映射，<strong>这个数据结构保存了当前对象对应的所有关联对象</strong>：</p>

<pre><code class="language-objectivec">class ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt; {
public:
   void *operator new(size_t n) { return ::malloc(n); }
   void operator delete(void *ptr) { ::free(ptr); }
};
</code></pre>

<p>最关键的 <code>ObjcAssociation</code> 包含了 <code>policy</code> 以及 <code>value</code>：</p>

<pre><code class="language-objectivec">class ObjcAssociation {
    uintptr_t _policy;
    id _value;
public:
    ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) {}
    ObjcAssociation() : _policy(0), _value(nil) {}

    uintptr_t policy() const { return _policy; }
    id value() const { return _value; }

    bool hasValue() { return _value != nil; }
};
</code></pre>

<p>举一个简单的例子来说明关联对象在内存中以什么形式存储的，以下面的代码为例：</p>

<pre><code class="language-objectivec">int main(int argc, const char * argv[]) {
    @autoreleasepool {

        NSObject *obj = [NSObject new];
        objc_setAssociatedObject(obj, @selector(hello), @"Hello", OBJC_ASSOCIATION_RETAIN_NONATOMIC);

    }
    return 0;
}
</code></pre>

<p>这里的关联对象 <code>ObjcAssociation(OBJC_ASSOCIATION_RETAIN_NONATOMIC, @"Hello")</code> 在内存中是这么存储的：</p>

<p><img src="https://img.nju520.me/2016-06-08-objc-ao-associateobjcect.png-1000width" alt="objc-ao-associateobjcect" /></p>

<hr />

<p>接下来我们可以重新回到对 <code>objc_setAssociatedObject</code> 方法的分析了。</p>

<p>在这里会将方法的执行分为两种情况：</p>

<ul>
  <li><code>new_value != nil</code> 设置/更新关联对象的值</li>
  <li><code>new_value == nil</code> 删除一个关联对象</li>
</ul>

<h4 id="new_value--nil">new_value != nil</h4>

<p>先来分析在 <code>new_value != nil</code> 的情况下，该方法的执行是什么样的：</p>

<pre><code class="language-objectivec">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {
    ObjcAssociation old_association(0, nil);
    id new_value = value ? acquireValue(value, policy) : nil;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;associations(manager.associations());
        disguised_ptr_t disguised_object = DISGUISE(object);

        AssociationsHashMap::iterator i = associations.find(disguised_object);
        if (i != associations.end()) {
            ObjectAssociationMap *refs = i-&gt;second;
            ObjectAssociationMap::iterator j = refs-&gt;find(key);
            if (j != refs-&gt;end()) {
                old_association = j-&gt;second;
                j-&gt;second = ObjcAssociation(policy, new_value);
            } else {
                (*refs)[key] = ObjcAssociation(policy, new_value);
            }
        } else {
            ObjectAssociationMap *refs = new ObjectAssociationMap;
            associations[disguised_object] = refs;
            (*refs)[key] = ObjcAssociation(policy, new_value);
            object-&gt;setHasAssociatedObjects();
        }
    }
    if (old_association.hasValue()) ReleaseValue()(old_association);
}
</code></pre>

<ol>
  <li>使用 <code>old_association(0, nil)</code> 创建一个临时的 <code>ObjcAssociation</code> 对象（用于持有原有的关联对象，方便在方法调用的最后释放值）</li>
  <li>
    <p>调用 <code>acquireValue</code> 对 <code>new_value</code> 进行 <code>retain</code> 或者 <code>copy</code></p>

    <pre><code> static id acquireValue(id value, uintptr_t policy) {
     switch (policy &amp; 0xFF) {
     case OBJC_ASSOCIATION_SETTER_RETAIN:
         return ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);
     case OBJC_ASSOCIATION_SETTER_COPY:
         return ((id(*)(id, SEL))objc_msgSend)(value, SEL_copy);
     }
     return value;
 }
</code></pre>
  </li>
  <li>
    <p>初始化一个 <code>AssociationsManager</code>，并获取唯一的保存关联对象的哈希表 <code>AssociationsHashMap</code></p>

    <pre><code> AssociationsManager manager;
 AssociationsHashMap &amp;associations(manager.associations());
</code></pre>
  </li>
  <li>先使用 <code>DISGUISE(object)</code> 作为 key 寻找对应的 <code>ObjectAssociationMap</code></li>
  <li>
    <p>如果没有找到，初始化一个 <code>ObjectAssociationMap</code>，再实例化 <code>ObjcAssociation</code> 对象添加到 Map 中，并调用 <code>setHasAssociatedObjects</code> 方法，表明当前对象含有关联对象</p>

    <pre><code> ObjectAssociationMap *refs = new ObjectAssociationMap;
 associations[disguised_object] = refs;
 (*refs)[key] = ObjcAssociation(policy, new_value);
 object-&gt;setHasAssociatedObjects();
</code></pre>
  </li>
  <li>
    <p>如果找到了对应的 <code>ObjectAssociationMap</code>，就要看 <code>key</code> 是否存在了，由此来决定是更新原有的关联对象，还是增加一个</p>

    <pre><code> ObjectAssociationMap *refs = i-&gt;second;
 ObjectAssociationMap::iterator j = refs-&gt;find(key);
 if (j != refs-&gt;end()) {
     old_association = j-&gt;second;
     j-&gt;second = ObjcAssociation(policy, new_value);
 } else {
     (*refs)[key] = ObjcAssociation(policy, new_value);
 }
</code></pre>
  </li>
  <li>
    <p>最后的最后，如果原来的关联对象有值的话，会调用 <code>ReleaseValue()</code> 释放关联对象的值</p>

    <pre><code> struct ReleaseValue {
     void operator() (ObjcAssociation &amp;association) {
         releaseValue(association.value(), association.policy());
     }
 };

 static void releaseValue(id value, uintptr_t policy) {
     if (policy &amp; OBJC_ASSOCIATION_SETTER_RETAIN) {
         ((id(*)(id, SEL))objc_msgSend)(value, SEL_release);
     }
 }
</code></pre>
  </li>
</ol>

<p>到这里，该条件下的方法实现就结束了。</p>

<h4 id="new_value--nil-1">new_value == nil</h4>

<p>如果 <code>new_value == nil</code>，就说明我们要删除对应 <code>key</code> 的关联对象，实现如下：</p>

<pre><code class="language-objectivec">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {
    ObjcAssociation old_association(0, nil);
    id new_value = value ? acquireValue(value, policy) : nil;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;associations(manager.associations());
        disguised_ptr_t disguised_object = DISGUISE(object);

        AssociationsHashMap::iterator i = associations.find(disguised_object);
        if (i !=  associations.end()) {
            ObjectAssociationMap *refs = i-&gt;second;
            ObjectAssociationMap::iterator j = refs-&gt;find(key);
            if (j != refs-&gt;end()) {
                old_association = j-&gt;second;
                refs-&gt;erase(j);
            }
        }
    }
    if (old_association.hasValue()) ReleaseValue()(old_association);
}
</code></pre>

<p>这种情况下方法的实现与前面的唯一区别就是，我们会调用 <code>erase</code> 方法，擦除 <code>ObjectAssociationMap</code> 中 <code>key</code> 对应的节点。</p>

<h4 id="sethasassociatedobjects">setHasAssociatedObjects()</h4>

<p>其实上面的两种情况已经将 <code>objc_setAssociatedObject</code> 方法的实现分析得很透彻了，不过，这里还有一个小问题来等待我们解决，<code>setHasAssociatedObjects()</code> 方法的作用是什么？</p>

<pre><code class="language-objectivec">inline void objc_object::setHasAssociatedObjects() {
    if (isTaggedPointer()) return;

 retry:
    isa_t oldisa = LoadExclusive(&amp;isa.bits);
    isa_t newisa = oldisa;
    if (!newisa.indexed) return;
    if (newisa.has_assoc) return;
    newisa.has_assoc = true;
    if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;
}
</code></pre>

<p>它会将 <code>isa</code> 结构体中的标记位 <code>has_assoc</code> 标记为 <code>true</code>，也就是表示当前对象有关联对象，在这里我还想祭出这张图来介绍 <code>isa</code> 中的各个标记位都是干什么的。</p>

<p><img src="https://img.nju520.me/2016-06-08-objc-ao-isa-struct.png-1000width" alt="objc-ao-isa-struct" /></p>

<blockquote>
  <p>如果想要了解关于 isa 的知识，可以阅读<a href="https://github.com/nju520/iOS-Source-Code-Analyze/blob/master/objc/从%20NSObject%20的初始化了解%20isa.md">从 NSObject 的初始化了解 isa</a></p>
</blockquote>

<h3 id="objc_getassociatedobject">objc_getAssociatedObject</h3>

<p>我们既然已经对 <code>objc_setAssociatedObject</code> 的实现已经比较熟悉了，相信对于 <code>objc_getAssociatedObject</code> 的理解也会更加容易。</p>

<p>方法的调用栈和 <code>objc_setAssociatedObject</code> 非常相似：</p>

<pre><code class="language-objectivec">id objc_getAssociatedObject(id object, const void *key)
└── id objc_getAssociatedObject_non_gc(id object, const void *key);
    └── id _object_get_associative_reference(id object, void *key)
</code></pre>

<p>而 <code>_object_get_associative_reference</code> 相比于前面方法的实现更加简单。</p>

<pre><code class="language-objectivec">id _object_get_associative_reference(id object, void *key) {
    id value = nil;
    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;associations(manager.associations());
        disguised_ptr_t disguised_object = DISGUISE(object);
        AssociationsHashMap::iterator i = associations.find(disguised_object);
        if (i != associations.end()) {
            ObjectAssociationMap *refs = i-&gt;second;
            ObjectAssociationMap::iterator j = refs-&gt;find(key);
            if (j != refs-&gt;end()) {
                ObjcAssociation &amp;entry = j-&gt;second;
                value = entry.value();
                policy = entry.policy();
                if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);
            }
        }
    }
    if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) {
        ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease);
    }
    return value;
}
</code></pre>

<p>代码中寻找关联对象的逻辑和 <code>objc_setAssociatedObject</code> 差不多：</p>

<ol>
  <li>获取静态变量 <code>AssociationsHashMap</code></li>
  <li>以 <code>DISGUISE(object)</code> 为 key 查找 <code>AssociationsHashMap</code></li>
  <li>以 <code>void *key</code> 为 key 查找 <code>ObjcAssociation</code></li>
  <li>
    <p>根据 <code>policy</code> 调用相应的方法</p>

    <pre><code> if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);

 if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) {
     ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease);
 }
</code></pre>
  </li>
  <li>返回关联对象 <code>ObjcAssociation</code> 的值</li>
</ol>

<h3 id="objc_removeassociatedobjects">objc_removeAssociatedObjects</h3>

<p>关于最后的 <code>objc_removeAssociatedObjects</code> 方法，其实现也相对简单，这是方法的调用栈：</p>

<pre><code class="language-objectivec">void objc_removeAssociatedObjects(id object)
└── void _object_remove_assocations(id object)
</code></pre>

<p>这是简化版本的 <code>objc_removeAssociatedObjects</code> 方法实现：</p>

<pre><code class="language-objectivec">void objc_removeAssociatedObjects(id object) {
    if (object &amp;&amp; object-&gt;hasAssociatedObjects()) {
        _object_remove_assocations(object);
    }
}
</code></pre>

<p>为了加速移除对象的关联对象的速度，我们会通过标记位 <code>has_assoc</code> 来避免不必要的方法调用，在确认了对象和关联对象的存在之后，才会调用 <code>_object_remove_assocations</code> 方法移除对象上所有的关联对象：</p>

<pre><code class="language-objectivec">void _object_remove_assocations(id object) {
    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;associations(manager.associations());
        if (associations.size() == 0) return;
        disguised_ptr_t disguised_object = DISGUISE(object);
        AssociationsHashMap::iterator i = associations.find(disguised_object);
        if (i != associations.end()) {
            ObjectAssociationMap *refs = i-&gt;second;
            for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) {
                elements.push_back(j-&gt;second);
            }
            delete refs;
            associations.erase(i);
        }
    }
    for_each(elements.begin(), elements.end(), ReleaseValue());
}
</code></pre>

<p>方法会将对象包含的所有关联对象加入到一个 <code>vector</code> 中，然后对所有的 <code>ObjcAssociation</code> 对象调用 <code>ReleaseValue()</code> 方法，释放不再被需要的值。</p>

<h2 id="小结">小结</h2>

<h3 id="关于应用">关于应用</h3>

<p>本来在这个系列的文章中并不会涉及关联对象这个话题，不过，有人问过我这么一个问题：在分类中到底能否实现属性？其实在回答这个问题之前，首先要知道到底属性是什么？而属性的概念决定了这个问题的答案。</p>

<ul>
  <li>如果你把属性理解为<strong>通过方法访问的实例变量</strong>，我相信这个问题的答案是不能，<strong>因为分类不能为类增加额外的实例变量</strong>。</li>
  <li>不过如果属性只是一个<strong>存取方法以及存储值的容器的集合</strong>，那么分类是可以实现属性的。</li>
</ul>

<blockquote>
  <p><strong>分类中对属性的实现其实只是实现了一个看起来像属性的接口而已</strong>。</p>
</blockquote>

<h3 id="关于实现">关于实现</h3>

<p>关联对象又是如何实现并且管理的呢：</p>

<ul>
  <li>关联对象其实就是 <code>ObjcAssociation</code> 对象</li>
  <li>关联对象由 <code>AssociationsManager</code> 管理并在  <code>AssociationsHashMap</code> 存储</li>
  <li>对象的指针以及其对应 <code>ObjectAssociationMap</code> 以键值对的形式存储在 <code>AssociationsHashMap</code> 中</li>
  <li><code>ObjectAssociationMap</code> 则是用于存储关联对象的数据结构</li>
  <li>每一个对象都有一个标记位 <code>has_assoc</code> 指示对象是否含有关联对象</li>
</ul>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>


  ]]></description>
</item>

<item>
  <title>黑箱中的 retain 和 release</title>
  <link>//rr</link>
  <author>nju520</author>
  <pubDate>2016-05-30T12:10:37+08:00</pubDate>
  <guid>//rr</guid>
  <description><![CDATA[
  <blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>
  <p>由于 Objective-C 中的内存管理是一个比较大的话题，所以会分为两篇文章来对内存管理中的一些机制进行剖析，一部分分析自动释放池以及 <code>autorelease</code> 方法，另一部分分析 <code>retain</code>、<code>release</code> 方法的实现以及自动引用计数。</p>
</blockquote>

<ul>
  <li><a href="https://github.com/nju520/iOS-Source-Code-Analyze/blob/master/objc/自动释放池的前世今生.md">自动释放池的前世今生</a></li>
  <li><a href="https://github.com/nju520/iOS-Source-Code-Analyze/blob/master/objc/黑箱中的%20retain%20和%20release.md">黑箱中的 retain 和 release</a></li>
</ul>

<h2 id="写在前面">写在前面</h2>

<p>在接口设计时，我们经常要考虑某些意义上的平衡。在内存管理中也是这样，Objective-C 同时为我们提供了增加引用计数的 <code>retain</code> 和减少引用计数的 <code>release</code> 方法。</p>

<p>这篇文章会在源代码层面介绍 Objective-C 中 <code>retain</code> 和 <code>release</code> 的实现，它们是如何达到平衡的。</p>

<h2 id="从-retain-开始">从 retain 开始</h2>

<p>如今我们已经进入了全面使用 ARC 的时代，几年前还经常使用的 <code>retain</code> 和 <code>release</code> 方法已经很难出现于我们的视野中了，绝大多数内存管理的实现细节都由编译器代劳。</p>

<p>在这里，我们还要从 <code>retain</code> 方法开始，对内存管理的实现细节一探究竟。</p>

<p>下面是 <code>retain</code> 方法的调用栈：</p>

<pre><code class="language-objectivec">- [NSObject retain]
└── id objc_object::rootRetain()
    └── id objc_object::rootRetain(bool tryRetain, bool handleOverflow)
        ├── uintptr_t LoadExclusive(uintptr_t *src)
        ├── uintptr_t addc(uintptr_t lhs, uintptr_t rhs, uintptr_t carryin, uintptr_t *carryout)
        ├── uintptr_t bits
        │   └── uintptr_t has_sidetable_rc  
        ├── bool StoreExclusive(uintptr_t *dst, uintptr_t oldvalue, uintptr_t value)
        └── bool objc_object::sidetable_addExtraRC_nolock(size_t delta_rc)                
            └── uintptr_t addc(uintptr_t lhs, uintptr_t rhs, uintptr_t carryin, uintptr_t *carryout)
</code></pre>

<p>调用栈中的前两个方法的实现直接调用了下一个方法：</p>

<pre><code class="language-objectivec">- (id)retain {
    return ((id)self)-&gt;rootRetain();
}

id objc_object::rootRetain() {
    return rootRetain(false, false);
}
</code></pre>

<p>而 <code>id objc_object::rootRetain(bool tryRetain, bool handleOverflow)</code> 方法是调用栈中最重要的方法，其原理就是将 <code>isa</code> 结构体中的 <code>extra_rc</code> 的值加一。</p>

<p><code>extra_rc</code> 就是用于保存自动引用计数的标志位，下面就是 <code>isa</code> 结构体中的结构：</p>

<p><img src="https://img.nju520.me/2016-05-27-objc-rr-isa-struct.png-1000width" alt="objc-rr-isa-struct" /></p>

<p>接下来我们会分三种情况对 <code>rootRetain</code> 进行分析。</p>

<h3 id="正常的-rootretain">正常的 rootRetain</h3>

<p>这是简化后的 <code>rootRetain</code> 方法的实现，其中只有处理一般情况的代码：</p>

<pre><code class="language-objectivec">id objc_object::rootRetain(bool tryRetain, bool handleOverflow) {
    isa_t oldisa;
    isa_t newisa;

    do {
        oldisa = LoadExclusive(&amp;isa.bits);
        newisa = oldisa;

        uintptr_t carry;
        newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry);
    } while (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits));

    return (id)this;
}
</code></pre>

<blockquote>
  <p>在这里我们假设的条件是 <code>isa</code> 中的 <code>extra_rc</code> 的位数足以存储 <code>retainCount</code>。</p>
</blockquote>

<ol>
  <li>使用 <code>LoadExclusive</code> 加载 <code>isa</code> 的值</li>
  <li>调用 <code>addc(newisa.bits, RC_ONE, 0, &amp;carry)</code> 方法将 <code>isa</code> 的值加一</li>
  <li>调用 <code>StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)</code> 更新 <code>isa</code> 的值</li>
  <li>返回当前对象</li>
</ol>

<h3 id="有进位版本的-rootretain">有进位版本的 rootRetain</h3>

<p>在这里调用 <code>addc</code> 方法为 <code>extra_rc</code> 加一时，8 位的 <code>extra_rc</code> 可能不足以保存引用计数。</p>

<pre><code class="language-objectivec">id objc_object::rootRetain(bool tryRetain, bool handleOverflow) {
    transcribeToSideTable = false;
    isa_t oldisa = LoadExclusive(&amp;isa.bits);
    isa_t newisa = oldisa;

    uintptr_t carry;
    newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry);

    if (carry &amp;&amp; !handleOverflow)
        return rootRetain_overflow(tryRetain);
}
</code></pre>

<blockquote>
  <p><code>extra_rc</code> 不足以保存引用计数，并且 <code>handleOverflow = false</code>。</p>
</blockquote>

<p>当方法传入的 <code>handleOverflow = false</code> 时（这也是通常情况），我们会调用 <code>rootRetain_overflow</code> 方法：</p>

<pre><code class="language-objectivec">id objc_object::rootRetain_overflow(bool tryRetain) {
    return rootRetain(tryRetain, true);
}
</code></pre>

<p>这个方法其实就是重新执行 <code>rootRetain</code> 方法，并传入 <code>handleOverflow = true</code>。</p>

<h3 id="有进位版本的-rootretain处理溢出">有进位版本的 rootRetain（处理溢出）</h3>

<p>当传入的 <code>handleOverflow = true</code> 时，我们就会在 <code>rootRetain</code> 方法中处理引用计数的溢出。</p>

<pre><code class="language-objectivec">id objc_object::rootRetain(bool tryRetain, bool handleOverflow) {
    bool sideTableLocked = false;

    isa_t oldisa;
    isa_t newisa;

    do {
        oldisa = LoadExclusive(&amp;isa.bits);
        newisa = oldisa;
        uintptr_t carry;
        newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry);

        if (carry) {
            newisa.extra_rc = RC_HALF;
            newisa.has_sidetable_rc = true;
        }
    } while (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits));

    sidetable_addExtraRC_nolock(RC_HALF);

    return (id)this;
}
</code></pre>

<p>当调用这个方法，并且 <code>handleOverflow = true</code> 时，我们就可以确定 <code>carry</code> 一定是存在的了，</p>

<p>因为 <code>extra_rc</code> 已经溢出了，所以要更新它的值为 <code>RC_HALF</code>：</p>

<pre><code class="language-c">#define RC_HALF (1ULL&lt;&lt;7)
</code></pre>

<blockquote>
  <p><code>extra_rc</code> 总共为 8 位，<code>RC_HALF = 0b10000000</code>。</p>
</blockquote>

<p>然后设置 <code>has_sidetable_rc</code> 为真，存储新的 <code>isa</code> 的值之后，调用 <code>sidetable_addExtraRC_nolock</code> 方法。</p>

<pre><code class="language-objectivec">bool objc_object::sidetable_addExtraRC_nolock(size_t delta_rc) {
    SideTable&amp; table = SideTables()[this];

    size_t&amp; refcntStorage = table.refcnts[this];
    size_t oldRefcnt = refcntStorage;

    if (oldRefcnt &amp; SIDE_TABLE_RC_PINNED) return true;

    uintptr_t carry;
    size_t newRefcnt =
        addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, 0, &amp;carry);
    if (carry) {
        refcntStorage = SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK);
        return true;
    } else {
        refcntStorage = newRefcnt;
        return false;
    }
}
</code></pre>

<p>这里我们将溢出的一位 <code>RC_HALF</code> 添加到 <code>oldRefcnt</code> 中，其中的各种 <code>SIDE_TABLE</code> 宏定义如下：</p>

<pre><code class="language-objectivec">#define SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)
#define SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1)
#define SIDE_TABLE_RC_ONE            (1UL&lt;&lt;2)
#define SIDE_TABLE_RC_PINNED         (1UL&lt;&lt;(WORD_BITS-1))

#define SIDE_TABLE_RC_SHIFT 2
#define SIDE_TABLE_FLAG_MASK (SIDE_TABLE_RC_ONE-1)
</code></pre>

<p>因为 <code>refcnts</code> 中的 64 为的最低两位是有意义的标志位，所以在使用 <code>addc</code> 时要将 <code>delta_rc</code> 左移两位，获得一个新的引用计数 <code>newRefcnt</code>。</p>

<p>如果这时出现了溢出，那么就会撤销这次的行为。否则，会将新的引用计数存储到 <code>refcntStorage</code> 指针中。</p>

<hr />

<p>也就是说，在 iOS 的内存管理中，我们使用了 <code>isa</code> 结构体中的 <code>extra_rc</code> 和 <code>SideTable</code> 来存储某个对象的自动引用计数。</p>

<p>更重要的是，<strong>如果自动引用计数为 1，<code>extra_rc</code> 实际上为 0</strong>，因为它保存的是额外的引用计数，我们通过这个行为能够减少很多不必要的函数调用。</p>

<p>到目前为止，我们已经从头梳理了 <code>retain</code> 方法的调用栈及其实现。下面要介绍的是在内存管理中，我们是如何使用 <code>release</code> 方法平衡这个方法的。</p>

<h2 id="以-release-结束">以 release 结束</h2>

<p>与 release 方法相似，我们看一下这个方法简化后的调用栈：</p>

<pre><code class="language-objectivec">- [NSObject release]
└── id objc_object::rootRelease()
    └── id objc_object::rootRetain(bool performDealloc, bool handleUnderflow)
</code></pre>

<p>前面的两个方法的实现和 <code>retain</code> 中的相差无几，这里就直接跳过了。</p>

<p>同样，在分析 <code>release</code> 方法时，我们也根据上下文的不同，将 <code>release</code> 方法的实现拆分为三部分，说明它到底是如何调用的。</p>

<h3 id="正常的-release">正常的 release</h3>

<p>这一个版本的方法调用可以说是最简版本的方法调用了：</p>

<pre><code class="language-objectivec">bool objc_object::rootRelease(bool performDealloc, bool handleUnderflow) {
    isa_t oldisa;
    isa_t newisa;

    do {
        oldisa = LoadExclusive(&amp;isa.bits);
        newisa = oldisa;

        uintptr_t carry;
        newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry);
    } while (!StoreReleaseExclusive(&amp;isa.bits, oldisa.bits, newisa.bits));

    return false;
}
</code></pre>

<ol>
  <li>使用 <code>LoadExclusive</code> 获取 <code>isa</code> 内容</li>
  <li>将 <code>isa</code> 中的引用计数减一</li>
  <li>调用 <code>StoreReleaseExclusive</code> 方法保存新的 <code>isa</code></li>
</ol>

<h3 id="从-sidetable-借位">从 SideTable 借位</h3>

<p>接下来，我们就要看两种相对比较复杂的情况了，首先是从 <code>SideTable</code> 借位的版本：</p>

<pre><code class="language-objectivec">bool objc_object::rootRelease(bool performDealloc, bool handleUnderflow) {
    isa_t oldisa;
    isa_t newisa;

    do {
        oldisa = LoadExclusive(&amp;isa.bits);
        newisa = oldisa;

        uintptr_t carry;
        newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry);
        if (carry) goto underflow;
    } while (!StoreReleaseExclusive(&amp;isa.bits, oldisa.bits, newisa.bits));

    ...

 underflow:
    newisa = oldisa;

    if (newisa.has_sidetable_rc) {
        if (!handleUnderflow) {
            return rootRelease_underflow(performDealloc);
        }

        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);

        if (borrowed &gt; 0) {
            newisa.extra_rc = borrowed - 1;
            bool stored = StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits);

            return false;
        }
    }
}
</code></pre>

<blockquote>
  <p>这里省去了使用锁来<strong>防止竞争条件</strong>以及<strong>调用 <code>StoreExclusive</code> 失败后恢复现场</strong>的代码。
我们会默认这里存在 <code>SideTable</code>，也就是 <code>has_sidetable_rc = true</code>。</p>
</blockquote>

<p>你可以看到，这里也有一个 <code>handleUnderflow</code>，与 retain 中的相同，如果发生了 <code>underflow</code>，会重新调用该 <code>rootRelease</code> 方法，并传入 <code>handleUnderflow = true</code>。</p>

<p>在调用 <code>sidetable_subExtraRC_nolock</code> 成功借位之后，我们会重新设置 <code>newisa</code> 的值 <code>newisa.extra_rc = borrowed - 1</code> 并更新 <code>isa</code>。</p>

<h3 id="release-中调用-dealloc">release 中调用 dealloc</h3>

<p>如果在 <code>SideTable</code> 中也没有获取到借位的话，就说明没有任何的变量引用了当前对象（即 <code>retainCount = 0</code>），就需要向它发送 <code>dealloc</code> 消息了。</p>

<pre><code class="language-objectivec">bool objc_object::rootRelease(bool performDealloc, bool handleUnderflow) {
    isa_t oldisa;
    isa_t newisa;

 retry:
    do {
        oldisa = LoadExclusive(&amp;isa.bits);
        newisa = oldisa;

        uintptr_t carry;
        newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry);
        if (carry) goto underflow;
    } while (!StoreReleaseExclusive(&amp;isa.bits, oldisa.bits, newisa.bits));

    ...

 underflow:
    newisa = oldisa;

    if (newisa.deallocating) {
        return overrelease_error();
    }
    newisa.deallocating = true;
    StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits);

    if (performDealloc) {
        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);
    }
    return true;
}
</code></pre>

<p>上述代码会直接调用 <code>objc_msgSend</code> 向当前对象发送 <code>dealloc</code> 消息。</p>

<p>不过为了确保消息只会发送一次，我们使用 <code>deallocating</code> 标记位。</p>

<h2 id="获取自动引用计数">获取自动引用计数</h2>

<p>在文章的最结尾，笔者想要介绍一下 <code>retainCount</code> 的值是怎么计算的，我们直接来看 <code>retainCount</code> 方法的实现：</p>

<pre><code class="language-objectivec">- (NSUInteger)retainCount {
    return ((id)self)-&gt;rootRetainCount();
}

inline uintptr_t objc_object::rootRetainCount() {
    isa_t bits = LoadExclusive(&amp;isa.bits);
    uintptr_t rc = 1 + bits.extra_rc;
    if (bits.has_sidetable_rc) {
        rc += sidetable_getExtraRC_nolock();
    }
    return rc;
}
</code></pre>

<p>根据方法的实现，retainCount 有三部分组成：</p>

<ul>
  <li>1</li>
  <li><code>extra_rc</code> 中存储的值</li>
  <li><code>sidetable_getExtraRC_nolock</code> 返回的值</li>
</ul>

<p>这也就证明了我们之前得到的结论。</p>

<h2 id="小结">小结</h2>

<p>我们在这篇文章中已经介绍了 <code>retain</code> 和 <code>release</code> 这一对用于内存管理的方法是如何实现的，这里总结一下文章一下比较重要的问题。</p>

<ul>
  <li><code>extra_rc</code> 只会保存额外的自动引用计数，对象实际的引用计数会在这个基础上 +1</li>
  <li>Objective-C 使用 <code>isa</code> 中的 <code>extra_rc</code> 和 <code>SideTable</code> 来存储对象的引用计数</li>
  <li>在对象的引用计数归零时，会调用 <code>dealloc</code> 方法回收对象</li>
</ul>

<p>有关于自动释放池实现的介绍，可以看<a href="https://github.com/nju520/iOS-Source-Code-Analyze/blob/master/objc/自动释放池的前世今生.md">自动释放池的前世今生</a>。</p>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>


  ]]></description>
</item>

<item>
  <title>自动释放池的前世今生 ---- 深入解析 autoreleasepool</title>
  <link>//autoreleasepool</link>
  <author>nju520</author>
  <pubDate>2016-05-16T01:20:23+08:00</pubDate>
  <guid>//autoreleasepool</guid>
  <description><![CDATA[
  <blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>
  <p>由于 Objective-C 中的内存管理是一个比较大的话题，所以会分为两篇文章来对内存管理中的一些机制进行剖析，一部分分析自动释放池以及 <code>autorelease</code> 方法，另一部分分析 <code>retain</code>、<code>release</code> 方法的实现以及自动引用计数。</p>
</blockquote>

<h2 id="写在前面">写在前面</h2>

<p>这篇文章会在源代码层面介绍 Objective-C 中自动释放池，以及方法的 <code>autorelease</code> 的具体实现。</p>

<h2 id="从-main-函数开始">从 main 函数开始</h2>

<p><code>main</code> 函数可以说是在整个 iOS 开发中非常不起眼的一个函数，它很好地隐藏在 <code>Supporting Files</code> 文件夹中，却是整个 iOS 应用的入口。
<img src="https://img.nju520.me/2016-05-16-objc-autorelease-main.png-1000width" alt="objc-autorelease-main" /></p>

<p><code>main.m</code> 文件中的内容是这样的：</p>

<pre><code class="language-objectivec">int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
</code></pre>

<p>在这个 <code>@autoreleasepool</code> block 中只包含了一行代码，这行代码将所有的事件、消息全部交给了 <code>UIApplication</code> 来处理，但是这不是本文关注的重点。</p>

<p>需要注意的是：<strong>整个 iOS 的应用都是包含在一个自动释放池 block 中的</strong>。</p>

<h2 id="autoreleasepool">@autoreleasepool</h2>

<p><code>@autoreleasepool</code> 到底是什么？我们在命令行中使用 <code>clang -rewrite-objc main.m</code> 让编译器重新改写这个文件：</p>

<pre><code class="language-c">$ clang -rewrite-objc main.m
</code></pre>

<p>在生成了一大堆警告之后，当前目录下多了一个 <code>main.cpp</code> 文件</p>

<p><img src="https://img.nju520.me/2016-05-16-objc-autorelease-main-cpp.png-1000width" alt="objc-autorelease-main-cpp" /></p>

<blockquote>
  <p>这里删除了 <code>main</code> 函数中其他无用的代码。</p>
</blockquote>

<p>在这个文件中，有一个非常奇怪的 <code>__AtAutoreleasePool</code> 的结构体，前面的注释写到 <code>/* @autoreleasepopl */</code>。也就是说 <code>@autoreleasepool {}</code> 被转换为一个 <code>__AtAutoreleasePool</code> 结构体：</p>

<pre><code class="language-objectivec">{
    __AtAutoreleasePool __autoreleasepool;
}
</code></pre>

<p>想要弄清楚这行代码的意义，我们要在 <code>main.cpp</code> 中查找名为 <code>__AtAutoreleasePool</code> 的结构体：</p>

<p><img src="https://img.nju520.me/2016-05-16-objc-autorelease-main-cpp-struct.png-1000width" alt="objc-autorelease-main-cpp-struct" /></p>

<pre><code class="language-objectivec">struct __AtAutoreleasePool {
  __AtAutoreleasePool() {atautoreleasepoolobj = objc_autoreleasePoolPush();}
  ~__AtAutoreleasePool() {objc_autoreleasePoolPop(atautoreleasepoolobj);}
  void * atautoreleasepoolobj;
};
</code></pre>

<p>这个结构体会在初始化时调用 <code>objc_autoreleasePoolPush()</code> 方法，会在析构时调用 <code>objc_autoreleasePoolPop</code> 方法。</p>

<p>这表明，我们的 <code>main</code> 函数在实际工作时其实是这样的：</p>

<pre><code class="language-objectivec">int main(int argc, const char * argv[]) {
    {
        void * atautoreleasepoolobj = objc_autoreleasePoolPush();

        // do whatever you want

        objc_autoreleasePoolPop(atautoreleasepoolobj);
    }
    return 0;
}
</code></pre>

<p><code>@autoreleasepool</code> 只是帮助我们少写了这两行代码而已，让代码看起来更美观，然后要根据上述两个方法来分析自动释放池的实现。</p>

<h2 id="autoreleasepool-是什么">AutoreleasePool 是什么</h2>

<p>这一节开始分析方法 <code>objc_autoreleasePoolPush</code> 和 <code>objc_autoreleasePoolPop</code> 的实现：</p>

<pre><code class="language-objectivec">void *objc_autoreleasePoolPush(void) {
    return AutoreleasePoolPage::push();
}

void objc_autoreleasePoolPop(void *ctxt) {
    AutoreleasePoolPage::pop(ctxt);
}
</code></pre>

<p>上面的方法看上去是对 <code>AutoreleasePoolPage</code> 对应<strong>静态方法</strong> <code>push</code> 和 <code>pop</code> 的封装。</p>

<p>这一小节会按照下面的顺序逐步解析代码中的内容：</p>

<ul>
  <li><a href="#AutoreleasePoolPage">AutoreleasePoolPage 的结构</a></li>
  <li><a href="#objc_autoreleasePoolPush">objc_autoreleasePoolPush 方法</a></li>
  <li><a href="#objc_autoreleasePoolPop">objc_autoreleasePoolPop 方法</a></li>
</ul>

<h3 id="autoreleasepoolpage-的结构">AutoreleasePoolPage 的结构</h3>

<p><code>AutoreleasePoolPage</code> 是一个 C++ 中的类：</p>

<p><img src="https://img.nju520.me/2016-05-16-objc-autorelease-AutoreleasePoolPage.png-1000width" alt="objc-autorelease-AutoreleasePoolPage" /></p>

<p>它在 <code>NSObject.mm</code> 中的定义是这样的：</p>

<pre><code class="language-objectivec">class AutoreleasePoolPage {
    magic_t const magic;
    id *next;
    pthread_t const thread;
    AutoreleasePoolPage * const parent;
    AutoreleasePoolPage *child;
    uint32_t const depth;
    uint32_t hiwat;
};
</code></pre>

<ul>
  <li><code>magic</code> 用于对当前 <code>AutoreleasePoolPage</code> <strong>完整性</strong>的校验</li>
  <li><code>thread</code> 保存了当前页所在的线程</li>
</ul>

<p><strong>每一个自动释放池都是由一系列的 <code>AutoreleasePoolPage</code> 组成的，并且每一个 <code>AutoreleasePoolPage</code> 的大小都是 <code>4096</code> 字节（16 进制 0x1000）</strong></p>

<pre><code class="language-c">#define I386_PGBYTES 4096
#define PAGE_SIZE I386_PGBYTES
</code></pre>

<h4 id="双向链表">双向链表</h4>

<p>自动释放池中的 <code>AutoreleasePoolPage</code> 是以<strong>双向链表</strong>的形式连接起来的：</p>

<p><img src="https://img.nju520.me/2016-05-16-objc-autorelease-AutoreleasePoolPage-linked-list.png-1000width" alt="objc-autorelease-AutoreleasePoolPage-linked-list" /></p>

<blockquote>
  <p><code>parent</code> 和 <code>child</code> 就是用来构造双向链表的指针。</p>
</blockquote>

<h4 id="自动释放池中的栈">自动释放池中的栈</h4>

<p>如果我们的一个 <code>AutoreleasePoolPage</code> 被初始化在内存的 <code>0x100816000 ~ 0x100817000</code> 中，它在内存中的结构如下：</p>

<p><img src="https://img.nju520.me/2016-05-16-objc-autorelease-page-in-memory.png-1000width" alt="objc-autorelease-page-in-memory" /></p>

<p>其中有 56 bit 用于存储 <code>AutoreleasePoolPage</code> 的成员变量，剩下的 <code>0x100816038 ~ 0x100817000</code> 都是用来存储<strong>加入到自动释放池中的对象</strong>。</p>

<blockquote>
  <p><code>begin()</code> 和 <code>end()</code> 这两个类的实例方法帮助我们快速获取 <code>0x100816038 ~ 0x100817000</code> 这一范围的边界地址。</p>
</blockquote>

<p><code>next</code> 指向了下一个为空的内存地址，如果 <code>next</code> 指向的地址加入一个 <code>object</code>，它就会如下图所示<strong>移动到下一个为空的内存地址中</strong>：</p>

<p><img src="https://img.nju520.me/2016-05-16-objc-autorelease-after-insert-to-page.png-1000width" alt="objc-autorelease-after-insert-to-page" /></p>

<blockquote>
  <p>关于 <code>hiwat</code> 和 <code>depth</code> 在文章中并不会进行介绍，因为它们并不影响整个自动释放池的实现，也不在关键方法的调用栈中。</p>
</blockquote>

<h4 id="pool_sentinel哨兵对象">POOL_SENTINEL（哨兵对象）</h4>

<p>到了这里，你可能想要知道 <code>POOL_SENTINEL</code> 到底是什么，还有它为什么在栈中。</p>

<p>首先回答第一个问题： <code>POOL_SENTINEL</code> 只是 <code>nil</code> 的别名。</p>

<pre><code class="language-objectivec">#define POOL_SENTINEL nil
</code></pre>

<p>在每个自动释放池初始化调用 <code>objc_autoreleasePoolPush</code> 的时候，都会把一个 <code>POOL_SENTINEL</code> push 到自动释放池的栈顶，并且返回这个 <code>POOL_SENTINEL</code> 哨兵对象。</p>

<pre><code class="language-objectivec">int main(int argc, const char * argv[]) {
    {
        void * atautoreleasepoolobj = objc_autoreleasePoolPush();

        // do whatever you want

        objc_autoreleasePoolPop(atautoreleasepoolobj);
    }
    return 0;
}
</code></pre>

<blockquote>
  <p>上面的 <code>atautoreleasepoolobj</code> 就是一个 <code>POOL_SENTINEL</code>。</p>
</blockquote>

<p>而当方法 <code>objc_autoreleasePoolPop</code> 调用时，就会向自动释放池中的对象发送 <code>release</code> 消息，直到第一个 <code>POOL_SENTINEL</code>：</p>

<p><img src="https://img.nju520.me/2016-05-16-objc-autorelease-pop-stack.png-1000width" alt="objc-autorelease-pop-stack" /></p>

<h3 id="objc_autoreleasepoolpush-方法"><a id="objc_autoreleasePoolPush"></a>objc_autoreleasePoolPush 方法</h3>

<p>了解了 <code>POOL_SENTINEL</code>，我们来重新回顾一下 <code>objc_autoreleasePoolPush</code> 方法：</p>

<pre><code class="language-objectivec">void *objc_autoreleasePoolPush(void) {
    return AutoreleasePoolPage::push();
}
</code></pre>

<p>它调用 <code>AutoreleasePoolPage</code> 的类方法 <code>push</code>，也非常简单：</p>

<pre><code class="language-objectivec">static inline void *push() {
   return autoreleaseFast(POOL_SENTINEL);
}
</code></pre>

<p><a id="autoreleaseFast"></a>在这里会进入一个比较关键的方法 <code>autoreleaseFast</code>，并传入哨兵对象 <code>POOL_SENTINEL</code>：</p>

<pre><code class="language-objectivec">static inline id *autoreleaseFast(id obj)
{
   AutoreleasePoolPage *page = hotPage();
   if (page &amp;&amp; !page-&gt;full()) {
       return page-&gt;add(obj);
   } else if (page) {
       return autoreleaseFullPage(obj, page);
   } else {
       return autoreleaseNoPage(obj);
   }
}
</code></pre>

<p>上述方法分三种情况选择不同的代码执行：</p>

<ul>
  <li>有 <code>hotPage</code> 并且当前 <code>page</code> 不满
    <ul>
      <li>调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中</li>
    </ul>
  </li>
  <li>有 <code>hotPage</code> 并且当前 <code>page</code> 已满
    <ul>
      <li>调用 <code>autoreleaseFullPage</code> 初始化一个新的页</li>
      <li>调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中</li>
    </ul>
  </li>
  <li>无 <code>hotPage</code>
    <ul>
      <li>调用 <code>autoreleaseNoPage</code> 创建一个 <code>hotPage</code></li>
      <li>调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中</li>
    </ul>
  </li>
</ul>

<p>最后的都会调用 <code>page-&gt;add(obj)</code> 将对象添加到自动释放池中。</p>

<blockquote>
  <p><code>hotPage</code> 可以理解为当前正在使用的 <code>AutoreleasePoolPage</code>。</p>
</blockquote>

<h4 id="page-add-添加对象">page-&gt;add 添加对象</h4>

<p><code>id *add(id obj)</code> 将对象添加到自动释放池页中：</p>

<pre><code class="language-objectivec">id *add(id obj) {
    id *ret = next;
    *next = obj;
    next++;
    return ret;
}
</code></pre>

<blockquote>
  <p>笔者对这个方法进行了处理，更方便理解。</p>
</blockquote>

<p>这个方法其实就是一个压栈的操作，将对象加入 <code>AutoreleasePoolPage</code> 然后移动栈顶的指针。</p>

<h4 id="autoreleasefullpage当前-hotpage-已满">autoreleaseFullPage（当前 hotPage 已满）</h4>

<p><code>autoreleaseFullPage</code> 会在当前的 <code>hotPage</code> 已满的时候调用：</p>

<pre><code class="language-objectivec">static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) {
    do {
        if (page-&gt;child) page = page-&gt;child;
        else page = new AutoreleasePoolPage(page);
    } while (page-&gt;full());

    setHotPage(page);
    return page-&gt;add(obj);
}
</code></pre>

<p>它会从传入的 <code>page</code> 开始遍历整个双向链表，直到：</p>

<ol>
  <li>查找到一个未满的 <code>AutoreleasePoolPage</code></li>
  <li>使用构造器传入 <code>parent</code> 创建一个新的 <code>AutoreleasePoolPage</code></li>
</ol>

<p>在查找到一个可以使用的 <code>AutoreleasePoolPage</code> 之后，会将该页面标记成 <code>hotPage</code>，然后调动上面分析过的 <code>page-&gt;add</code> 方法添加对象。</p>

<h4 id="autoreleasenopage没有-hotpage">autoreleaseNoPage（没有 hotPage)</h4>

<p>如果当前内存中不存在 <code>hotPage</code>，就会调用 <code>autoreleaseNoPage</code> 方法初始化一个 <code>AutoreleasePoolPage</code>：</p>

<pre><code class="language-objectivec">static id *autoreleaseNoPage(id obj) {
    AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);
    setHotPage(page);

    if (obj != POOL_SENTINEL) {
        page-&gt;add(POOL_SENTINEL);
    }

    return page-&gt;add(obj);
}
</code></pre>

<p>既然当前内存中不存在 <code>AutoreleasePoolPage</code>，就要<strong>从头开始构建这个自动释放池的双向链表</strong>，也就是说，新的 <code>AutoreleasePoolPage</code> 是没有 <code>parent</code> 指针的。</p>

<p>初始化之后，将当前页标记为 <code>hotPage</code>，然后会先向这个 <code>page</code> 中添加一个 <code>POOL_SENTINEL</code> 对象，来确保在 <code>pop</code> 调用的时候，不会出现异常。</p>

<p>最后，将 <code>obj</code> 添加到自动释放池中。</p>

<h3 id="objc_autoreleasepoolpop-方法"><a id="objc_autoreleasePoolPop"></a>objc_autoreleasePoolPop 方法</h3>

<p>同样，回顾一下上面提到的 <code>objc_autoreleasePoolPop</code> 方法：</p>

<pre><code class="language-objectivec">void objc_autoreleasePoolPop(void *ctxt) {
    AutoreleasePoolPage::pop(ctxt);
}
</code></pre>

<blockquote>
  <p>看起来传入任何一个指针都是可以的，但是在整个工程并没有发现传入其他对象的例子。不过在这个方法中<strong>传入其它的指针也是可行的</strong>，会将自动释放池释放到相应的位置。</p>
</blockquote>

<p>我们一般都会在这个方法中传入一个哨兵对象 <code>POOL_SENTINEL</code>，如下图一样释放对象：</p>

<p><img src="https://img.nju520.me/2016-05-16-objc-autorelease-pop-stack.png-1000width" alt="objc-autorelease-pop-stack" /></p>

<h4 id="对-objc_autoreleasepoolpop-行为的测试">对 objc_autoreleasePoolPop 行为的测试</h4>

<p>在继续分析这个方法之前做一个小测试，在 <code>objc_autoreleasePoolPop</code> 传入非哨兵对象，测试一下这个方法的行为。</p>

<p>下面是 <code>main.m</code> 文件中的源代码：</p>

<pre><code class="language-objectivec">#import &lt;Foundation/Foundation.h&gt;

int main(int argc, const char * argv[]) {
    @autoreleasepool {

        NSString *s = @"nju520";
        [s stringByAppendingString:@"-Suffix"];

    }
    return 0;
}
</code></pre>

<p>在代码的这一行打一个断点，因为这里会调用 <code>autorelease</code> 方法，将字符串加入自动释放池：</p>

<p><img src="https://img.nju520.me/2016-05-16-objc-autorelease-breakpoint-main.png-1000width" alt="objc-autorelease-breakpoint-main" /></p>

<p>当代码运行到这里时，通过 lldb 打印出当前 <code>hotPage</code> 中的栈内容：</p>

<p><img src="https://img.nju520.me/2016-05-16-objc-autorelease-print-pool-content.png-1000width" alt="objc-autorelease-print-pool-content" /></p>

<ol>
  <li>通过 <code>static</code> 方法获取当前 <code>hotPage</code></li>
  <li>打印 <code>AutoreleasePoolPage</code> 中的内容</li>
  <li>打印当前 <code>next</code> 指针指向的内容，以及之前的内容，<code>-2 </code>时已经到了 <code>begin()</code> 位置</li>
  <li>使用 <code>print() </code>和 <code>printAll() </code>打印自动释放池中内容</li>
</ol>

<p>然后将字符串 <code>@"nju520-Suffix"</code> 的指针传入 <code>pop</code> 方法，测试 <code>pop</code> 方法能否传入非哨兵参数。</p>

<p><img src="https://img.nju520.me/2016-05-16-objc-autorelease-pop-string.png-1000width" alt="objc-autorelease-pop-string" /></p>

<p>再次打印当前 <code>AutoreleasePoolPage</code> 的内容时，字符串已经不存在了，这说明<strong>向 <code>pop</code> 方法传入非哨兵参数是可行的</strong>，只是我们一般不会传入非哨兵对象。</p>

<hr />

<p>让我们重新回到对 <code>objc_autoreleasePoolPop</code> 方法的分析，也就是 <code>AutoreleasePoolPage::pop</code> 方法的调用：</p>

<pre><code class="language-objectivec">static inline void pop(void *token) {
    AutoreleasePoolPage *page = pageForPointer(token);
    id *stop = (id *)token;

    page-&gt;releaseUntil(stop);

    if (page-&gt;child) {
        if (page-&gt;lessThanHalfFull()) {
            page-&gt;child-&gt;kill();
        } else if (page-&gt;child-&gt;child) {
            page-&gt;child-&gt;child-&gt;kill();
        }
    }
}
</code></pre>

<blockquote>
  <p>在这个方法中删除了大量无关的代码，以及对格式进行了调整。</p>
</blockquote>

<p>该静态方法总共做了三件事情：</p>

<ol>
  <li>使用 <code>pageForPointer</code> 获取当前 <code>token</code> 所在的 <code>AutoreleasePoolPage</code></li>
  <li>调用 <code>releaseUntil</code> 方法释放<strong>栈中的</strong>对象，直到 <code>stop</code></li>
  <li>调用 <code>child</code> 的 <code>kill</code> 方法</li>
</ol>

<blockquote>
  <p>我到现在也不是很清楚为什么要根据当前页的不同状态 <code>kill</code> 掉不同 <code>child</code> 的页面。</p>
</blockquote>

<pre><code class="language-objectivec">if (page-&gt;lessThanHalfFull()) {
    page-&gt;child-&gt;kill();
} else if (page-&gt;child-&gt;child) {
    page-&gt;child-&gt;child-&gt;kill();
}
</code></pre>

<h4 id="pageforpointer-获取-autoreleasepoolpage">pageForPointer 获取 AutoreleasePoolPage</h4>

<p><code>pageForPointer</code> 方法主要是通过内存地址的操作，获取当前指针所在页的首地址：</p>

<pre><code class="language-objectivec">static AutoreleasePoolPage *pageForPointer(const void *p) {
    return pageForPointer((uintptr_t)p);
}

static AutoreleasePoolPage *pageForPointer(uintptr_t p) {
    AutoreleasePoolPage *result;
    uintptr_t offset = p % SIZE;

    assert(offset &gt;= sizeof(AutoreleasePoolPage));

    result = (AutoreleasePoolPage *)(p - offset);
    result-&gt;fastcheck();

    return result;
}
</code></pre>

<p>将指针与页面的大小，也就是 4096 取模，得到当前指针的偏移量，因为所有的 <code>AutoreleasePoolPage</code> 在内存中都是对齐的：</p>

<pre><code>p = 0x100816048
p % SIZE = 0x48
result = 0x100816000
</code></pre>

<p>而最后调用的方法 <code>fastCheck()</code> 用来检查当前的 <code>result</code> 是不是一个 <code>AutoreleasePoolPage</code>。</p>

<blockquote>
  <p>通过检查 <code>magic_t</code> 结构体中的某个成员是否为 <code>0xA1A1A1A1</code>。</p>
</blockquote>

<h4 id="releaseuntil-释放对象">releaseUntil 释放对象</h4>

<p><code>releaseUntil</code> 方法的实现如下：</p>

<pre><code class="language-objectivec">void releaseUntil(id *stop) {
    while (this-&gt;next != stop) {
        AutoreleasePoolPage *page = hotPage();

        while (page-&gt;empty()) {
            page = page-&gt;parent;
            setHotPage(page);
        }

        page-&gt;unprotect();
        id obj = *--page-&gt;next;
        memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next));
        page-&gt;protect();

        if (obj != POOL_SENTINEL) {
            objc_release(obj);
        }
    }

    setHotPage(this);
}
</code></pre>

<p>它的实现还是很容易的，用一个 <code>while</code> 循环持续释放 <code>AutoreleasePoolPage</code> 中的内容，直到 <code>next</code> 指向了 <code>stop</code> 。</p>

<p>使用 <code>memset</code> 将内存的内容设置成 <code>SCRIBBLE</code>，然后使用 <code>objc_release</code> 释放对象。</p>

<h4 id="kill-方法">kill() 方法</h4>

<p>到这里，没有分析的方法就只剩下 <code>kill</code> 了，而它会将当前页面以及子页面全部删除：</p>

<pre><code class="language-objectivec">void kill() {
    AutoreleasePoolPage *page = this;
    while (page-&gt;child) page = page-&gt;child;

    AutoreleasePoolPage *deathptr;
    do {
        deathptr = page;
        page = page-&gt;parent;
        if (page) {
            page-&gt;unprotect();
            page-&gt;child = nil;
            page-&gt;protect();
        }
        delete deathptr;
    } while (deathptr != this);
}
</code></pre>

<h3 id="autorelease-方法">autorelease 方法</h3>

<p>我们已经对自动释放池生命周期有一个比较好的了解，最后需要了解的话题就是 <code>autorelease</code> 方法的实现，先来看一下方法的调用栈：</p>

<pre><code class="language-objectivec">- [NSObject autorelease]
└── id objc_object::rootAutorelease()
    └── id objc_object::rootAutorelease2()
        └── static id AutoreleasePoolPage::autorelease(id obj)
            └── static id AutoreleasePoolPage::autoreleaseFast(id obj)
                ├── id *add(id obj)
                ├── static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)
                │   ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)
                │   └── id *add(id obj)
                └── static id *autoreleaseNoPage(id obj)
                    ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)
                    └── id *add(id obj)
</code></pre>

<p>在 <code>autorelease</code> 方法的调用栈中，最终都会调用上面提到的 <a href="#autoreleaseFast">autoreleaseFast</a> 方法，将当前对象加到 <code>AutoreleasePoolPage</code> 中。</p>

<p>这一小节中这些方法的实现都非常容易，只是进行了一些参数上的检查，最终还要调用 <a href="#autoreleaseFast">autoreleaseFast</a> 方法：</p>

<pre><code class="language-objectivec">inline id objc_object::rootAutorelease() {
    if (isTaggedPointer()) return (id)this;
    if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this;

    return rootAutorelease2();
}

__attribute__((noinline,used)) id objc_object::rootAutorelease2() {
    return AutoreleasePoolPage::autorelease((id)this);
}

static inline id autorelease(id obj) {
   id *dest __unused = autoreleaseFast(obj);
   return obj;
}
</code></pre>

<p>由于在上面已经分析过 <code>autoreleaseFast</code> 方法的实现，这里就不会多说了。</p>

<h2 id="小结">小结</h2>

<p>整个自动释放池 <code>AutoreleasePool</code> 的实现以及 <code>autorelease</code> 方法都已经分析完了，我们再来回顾一下文章中的一些内容：</p>

<ul>
  <li>自动释放池是由 <code>AutoreleasePoolPage</code> 以双向链表的方式实现的</li>
  <li>当对象调用 <code>autorelease</code> 方法时，会将对象加入 <code>AutoreleasePoolPage</code> 的栈中</li>
  <li>调用 <code>AutoreleasePoolPage::pop</code> 方法会向栈中的对象发送 <code>release</code> 消息</li>
</ul>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="http://stackoverflow.com/questions/14677049/what-is-autoreleasepool-objective-c">What is autoreleasepool? - Objective-C</a></li>
  <li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html">Using Autorelease Pool Blocks</a></li>
  <li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html#//apple_ref/occ/cl/NSAutoreleasePool">NSAutoreleasePool</a></li>
  <li><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的 Autorelease</a></li>
</ul>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>


  ]]></description>
</item>

<item>
  <title>上古时代 Objective-C 中哈希表的实现</title>
  <link>//hashtable</link>
  <author>nju520</author>
  <pubDate>2016-05-07T00:12:56+08:00</pubDate>
  <guid>//hashtable</guid>
  <description><![CDATA[
  <blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>
</blockquote>

<blockquote>
  <p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p>
</blockquote>

<h2 id="写在前面">写在前面</h2>

<p>文章会介绍上古时代 Objective-C 哈希表，也就是 <code>NXHashTable</code> ：</p>

<ul>
  <li><code>NXHashTable</code> 的实现</li>
  <li><code>NXHashTable</code> 的性能分析</li>
  <li><code>NXHashTable</code> 的作用</li>
</ul>

<p><code>NXHashTable</code> 的实现有着将近 30 年的历史，不过仍然作为重要的底层数据结构存储整个应用中的类。</p>

<blockquote>
  <p>文中会涉及一些数据结构方面的简单知识，例如<a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists">拉链法</a>。</p>

  <p>注意：<strong>文章中分析的不是 <code>NSHashTable</code> 而是 <code>NXHashTable</code>。</strong></p>
</blockquote>

<h2 id="nxhashtable">NXHashTable</h2>

<p><code>NXHashTable</code> 的实现位于 <code>hashtable2.mm</code> 文件，我们先来看一下 <code>NXHashTable</code> 的结构以及重要的接口：</p>

<pre><code class="language-objectivec">typedef struct {
    const NXHashTablePrototype *prototype;
    unsigned count;
    unsigned nbBuckets;
    void *buckets;
    const void *info;
} NXHashTable;
</code></pre>

<p>对于结构体中的 <code>NXHashTablePrototype</code> 属性暂且不说，其中的 <code>buckets</code> 是真正用来<strong>存储数据的数组</strong>。</p>

<pre><code class="language-objectivec">NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, unsigned capacity, const void *info, void *z);
unsigned NXCountHashTable (NXHashTable *table);
int NXHashMember (NXHashTable *table, const void *data);
void *NXHashGet (NXHashTable *table, const void *data);
void *NXHashInsert (NXHashTable *table, const void *data);
void *NXHashRemove (NXHashTable *table, const void *data);
</code></pre>

<p>我们会以上面的这些方法作为切入点，分析 <code>NXHashTable</code> 的实现。</p>

<h3 id="nxcreatehashtablefromzone">NXCreateHashTableFromZone</h3>

<p><code>NXHashTable</code> 使用 <code>NXCreateHashTableFromZone</code> 方法初始化：</p>

<pre><code class="language-objectivec">NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, unsigned capacity, const void *info, void *z) {
    NXHashTable			*table;
    NXHashTablePrototype	 *proto;

    table = ALLOCTABLE(z);
    if (! prototypes) bootstrap ();
    if (! prototype.hash) prototype.hash = NXPtrHash;
    if (! prototype.isEqual) prototype.isEqual = NXPtrIsEqual;
    if (! prototype.free) prototype.free = NXNoEffectFree;

    proto = (NXHashTablePrototype *)NXHashGet (prototypes, &amp;prototype);
    if (! proto) {
        proto = (NXHashTablePrototype *) malloc(sizeof (NXHashTablePrototype));
        bcopy ((const char*)&amp;prototype, (char*)proto, sizeof (NXHashTablePrototype));
        (void) NXHashInsert (prototypes, proto);
        proto = (NXHashTablePrototype *)NXHashGet (prototypes, &amp;prototype);
    };
    table-&gt;prototype = proto;
    table-&gt;count = 0;
    table-&gt;info = info;
    table-&gt;nbBuckets = GOOD_CAPACITY(capacity);
    table-&gt;buckets = ALLOCBUCKETS(z, table-&gt;nbBuckets);
    return table;
}
</code></pre>

<p>在这个方法中，绝大多数代码都是用来初始化 <code>table-&gt;prototype</code> 的，我们先把这部分全部忽略，分析一下简略版本的实现。</p>

<pre><code class="language-objectivec">NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, unsigned capacity, const void *info, void *z) {
    NXHashTable			*table;
    NXHashTablePrototype	 *proto;

    table = ALLOCTABLE(z);

    ...

    table-&gt;count = 0;
    table-&gt;info = info;
    table-&gt;nbBuckets = GOOD_CAPACITY(capacity);
    table-&gt;buckets = ALLOCBUCKETS(z, table-&gt;nbBuckets);
    return table;
}
</code></pre>

<p>其中 <code>ALLOCTABLE</code>、<code>GOOD_CAPACITY</code> 以及 <code>ALLOCBUCKETS</code> 都是用来辅助初始化的宏：</p>

<pre><code class="language-objectivec">#define	 ALLOCTABLE(z) ((NXHashTable *) malloc_zone_malloc ((malloc_zone_t *)z,sizeof (NXHashTable)))
#define GOOD_CAPACITY(c) (exp2m1u (log2u (c)+1))
#define ALLOCBUCKETS(z,nb) ((HashBucket *) malloc_zone_calloc ((malloc_zone_t *)z, nb, sizeof (HashBucket)))
</code></pre>

<p><code>ALLOCTABLE</code> 和 <code>ALLOCBUCKETS</code> 只是调用了 <code>malloc_zone_calloc</code> 来初始化相应的结构体，而 <code>GOOD_CAPACITY</code> 有一些特殊，我们来举个例子说明：</p>

<pre><code>c   binary  result
1   1       1
2   10      3(0b11)
6   110     7(0b111)
100 1100100 127(0b111 1111)
</code></pre>

<p><code>c</code> 表示传入参数，<code>binary</code> 表示二进制下的参数，而 <code>result</code> 就是 <code>GOOD_CAPACITY</code> 返回的结果。</p>

<blockquote>
  <p>每次返回当前位数下的二进制最大值。</p>
</blockquote>

<p>获得 <code>table-&gt;nbBuckets</code> 之后，再初始化 <code>table-&gt;nbBuckets * sizeof (HashBucket)</code> 大小的内存空间。</p>

<h4 id="nxhashtableprototype">NXHashTablePrototype</h4>

<p>在继续分析其它方法之前，我们需要先知道 <code>NXHashTablePrototype</code> 是什么：</p>

<pre><code class="language-objectivec">typedef struct {
    uintptr_t (*hash)(const void *info, const void *data);
    int (*isEqual)(const void *info, const void *data1, const void *data2);
    void (*free)(const void *info, void *data);
    int style; /* reserved for future expansion; currently 0 */
} NXHashTablePrototype;
</code></pre>

<p><code>NXHashTablePrototype</code> 中存储了 <code>hash</code>、<code>isEqual</code> 和 <code>free</code> 的函数指针（用于获取数据的哈希、判断两个数据是否相等以及释放数据）。</p>

<p>在 <code>hashtable2.mm</code> 文件中有一个宏 <code>ISEQUAL</code> 就是用了 <code>NXHashTablePrototype</code> 中的 <code>isEqual</code> 来判断两个数据是否相等：</p>

<pre><code class="language-objectivec">#define ISEQUAL(table, data1, data2) ((data1 == data2) || (*table-&gt;prototype-&gt;isEqual)(table-&gt;info, data1, data2))
</code></pre>

<p>可以说，<code>NXHashTablePrototype</code> 中存储了一些<strong>构建哈希表必要的函数指针</strong>。</p>

<blockquote>
  <p>因为 <code>NXHashTable</code> 使用<a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists">拉链法</a>来实现哈希表，在存入表前对数据执行 hash，然后找到对应的 buckets，如果与 buckets 中的数据相同（使用 isEqual 判断），就替换原数据，否则将数据添加到链表中。</p>
</blockquote>

<h4 id="hashbucket">HashBucket</h4>

<p>在这里另一个需要注意的数据结构就是 <code>HashBucket</code>：</p>

<pre><code class="language-c">typedef struct	{
    unsigned count;
    oneOrMany elements;
} HashBucket;
</code></pre>

<p><code>oneOrMany</code> 是一个 <code>union</code> 结构体：</p>

<pre><code class="language-c">typedef union {
    const void *one;
    const void **many;
} oneOrMany;
</code></pre>

<blockquote>
  <p>这么设计的主要原因是<strong>提升性能</strong>。</p>
</blockquote>

<p>如果 <code>HashBucket</code> 中只有一个元素，那么就直接访问 <code>one</code>，否则访问 <code>many</code>，遍历这个 <code>many</code> 列表。</p>

<h3 id="nxcounthashtable">NXCountHashTable</h3>

<p><code>NXCountHashTable</code> 方法应该是我们要介绍的方法中的最简单的一个，它会直接返回 <code>NXHashTable</code> 结构体中的 <code>count</code>。</p>

<pre><code class="language-objectivec">unsigned NXCountHashTable (NXHashTable *table) {
    return table-&gt;count;
}
</code></pre>

<h3 id="nxhashmember">NXHashMember</h3>

<p><code>NXHashMember</code> 的函数签名虽然会返回 <code>int</code>，其实它是一个布尔值，会判断当前的 <code>NXHashTable</code> 中是否包含传入的数据：</p>

<pre><code class="language-objectivec">int NXHashMember (NXHashTable *table, const void *data) {
    HashBucket	*bucket = BUCKETOF(table, data);
    unsigned	j = bucket-&gt;count;
    const void	**pairs;

    if (! j) return 0;
    if (j == 1) {
        return ISEQUAL(table, data, bucket-&gt;elements.one);
    };
    pairs = bucket-&gt;elements.many;
    while (j--) {
        if (ISEQUAL(table, data, *pairs)) return 1;
        pairs ++;
    };
    return 0;
}
</code></pre>

<p>使用 <code>BUCKETOF</code> 对 <code>data</code> 进行 hash，将结果与哈希表的 <code>buckets</code> 数取模，返回 <code>buckets</code> 数组中对应的 <code>NXHashBucket</code>。</p>

<pre><code class="language-objectivec">#define BUCKETOF(table, data) (((HashBucket *)table-&gt;buckets)+((*table-&gt;prototype-&gt;hash)(table-&gt;info, data) % table-&gt;nbBuckets))
</code></pre>

<p>在获取了 <code>bucket</code> 之后，根据其中元素个数的不同，选择不同的分支：</p>

<pre><code class="language-objectivec">if (! j) return 0;
if (j == 1) {
    return ISEQUAL(table, data, bucket-&gt;elements.one);
};
pairs = bucket-&gt;elements.many;
while (j--) {
    if (ISEQUAL(table, data, *pairs)) return 1;
    pairs ++;
};
</code></pre>

<ul>
  <li><code>count == 0</code>，直接返回</li>
  <li><code>count == 1</code>，使用 <code>ISEQUAL</code> 比较查找的数据与 <code>bucket-&gt;elements.one</code></li>
  <li>
    <p><code>count &gt; 1</code>，依次与 <code>bucket-&gt;elements.many</code> 中的值进行比较</p>

    <blockquote>
      <p>你可能觉得到这里的时间复杂度比较糟糕，然而这个列表并不会很长，具体会在 <a href="#nxhashinsert">NXHashInsert</a> 中解释。</p>
    </blockquote>
  </li>
</ul>

<h3 id="nxhashget">NXHashGet</h3>

<blockquote>
  <p>其实我一直觉得这个方法可能用处不是很大，尤其是在使用默认的 <code>NXHashTablePrototype</code> 时，因为默认的 <code>NXHashTablePrototype</code> 中的 <code>isEqual</code> 函数指针只是比较两个数据的指针是否相同。</p>

  <p>其最大作用就是查看当前 <code>data</code> 是不是在表中。</p>

  <p>如果当前数据在表中，那么这个方法只会返回一个相同的指针，没有太多的意义。</p>
</blockquote>

<p>它的实现跟上面的 <code>NXHashMember</code> 区别并不大，这里就不过多介绍了：</p>

<pre><code class="language-objectivec">void *NXHashGet (NXHashTable *table, const void *data) {
    HashBucket	*bucket = BUCKETOF(table, data);
    unsigned	j = bucket-&gt;count;
    const void	**pairs;

    if (! j) return NULL;
    if (j == 1) {
        return ISEQUAL(table, data, bucket-&gt;elements.one)
        ? (void *) bucket-&gt;elements.one : NULL;
    };
    pairs = bucket-&gt;elements.many;
    while (j--) {
        if (ISEQUAL(table, data, *pairs)) return (void *) *pairs;
        pairs ++;
    };
    return NULL;
}
</code></pre>

<h3 id="nxhashinsert">NXHashInsert</h3>

<p><code>NXHashInsert</code> 是 <code>NXHashTable</code> 中比较重要的方法，其作用就是向表中插入数据：</p>

<pre><code class="language-objectivec">void *NXHashInsert (NXHashTable *table, const void *data) {
    HashBucket *bucket = BUCKETOF(table, data);
    unsigned j = bucket-&gt;count;
    const void **pairs;
    const void **newt;

    if (! j) {
        bucket-&gt;count++;
        bucket-&gt;elements.one = data;
        table-&gt;count++;
        return NULL;
    };
    if (j == 1) {
        if (ISEQUAL(table, data, bucket-&gt;elements.one)) {
            const void *old = bucket-&gt;elements.one;
            bucket-&gt;elements.one = data;
            return (void *) old;
        };
        newt = ALLOCPAIRS(z, 2);
        newt[1] = bucket-&gt;elements.one;
        *newt = data;
        bucket-&gt;count++;
        bucket-&gt;elements.many = newt;
        table-&gt;count++;
        if (table-&gt;count &gt; table-&gt;nbBuckets) _NXHashRehash (table);
        return NULL;
    };
    pairs = bucket-&gt;elements.many;
    while (j--) {
        if (ISEQUAL(table, data, *pairs)) {
            const void	*old = *pairs;
            *pairs = data;
            return (void *) old;
        };
        pairs ++;
    };
    newt = ALLOCPAIRS(z, bucket-&gt;count+1);
    if (bucket-&gt;count) bcopy ((const char*)bucket-&gt;elements.many, (char*)(newt+1), bucket-&gt;count * PTRSIZE);
    *newt = data;
    FREEPAIRS (bucket-&gt;elements.many);
    bucket-&gt;count++;
    bucket-&gt;elements.many = newt;
    table-&gt;count++;
    if (table-&gt;count &gt; table-&gt;nbBuckets) _NXHashRehash (table);
    return NULL;
}
</code></pre>

<p>虽然这里的实现比上面的两个方法复杂得多，但是脉络仍然很清晰，我们将插入的过程分为三种情况：</p>

<ul>
  <li><code>bucket-&gt;count == 0</code></li>
  <li><code>bucket-&gt;count == 1</code></li>
  <li><code>bucket-&gt;count &gt; 1</code></li>
</ul>

<p>如果对应的 <code>bucket</code> 为空：</p>

<pre><code class="language-objectivec">if (! j) {
    bucket-&gt;count++;
    bucket-&gt;elements.one = data;
    table-&gt;count++;
    return NULL;
};
</code></pre>

<p>将数据直接填入 <code>bucket</code>，增加 <code>bucket</code> 中元素的数目，以及 <code>table</code> 中存储的元素的数目：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-05-07-objc-hashtable-insert-empty.gif" alt="objc-hashtable-insert-empty" /></p>

<p>如果原来的 <code>buckets</code> 中有一个元素，它会替换或者使用 <code>many</code> 替换原来的 <code>one</code>：</p>

<pre><code class="language-objectivec">if (j == 1) {
    if (ISEQUAL(table, data, bucket-&gt;elements.one)) {
        const void	*old = bucket-&gt;elements.one;
        bucket-&gt;elements.one = data;
        return (void *) old;
    };
    newt = ALLOCPAIRS(z, 2);
    newt[1] = bucket-&gt;elements.one;
    *newt = data;
    bucket-&gt;count++;
    bucket-&gt;elements.many = newt;
    table-&gt;count++;

    ...

    return NULL;
};
</code></pre>

<p>当前数据 <code>data</code> 如果与 <code>bucket</code> 中存储的数据相同，就会更新这个数据，否则就会使用 <code>ALLOCPAIRS</code> 初始化一个新的数组，然后将 <code>data</code> 和原来的数据传入。</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-05-07-objc-hashtable-insert-one.gif.gif" alt="objc-hashtable-insert-one.gif" /></p>

<p>但是如果原来的 <code>bucket</code> 中存储的元素大于 1，那么会在链表的头部追加一个新的元素：</p>

<pre><code class="language-objectivec">while (j--) {
    if (ISEQUAL(table, data, *pairs)) {
        const void	*old = *pairs;
        *pairs = data;
        return (void *) old;
    };
    pairs ++;
};
newt = ALLOCPAIRS(z, bucket-&gt;count+1);
if (bucket-&gt;count) bcopy ((const char*)bucket-&gt;elements.many, (char*)(newt+1), bucket-&gt;count * PTRSIZE);
*newt = data;
FREEPAIRS (bucket-&gt;elements.many);
bucket-&gt;count++;
bucket-&gt;elements.many = newt;
table-&gt;count++;
</code></pre>

<p>上面的代码使用 <code>bcopy</code> 将原链表中元素拷贝到新的数组 <code>newt</code> 中。</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-05-07-objc-hashtable-insert-many.gif.gif" alt="objc-hashtable-insert-many.gif" /></p>

<p>在每次添加完一个元素之后，都会进行下面的判断：</p>

<pre><code class="language-objectivec">if (table-&gt;count &gt; table-&gt;nbBuckets) _NXHashRehash (table);
</code></pre>

<blockquote>
  <p>上面的这行代码会保证<strong>哈希表中的元素数据小于等于表中的 bucket 数量</strong>。</p>
</blockquote>

<p>这就是 <code>buckets</code> 后面的列表非常短的原因，在理想情况下，<strong>每一个 <code>buckets</code> 中都只存储一个或零个元素</strong>。</p>

<h4 id="_nxhashrehash">_NXHashRehash</h4>

<p>如果哈希表在添加元素后，其中的数据多于 <code>buckets</code> 数量，就会对 <code>NXHashTable</code> 进行 <code>_NXHashRehash</code> 操作。</p>

<pre><code class="language-objectivec">static void _NXHashRehash (NXHashTable *table) {
    _NXHashRehashToCapacity (table, MORE_CAPACITY(table-&gt;nbBuckets));
}
</code></pre>

<p>它调用 <code>_NXHashRehashToCapacity</code> 方法来扩大 <code>NXHashTable</code> 的容量（<code>HashBucket</code> 的个数）。</p>

<pre><code class="language-c">#define MORE_CAPACITY(b) (b*2+1)
</code></pre>

<p>而 <code>MORE_CAPACITY</code> 会将当前哈希表的容量翻倍，并将新的容量传入 <code>_NXHashRehashToCapacity</code> 中：</p>

<pre><code class="language-objectivec">void _NXHashRehashToCapacity (NXHashTable *table, unsigned newCapacity) {
    NXHashTable	*old;
    NXHashState	state;
    void	*aux;
    __unused void *z = ZONE_FROM_PTR(table);

    old = ALLOCTABLE(z);
    old-&gt;prototype = table-&gt;prototype; old-&gt;count = table-&gt;count;
    old-&gt;nbBuckets = table-&gt;nbBuckets; old-&gt;buckets = table-&gt;buckets;
    table-&gt;nbBuckets = newCapacity;
    table-&gt;count = 0; table-&gt;buckets = ALLOCBUCKETS(z, table-&gt;nbBuckets);
    state = NXInitHashState (old);
    while (NXNextHashState (old, &amp;state, &amp;aux))
        (void) NXHashInsert (table, aux);
    freeBuckets (old, NO);

    free (old-&gt;buckets);
    free (old);
}
</code></pre>

<ol>
  <li>创建一个 <code>NXHashTable</code> 的指针指向原哈希表</li>
  <li>改变哈希表的 <code>nbBuckets</code>，并重新初始化哈希表的 <code>buckets</code> 数组</li>
  <li>重新将元素插入到哈希表中</li>
  <li>释放原哈希表 <code>old</code> 以及 <code>buckets</code></li>
</ol>

<h4 id="nxhashstate">NXHashState</h4>

<p>在将元素重新插入到哈希表中涉及了一个非常奇怪的结构体 <code>NXHashState</code>，这个结构体主要作用是遍历 <code>NXHashTable</code> 中的元素。</p>

<pre><code class="language-objectivec">typedef struct {
    int i;
    int j;
} NXHashState;
</code></pre>

<p>我们可以使用如下的代码对哈希表中的元素进行遍历：</p>

<pre><code class="language-objectivec"> unsigned count = 0;
 MyData	 *data;
 NXHashState state = NXInitHashState(table);
 while (NXNextHashState(table, &amp;state, &amp;data)) {
    count++;
 }
</code></pre>

<p>代码片段中调用了两个方法，分别是 <code>NXInitHashState</code> 以及 <code>NXNextHashState</code>：</p>

<pre><code class="language-objectivec">NXHashState NXInitHashState (NXHashTable *table) {
    NXHashState	state;

    state.i = table-&gt;nbBuckets;
    state.j = 0;
    return state;
};
</code></pre>

<p><code>NXInitHashState</code> 会将 <code>NXHashState</code> 指向哈希表的最末端：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-05-07-objc-hashtable-hash-state-init.png" alt="objc-hashtable-hash-state-init" /></p>

<blockquote>
  <p>这个位置其实并不属于 <code>NXHashTable</code>，它一定会为空。</p>
</blockquote>

<p>而每次调用 <code>NXNextHashState</code> 都会向『前』移动一次：</p>

<pre><code class="language-objectivec">int NXNextHashState (NXHashTable *table, NXHashState *state, void **data) {
    HashBucket		*buckets = (HashBucket *) table-&gt;buckets;

    while (state-&gt;j == 0) {
        if (state-&gt;i == 0) return NO;
        state-&gt;i--; state-&gt;j = buckets[state-&gt;i].count;
    }
    state-&gt;j--;
    buckets += state-&gt;i;
    *data = (void *) ((buckets-&gt;count == 1)
                      ? buckets-&gt;elements.one : buckets-&gt;elements.many[state-&gt;j]);
    return YES;
};
</code></pre>

<p>下面的 gif 为我们展示了每一次调用 <code>NXNextHashState</code> 方法之后当前的 <code>NXHashState</code>：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-05-07-objc-hashtable-hashstate-next.gif" alt="objc-hashtable-hashstate-next" /></p>

<h3 id="nxhashremove">NXHashRemove</h3>

<p>这里的 <code>NXHashRemove</code>在某种意义上是 <code>NXHashInsert</code> 的逆操作：</p>

<pre><code class="language-objectivec">void *NXHashRemove (NXHashTable *table, const void *data) {
    HashBucket	*bucket = BUCKETOF(table, data);
    unsigned	j = bucket-&gt;count;
    const void	**pairs;
    const void	**newt;
    __unused void *z = ZONE_FROM_PTR(table);

    if (! j) return NULL;
    if (j == 1) {
        if (! ISEQUAL(table, data, bucket-&gt;elements.one)) return NULL;
        data = bucket-&gt;elements.one;
        table-&gt;count--; bucket-&gt;count--; bucket-&gt;elements.one = NULL;
        return (void *) data;
    };
    pairs = bucket-&gt;elements.many;
    if (j == 2) {
        if (ISEQUAL(table, data, pairs[0])) {
            bucket-&gt;elements.one = pairs[1]; data = pairs[0];
        }
        else if (ISEQUAL(table, data, pairs[1])) {
            bucket-&gt;elements.one = pairs[0]; data = pairs[1];
        }
        else return NULL;
        FREEPAIRS (pairs);
        table-&gt;count--; bucket-&gt;count--;
        return (void *) data;
    };
    while (j--) {
        if (ISEQUAL(table, data, *pairs)) {
            data = *pairs;
            /* we shrink this bucket */
            newt = (bucket-&gt;count-1)
            ? ALLOCPAIRS(z, bucket-&gt;count-1) : NULL;
            if (bucket-&gt;count-1 != j)
                bcopy ((const char*)bucket-&gt;elements.many, (char*)newt, PTRSIZE*(bucket-&gt;count-j-1));
            if (j)
                bcopy ((const char*)(bucket-&gt;elements.many + bucket-&gt;count-j), (char*)(newt+bucket-&gt;count-j-1), PTRSIZE*j);
            FREEPAIRS (bucket-&gt;elements.many);
            table-&gt;count--; bucket-&gt;count--; bucket-&gt;elements.many = newt;
            return (void *) data;
        };
        pairs ++;
    };
    return NULL;
}
</code></pre>

<p>它的实现也分为三种情况，不过在这里就不多说了。</p>

<h2 id="nxhashtable-的性能">NXHashTable 的性能</h2>

<p>在已经熟悉了 <code>NXHashTable</code> 的具体实现之后，我们要分析插入<strong>不同数据量级</strong>的情况下，所需要的时间，这里是主程序的代码，分别测试了在 <code>100, 1000, 10000, 100000, 1000000, 2000000, 3000000, 5000000, 10000000</code> 数据下 <code>NXHashTable</code> 的性能表现：</p>

<pre><code class="language-objectivec">#import &lt;Foundation/Foundation.h&gt;
#import "hashtable2.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSArray&lt;NSNumber *&gt; *capacities = @[
            @100,
            @1000,
            @10000,
            @100000,
            @1000000,
            @2000000,
            @3000000,
            @5000000,
            @10000000
        ];

        for (NSNumber *capacity in capacities) {
            NXHashTable *hashTable = NXCreateHashTable(NXPtrPrototype, 0, NULL);
            NSDate *methodStart = [NSDate date];
            for (NSInteger i = 0; i &lt; capacity.integerValue; i++) {
                NSString *value = [NSString stringWithFormat:@"%ld", (long)i];
                NXHashInsert(hashTable, (__bridge void *)value);
            }
            NSDate *methodFinish = [NSDate date];
            NSTimeInterval executionTime = [methodFinish timeIntervalSinceDate:methodStart];
            NSLog(@"Capacities: %@, executionTime = %f, meanTime = %.10f", capacity, executionTime, executionTime / capacity.integerValue);

            free(hashTable);
        }

    }
    return 0;
}
</code></pre>

<p>代码中初始化了一个 <code>capacities</code> 存储需要测量的数据量级，然后调用 <code>NXHashInsert</code> 方法将相当数量级的数据添加到哈希表中：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">Capacities</th>
      <th style="text-align: right">Execution Time</th>
      <th style="text-align: right">Mean Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">100</td>
      <td style="text-align: right">0.000334</td>
      <td style="text-align: right">0.0000033402</td>
    </tr>
    <tr>
      <td style="text-align: right">1000</td>
      <td style="text-align: right">0.001962</td>
      <td style="text-align: right">0.0000019619</td>
    </tr>
    <tr>
      <td style="text-align: right">10000</td>
      <td style="text-align: right">0.022001</td>
      <td style="text-align: right">0.0000022001</td>
    </tr>
    <tr>
      <td style="text-align: right">100000</td>
      <td style="text-align: right">0.349998</td>
      <td style="text-align: right">0.0000035000</td>
    </tr>
    <tr>
      <td style="text-align: right">1000000</td>
      <td style="text-align: right">2.622551</td>
      <td style="text-align: right">0.0000026226</td>
    </tr>
    <tr>
      <td style="text-align: right">2000000</td>
      <td style="text-align: right">4.165023</td>
      <td style="text-align: right">0.0000020825</td>
    </tr>
    <tr>
      <td style="text-align: right">3000000</td>
      <td style="text-align: right">6.973098</td>
      <td style="text-align: right">0.0000023244</td>
    </tr>
    <tr>
      <td style="text-align: right">5000000</td>
      <td style="text-align: right">13.179743</td>
      <td style="text-align: right">0.0000026359</td>
    </tr>
    <tr>
      <td style="text-align: right"><strong>10000000</strong></td>
      <td style="text-align: right"><strong>53.387356</strong></td>
      <td style="text-align: right"><strong>0.0000053387</strong></td>
    </tr>
  </tbody>
</table>

<p>在对 <code>NXHashTable</code> 的性能测试中，当数据量小于 5000000 时，执行时间的增长还是线性的，平均时间也基本稳定，但是一旦数据量达到了千万级，执行时间就会出现显著的增长。</p>

<p>如果仅仅在哈希表中插入数据，相信其时间增长应该都是线性的，这里出现问题的原因推测是<strong>在对哈希表进行 Rehash 的时候，迁移原数据至新的数组所造成的</strong>。</p>

<p>如何避免哈希表的 Rehash 呢，重新回顾一下创建哈希表的函数：</p>

<pre><code class="language-objectivec">NXHashTable *NXCreateHashTable (NXHashTablePrototype prototype, unsigned capacity, const void *info);
</code></pre>

<p>这个函数的签名中包含一个 <code>capacity</code> 的参数，我们在上面的代码中传入了 0，也就是最开始的 <code>buckets</code> 数为 0，但是它的数目并不是固定的，它会随着哈希表中数据的增多，逐渐变大。</p>

<blockquote>
  <p><code>capacity</code> 只是一个提示，帮助 NXHashTable 了解其中会存储多少数据。</p>
</blockquote>

<p>如果在创建 <code>NXHashTable</code> 时传入 <code>capacity.integerValue</code>：</p>

<pre><code class="language-objectivec">  NXHashTable *hashTable = NXCreateHashTable(NXPtrPrototype, capacity.integerValue, NULL);
</code></pre>

<p>重新运行代码，测量性能：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">Capacities</th>
      <th style="text-align: right">Execution Time</th>
      <th style="text-align: right">Mean Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">100</td>
      <td style="text-align: right">0.000740</td>
      <td style="text-align: right">0.0000073999</td>
    </tr>
    <tr>
      <td style="text-align: right">1000</td>
      <td style="text-align: right">0.003442</td>
      <td style="text-align: right">0.0000034420</td>
    </tr>
    <tr>
      <td style="text-align: right">10000</td>
      <td style="text-align: right">0.023341</td>
      <td style="text-align: right">0.0000023341</td>
    </tr>
    <tr>
      <td style="text-align: right">100000</td>
      <td style="text-align: right">0.215209</td>
      <td style="text-align: right">0.0000021521</td>
    </tr>
    <tr>
      <td style="text-align: right">1000000</td>
      <td style="text-align: right">1.836802</td>
      <td style="text-align: right">0.0000018368</td>
    </tr>
    <tr>
      <td style="text-align: right">2000000</td>
      <td style="text-align: right">3.683246</td>
      <td style="text-align: right">0.0000018416</td>
    </tr>
    <tr>
      <td style="text-align: right">3000000</td>
      <td style="text-align: right">5.474610</td>
      <td style="text-align: right">0.0000018249</td>
    </tr>
    <tr>
      <td style="text-align: right">5000000</td>
      <td style="text-align: right">10.576254</td>
      <td style="text-align: right">0.0000021153</td>
    </tr>
    <tr>
      <td style="text-align: right">10000000</td>
      <td style="text-align: right">46.725459</td>
      <td style="text-align: right">0.0000046725</td>
    </tr>
  </tbody>
</table>

<p>虽然在测试 <code>10,000,000</code> 数据时其平均时间依然是 <code>5,000,000</code> 时的二倍，不过整体的性能都有所提升，然而这部分性能的损耗暂时还不是很清楚原因。</p>

<p>如果我们使用 Instrument 对有无 <code>capacity</code> 的情况进行比较（这是在使用 <code>2,000,000</code> 数据时进行的测试）：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-05-07-objc-hashtable-instrument.png" alt="objc-hashtable-instrument" /></p>

<p>没有传入 <code>capacity</code> 的哈希表会在多次插入之后出现一个峰值（由于 Rehash 引起的，其宽度就是 Rehash 使用的时间），而传入 <code>capacity</code> 的哈希表会在代码刚运行时就初始化足够大的数组。</p>

<h2 id="nsmutablearray-性能">NSMutableArray 性能</h2>

<blockquote>
  <p>这部分只算是一个小插曲，你可以选择跳过这一小节的内容。</p>
</blockquote>

<p><code>NSMutableArray</code> 的构造器 <code>- (instancetype)initWithCapacity:(NSUInteger)numItems</code> 也有一个参数 <code>capacity</code>，虽然数组和哈希表是两种数据结构。</p>

<blockquote>
  <p>不过我们这里主要研究的是：<strong>传入 <code>capacity</code> 是否会对性能造成影响</strong>。</p>
</blockquote>

<p>首先是使用 <code>init</code> 创建的 <code>NSMutableArray</code> 数组，也就是没有传入 <code>capacity</code>：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">Capacities</th>
      <th style="text-align: right">Execution Time</th>
      <th style="text-align: right">Mean Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">100</td>
      <td style="text-align: right">0.000539</td>
      <td style="text-align: right">0.0000053900</td>
    </tr>
    <tr>
      <td style="text-align: right">1000</td>
      <td style="text-align: right">0.003185</td>
      <td style="text-align: right">0.0000031850</td>
    </tr>
    <tr>
      <td style="text-align: right">10000</td>
      <td style="text-align: right">0.074033</td>
      <td style="text-align: right">0.0000074033</td>
    </tr>
    <tr>
      <td style="text-align: right">100000</td>
      <td style="text-align: right">0.370899</td>
      <td style="text-align: right">0.0000037090</td>
    </tr>
    <tr>
      <td style="text-align: right">1000000</td>
      <td style="text-align: right">1.504855</td>
      <td style="text-align: right">0.0000015049</td>
    </tr>
    <tr>
      <td style="text-align: right">2000000</td>
      <td style="text-align: right">2.852519</td>
      <td style="text-align: right">0.0000014263</td>
    </tr>
    <tr>
      <td style="text-align: right">3000000</td>
      <td style="text-align: right">3.995536</td>
      <td style="text-align: right">0.0000013318</td>
    </tr>
    <tr>
      <td style="text-align: right">5000000</td>
      <td style="text-align: right">6.833879</td>
      <td style="text-align: right">0.0000013668</td>
    </tr>
    <tr>
      <td style="text-align: right">10000000</td>
      <td style="text-align: right">14.444605</td>
      <td style="text-align: right">0.0000014445</td>
    </tr>
  </tbody>
</table>

<p>下面是使用 <code>initWithCapacity:</code> 创建的数组：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">Capacities</th>
      <th style="text-align: right">Execution Time</th>
      <th style="text-align: right">Mean Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">100</td>
      <td style="text-align: right">0.000256</td>
      <td style="text-align: right">0.0000025600</td>
    </tr>
    <tr>
      <td style="text-align: right">1000</td>
      <td style="text-align: right">0.001775</td>
      <td style="text-align: right">0.0000017750</td>
    </tr>
    <tr>
      <td style="text-align: right">10000</td>
      <td style="text-align: right">0.015906</td>
      <td style="text-align: right">0.0000015906</td>
    </tr>
    <tr>
      <td style="text-align: right">100000</td>
      <td style="text-align: right">0.174376</td>
      <td style="text-align: right">0.0000017438</td>
    </tr>
    <tr>
      <td style="text-align: right">1000000</td>
      <td style="text-align: right">1.650481</td>
      <td style="text-align: right">0.0000016505</td>
    </tr>
    <tr>
      <td style="text-align: right">2000000</td>
      <td style="text-align: right">2.802310</td>
      <td style="text-align: right">0.0000014012</td>
    </tr>
    <tr>
      <td style="text-align: right">3000000</td>
      <td style="text-align: right">4.451261</td>
      <td style="text-align: right">0.0000014838</td>
    </tr>
    <tr>
      <td style="text-align: right">5000000</td>
      <td style="text-align: right">7.093753</td>
      <td style="text-align: right">0.0000014188</td>
    </tr>
    <tr>
      <td style="text-align: right">10000000</td>
      <td style="text-align: right">14.598415</td>
      <td style="text-align: right">0.0000014598</td>
    </tr>
  </tbody>
</table>

<p>你可以在表格中看到，两者在执行效率上并没有显著的差异或者区别。</p>

<p>但是如果使用 instrument 来查看两者的内存分配，可以很明显的看到，没有传入 <code>capacity</code> 的 <code>NSMutableArray</code> 会在可变数组内存占用增加前出现一个<strong>短暂的内存分配峰值</strong>。</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-05-07-objc-hashtable-nsarray-instrument.png" alt="objc-hashtable-nsarray-instrument" /></p>

<p>导致这一现象的原始可能是：在将原数组中的内容移入新数组时，<strong>临时变量申请了大量的内存控件</strong>。</p>

<blockquote>
  <p>在之后关于 CoreFoundation 源代码分析的文中会介绍它们是怎么实现的。</p>
</blockquote>

<h2 id="nxhashtable-的应用">NXHashTable 的应用</h2>

<p>在整个 objc/runtime 中，作为<strong>私有</strong>的数据结构 <code>NXHashTable</code>，直接使用了它的就是<strong>存储所有类或者元类</strong>的哈希表（在这里会忽略对元类的存储，因为实现几乎完全相同）：</p>

<pre><code class="language-objectivec">static NXHashTable *realized_class_hash = nil;
</code></pre>

<p>我么可以使用 <code>objc_copyClassList</code> 获取类的数组：</p>

<pre><code class="language-objectivec">Class *
objc_copyClassList(unsigned int *outCount)
{
    rwlock_writer_t lock(runtimeLock);

    realizeAllClasses();

    Class *result = nil;
    NXHashTable *classes = realizedClasses();
    unsigned int count = NXCountHashTable(classes);

    if (count &gt; 0) {
        Class cls;
        NXHashState state = NXInitHashState(classes);
        result = (Class *)malloc((1+count) * sizeof(Class));
        count = 0;
        while (NXNextHashState(classes, &amp;state, (void **)&amp;cls)) {
            result[count++] = cls;
        }
        result[count] = nil;
    }

    if (outCount) *outCount = count;
    return result;
}
</code></pre>

<ol>
  <li>调用 <code>realizedClasses</code> 返回 <code>realized_class_hash</code> 哈希表</li>
  <li>使用 <code>NSHashState</code> 遍历 <code>realized_class_hash</code> 中的类，并将所有的类存入 <code>result</code></li>
</ol>

<p>接下来使用上面的方法，打印出 <code>realized_class_hash</code> 中存储的所有类：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-05-07-objc-hashtable-copy-class-list.png" alt="objc-hashtable-copy-class-list" /></p>

<h2 id="小结">小结</h2>

<blockquote>
  <p><code>NXHashTable</code> 在 OS X 10.1 中就已经标记为弃用了，但是依旧支持着 runtime 底层的工作。</p>
</blockquote>

<p><code>NXHashTable</code> 可以说有着<strong>非常非常</strong>久远的历史了，最早可以追溯到将近 30 多年前 NeXT 时代：</p>

<pre><code class="language-c">// hashtable2.mm 文件中

hashtable2.m
Copyright 1989-1996 NeXT Software, Inc.
Created by Bertrand Serlet, Feb 89
</code></pre>

<p><code>NSHashTable</code> 对哈希表的实现还是非常优雅的，可以说非常标准的使用了<a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists">拉链法</a>实现哈希表。</p>

<p>不过现在，我们会使用 <code>NSHashTable</code> 来取代这个上古时代的产物。</p>

<iframe src="http://ghbtns.com/github-btn.html?user=nju520&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>
</blockquote>

  ]]></description>
</item>

<item>
  <title>懒惰的 initialize 方法</title>
  <link>//initialize</link>
  <author>nju520</author>
  <pubDate>2016-04-30T17:50:08+08:00</pubDate>
  <guid>//initialize</guid>
  <description><![CDATA[
  <iframe src="http://ghbtns.com/github-btn.html?user=nju520&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>
</blockquote>

<blockquote>
  <p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p>
</blockquote>

<h2 id="写在前面">写在前面</h2>

<p>这篇文章可能是对 Objective-C 源代码解析系列文章中最短的一篇了，在 Objective-C 中，我们总是会同时想到 <code>load</code>、<code>initialize</code> 这两个类方法。而这两个方法也经常在一起比较：</p>

<p>在上一篇介绍 <code>load</code> 方法的<a href="https://github.com/nju520/iOS-Source-Code-Analyze/blob/master/objc/你真的了解%20load%20方法么？.md">文章</a>中，已经对 <code>load</code> 方法的调用时机、调用顺序进行了详细地分析，所以对于 <code>load</code> 方法，这里就不在赘述了。</p>

<p>这篇文章会<del>假设你知道：</del>假设你是 iOS 开发者。</p>

<p>本文会主要介绍：</p>

<ol>
  <li><code>initialize</code> 方法的调用为什么是惰性的</li>
  <li>这货能干啥</li>
</ol>

<h2 id="initialize-的调用栈">initialize 的调用栈</h2>

<p>在分析其调用栈之前，首先来解释一下，什么是惰性的。</p>

<p>这是 <code>main.m</code> 文件中的代码：</p>

<pre><code class="language-objectivec">#import &lt;Foundation/Foundation.h&gt;

@interface XXObject : NSObject @end

@implementation XXObject

+ (void)initialize {
    NSLog(@"XXObject initialize");
}

@end

int main(int argc, const char * argv[]) {
    @autoreleasepool { }
    return 0;
}
</code></pre>

<p>主函数中的代码为空，如果我们运行这个程序：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-30-objc-initialize-print-nothing.png" alt="objc-initialize-print-nothing" /></p>

<p>你会发现与 <code>load</code> 方法不同的是，虽然我们在 <code>initialize</code> 方法中调用了 <code>NSLog</code>。但是程序运行之后没有任何输出。</p>

<p>如果，我们在自动释放池中加入以下代码：</p>

<pre><code class="language-objectivec">int main(int argc, const char * argv[]) {
    @autoreleasepool {
        __unused XXObject *object = [[XXObject alloc] init];
    }
    return 0;
}
</code></pre>

<p>再运行程序：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-30-objc-initialize-print-initialize.png" alt="objc-initialize-print-initialize" /></p>

<p>你会发现，虽然我们没有直接调用 <code>initialize</code> 方法。但是，这里也打印出了 <code>XXObject initialize</code> 字符串。</p>

<blockquote>
  <p><code>initialize</code> <strong>只会在对应类的方法第一次被调用时，才会调用</strong>。</p>
</blockquote>

<p>我们在 <code>initialize</code> 方法中打一个断点，来查看这个方法的调用栈：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-30-objc-initialize-breakpoint.png" alt="objc-initialize-breakpoint" /></p>

<pre><code class="language-objectivec">0 +[XXObject initialize]
1 _class_initialize
2 lookUpImpOrForward
3 _class_lookupMethodAndLoadCache3
4 objc_msgSend
5 main
6 start
</code></pre>

<p>直接来看调用栈中的 <code>lookUpImpOrForward</code> 方法，<code>lookUpImpOrForward</code> 方法<strong>只会在向对象发送消息，并且在类的缓存中没有找到消息的选择子时</strong>才会调用，具体可以看这篇文章，<a href="https://github.com/nju520/iOS-Source-Code-Analyze/blob/master/objc/从源代码看%20ObjC%20中消息的发送.md">从源代码看 ObjC 中消息的发送</a>。</p>

<p>在这里，我们知道 <code>lookUpImpOrForward</code> 方法是 <code>objc_msgSend</code> 触发的就够了。</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-30-objc-initialize-print-selector.png" alt="objc-initialize-print-selecto" /></p>

<p>在 lldb 中输入 <code>p sel</code> 打印选择子，会发现当前调用的方法是 <code>alloc</code> 方法，也就是说，<code>initialize</code> 方法是在 <code>alloc</code> 方法之前调用的，<code>alloc</code> 的调用导致了前者的执行。</p>

<p>其中，使用 <code>if (initialize  &amp;&amp;  !cls-&gt;isInitialized())</code> 来判断当前类是否初始化过：</p>

<pre><code class="language-objectivec">bool isInitialized() {
   return getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED;
}
</code></pre>

<blockquote>
  <p>当前类是否初始化过的信息就保存在<a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html">元类</a>的 <code>class_rw_t</code> 结构体中的 <code>flags</code> 中。</p>
</blockquote>

<p>这是 <code>flags</code> 中保存的信息，它记录着跟当前类的元数据，其中第 16-31 位有如下的作用：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-30-objc-initialize-class_rw_t_-bits-flag.png" alt="objc-initialize-class_rw_t_-bits-flag" /></p>

<p><code>flags</code> 的第 29 位 <code>RW_INITIALIZED</code> 就保存了当前类是否初始化过的信息。</p>

<h2 id="_class_initialize-方法">_class_initialize 方法</h2>

<p>在 <code>initialize</code> 的调用栈中，直接调用其方法的是下面的这个 C 语言函数：</p>

<pre><code class="language-objectivec">void _class_initialize(Class cls)
{
    Class supercls;
    BOOL reallyInitialize = NO;

    // 1. 强制父类先调用 initialize 方法
    supercls = cls-&gt;superclass;
    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) {
        _class_initialize(supercls);
    }

    {
        // 2. 通过加锁来设置 RW_INITIALIZING 标志位
        monitor_locker_t lock(classInitLock);
        if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) {
            cls-&gt;setInitializing();
            reallyInitialize = YES;
        }
    }

    if (reallyInitialize) {
        // 3. 成功设置标志位，向当前类发送 +initialize 消息
        _setThisThreadIsInitializingClass(cls);

        ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);

        // 4. 完成初始化，如果父类已经初始化完成，设置 RW_INITIALIZED 标志位，
        //    否则，在父类初始化完成之后再设置标志位。
        monitor_locker_t lock(classInitLock);
        if (!supercls  ||  supercls-&gt;isInitialized()) {
            _finishInitializing(cls, supercls);
        } else {
            _finishInitializingAfter(cls, supercls);
        }
        return;
    } else if (cls-&gt;isInitializing()) {
        // 5. 当前线程正在初始化当前类，直接返回，否则，会等待其它线程初始化结束后，再返回
        if (_thisThreadIsInitializingClass(cls)) {
            return;
        } else {
            monitor_locker_t lock(classInitLock);
            while (!cls-&gt;isInitialized()) {
                classInitLock.wait();
            }
            return;
        }
    } else if (cls-&gt;isInitialized()) {
        // 6. 初始化成功后，直接返回
        return;
    } else {
        _objc_fatal("thread-safe class init in objc runtime is buggy!");
    }
}
</code></pre>

<p>方法的主要作用自然是向未初始化的类发送 <code>+initialize</code> 消息，不过会强制父类先发送 <code>+initialize</code>。</p>

<ol>
  <li>
    <p>强制<strong>未初始化过的</strong>父类调用 <code>initialize</code> 方法</p>

    <pre><code> if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) {
     _class_initialize(supercls);
 }
</code></pre>
  </li>
  <li>
    <p>通过加锁来设置 <code>RW_INITIALIZING</code> 标志位</p>

    <pre><code> monitor_locker_t lock(classInitLock);
 if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) {
     cls-&gt;setInitializing();
     reallyInitialize = YES;
 }
</code></pre>
  </li>
  <li>
    <p>成功设置标志位、向当前类发送 <code>+initialize</code> 消息</p>

    <pre><code class="language-objectivec"> ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);
</code></pre>
  </li>
  <li>
    <p>完成初始化，如果父类已经初始化完成，设置 <code>RW_INITIALIZED</code> 标志位。否则，在父类初始化完成之后再设置标志位</p>

    <pre><code> monitor_locker_t lock(classInitLock);
 if (!supercls  ||  supercls-&gt;isInitialized()) {
     _finishInitializing(cls, supercls);
 } else {
     _finishInitializingAfter(cls, supercls);
 }
</code></pre>
  </li>
  <li>
    <p>如果当前线程正在初始化当前类，直接返回，否则，会等待其它线程初始化结束后，再返回，<strong>保证线程安全</strong></p>

    <pre><code> if (_thisThreadIsInitializingClass(cls)) {
     return;
 } else {
     monitor_locker_t lock(classInitLock);
     while (!cls-&gt;isInitialized()) {
         classInitLock.wait();
     }
     return;
 }
</code></pre>
  </li>
  <li>
    <p>初始化成功后，直接返回</p>

    <pre><code> return;
</code></pre>
  </li>
</ol>

<h2 id="管理初始化队列">管理初始化队列</h2>

<p>因为我们始终要保证父类的初始化方法要在子类之前调用，所以我们需要维护一个 <code>PendingInitializeMap</code> 的数据结构来存储<strong>当前的类初始化需要哪个父类先初始化完成</strong>。</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-30-PendingInitializeMap.png" alt="PendingInitializeMap" /></p>

<p>这个数据结构中的信息会被两个方法改变：</p>

<pre><code class="language-objectivec">if (!supercls  ||  supercls-&gt;isInitialized()) {
  _finishInitializing(cls, supercls);
} else {
  _finishInitializingAfter(cls, supercls);
}
</code></pre>

<p>分别是 <code>_finishInitializing</code> 以及 <code>_finishInitializingAfter</code>，先来看一下后者是怎么实现的，也就是<strong>在父类没有完成初始化的时候</strong>调用的方法：</p>

<pre><code class="language-objectivec">static void _finishInitializingAfter(Class cls, Class supercls)
{
    PendingInitialize *pending;
    pending = (PendingInitialize *)malloc(sizeof(*pending));
    pending-&gt;subclass = cls;
    pending-&gt;next = (PendingInitialize *)NXMapGet(pendingInitializeMap, supercls);
    NXMapInsert(pendingInitializeMap, supercls, pending);
}
</code></pre>

<p>因为当前类的父类没有初始化，所以会将子类加入一个数据结构 <code>PendingInitialize</code> 中，这个数据结构其实就类似于一个保存子类的链表。这个链表会以父类为键存储到 <code>pendingInitializeMap</code> 中。</p>

<pre><code class="language-objective">NXMapInsert(pendingInitializeMap, supercls, pending);
</code></pre>

<p>而在<strong>父类已经调用了初始化方法</strong>的情况下，对应方法 <code>_finishInitializing</code> 的实现就稍微有些复杂了：</p>

<pre><code class="language-objectivec">static void _finishInitializing(Class cls, Class supercls)
{
    PendingInitialize *pending;

    cls-&gt;setInitialized();

    if (!pendingInitializeMap) return;
    pending = (PendingInitialize *)NXMapGet(pendingInitializeMap, cls);
    if (!pending) return;

    NXMapRemove(pendingInitializeMap, cls);

    while (pending) {
        PendingInitialize *next = pending-&gt;next;
        if (pending-&gt;subclass) _finishInitializing(pending-&gt;subclass, cls);
        free(pending);
        pending = next;
    }
}
</code></pre>

<p>首先，由于父类已经完成了初始化，在这里直接将当前类标记成已经初始化，然后<strong>递归地将被当前类 block 的子类标记为已初始化</strong>，再把这些当类移除 <code>pendingInitializeMap</code>。</p>

<h2 id="小结">小结</h2>

<p>到这里，我们对 <code>initialize</code> 方法的研究基本上已经结束了，这里会总结一下关于其方法的特性：</p>

<ol>
  <li><code>initialize</code> 的调用是惰性的，它会在第一次调用当前类的方法时被调用</li>
  <li>与 <code>load</code> 不同，<code>initialize</code> 方法调用时，所有的类都<strong>已经加载</strong>到了内存中</li>
  <li><code>initialize</code> 的运行是线程安全的</li>
  <li>子类会<strong>继承</strong>父类的 <code>initialize</code> 方法</li>
</ol>

<p>而其作用也非常局限，一般我们只会在 <code>initialize</code> 方法中进行一些常量的初始化。</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html">What is a meta-class in Objective-C?</a></li>
  <li><a href="http://stackoverflow.com/questions/13326435/nsobject-load-and-initialize-what-do-they-do">NSObject +load and +initialize - What do they do?</a></li>
</ul>

<iframe src="http://ghbtns.com/github-btn.html?user=nju520&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>
</blockquote>

  ]]></description>
</item>

<item>
  <title>你真的了解 load 方法么？</title>
  <link>//load</link>
  <author>nju520</author>
  <pubDate>2016-04-28T13:33:07+08:00</pubDate>
  <guid>//load</guid>
  <description><![CDATA[
  <blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>
</blockquote>

<blockquote>
  <p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p>
</blockquote>

<h2 id="写在前面">写在前面</h2>

<blockquote>
  <p>文章的标题与其说是问各位读者，不如说是问笔者自己：<strong>我</strong>真的了解 <code>+ load</code> 方法么？</p>
</blockquote>

<p><code>+ load</code> 作为 Objective-C 中的一个方法，与其它方法有很大的不同。它只是一个<strong>在整个文件被加载到运行时，在 <code>main</code> 函数调用之前被 ObjC 运行时调用的钩子方法</strong>。其中关键字有这么几个：</p>

<ul>
  <li>文件刚加载</li>
  <li><code>main</code> 函数之前</li>
  <li>钩子方法</li>
</ul>

<p>我在阅读 ObjC 源代码之前，曾经一度感觉自己对 <code>+ load</code> 方法的作用非常了解，直到看了源代码中的实现，才知道以前的以为，只是自己的以为罢了。</p>

<p>这篇文章会假设你知道：</p>

<ul>
  <li>使用过 <code>+ load</code> 方法</li>
  <li>知道 <code>+ load</code> 方法的调用顺序（文章中会简单介绍）</li>
</ul>

<p>在这篇文章中并不会用大篇幅介绍 <code>+ load</code> 方法的作用<del>其实也没几个作用</del>，关注点主要在以下两个问题上：</p>

<ul>
  <li><code>+ load</code> 方法是如何被调用的</li>
  <li><code>+ load</code> 方法为什么会有这种调用顺序</li>
</ul>

<h2 id="load-方法的调用栈">load 方法的调用栈</h2>

<p>首先来通过 <code>load</code> 方法的调用栈，分析一下它到底是如何被调用的。</p>

<p>下面是程序的全部代码：</p>

<pre><code class="language-objectivec">// main.m
#import &lt;Foundation/Foundation.h&gt;

@interface XXObject : NSObject @end

@implementation XXObject

+ (void)load {
    NSLog(@"XXObject load");
}

@end

int main(int argc, const char * argv[]) {
    @autoreleasepool { }
    return 0;
}
</code></pre>

<p>代码总共只实现了一个 <code>XXObject</code> 的 <code>+ load</code> 方法，主函数中也没有任何的东西：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-28-objc-load-print-load.png" alt="objc-load-print-load" /></p>

<p>虽然在主函数中什么方法都没有调用，但是运行之后，依然打印了 <code>XXObject load</code> 字符串，也就是说调用了 <code>+ load</code> 方法。</p>

<h3 id="使用符号断点">使用符号断点</h3>

<p>使用 Xcode 添加一个符号断点 <code>+[XXObject load]</code>：</p>

<blockquote>
  <p>注意这里 <code>+</code> 和 <code>[</code> 之间没有空格</p>
</blockquote>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-28-objc-load-symbolic-breakpoint.png" alt="objc-load-symbolic-breakpoint" /></p>

<blockquote>
  <p>为什么要加一个符号断点呢？因为这样看起来比较高级。</p>
</blockquote>

<p>重新运行程序。这时，代码会停在 <code>NSLog(@"XXObject load");</code> 这一行的实现上：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-28-objc-load-break-after-add-breakpoint.png" alt="objc-load-break-after-add-breakpoint" /></p>

<p>左侧的调用栈很清楚的告诉我们，哪些方法被调用了：</p>

<pre><code class="language-objectivec">0  +[XXObject load]
1  call_class_loads()
2  call_load_methods
3  load_images
4  dyld::notifySingle(dyld_image_states, ImageLoader const*)
11 _dyld_start
</code></pre>

<blockquote>
  <p><a href="https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dyld.3.html">dyld</a> 是 the dynamic link editor 的缩写，它是苹果的<em>动态链接器</em>。</p>

  <p>在系统内核做好程序准备工作之后，交由 dyld 负责余下的工作。本文不会对其进行解释</p>
</blockquote>

<p>每当有新的镜像加载之后，都会执行 <code>3 load_images</code> 方法进行回调，这里的回调是在整个运行时初始化时 <code>_objc_init</code> 注册的（会在之后的文章中具体介绍）：</p>

<pre><code class="language-objectivec">dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);
</code></pre>

<p>有新的镜像被加载到 runtime 时，调用 <code>load_images</code> 方法，并传入最新镜像的信息列表 <code>infoList</code>：</p>

<pre><code class="language-objectivec">const char *
load_images(enum dyld_image_states state, uint32_t infoCount,
            const struct dyld_image_info infoList[])
{
    bool found;

    found = false;
    for (uint32_t i = 0; i &lt; infoCount; i++) {
        if (hasLoadMethods((const headerType *)infoList[i].imageLoadAddress)) {
            found = true;
            break;
        }
    }
    if (!found) return nil;

    recursive_mutex_locker_t lock(loadMethodLock);

    {
        rwlock_writer_t lock2(runtimeLock);
        found = load_images_nolock(state, infoCount, infoList);
    }

    if (found) {
        call_load_methods();
    }

    return nil;
}
</code></pre>

<h3 id="什么是镜像">什么是镜像</h3>

<p>这里就会遇到一个问题：镜像到底是什么，我们用一个断点打印出所有加载的镜像：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-28-objc-load-print-image-info.png" alt="objc-load-print-image-info" /></p>

<p>从控制台输出的结果大概就是这样的，我们可以看到镜像并不是一个 Objective-C 的代码文件，它应该是一个 target 的编译产物。</p>

<pre><code class="language-objectivec">...
(const dyld_image_info) $52 = {
  imageLoadAddress = 0x00007fff8a144000
  imageFilePath = 0x00007fff8a144168 "/System/Library/Frameworks/CoreServices.framework/Versions/A/CoreServices"
  imageFileModDate = 1452737802
}
(const dyld_image_info) $53 = {
  imageLoadAddress = 0x00007fff946d9000
  imageFilePath = 0x00007fff946d9480 "/usr/lib/liblangid.dylib"
  imageFileModDate = 1452737618
}
(const dyld_image_info) $54 = {
  imageLoadAddress = 0x00007fff88016000
  imageFilePath = 0x00007fff88016d40 "/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation"
  imageFileModDate = 1452737917
}
(const dyld_image_info) $55 = {
  imageLoadAddress = 0x0000000100000000
  imageFilePath = 0x00007fff5fbff8f0 "/Users/apple/Library/Developer/Xcode/DerivedData/objc-dibgivkseuawonexgbqssmdszazo/Build/Products/Debug/debug-objc"
  imageFileModDate = 0
}
</code></pre>

<p>这里面有很多的动态链接库，还有一些苹果为我们提供的框架，比如 Foundation、 CoreServices 等等，都是在这个 <code>load_images</code> 中加载进来的，而这些 <code>imageFilePath</code> 都是对应的<strong>二进制文件</strong>的地址。</p>

<p>但是如果进入最下面的这个目录，会发现它是一个<strong>可执行文件</strong>，它的运行结果与 Xcode 中的运行结果相同：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-28-objc-load-image-binary.png" alt="objc-load-image-binary" /></p>

<h3 id="准备--load-方法">准备 + load 方法</h3>

<p>我们重新回到 <code>load_images</code> 方法，如果在扫描镜像的过程中发现了 <code>+ load</code> 符号：</p>

<pre><code class="language-objectivec">for (uint32_t i = 0; i &lt; infoCount; i++) {
    if (hasLoadMethods((const headerType *)infoList[i].imageLoadAddress)) {
        found = true;
        break;
    }
}
</code></pre>

<p>就会进入 <code>load_images_nolock</code> 来查找 <code>load</code> 方法：</p>

<pre><code class="language-objectivec">bool load_images_nolock(enum dyld_image_states state,uint32_t infoCount,
                   const struct dyld_image_info infoList[])
{
    bool found = NO;
    uint32_t i;

    i = infoCount;
    while (i--) {
        const headerType *mhdr = (headerType*)infoList[i].imageLoadAddress;
        if (!hasLoadMethods(mhdr)) continue;

        prepare_load_methods(mhdr);
        found = YES;
    }

    return found;
}
</code></pre>

<p>调用 <code>prepare_load_methods</code> 对 <code>load</code> 方法的调用进行准备（将需要调用 <code>load</code> 方法的类添加到一个列表中，后面的小节中会介绍）：</p>

<pre><code class="language-objectivec">void prepare_load_methods(const headerType *mhdr)
{
    size_t count, i;

    runtimeLock.assertWriting();

    classref_t *classlist =
        _getObjc2NonlazyClassList(mhdr, &amp;count);
    for (i = 0; i &lt; count; i++) {
        schedule_class_load(remapClass(classlist[i]));
    }

    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);
    for (i = 0; i &lt; count; i++) {
        category_t *cat = categorylist[i];
        Class cls = remapClass(cat-&gt;cls);
        if (!cls) continue;  // category for ignored weak-linked class
        realizeClass(cls);
        assert(cls-&gt;ISA()-&gt;isRealized());
        add_category_to_loadable_list(cat);
    }
}
</code></pre>

<p>通过 <code>_getObjc2NonlazyClassList</code> 获取所有的类的列表之后，会通过 <code>remapClass</code> 获取类对应的指针，然后调用 <code>schedule_class_load</code> <strong>递归地安排当前类和没有调用 <code>+ load</code> 父类</strong>进入列表。</p>

<pre><code class="language-objectivec">static void schedule_class_load(Class cls)
{
    if (!cls) return;
    assert(cls-&gt;isRealized());

    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;

    schedule_class_load(cls-&gt;superclass);

    add_class_to_loadable_list(cls);
    cls-&gt;setInfo(RW_LOADED);
}
</code></pre>

<p>在执行 <code>add_class_to_loadable_list(cls)</code> 将当前类加入加载列表之前，会<strong>先把父类加入待加载的列表</strong>，保证父类在子类前调用 <code>load</code> 方法。</p>

<h3 id="调用--load-方法">调用 + load 方法</h3>

<p>在将镜像加载到运行时、对 <code>load</code> 方法的准备就绪之后，执行 <code>call_load_methods</code>，开始调用 <code>load</code> 方法：</p>

<pre><code class="language-objectivec">void call_load_methods(void)
{
    ...

    do {
        while (loadable_classes_used &gt; 0) {
            call_class_loads();
        }

        more_categories = call_category_loads();

    } while (loadable_classes_used &gt; 0  ||  more_categories);

    ...
}
</code></pre>

<p>方法的调用流程大概是这样的：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-28-objc-load-diagram.png" alt="objc-load-diagra" /></p>

<p>其中 <code>call_class_loads</code> 会从一个待加载的类列表 <code>loadable_classes</code> 中寻找对应的类，然后找到 <code>@selector(load)</code> 的实现并执行。</p>

<pre><code class="language-objectivec">static void call_class_loads(void)
{
    int i;

    struct loadable_class *classes = loadable_classes;
    int used = loadable_classes_used;
    loadable_classes = nil;
    loadable_classes_allocated = 0;
    loadable_classes_used = 0;

    for (i = 0; i &lt; used; i++) {
        Class cls = classes[i].cls;
        load_method_t load_method = (load_method_t)classes[i].method;
        if (!cls) continue;

        (*load_method)(cls, SEL_load);
    }

    if (classes) free(classes);
}
</code></pre>

<p>这行 <code>(*load_method)(cls, SEL_load)</code> 代码就会调用 <code>+[XXObject load]</code> 方法。</p>

<blockquote>
  <p>我们会在下面介绍 <code>loadable_classes</code> 列表是如何管理的。</p>
</blockquote>

<p>到现在，我们回答了第一个问题：</p>

<p>Q：<strong><code>load</code> 方法是如何被调用的？</strong></p>

<p>A：当 Objective-C 运行时初始化的时候，会通过 <code>dyld_register_image_state_change_handler</code> 在每次有新的镜像加入<em>运行时</em>的时候，进行回调。执行 <code>load_images</code> 将所有包含 <code>load</code> 方法的文件加入列表 <code>loadable_classes</code> ，然后从这个列表中找到对应的 <code>load</code> 方法的实现，调用 <code>load</code> 方法。</p>

<h2 id="加载的管理">加载的管理</h2>

<p>ObjC 对于加载的管理，主要使用了两个列表，分别是 <code>loadable_classes</code> 和 <code>loadable_categories</code>。</p>

<p>方法的调用过程也分为两个部分，准备 <code>load</code> 方法和调用 <code>load</code> 方法，我更觉得这两个部分比较像生产者与消费者：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-28-objc-load-producer-consumer-diagram.png" alt="objc-load-producer-consumer-diagra" /></p>

<p><code>add_class_to_loadable_list</code> 方法负责将类加入 <code>loadable_classes</code> 集合，而 <code>call_class_loads</code> 负责消费集合中的元素。</p>

<p>而对于分类来说，其模型也是类似的，只不过使用了另一个列表 <code>loadable_categories</code>。</p>

<h3 id="生产-loadable_class">“生产” loadable_class</h3>

<p>在调用 <code>load_images -&gt; load_images_nolock -&gt; prepare_load_methods -&gt; schedule_class_load -&gt; add_class_to_loadable_list</code> 的时候会将未加载的类添加到 <code>loadable_classes</code> 数组中：</p>

<pre><code class="language-objectivec">void add_class_to_loadable_list(Class cls)
{
    IMP method;

    loadMethodLock.assertLocked();

    method = cls-&gt;getLoadMethod();
    if (!method) return;

    if (loadable_classes_used == loadable_classes_allocated) {
        loadable_classes_allocated = loadable_classes_allocated*2 + 16;
        loadable_classes = (struct loadable_class *)
            realloc(loadable_classes,
                              loadable_classes_allocated *
                              sizeof(struct loadable_class));
    }

    loadable_classes[loadable_classes_used].cls = cls;
    loadable_classes[loadable_classes_used].method = method;
    loadable_classes_used++;
}
</code></pre>

<p>方法刚被调用时：</p>

<ol>
  <li>会从 <code>class</code> 中获取 <code>load</code> 方法： <code>method = cls-&gt;getLoadMethod();</code></li>
  <li>判断当前 <code>loadable_classes</code> 这个数组是否已经被全部占用了：<code>loadable_classes_used == loadable_classes_allocated</code></li>
  <li>在当前数组的基础上扩大数组的大小：<code>realloc</code></li>
  <li>把传入的 <code>class</code> 以及对应的方法的实现加到列表中</li>
</ol>

<p>另外一个用于保存分类的列表 <code>loadable_categories</code> 也有一个类似的方法 <code>add_category_to_loadable_list</code>。</p>

<pre><code class="language-objectivec">void add_category_to_loadable_list(Category cat)
{
    IMP method;

    loadMethodLock.assertLocked();

    method = _category_getLoadMethod(cat);

    if (!method) return;

    if (loadable_categories_used == loadable_categories_allocated) {
        loadable_categories_allocated = loadable_categories_allocated*2 + 16;
        loadable_categories = (struct loadable_category *)
            realloc(loadable_categories,
                              loadable_categories_allocated *
                              sizeof(struct loadable_category));
    }

    loadable_categories[loadable_categories_used].cat = cat;
    loadable_categories[loadable_categories_used].method = method;
    loadable_categories_used++;
}
</code></pre>

<p>实现几乎与 <code>add_class_to_loadable_list</code> 完全相同。</p>

<p>到这里我们完成了对 <code>loadable_classes</code> 以及 <code>loadable_categories</code> 的提供，下面会开始消耗列表中的元素。</p>

<h3 id="消费-loadable_class">“消费” loadable_class</h3>

<p>调用 <code>load</code> 方法的过程就是“消费” <code>loadable_classes</code> 的过程，<code>load_images -&gt; call_load_methods -&gt; call_class_loads</code> 会从 <code>loadable_classes</code> 中取出对应类和方法，执行 <code>load</code>。</p>

<pre><code class="language-objectivec">void call_load_methods(void)
{
    static bool loading = NO;
    bool more_categories;

    loadMethodLock.assertLocked();

    if (loading) return;
    loading = YES;

    void *pool = objc_autoreleasePoolPush();

    do {
        while (loadable_classes_used &gt; 0) {
            call_class_loads();
        }

        more_categories = call_category_loads();

    } while (loadable_classes_used &gt; 0  ||  more_categories);

    objc_autoreleasePoolPop(pool);

    loading = NO;
}
</code></pre>

<p>上述方法对所有在 <code>loadable_classes</code> 以及 <code>loadable_categories</code> 中的类以及分类执行 <code>load</code> 方法。</p>

<pre><code class="language-objectivec">do {
    while (loadable_classes_used &gt; 0) {
        call_class_loads();
    }

    more_categories = call_category_loads();

} while (loadable_classes_used &gt; 0  ||  more_categories);
</code></pre>

<p>调用顺序如下：</p>

<ol>
  <li>不停调用类的 <code>+ load</code> 方法，直到 <code>loadable_classes</code> 为空</li>
  <li>调用<strong>一次</strong> <code>call_category_loads</code> 加载分类</li>
  <li>如果有 <code>loadable_classes</code> 或者更多的分类，继续调用 <code>load</code> 方法</li>
</ol>

<p>相比于类 <code>load</code> 方法的调用，分类中 <code>load</code> 方法的调用就有些复杂了：</p>

<pre><code class="language-objectivec">static bool call_category_loads(void)
{
    int i, shift;
    bool new_categories_added = NO;
    // 1. 获取当前可以加载的分类列表
    struct loadable_category *cats = loadable_categories;
    int used = loadable_categories_used;
    int allocated = loadable_categories_allocated;
    loadable_categories = nil;
    loadable_categories_allocated = 0;
    loadable_categories_used = 0;

    for (i = 0; i &lt; used; i++) {
        Category cat = cats[i].cat;
        load_method_t load_method = (load_method_t)cats[i].method;
        Class cls;
        if (!cat) continue;

        cls = _category_getClass(cat);
        if (cls  &amp;&amp;  cls-&gt;isLoadable()) {
            // 2. 如果当前类是可加载的 `cls  &amp;&amp;  cls-&gt;isLoadable()` 就会调用分类的 load 方法
            (*load_method)(cls, SEL_load);
            cats[i].cat = nil;
        }
    }

    // 3. 将所有加载过的分类移除 `loadable_categories` 列表
    shift = 0;
    for (i = 0; i &lt; used; i++) {
        if (cats[i].cat) {
            cats[i-shift] = cats[i];
        } else {
            shift++;
        }
    }
    used -= shift;

    // 4. 为 `loadable_categories` 重新分配内存，并重新设置它的值
    new_categories_added = (loadable_categories_used &gt; 0);
    for (i = 0; i &lt; loadable_categories_used; i++) {
        if (used == allocated) {
            allocated = allocated*2 + 16;
            cats = (struct loadable_category *)
                realloc(cats, allocated *
                                  sizeof(struct loadable_category));
        }
        cats[used++] = loadable_categories[i];
    }

    if (loadable_categories) free(loadable_categories);

    if (used) {
        loadable_categories = cats;
        loadable_categories_used = used;
        loadable_categories_allocated = allocated;
    } else {
        if (cats) free(cats);
        loadable_categories = nil;
        loadable_categories_used = 0;
        loadable_categories_allocated = 0;
    }

    return new_categories_added;
}
</code></pre>

<p>这个方法有些长，我们来分步解释方法的作用：</p>

<ol>
  <li>获取当前可以加载的分类列表</li>
  <li>如果当前类是可加载的 <code>cls  &amp;&amp;  cls-&gt;isLoadable()</code> 就会调用分类的 <code>load</code> 方法</li>
  <li>将所有加载过的分类移除 <code>loadable_categories</code> 列表</li>
  <li>为 <code>loadable_categories</code> 重新分配内存，并重新设置它的值</li>
</ol>

<h2 id="调用的顺序">调用的顺序</h2>

<p>你过去可能会听说过，对于 <code>load</code> 方法的调用顺序有两条规则：</p>

<ol>
  <li>父类先于子类调用</li>
  <li>类先于分类调用</li>
</ol>

<p>这种现象是非常符合我们的直觉的，我们来分析一下这种现象出现的原因。</p>

<p>第一条规则是由于 <code>schedule_class_load</code> 有如下的实现：</p>

<pre><code class="language-objectivec">static void schedule_class_load(Class cls)
{
    if (!cls) return;
    assert(cls-&gt;isRealized());

    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;

    schedule_class_load(cls-&gt;superclass);

    add_class_to_loadable_list(cls);
    cls-&gt;setInfo(RW_LOADED);
}
</code></pre>

<p>这里通过这行代码 <code>schedule_class_load(cls-&gt;superclass)</code> 总是能够保证没有调用 <code>load</code> 方法的父类先于子类加入 <code>loadable_classes</code> 数组，从而确保其调用顺序的正确性。</p>

<p>类与分类中 <code>load</code> 方法的调用顺序主要在 <code>call_load_methods</code> 中实现：</p>

<pre><code class="language-objectivec">do {
    while (loadable_classes_used &gt; 0) {
        call_class_loads();
    }

    more_categories = call_category_loads();

} while (loadable_classes_used &gt; 0  ||  more_categories);
</code></pre>

<p>上面的 <code>do while</code> 语句能够在一定程度上确保，类的 <code>load</code> 方法会先于分类调用。但是这里不能完全保证调用顺序的正确。</p>

<p>如果<strong>分类的镜像在类的镜像之前加载到运行时</strong>，上面的代码就没法保证顺序的正确了，所以，我们还需要在 <code>call_category_loads</code> 中判断类是否已经加载到内存中（调用 <code>load</code> 方法）：</p>

<pre><code class="language-objectivec">if (cls  &amp;&amp;  cls-&gt;isLoadable()) {
    (*load_method)(cls, SEL_load);
    cats[i].cat = nil;
}
</code></pre>

<p>这里，检查了类是否存在并且是否可以加载，如果都为真，那么就可以调用分类的 load 方法了。</p>

<h2 id="load-的应用">load 的应用</h2>

<p><code>load</code> 可以说我们在日常开发中可以接触到的调用时间<strong>最靠前的方法</strong>，在主函数运行之前，<code>load</code> 方法就会调用。</p>

<p>由于它的调用不是<em>惰性</em>的，且其只会在程序调用期间调用一次，最最重要的是，如果在类与分类中都实现了 <code>load</code> 方法，它们都会被调用，不像其它的在分类中实现的方法会被覆盖，这就使 <code>load</code> 方法成为了<a href="http://nshipster.com/method-swizzling/">方法调剂</a>的绝佳时机。</p>

<p>但是由于 <code>load</code> 方法的运行时间过早，所以这里可能不是一个理想的环境，因为<strong>某些类可能需要在在其它类之前加载</strong>，但是这是我们无法保证的。不过在这个时间点，所有的 framework 都已经加载到了运行时中，所以调用 framework 中的方法都是安全的。</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="http://stackoverflow.com/questions/13326435/nsobject-load-and-initialize-what-do-they-do">NSObject +load and +initialize - What do they do?</a></li>
  <li><a href="http://nshipster.com/method-swizzling/">Method Swizzling</a></li>
  <li><a href="https://www.mikeash.com/pyblog/friday-qa-2009-05-22-objective-c-class-loading-and-initialization.html">Objective-C Class Loading and Initialization</a></li>
</ul>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>
</blockquote>


  ]]></description>
</item>

<item>
  <title>从源代码看 ObjC 中消息的发送</title>
  <link>//message</link>
  <author>nju520</author>
  <pubDate>2016-04-25T21:53:54+08:00</pubDate>
  <guid>//message</guid>
  <description><![CDATA[
  <p>Blog: <a href="http://nju520.me">nju520</a></p>

<iframe src="http://ghbtns.com/github-btn.html?user=nju520&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<p>关注仓库，及时获得更新：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

<blockquote>
  <p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p>
</blockquote>

<h2 id="写在前面">写在前面</h2>

<p>如果你点开这篇文章，相信你对 Objective-C 比较熟悉，并且有多年使用 Objective-C 编程的经验，这篇文章会假设你知道：</p>

<ol>
  <li>在 Objective-C 中的“方法调用”其实应该叫做消息传递</li>
  <li><code>[receiver message]</code> 会被翻译为 <code>objc_msgSend(receiver, @selector(message))</code></li>
  <li>在消息的响应链中<strong>可能</strong>会调用 <code>- resolveInstanceMethod:</code> 或者 <code>- forwardInvocation:</code> 等方法</li>
  <li>
    <p>关于选择子 SEL 的知识</p>

    <blockquote>
      <p>如果对于上述的知识不够了解，可以看一下这篇文章 <a href="http://tech.glowing.com/cn/objective-c-runtime/">Objective-C Runtime</a>，但是其中关于 <code>objc_class</code> 的结构体的代码已经过时了，不过不影响阅读以及理解。</p>
    </blockquote>
  </li>
  <li>方法在内存中存储的位置，<a href="http://nju520.me/method-struct">深入解析 ObjC 中方法的结构</a>
    <blockquote>
      <p>文章中不会刻意区别方法和函数、消息传递和方法调用之间的区别。</p>
    </blockquote>
  </li>
  <li>能翻墙（会有一个 Youtube 的链接）</li>
</ol>

<h2 id="概述">概述</h2>

<p>关于 Objective-C 中的消息传递的文章真的是太多了，而这篇文章又与其它文章有什么不同呢？</p>

<p>由于这个系列的文章都是对 Objective-C 源代码的分析，所以会<strong>从 Objective-C 源代码中分析并合理地推测一些关于消息传递的问题</strong>。</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-core.png" alt="objc-message-core" /></p>

<h2 id="关于-selector-你需要知道的">关于 @selector() 你需要知道的</h2>

<p>因为在 Objective-C 中，所有的消息传递中的“消息“都会被转换成一个 <code>selector</code> 作为 <code>objc_msgSend</code> 函数的参数：</p>

<pre><code class="language-objectivec">[object hello] -&gt; objc_msgSend(object, @selector(hello))
</code></pre>

<p>这里面使用 <code>@selector(hello)</code> 生成的选择子 <strong>SEL</strong> 是这一节中关注的重点。</p>

<p>我们需要预先解决的问题是：使用 <code>@selector(hello)</code> 生成的选择子，是否会因为类的不同而不同？各位读者可以自己思考一下。</p>

<p>先放出结论：使用 <code>@selector()</code> 生成的选择子不会因为类的不同而改变，其内存地址在编译期间就已经确定了。也就是说<strong>向不同的类发送相同的消息时，其生成的选择子是完全相同的</strong>。</p>

<pre><code class="language-objectivec">XXObject *xx = [[XXObject alloc] init]
YYObject *yy = [[YYObject alloc] init]
objc_msgSend(xx, @selector(hello))
objc_msgSend(yy, @selector(hello))
</code></pre>

<p>接下来，我们开始验证这一结论的正确性，这是程序主要包含的代码：</p>

<pre><code class="language-objectivec">// XXObject.h
#import &lt;Foundation/Foundation.h&gt;

@interface XXObject : NSObject

- (void)hello;

@end

// XXObject.m
#import "XXObject.h"

@implementation XXObject

- (void)hello {
    NSLog(@"Hello");
}

@end
// main.m
#import &lt;Foundation/Foundation.h&gt;
#import "XXObject.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        XXObject *object = [[XXObject alloc] init];
        [object hello];
    }
    return 0;
}
</code></pre>

<p>在主函数任意位置打一个断点， 比如 <code>-&gt; [object hello];</code> 这里，然后在 lldb 中输入：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-selector.png" alt="objc-message-selecto" /></p>

<p>这里面我们打印了两个选择子的地址<code> @selector(hello)</code> 以及 <code>@selector(undefined_hello_method)</code>，需要注意的是：</p>

<blockquote>
  <p><code>@selector(hello)</code> 是在编译期间就声明的选择子，而后者在编译期间并不存在，<code>undefined_hello_method</code> 选择子由于是在运行时生成的，所以内存地址明显比 <code>hello</code> 大很多</p>
</blockquote>

<p>如果我们修改程序的代码：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-selector-undefined.png" alt="objc-message-selector-undefined" /></p>

<p>在这里，由于我们在代码中显示地写出了 <code>@selector(undefined_hello_method)</code>，所以在 lldb 中再次打印这个 <code>sel</code> 内存地址跟之前相比有了很大的改变。</p>

<p>更重要的是，我没有通过指针的操作来获取 <code>hello</code> 选择子的内存地址，而只是通过 <code>@selector(hello)</code> 就可以返回一个选择子。</p>

<p>从上面的这些现象，可以推断出选择子有以下的特性：</p>

<ol>
  <li>Objective-C 为我们维护了一个巨大的选择子表</li>
  <li>在使用 <code>@selector()</code> 时会从这个选择子表中根据选择子的名字查找对应的 <code>SEL</code>。如果没有找到，则会生成一个 <code>SEL</code> 并添加到表中</li>
  <li>在编译期间会扫描全部的头文件和实现文件将其中的方法以及使用 <code>@selector()</code> 生成的选择子加入到选择子表中</li>
</ol>

<p>在运行时初始化之前，打印 <code>hello</code> 选择子的的内存地址：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-find-selector-before-init.png" alt="objc-message-find-selector-before-init" /></p>

<h2 id="messageh-文件">message.h 文件</h2>

<p>Objective-C 中 <code>objc_msgSend</code> 的实现并没有开源，它只存在于 <code>message.h</code> 这个头文件中。</p>

<pre><code class="language-objectivec">/**
 * @note When it encounters a method call, the compiler generates a call to one of the
 *  functions \c objc_msgSend, \c objc_msgSend_stret, \c objc_msgSendSuper, or \c objc_msgSendSuper_stret.
 *  Messages sent to an object’s superclass (using the \c super keyword) are sent using \c objc_msgSendSuper;
 *  other messages are sent using \c objc_msgSend. Methods that have data structures as return values
 *  are sent using \c objc_msgSendSuper_stret and \c objc_msgSend_stret.
 */
OBJC_EXPORT id objc_msgSend(id self, SEL op, ...)
</code></pre>

<p>在这个头文件的注释中对<strong>消息发送的一系列方法</strong>解释得非常清楚：</p>

<blockquote>
  <p>当编译器遇到一个方法调用时，它会将方法的调用翻译成以下函数中的一个 <code>objc_msgSend</code>、<code>objc_msgSend_stret</code>、<code>objc_msgSendSuper</code> 和 <code>objc_msgSendSuper_stret</code>。
发送给对象的父类的消息会使用 <code>objc_msgSendSuper</code>
有数据结构作为返回值的方法会使用 <code>objc_msgSendSuper_stret</code> 或 <code>objc_msgSend_stret</code>
其它的消息都是使用 <code>objc_msgSend</code> 发送的</p>
</blockquote>

<p>在这篇文章中，我们只会对<strong>消息发送的过程</strong>进行分析，而不会对<strong>上述消息发送方法的区别</strong>进行分析，默认都使用 <code>objc_msgSend</code> 函数。</p>

<h2 id="objc_msgsend-调用栈">objc_msgSend 调用栈</h2>

<p>这一小节会以向 <code>XXObject</code> 的实例发送 <code>hello</code> 消息为例，在 Xcode 中观察整个消息发送的过程中调用栈的变化，再来看一下程序的代码：</p>

<pre><code class="language-objectivec">// XXObject.h
#import &lt;Foundation/Foundation.h&gt;

@interface XXObject : NSObject

- (void)hello;

@end

// XXObject.m
#import "XXObject.h"

@implementation XXObject

- (void)hello {
    NSLog(@"Hello");
}

@end
// main.m
#import &lt;Foundation/Foundation.h&gt;
#import "XXObject.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        XXObject *object = [[XXObject alloc] init];
        [object hello];
    }
    return 0;
}
</code></pre>

<p>在调用 <code>hello</code> 方法的这一行打一个断点，当我们尝试进入（Step in）这个方法只会直接跳入这个方法的实现，而不会进入 <code>objc_msgSend</code>：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-wrong-step-in.gif" alt="objc-message-wrong-step-in" /></p>

<p>因为 <code>objc_msgSend</code> 是一个私有方法，我们没有办法进入它的实现，但是，我们却可以在 <code>objc_msgSend</code> 的调用栈中“截下”这个函数调用的过程。</p>

<p>调用 <code>objc_msgSend</code> 时，传入了 <code>self</code> 以及 <code>SEL</code> 参数。</p>

<p>既然要执行对应的方法，肯定要寻找选择子对应的实现。</p>

<p>在 <code>objc-runtime-new.mm</code> 文件中有一个函数 <code>lookUpImpOrForward</code>，这个函数的作用就是查找方法的实现，于是运行程序，在运行到 <code>hello</code> 这一行时，激活 <code>lookUpImpOrForward</code> 函数中的断点。</p>

<p><a href="https://youtu.be/bCdjdI4VhwQ" target="_blank"><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-youtube-preview.jpg" /></a></p>

<blockquote>
  <p>由于转成 gif 实在是太大了，笔者试着用各种方法生成动图，然而效果也不是很理想，只能贴一个 Youtube 的视频链接，不过对于能够翻墙的开发者们，应该也不是什么问题吧（手动微笑）</p>
</blockquote>

<p>如果跟着视频看这个方法的调用栈有些混乱的话，也是正常的。在下一个节中会对其调用栈进行详细的分析。</p>

<h1 id="解析-objc_msgsend">解析 objc_msgSend</h1>

<p>对 <code>objc_msgSend</code> 解析总共分两个步骤，我们会向 <code>XXObject</code> 的实例发送两次 <code>hello</code> 消息，分别模拟无缓存和有缓存两种情况下的调用栈。</p>

<h2 id="无缓存">无缓存</h2>

<p>在 <code>-&gt; [object hello]</code> 这里增加一个断点，<strong>当程序运行到这一行时</strong>，再向 <code>lookUpImpOrForward</code> 函数的第一行添加断点，确保是捕获 <code>@selector(hello)</code> 的调用栈，而不是调用其它选择子的调用栈。</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-first-call-hello.png" alt="objc-message-first-call-hello" /></p>

<p>由图中的变量区域可以了解，传入的选择子为 <code>"hello"</code>，对应的类是 <code>XXObject</code>。所以我们可以确信这就是当调用 <code>hello</code> 方法时执行的函数。在 Xcode 左侧能看到方法的调用栈：</p>

<pre><code class="language-objectivec">0 lookUpImpOrForward
1 _class_lookupMethodAndLoadCache3
2 objc_msgSend
3 main
4 start
</code></pre>

<p>调用栈在这里告诉我们： <code>lookUpImpOrForward</code> 并不是 <code>objc_msgSend</code> 直接调用的，而是通过 <code>_class_lookupMethodAndLoadCache3</code> 方法：</p>

<pre><code class="language-objectivec">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)
{
    return lookUpImpOrForward(cls, sel, obj,
                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);
}
</code></pre>

<p>这是一个<strong>仅提供给派发器（dispatcher）</strong>用于方法查找的函数，其它的代码都应该使用 <code>lookUpImpOrNil()</code>（不会进行方法转发）。<code>_class_lookupMethodAndLoadCache3</code> 会传入 <code>cache = NO</code> 避免在<strong>没有加锁</strong>的时候对缓存进行查找，因为派发器已经做过这件事情了。</p>

<h3 id="实现的查找-lookupimporforward">实现的查找 lookUpImpOrForward</h3>

<p>由于实现的查找方法 <code>lookUpImpOrForward</code> 涉及很多函数的调用，所以我们将它分成以下几个部分来分析：</p>

<ol>
  <li>无锁的缓存查找</li>
  <li>如果类没有实现（isRealized）或者初始化（isInitialized），实现或者初始化类</li>
  <li>加锁</li>
  <li>缓存以及当前类中方法的查找</li>
  <li>尝试查找父类的缓存以及方法列表</li>
  <li>没有找到实现，尝试方法解析器</li>
  <li>进行消息转发</li>
  <li>解锁、返回实现</li>
</ol>

<h4 id="无锁的缓存查找">无锁的缓存查找</h4>

<p>下面是在没有加锁的时候对缓存进行查找，提高缓存使用的性能：</p>

<pre><code class="language-objectivec">runtimeLock.assertUnlocked();

// Optimistic cache lookup
if (cache) {
   imp = cache_getImp(cls, sel);
   if (imp) return imp;
}
</code></pre>

<p>不过因为 <code>_class_lookupMethodAndLoadCache3</code> 传入的 <code>cache = NO</code>，所以这里会直接跳过 if 中代码的执行，在 <code>objc_msgSend</code> 中已经使用汇编代码查找过了。</p>

<h4 id="类的实现和初始化">类的实现和初始化</h4>

<p>在 <em>Objective-C 运行时</em> 初始化的过程中会对其中的类进行第一次初始化也就是执行 <code>realizeClass</code> 方法，为类分配可读写结构体 <code>class_rw_t</code> 的空间，并返回正确的类结构体。</p>

<p>而 <code>_class_initialize</code> 方法会调用类的 <code>initialize</code> 方法，我会在之后的文章中对类的初始化进行分析。</p>

<pre><code class="language-objectivec">if (!cls-&gt;isRealized()) {
    rwlock_writer_t lock(runtimeLock);
    realizeClass(cls);
}

if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) {
    _class_initialize (_class_getNonMetaClass(cls, inst));
}
</code></pre>

<h4 id="加锁">加锁</h4>

<p>加锁这一部分只有一行简单的代码，其主要目的保证方法查找以及缓存填充（cache-fill）的原子性，保证在运行以下代码时不会有<strong>新方法添加导致缓存被冲洗（flush）</strong>。</p>

<pre><code class="language-objectivec">runtimeLock.read();
</code></pre>

<h4 id="在当前类中查找实现">在当前类中查找实现</h4>

<p>实现很简单，先调用了 <code>cache_getImp</code> 从某个类的 <code>cache</code> 属性中获取选择子对应的实现：</p>

<pre><code class="language-objectivec">imp = cache_getImp(cls, sel);
if (imp) goto done;
</code></pre>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-cache-struct.png" alt="objc-message-cache-struct" /></p>

<p>不过 <code>cache_getImp</code> 的实现目测是不开源的，同时也是汇编写的，在我们尝试 step in 的时候进入了如下的汇编代码。</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-step-in-cache-getimp.png" alt="objc-message-step-in-cache-getimp" /></p>

<p>它会进入一个 <code>CacheLookup</code> 的标签，获取实现，使用汇编的原因还是因为要加速整个实现查找的过程，其原理推测是在类的 <code>cache</code> 中寻找对应的实现，只是做了一些性能上的优化。</p>

<p>如果查找到实现，就会跳转到 <code>done</code> 标签，因为我们在这个小结中的假设是无缓存的（第一次调用 <code>hello</code> 方法），所以会进入下面的代码块，从类的方法列表中寻找方法的实现：</p>

<pre><code class="language-objectivec">meth = getMethodNoSuper_nolock(cls, sel);
if (meth) {
    log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);
    imp = meth-&gt;imp;
    goto done;
}
</code></pre>

<p>调用 <code>getMethodNoSuper_nolock</code> 方法查找对应的方法的结构体指针 <code>method_t</code>：</p>

<pre><code class="language-objectivec">static method_t *getMethodNoSuper_nolock(Class cls, SEL sel) {
    for (auto mlists = cls-&gt;data()-&gt;methods.beginLists(),
              end = cls-&gt;data()-&gt;methods.endLists();
         mlists != end;
         ++mlists)
    {
        method_t *m = search_method_list(*mlists, sel);
        if (m) return m;
    }

    return nil;
}
</code></pre>

<p>因为类中数据的方法列表 <code>methods</code> 是一个二维数组 <code>method_array_t</code>，写一个 <code>for</code> 循环遍历整个方法列表，而这个 <code>search_method_list</code> 的实现也特别简单：</p>

<pre><code class="language-objectivec">static method_t *search_method_list(const method_list_t *mlist, SEL sel)
{
    int methodListIsFixedUp = mlist-&gt;isFixedUp();
    int methodListHasExpectedSize = mlist-&gt;entsize() == sizeof(method_t);

    if (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, 1)) {
        return findMethodInSortedMethodList(sel, mlist);
    } else {
        for (auto&amp; meth : *mlist) {
            if (meth.name == sel) return &amp;meth;
        }
    }

    return nil;
}
</code></pre>

<p><code>findMethodInSortedMethodList</code> 方法对有序方法列表进行线性探测，返回方法结构体 <code>method_t</code>。</p>

<p>如果在这里找到了方法的实现，将它加入类的缓存中，这个操作最后是由 <code>cache_fill_nolock</code> 方法来完成的：</p>

<pre><code class="language-objectivec">static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)
{
    if (!cls-&gt;isInitialized()) return;
    if (cache_getImp(cls, sel)) return;

    cache_t *cache = getCache(cls);
    cache_key_t key = getKey(sel);

    mask_t newOccupied = cache-&gt;occupied() + 1;
    mask_t capacity = cache-&gt;capacity();
    if (cache-&gt;isConstantEmptyCache()) {
        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);
    } else if (newOccupied &lt;= capacity / 4 * 3) {

    } else {
        cache-&gt;expand();
    }

    bucket_t *bucket = cache-&gt;find(key, receiver);
    if (bucket-&gt;key() == 0) cache-&gt;incrementOccupied();
    bucket-&gt;set(key, imp);
}
</code></pre>

<p>如果缓存中的内容大于容量的 <code>3/4</code> 就会扩充缓存，使缓存的大小翻倍。</p>

<blockquote>
  <p>在缓存翻倍的过程中，当前类<strong>全部的缓存都会被清空</strong>，Objective-C 出于性能的考虑不会将原有缓存的 <code>bucket_t</code> 拷贝到新初始化的内存中。</p>
</blockquote>

<p>找到第一个空的 <code>bucket_t</code>，以 <code>(SEL, IMP)</code> 的形式填充进去。</p>

<h4 id="在父类中寻找实现">在父类中寻找实现</h4>

<p>这一部分与上面的实现基本上是一样的，只是多了一个循环用来判断根类：</p>

<ol>
  <li>查找缓存</li>
  <li>搜索方法列表</li>
</ol>

<pre><code class="language-objectivec">curClass = cls;
while ((curClass = curClass-&gt;superclass)) {
    imp = cache_getImp(curClass, sel);
    if (imp) {
        if (imp != (IMP)_objc_msgForward_impcache) {
            log_and_fill_cache(cls, imp, sel, inst, curClass);
            goto done;
        } else {
            break;
        }
    }

    meth = getMethodNoSuper_nolock(curClass, sel);
    if (meth) {
        log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);
        imp = meth-&gt;imp;
        goto done;
    }
}
</code></pre>

<p>与当前类寻找实现的区别是：在父类中寻找到的 <code>_objc_msgForward_impcache</code> 实现会交给当前类来处理。</p>

<h4 id="方法决议">方法决议</h4>

<p>选择子在当前类和父类中都没有找到实现，就进入了方法决议（method resolve）的过程：</p>

<pre><code class="language-objectivec">if (resolver  &amp;&amp;  !triedResolver) {
    _class_resolveMethod(cls, sel, inst);
    triedResolver = YES;
    goto retry;
}
</code></pre>

<p>这部分代码调用 <code>_class_resolveMethod</code> 来解析没有找到实现的方法。</p>

<pre><code class="language-objectivec">void _class_resolveMethod(Class cls, SEL sel, id inst)
{
    if (! cls-&gt;isMetaClass()) {
        _class_resolveInstanceMethod(cls, sel, inst);
    }
    else {
        _class_resolveClassMethod(cls, sel, inst);
        if (!lookUpImpOrNil(cls, sel, inst,
                            NO/*initialize*/, YES/*cache*/, NO/*resolver*/))
        {
            _class_resolveInstanceMethod(cls, sel, inst);
        }
    }
}
</code></pre>

<p>根据当前的类是不是<a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">元类</a>在 <code>_class_resolveInstanceMethod</code> 和 <code>_class_resolveClassMethod</code> 中选择一个进行调用。</p>

<pre><code class="language-objectivec">static void _class_resolveInstanceMethod(Class cls, SEL sel, id inst) {
    if (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls,
                         NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) {
        // 没有找到 resolveInstanceMethod: 方法，直接返回。
        return;
    }

    BOOL (*msg)(Class, SEL, SEL) = (__typeof__(msg))objc_msgSend;
    bool resolved = msg(cls, SEL_resolveInstanceMethod, sel);

    // 缓存结果，以防止下次在调用 resolveInstanceMethod: 方法影响性能。
    IMP imp = lookUpImpOrNil(cls, sel, inst,
                             NO/*initialize*/, YES/*cache*/, NO/*resolver*/);
}
</code></pre>

<p>这两个方法的实现其实就是判断当前类是否实现了 <code>resolveInstanceMethod:</code> 或者 <code>resolveClassMethod:</code> 方法，然后用 <code>objc_msgSend</code> 执行上述方法，并传入需要决议的选择子。</p>

<blockquote>
  <p>关于 <code>resolveInstanceMethod</code> 之后可能会写一篇文章专门介绍，不过关于这个方法的文章也确实不少，在 Google 上搜索会有很多的文章。</p>
</blockquote>

<p>在执行了 <code>resolveInstanceMethod:</code> 之后，会跳转到 retry 标签，<strong>重新执行查找方法实现的流程</strong>，只不过不会再调用 <code>resolveInstanceMethod:</code> 方法了（将 <code>triedResolver</code> 标记为 <code>YES</code>）。</p>

<h4 id="消息转发">消息转发</h4>

<p>在缓存、当前类、父类以及 <code>resolveInstanceMethod:</code> 都没有解决实现查找的问题时，Objective-C 还为我们提供了最后一次翻身的机会，进行方法转发：</p>

<pre><code class="language-objectivec">imp = (IMP)_objc_msgForward_impcache;
cache_fill(cls, sel, imp, inst);
</code></pre>

<p>返回实现 <code>_objc_msgForward_impcache</code>，然后加入缓存。</p>

<p>====</p>

<p>这样就结束了整个方法第一次的调用过程，缓存没有命中，但是在当前类的方法列表中找到了 <code>hello</code> 方法的实现，调用了该方法。</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-first-call-hello.png" alt="objc-message-first-call-hello" /></p>

<h2 id="缓存命中">缓存命中</h2>

<p>如果使用对应的选择子时，缓存命中了，那么情况就大不相同了，我们修改主程序中的代码：</p>

<pre><code class="language-objectivec">int main(int argc, const char * argv[]) {
    @autoreleasepool {
        XXObject *object = [[XXObject alloc] init];
        [object hello];
        [object hello];
    }
    return 0;
}
</code></pre>

<p>然后在第二次调用 <code>hello</code> 方法时，加一个断点：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-objc-msgSend-with-cache.gif" alt="objc-message-objc-msgSend-with-cache" /></p>

<p><code>objc_msgSend</code> 并没有走 <code>lookupImpOrForward</code> 这个方法，而是直接结束，打印了另一个 <code>hello</code> 字符串。</p>

<p>我们如何确定 <code>objc_msgSend</code> 的实现到底是什么呢？其实我们没有办法来<strong>确认</strong>它的实现，因为这个函数的实现使用汇编写的，并且实现是不开源的。</p>

<p>不过，我们需要确定它是否真的<strong>访问了类中的缓存</strong>来加速实现寻找的过程。</p>

<p>好，现在重新运行程序至第二个 <code>hello</code> 方法调用之前：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-before-flush-cache.png" alt="objc-message-before-flush-cache" /></p>

<p>打印缓存中 bucket 的内容：</p>

<pre><code class="language-objectivec">(lldb) p (objc_class *)[XXObject class]
(objc_class *) $0 = 0x0000000100001230
(lldb) p (cache_t *)0x0000000100001240
(cache_t *) $1 = 0x0000000100001240
(lldb) p *$1
(cache_t) $2 = {
  _buckets = 0x0000000100604bd0
  _mask = 3
  _occupied = 2
}
(lldb) p $2.capacity()
(mask_t) $3 = 4
(lldb) p $2.buckets()[0]
(bucket_t) $4 = {
  _key = 0
  _imp = 0x0000000000000000
}
(lldb) p $2.buckets()[1]
(bucket_t) $5 = {
  _key = 0
  _imp = 0x0000000000000000
}
(lldb) p $2.buckets()[2]
(bucket_t) $6 = {
  _key = 4294971294
  _imp = 0x0000000100000e60 (debug-objc`-[XXObject hello] at XXObject.m:17)
}
(lldb) p $2.buckets()[3]
(bucket_t) $7 = {
  _key = 4300169955
  _imp = 0x00000001000622e0 (libobjc.A.dylib`-[NSObject init] at NSObject.mm:2216)
}
</code></pre>

<p>在这个缓存中只有对 <code>hello</code> 和 <code>init</code> 方法实现的缓存，我们要将其中 <code>hello</code> 的缓存清空：</p>

<pre><code class="language-objectivec">(lldb) expr $2.buckets()[2] = $2.buckets()[1]
(bucket_t) $8 = {
  _key = 0
  _imp = 0x0000000000000000
}
</code></pre>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-after-flush-cache.png" alt="objc-message-after-flush-cache" /></p>

<p>这样 <code>XXObject</code> 中就不存在 <code>hello</code> 方法对应实现的缓存了。然后继续运行程序：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-after-flush-cache-trap-in-lookup-again.png" alt="objc-message-after-flush-cache-trap-in-lookup-again" /></p>

<p>虽然第二次调用 <code>hello</code> 方法，但是因为我们清除了 <code>hello</code> 的缓存，所以，会再次进入 <code>lookupImpOrForward</code> 方法。</p>

<p>下面会换一种方法验证猜测：<strong>在 hello 调用之前添加缓存</strong>。</p>

<p>添加一个新的实现 <code>cached_imp</code>：</p>

<pre><code class="language-objectivec">#import &lt;Foundation/Foundation.h&gt;
#import &lt;objc/runtime.h&gt;
#import "XXObject.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        __unused IMP cached_imp = imp_implementationWithBlock(^() {
            NSLog(@"Cached Hello");
        });
        XXObject *object = [[XXObject alloc] init];
        [object hello];
        [object hello];
    }
    return 0;
}
</code></pre>

<p>我们将以 <code>@selector(hello), cached_imp</code> 为键值对，将其添加到类结构体的缓存中，这里的实现 <code>cached_imp</code> 有一些区别，它会打印 <code>@"Cached Hello"</code> 而不是 <code>@"Hello"</code> 字符串：</p>

<p>在第一个 <code>hello</code> 方法调用之前将实现加入缓存：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-add-imp-to-cache.png" alt="objc-message-add-imp-to-cache" /></p>

<p>然后继续运行代码：</p>

<p><img src="http://7xrlu3.com1.z0.glb.clouddn.com/2016-04-25-objc-message-run-after-add-cache.png" alt="objc-message-run-after-add-cache" /></p>

<p>可以看到，我们虽然没有改变 <code>hello</code> 方法的实现，但是在 <strong>objc_msgSend</strong> 的消息发送链路中，使用错误的缓存实现 <code>cached_imp</code> 拦截了实现的查找，打印出了 <code>Cached Hello</code>。</p>

<p>由此可以推定，<code>objc_msgSend</code> 在实现中确实检查了缓存。如果没有缓存会调用 <code>lookupImpOrForward</code> 进行方法查找。</p>

<p>为了提高消息传递的效率，ObjC 对 <code>objc_msgSend</code> 以及  <code>cache_getImp</code> 使用了汇编语言来编写。</p>

<p>如果你想了解有关 <code>objc_msgSend</code> 方法的汇编实现的信息，可以看这篇文章 <a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-16-lets-build-objc_msgsend.html">Let’s Build objc_msgSend</a></p>

<h2 id="小结">小结</h2>

<p>这篇文章与其说是讲 ObjC 中的消息发送的过程，不如说是讲方法的实现是如何查找的。</p>

<p>Objective-C 中实现查找的路径还是比较符合直觉的：</p>

<ol>
  <li>缓存命中</li>
  <li>查找当前类的缓存及方法</li>
  <li>查找父类的缓存及方法</li>
  <li>方法决议</li>
  <li>消息转发</li>
</ol>

<p>文章中关于方法调用栈的视频最开始是用 gif 做的，不过由于 gif 时间较长，试了很多的 gif 转换器，都没有得到一个较好的质量和合适的大小，所以最后选择用一个 Youtube 的视频。</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://github.com/nju520/iOS-Source-Code-Analyze/blob/master/objc/深入解析%20ObjC%20中方法的结构.md">深入解析 ObjC 中方法的结构</a></li>
  <li><a href="http://tech.glowing.com/cn/objective-c-runtime/">Objective-C Runtime</a></li>
  <li><a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-16-lets-build-objc_msgsend.html">Let’s Build objc_msgSend</a></li>
</ul>

<iframe src="http://ghbtns.com/github-btn.html?user=nju520&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<blockquote>
  <p>关注仓库，及时获得更新：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>
</blockquote>

<blockquote>
  <p>Blog: <a href="http://nju520.me">nju520</a></p>
</blockquote>

  ]]></description>
</item>


  </channel>
</rss>
