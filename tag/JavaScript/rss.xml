<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    
    <title>hwbnju.com</title>
    
    <link>http://hwbnju.com</link>
    <description>nju520's Blog</description>
    <language>en-uk</language>
    <managingEditor> nju520</managingEditor>
    <atom:link href="rss" rel="self" type="application/rss+xml" />
    
<item>
  <title>手动实现 MVVM 架构中的双向绑定</title>
  <link>//vue-mvvm</link>
  <author>nju520</author>
  <pubDate>2018-01-08T00:00:00+08:00</pubDate>
  <guid>//vue-mvvm</guid>
  <description><![CDATA[
  <h2 id="mvvm-实现双向绑定">MVVM 实现双向绑定</h2>

<p>相信大家对mvvm双向绑定应该都不陌生了，一言不合上代码，下面先看一个本文最终实现的效果吧，和vue一样的语法，如果还不了解双向绑定，猛戳Google</p>

<pre><code class="language-javascript">&lt;div id="mvvm-app"&gt;
    &lt;input type="text" v-model="word"&gt;
    &lt;p&gt;&lt;/p&gt;
    &lt;button v-on:click="sayHi"&gt;change model&lt;/button&gt;
&lt;/div&gt;

&lt;script src="./js/observer.js"&gt;&lt;/script&gt;
&lt;script src="./js/watcher.js"&gt;&lt;/script&gt;
&lt;script src="./js/compile.js"&gt;&lt;/script&gt;
&lt;script src="./js/mvvm.js"&gt;&lt;/script&gt;
&lt;script&gt;
var vm = new MVVM({
    el: '#mvvm-app',
        data: {
            word: 'Hello World!'
        },
        methods: {
            sayHi: function() {
                this.word = 'Hi, everybody!';
            }
        }
    });
&lt;/script&gt;
</code></pre>

<h2 id="几种实现双向绑定的做法">几种实现双向绑定的做法</h2>

<p>目前几种主流的mvc(vm)框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。</p>

<p>实现数据绑定的做法有大致如下几种：</p>

<ul>
  <li>
    <p>发布者-订阅者模式（backbone.js）</p>
  </li>
  <li>
    <p>脏值检查（angular.js）</p>
  </li>
  <li>
    <p>数据劫持（vue.js）</p>
  </li>
  <li>
    <p>发布者-订阅者模式: 一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set(‘property’, value)，这里有篇文章讲的比较详细，有兴趣可点这里</p>
  </li>
</ul>

<p>这种方式现在毕竟太low了，我们更希望通过 vm.property = value这种方式更新数据，同时自动更新视图，于是有了下面两种方式</p>

<p>脏值检查: angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：</p>

<ul>
  <li>DOM事件，譬如用户输入文本，点击按钮等。( ng-click )</li>
  <li>XHR响应事件 ( $http )</li>
  <li>浏览器Location变更事件 ( $location )</li>
  <li>Timer事件( timeout , interval )</li>
  <li>执行 digest() 或 apply()</li>
</ul>

<p>数据劫持: vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>

<h2 id="思路整理">思路整理</h2>

<p>已经了解到vue是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一，如果不熟悉defineProperty，猛戳这里</p>

<p>整理了一下，要实现mvvm的双向绑定，就必须要实现以下几点：</p>

<p>1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者</p>

<p>2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</p>

<p>3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</p>

<p>4、mvvm入口函数，整合以上三者</p>

<p>上述流程如图所示：</p>

<h3 id="实现observer">实现Observer</h3>

<p>ok, 思路已经整理完毕，也已经比较明确相关逻辑和模块功能了，let’s do it</p>

<p>我们知道可以利用Obeject.defineProperty()来监听属性变动</p>

<p>那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上	setter和getter</p>

<p>这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。。相关代码可以是这样：</p>

<pre><code class="language-javascript">var data = {name: 'kindeng'};
observe(data);
data.name = 'dmq'; // 哈哈哈，监听到值变化了 kindeng --&gt; dmq

function observe(data) {
    if (!data || typeof data !== 'object') {
        return;
    }
    // 取出所有属性遍历
    Object.keys(data).forEach(function(key) {
	    defineReactive(data, key, data[key]);
	});
};

function defineReactive(data, key, val) {
    observe(val); // 监听子属性
    Object.defineProperty(data, key, {
        enumerable: true, // 可枚举
        configurable: false, // 不能再define
        get: function() {
            return val;
        },
        set: function(newVal) {
            console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal);
            val = newVal;
        }
    });
}
</code></pre>

<p>这样我们已经可以监听每个数据的变化了，那么监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法，代码改善之后是这样：</p>

<pre><code class="language-javascript">// ... 省略
function defineReactive(data, key, val) {
	var dep = new Dep();
    observe(val); // 监听子属性

    Object.defineProperty(data, key, {
        // ... 省略
        set: function(newVal) {
        	if (val === newVal) return;
            console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal);
            val = newVal;
            dep.notify(); // 通知所有订阅者
        }
    });
}

function Dep() {
    this.subs = [];
}
Dep.prototype = {
    addSub: function(sub) {
        this.subs.push(sub);
    },
    notify: function() {
        this.subs.forEach(function(sub) {
            sub.update();
        });
    }
};
</code></pre>

<p>那么问题来了，谁是订阅者？怎么往订阅器添加订阅者？</p>

<p>没错，上面的思路整理中我们已经明确订阅者应该是Watcher, 而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作，所以我们可以在	getter里面动手脚：</p>

<pre><code class="language-javascript">// Observer.js
// ...省略
Object.defineProperty(data, key, {
	get: function() {
		// 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除
		Dep.target &amp;&amp; dep.addDep(Dep.target);
		return val;
	}
    // ... 省略
});

// Watcher.js
Watcher.prototype = {
	get: function(key) {
		Dep.target = this;
		this.value = data[key];	// 这里会触发待监听的数据data属性的getter，从而添加订阅者
		Dep.target = null;
	}
}
</code></pre>

<p>这里已经实现了一个Observer了，已经具备了监听数据和数据变化通知订阅者的功能，完整代码。那么接下来就是实现Compile了</p>

<h3 id="实现compile">实现Compile</h3>

<p>compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，如图所示：</p>

<p>因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中</p>

<pre><code class="language-javascript">function Compile(el) {
    this.$el = this.isElementNode(el) ? el : document.querySelector(el);
    if (this.$el) {
        this.$fragment = this.node2Fragment(this.$el);
        this.init();
        this.$el.appendChild(this.$fragment);
    }
}
Compile.prototype = {
	init: function() { this.compileElement(this.$fragment); },
    node2Fragment: function(el) {
        var fragment = document.createDocumentFragment(), child;
        // 将原生节点拷贝到fragment
        while (child = el.firstChild) {
            fragment.appendChild(child);
        }
        return fragment;
    }
};
</code></pre>

<p>compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定，详看代码及注释说明：</p>

<pre><code class="language-javascript">Compile.prototype = {
	// ... 省略
	compileElement: function(el) {
        var childNodes = el.childNodes, me = this;
        [].slice.call(childNodes).forEach(function(node) {
            var text = node.textContent;
            var reg = /\{\{(.*)\}\}/;	// 表达式文本
            // 按元素节点方式编译
            if (me.isElementNode(node)) {
                me.compile(node);
            } else if (me.isTextNode(node) &amp;&amp; reg.test(text)) {
                me.compileText(node, RegExp.$1);
            }
            // 遍历编译子节点
            if (node.childNodes &amp;&amp; node.childNodes.length) {
                me.compileElement(node);
            }
        });
    },

    compile: function(node) {
        var nodeAttrs = node.attributes, me = this;
        [].slice.call(nodeAttrs).forEach(function(attr) {
            // 规定：指令以 v-xxx 命名
            // 如 &lt;span v-text="content"&gt;&lt;/span&gt; 中指令为 v-text
            var attrName = attr.name;	// v-text
            if (me.isDirective(attrName)) {
                var exp = attr.value; // content
                var dir = attrName.substring(2);	// text
                if (me.isEventDirective(dir)) {
                	// 事件指令, 如 v-on:click
                    compileUtil.eventHandler(node, me.$vm, exp, dir);
                } else {
                	// 普通指令
                    compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp);
                }
            }
        });
    }
};

// 指令处理集合
var compileUtil = {
    text: function(node, vm, exp) {
        this.bind(node, vm, exp, 'text');
    },
    // ...省略
    bind: function(node, vm, exp, dir) {
        var updaterFn = updater[dir + 'Updater'];
        // 第一次初始化视图
        updaterFn &amp;&amp; updaterFn(node, vm[exp]);
        // 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher
        new Watcher(vm, exp, function(value, oldValue) {
        	// 一旦属性值有变化，会收到通知执行此更新函数，更新视图
            updaterFn &amp;&amp; updaterFn(node, value, oldValue);
        });
    }
};

// 更新函数
var updater = {
    textUpdater: function(node, value) {
        node.textContent = typeof value == 'undefined' ? '' : value;
    }
    // ...省略
};
</code></pre>

<p>这里通过递归遍历保证了每个节点及子节点都会解析编译到，包括了 双大括号 表达式声明的文本节点。指令的声明规定是通过特定前缀的节点属性来标记，如&lt;span v-text=”content” other-attr中v-text便是指令，而other-attr不是指令，只是普通的属性。</p>

<p>监听数据、绑定更新函数的处理是在compileUtil.bind()这个方法中，通过new Watcher()添加回调来接收数据变化的通知</p>

<p>至此，一个简单的Compile就完成了，完整代码。接下来要看看Watcher这个订阅者的具体实现了</p>

<h3 id="实现watcher">实现Watcher</h3>

<p>Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是:</p>

<p>1、在自身实例化时往属性订阅器(dep)里面添加自己</p>

<p>2、自身必须有一个update()方法</p>

<p>3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p>

<p>如果有点乱，可以回顾下前面的思路整理</p>

<pre><code class="language-javascript">function Watcher(vm, exp, cb) {
    this.cb = cb;
    this.vm = vm;
    this.exp = exp;
    // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解
    this.value = this.get();
}
Watcher.prototype = {
    update: function() {
        this.run();	// 属性值变化收到通知
    },
    run: function() {
        var value = this.get(); // 取到最新值
        var oldVal = this.value;
        if (value !== oldVal) {
            this.value = value;
            this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图
        }
    },
    get: function() {
        Dep.target = this;	// 将当前订阅者指向自己
        var value = this.vm[exp];	// 触发getter，添加自己到属性订阅器中
        Dep.target = null;	// 添加完毕，重置
        return value;
    }
};
// 这里再次列出Observer和Dep，方便理解
Object.defineProperty(data, key, {
	get: function() {
		// 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除
		Dep.target &amp;&amp; dep.addDep(Dep.target);
		return val;
	}
    // ... 省略
});
Dep.prototype = {
    notify: function() {
        this.subs.forEach(function(sub) {
            sub.update(); // 调用订阅者的update方法，通知变化
        });
    }
};
</code></pre>

<p>实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。</p>

<p>ok, Watcher也已经实现了，完整代码。</p>

<p>基本上vue中数据绑定相关比较核心的几个模块也是这几个，猛戳这里 , 在src 目录可找到vue源码。</p>

<p>最后来讲讲MVVM入口文件的相关逻辑和实现吧，相对就比较简单了~</p>

<h3 id="实现mvvm">实现MVVM</h3>

<p>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p>

<p>一个简单的MVVM构造器是这样子：</p>

<pre><code class="language-javascript">function MVVM(options) {
    this.$options = options;
    var data = this._data = this.$options.data;
    observe(data, this);
    this.$compile = new Compile(options.el || document.body, this)
}
</code></pre>

<p>但是这里有个问题，从代码中可看出监听的数据对象是options.data，每次需要更新视图，则必须通过var vm = new MVVM({data:{name: ‘kindeng’}}); vm._data.name = ‘dmq’;这样的方式来改变数据。</p>

<p>显然不符合我们一开始的期望，我们所期望的调用方式应该是这样的：</p>

<p>var vm = new MVVM({data: {name: ‘kindeng’}}); vm.name = ‘dmq’;</p>

<p>所以这里需要给MVVM实例添加一个属性代理的方法，使访问vm的属性代理为访问vm._data的属性，改造后的代码如下：</p>

<pre><code class="language-javascript">function MVVM(options) {
    this.$options = options;
    var data = this._data = this.$options.data, me = this;
    // 属性代理，实现 vm.xxx -&gt; vm._data.xxx
    Object.keys(data).forEach(function(key) {
        me._proxy(key);
    });
    observe(data, this);
    this.$compile = new Compile(options.el || document.body, this)
}

MVVM.prototype = {
	_proxy: function(key) {
		var me = this;
        Object.defineProperty(me, key, {
            configurable: false,
            enumerable: true,
            get: function proxyGetter() {
                return me._data[key];
            },
            set: function proxySetter(newVal) {
                me._data[key] = newVal;
            }
        });
	}
};
</code></pre>

<p>这里主要还是利用了Object.defineProperty()这个方法来劫持了vm实例对象的属性的读写权，使读写vm实例的属性转成读写了vm._data的属性值，达到鱼目混珠的效果，哈哈</p>

<p>至此，全部模块和功能已经完成了，如本文开头所承诺的两点。一个简单的MVVM模块已经实现，其思想和原理大部分来自经过简化改造的vue源码，猛戳这里可以看到本文的所有相关代码。</p>

<p>由于本文内容偏实践，所以代码量较多，且不宜列出大篇幅代码，所以建议想深入了解的童鞋可以再次结合本文源代码来进行阅读，这样会更加容易理解和掌握。</p>

<h2 id="总结">总结</h2>

<p>本文主要围绕“几种实现双向绑定的做法”、“实现Observer”、“实现Compile”、“实现Watcher”、“实现MVVM”这几个模块来阐述了双向绑定的原理和实现。并根据思路流程渐进梳理讲解了一些细节思路和比较关键的内容点，以及通过展示部分关键代码讲述了怎样一步步实现一个双向绑定MVVM。文中肯定会有一些不够严谨的思考和错误，欢迎大家指正，有兴趣欢迎一起探讨和改进~</p>

  ]]></description>
</item>

<item>
  <title>Promise 点滴</title>
  <link>//javascript-promise</link>
  <author>nju520</author>
  <pubDate>2017-12-05T00:00:00+08:00</pubDate>
  <guid>//javascript-promise</guid>
  <description><![CDATA[
  <h2 id="promise的含义">Promise的含义</h2>

<p>Promise是JavaScript语言早有实现，ES6将其写进了语言标准，统一了用法，原生提供了Promies对象。</p>

<p>所谓Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的API，可供进一步处理。</p>

<p>Promies对象有一下两个特点。</p>

<ol>
  <li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending【/’pendɪŋ/】（进行中）、Resolved【/rɪ’zɒlvd/】（已完成，又称Fulfilled【/fʊl’fɪld/】）和Rejected【rɪ’dʒekt】（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这是Promise这个名字的由来，他的英语意思就是“承诺”，表示其他手段无法改变。</li>
  <li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只有这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了额，你在对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，在去监听，是得不到结果的。</li>
</ol>

<p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p>

<p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果设置回调函数，Promise内部抛出的错误，不会反应到外部。第三当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>

<p>如果某些事件不断地反复发生，一般来说，使用stream模式是比部署Promise更好的选择。</p>

<h3 id="基本用法">基本用法</h3>

<p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。
下面代码创造了一个Promise实例。</p>

<pre><code class="language-javascript">var promise = new Promise(function(resolve,reject){
    //...some code
    if(/* 异步操作成功 */){
        resolve(value);
    }else{
        reject(error);
    }
});
</code></pre>

<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。他们是两个函数，由JavaScript引擎提供，不用自己部署。
resolve函数的作用是，将Promise对象的状态从“未完成”变成“成功”（即Pending变为Resolved），在在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>

<p>Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。</p>

<pre><code class="language-javascript">promise.then(function(value){
    //success
},function(value){
    // failure
});
</code></pre>

<p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p>

<p>下面是一个Promise对象的简单例子。</p>

<pre><code class="language-javascript">function timeout(ms) {
  return new Promise((resolve) =&gt; {
    setTimeout(resolve, ms, 'done');
  });
}
timeout(100).then((value) =&gt; {
  console.log(value);
});
</code></pre>

<p>上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为Resolved，就会触发then方法绑定的回调函数。</p>

<p>下面是一个用Promise对象实现的Ajax操作的例子。</p>

<pre><code class="language-javascript">var getJSON = function(url) {
  var promise = new Promise(function(resolve, reject){
    var client = new XMLHttpRequest();
    client.open("GET", url);
    client.onreadystatechange = handler;
    client.responseType = "json";
    client.setRequestHeader("Accept", "application/json");
    client.send();
    function handler() {
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
  });
  return promise;
};
getJSON("/posts.json").then(function(json) {
  console.log('Contents: ' + json);
}, function(error) {
  console.error('出错了', error);
});
</code></pre>

<p>上面代码中，getJSON是对XMLHttpRequest对象的封装，用于发出一个针对JSON数据的HTTP请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。</p>

<p>如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作，比如像下面这样。</p>

<pre><code class="language-javascript">var p1 = new Promise(function(resolve, reject){
  // ...
});
var p2 = new Promise(function(resolve, reject){
  // ...
  resolve(p1);
})
</code></pre>

<p>上面代码中，p1和p2都是Promise的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。</p>

<p>注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是Pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是Resolved或者Rejected，那么p2的回调函数将会立刻执行。</p>

<h3 id="promiseprototypethen">Promise.prototype.then()</h3>

<p>Promise实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。</p>

<p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>

<pre><code class="language-javascript">getJSON("/posts.json").then(function(json) {
  return json.post;
}).then(function(post) {
  // ...
});
</code></pre>

<p>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>

<p>采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p>

<pre><code class="language-javascript">getJSON("/post/1.json").then(function(post) {
  return getJSON(post.commentURL);
}).then(function funcA(comments) {
  console.log("Resolved: ", comments);
}, function funcB(err){
  console.log("Rejected: ", err);
});
</code></pre>

<p>上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为Resolved，就调用funcA，如果状态变为Rejected，就调用funcB。</p>

<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>

<pre><code class="language-javascript">getJSON("/post/1.json").then(
  post =&gt; getJSON(post.commentURL)
).then(
  comments =&gt; console.log("Resolved: ", comments),
  err =&gt; console.log("Rejected: ", err)
);
</code></pre>

<h3 id="promiseprototypecatch">Promise.prototype.catch()</h3>

<p>Promise.prototype.catch方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>

<pre><code class="language-javascript">getJSON("/posts.json").then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理前一个回调函数运行时发生的错误
  console.log('发生错误！', error);
});
</code></pre>

<p>上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为Resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调函数，处理这个错误。</p>

<pre><code class="language-javascript">p.then((val) =&gt; console.log("fulfilled:", val))
  .catch((err) =&gt; console.log("rejected:", err));
// 等同于
p.then((val) =&gt; console.log(fulfilled:", val))
  .then(null, (err) =&gt; console.log("rejected:", err));
var promise = new Promise(function(resolve, reject) {
  throw new Error('test')
});
promise.catch(function(error) { console.log(error) });
// Error: test
</code></pre>

<p>上面代码中，Promise抛出一个错误，就被catch方法指定的回调函数捕获。</p>

<p>如果Promise状态已经变成resolved，再抛出错误是无效的。</p>

<pre><code class="language-javascript">var promise = new Promise(function(resolve, reject) {
  resolve("ok");
  throw new Error('test');
});
promise
  .then(function(value) { console.log(value) })
  .catch(function(error) { console.log(error) });
// ok
</code></pre>

<p>上面代码中，Promise在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。</p>

<p>Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</p>

<pre><code class="language-javascript">getJSON("/post/1.json").then(function(post) {
  return getJSON(post.commentURL);
}).then(function(comments) {
  // some code
}).catch(function(error) {
  // 处理前面三个Promise产生的错误
});
</code></pre>

<p>上面代码中，一共有三个Promise对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。</p>

<p>跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>

<pre><code class="language-javascript">var someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  });
};
someAsyncThing().then(function() {
  console.log('everything is great');
});
</code></pre>

<p>上面代码中，someAsyncThing函数产生的Promise对象会报错，但是由于没有调用catch方法，这个错误不会被捕获，也不会传递到外层代码，导致运行后没有任何输出。</p>

<pre><code class="language-javascript">var promise = new Promise(function(resolve, reject) {
  resolve("ok");
  setTimeout(function() { throw new Error('test') }, 0)
});
promise.then(function(value) { console.log(value) });
// ok
// Uncaught Error: test
</code></pre>

<p>上面代码中，Promise指定在下一轮“事件循环”再抛出错误，结果由于没有指定catch语句，就冒泡到最外层，成了未捕获的错误。</p>

<p>Node.js有一个unhandledRejection事件，专门监听未捕获的reject错误。</p>

<pre><code class="language-javascript">process.on('unhandledRejection', function (err, p) {
  console.error(err.stack)
});
</code></pre>

<p>上面代码中，unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是报错的Promise实例，它可以用来了解发生错误的环境信息。。</p>

<p>需要注意的是，catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法。</p>

<pre><code class="language-javascript">var someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  });
};
someAsyncThing().then(function() {
  return someOtherAsyncThing();
}).catch(function(error) {
  console.log('oh no', error);
}).then(function() {
  console.log('carry on');
});
// oh no [ReferenceError: x is not defined]
// carry on
</code></pre>

<p>上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。</p>

<p>catch方法之中，还能再抛出错误。</p>

<pre><code class="language-javascript">var someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  });
};
someAsyncThing().then(function() {
  return someOtherAsyncThing();
}).catch(function(error) {
  console.log('oh no', error);
  // 下面一行会报错，因为y没有声明
  y + 2;
}).then(function() {
  console.log('carry on');
});
// oh no [ReferenceError: x is not defined]
</code></pre>

<p>上面代码中，catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p>

<pre><code class="language-javascript">someAsyncThing().then(function() {
  return someOtherAsyncThing();
}).catch(function(error) {
  console.log('oh no', error);
  // 下面一行会报错，因为y没有声明
  y + 2;
}).catch(function(error) {
  console.log('carry on', error);
});
// oh no [ReferenceError: x is not defined]
// carry on [ReferenceError: y is not defined]
</code></pre>

<p>上面代码中，第二个catch方法用来捕获，前一个catch方法抛出的错误。</p>

<h3 id="promiseall">Promise.all()</h3>

<p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p>

<pre><code class="language-javascript">var p = Promise.all([p1,p2,p3]);
</code></pre>

<p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例。（Promise.all方法的参数不一定是数组，但是必须具有iterator接口，且返回的每个成员都是Promise实例。）</p>

<p>p的状态由p1、p2、p3决定，分成两种情况。</p>

<ol>
  <li>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li>
  <li>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。
下面是一个具体的例子。</li>
</ol>

<pre><code class="language-javascript">/ 生成一个Promise对象的数组
var promises = [2, 3, 5, 7, 11, 13].map(function(id){
  return getJSON("/post/" + id + ".json");
});
Promise.all(promises).then(function(posts) {
  // ...
}).catch(function(reason){
  // ...
});
</code></pre>

<h3 id="promiserace">Promise.race()</h3>

<p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。</p>

<pre><code class="language-javascript">var p = Promise.race([p1,p2,p3]);
</code></pre>

<p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。</p>

<p>如果Promise.all方法和Promise.race方法的参数，不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。</p>

<h3 id="promiseresolve">Promise.resolve()</h3>

<p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。</p>

<pre><code class="language-javascript">var jsPromise = Promise.resolve($.ajax('/whatever.json'));
</code></pre>

<p>上面代码将jQuery生成deferred对象，转为一个新的Promise对象。</p>

<p>如果Promise.resolve方法的参数，不是具有then方法的对象（又称thenable对象），则返回一个新的Promise对象，且它的状态为Resolved。</p>

<pre><code class="language-javascript">var p = Promise.resolve('Hello');
p.then(function (s){
  console.log(s)
});
// Hello
</code></pre>

<p>上面代码生成一个新的Promise对象的实例p。由于字符串Hello不属于异步操作（判断方法是它不是具有then方法的对象），返回Promise实例的状态从一生成就是Resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。</p>

<p>Promise.resolve方法允许调用时不带参数。所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。</p>

<pre><code class="language-javascript">var p = Promise.resolve();
p.then(function () {
  // ...
});
</code></pre>

<p>上面代码的变量p就是一个Promise对象。
如果Promise.resolve方法的参数是一个Promise实例，则会被原封不动地返回。</p>

<h3 id="promisereject">Promise.reject()</h3>

<p>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。</p>

<pre><code class="language-javascript">var p = Promise.reject('出错了');
p.then(null, function (s){
  console.log(s)
});
// 出错了
</code></pre>

<p>上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。</p>

<h2 id="generator函数与promise的结合">Generator函数与Promise的结合</h2>

<p>使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。</p>

<pre><code class="language-javascript">function getFoo () {
  return new Promise(function (resolve, reject){
    resolve('foo');
  });
}
var g = function* () {
  try {
    var foo = yield getFoo();
    console.log(foo);
  } catch (e) {
    console.log(e);
  }
};
function run (generator) {
  var it = generator();
  function go(result) {
    if (result.done) return result.value;
    return result.value.then(function (value) {
      return go(it.next(value));
    }, function (error) {
      return go(it.throw(value));
    });
  }
  go(it.next());
}
run(g);
</code></pre>

<p>上面代码的Generator函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。</p>

<h2 id="async函数">async函数</h2>

<p>async函数与Promise、Generator函数一样，是用来取代回调函数、解决异步操作的一种方法。它本质上是Generator函数的语法糖。async函数并不属于ES6，而是被列入了ES7，但是traceur、Babel.js、regenerator等转码器已经支持这个功能，转码后立刻就能使用。</p>

<h2 id="手动实现一个-promise">手动实现一个 Promise</h2>

<p>又到了手动实现一个功能的时刻啦, 直接上代码:</p>

<pre><code class="language-javascript">/*
我们要满足状态只能三种状态：PENDING,FULFILLED,REJECTED三种状态，且状态只能由PENDING=&gt;FULFILLED,或者PENDING=&gt;REJECTED
*/
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
/*
value状态为执行成功事件的入参
deferreds保存着状态改变之后的需要处理的函数以及promise子节点，
换句话说, defferd保存的是一个对象, 对象中有一个属性指向需要处理的函数, 有一个promise属性 指向子节点

构造函数里面应该包含这三个属性的初始化
 */
function Promise(callback) {
    this.status = PENDING;
    this.value = null;
    this.defferd = [];
    // 虽然 setTimeout传入的延迟时间为0, 但是它仍然是异步执行; 可以将这个延迟时间换成 1000看看结果如何
    //所以返回的一个promise继续执行then函数
    console.log('I am in new Promise ');
    setTimeout(callback.bind(this, this.resolve.bind(this), this.reject.bind(this)), 0);
}

Promise.prototype = {
    constructor: Promise,
    //触发改变promise状态到FULFILLED
    //
    resolve: function (result) {
        this.status = FULFILLED;
        this.value = result;
        this.done();
    },
    //触发改变promise状态到REJECTED
    reject: function (error) {
        this.status = REJECTED;
        this.value = error;
    },
    //处理defferd
    handle: function (fn) {
        if (!fn) {
            return;
        }
        var value = this.value;
        var t = this.status;
        var p;
        if (t == PENDING) {
             this.defferd.push(fn);
        } else {
            if (t == FULFILLED &amp;&amp; typeof fn.onfulfiled == 'function') {
                p = fn.onfulfiled(value);
            }
            if (t == REJECTED &amp;&amp; typeof fn.onrejected == 'function') {
                p = fn.onrejected(value);
            }
        var promise = fn.promise;
        if (promise) {
            if (p &amp;&amp; p.constructor == Promise) {
                // p.defferd = promise2.defferd
                // 传入then中的 new Promise对象的  defferd 再此指向子promise的 defferd
                p.defferd = promise.defferd;
            } else {
                p = this;
                p.defferd = promise.defferd;
                this.done();
            }
        }
        }
    },
    //触发promise defferd 里面需要执行的函数
    done: function () {
        var status = this.status;
        if (status == PENDING) {
            return;
        }
        var defferd = this.defferd;
        // 这个defferd的长度要么是0,要么是1吧!!!
        // 不管 defferd是否为空, 下面的for循环都会至少执行一次
        // 当 defferd 为空时, handle(NULL) 直接return
        // 当 defferd不为空时, handle[defferd[0]]
        for (var i = 0; i &lt; defferd.length; i++) {
            this.handle(defferd[i]);
        }
    },
    /*储存then函数里面的事件
    返回promise对象
    defferd函数当前promise对象里面
    */
    // 链式调用then时, this是子promise, 不是父 promise
    then: function (success, fail) {
      console.log('I am in then function');
       var o = {
            onfulfiled: success,
            onrejected: fail
        };
        var status = this.status;
        o.promise = new this.constructor(function () {

        });
        if (status == PENDING) {
            // promise2.defferd.push(o)
            this.defferd.push(o);
        } else if (status == FULFILLED || status == REJECTED) {
            this.handle(o);
        }
        return o.promise;
    }
};

/*---------------------------------------------------------------------------*/


// 没有链式调用
promise1 = new Promise(function(resolve, reject) {
  console.log('I am in callback 1');
  // setTimeout模拟异步
  setTimeout(function() {
    // balabala
    // 这里实际上可以发送一个 GET请求, 将返回的结果传给 resolve
    var a = 'ruby';
    // resolve 方法绑定到了promise1
    resolve(a);
  }, 5000);
});

promise2 = promise1.then(function(result) {
  console.log(result);
})


/*---------------------------------------------------------------------------*/

// 存在链式调用

promise1 = new Promise(function(resolve, reject) {
  setTimeout(function() {
    var a = 'ruby';
    resolve(a);
  }, 5000);
})

promise2 = promise1.then(function(result) {
  console.log('passing from resolve ' + result);
  // 返回一个新的promise对象, 但是这个 promise 并不是 promise2
  // 返回的 promise2 对象是在 Promise.prototyp.then中定义的then方法返回的
  return new Promise(function(resolve, reject) {
    setTimeout(function() {
      var b = 'python';
      resolve(b);
    }, 5000);
  })
})

// promise2 调用 then, 此时 then方法中的this就指向 promise2, 而不是最开始的那个 promise
promise3 = promise2.then(function(result) {
  console.log(result);
})


promise1.defferd = [o1]
o2 = {
  onfulfiled: function(res) {
    console.log(res);
    return new Promise(funtion(resolve, reject) {
      setTimeout(function() {
        var b = 200;
        resolve(b);
      }, 5000)
    })
  },
  onrejected: function(err) {},
  promise: new Promise(function() {})
}

o.promise == promise2


promise2.defferd = [o2]
p.defferd = promise2.defferd = [o2]

o2 = {
  onfulfiled: function(res) {
    console.log(res);
  },
  onrejected: function(err) {},
  promise: new Promise(function() {})
}

o2.promise == promise3

</code></pre>


  ]]></description>
</item>

<item>
  <title>JavaScript bind 原理和实现</title>
  <link>//javascript-bind</link>
  <author>nju520</author>
  <pubDate>2017-06-10T00:00:00+08:00</pubDate>
  <guid>//javascript-bind</guid>
  <description><![CDATA[
  <h2 id="bind-原理">bind 原理</h2>

<p>bind是 ECMAScript 新增的方法, 这个方法的主要作用就是将函数绑定到某个对象.</p>

<p>当在函数 func()上调用 bind()方法并传入一个对象比如 bobo 作为参数, 返回一个新的函数.
返回的函数运行时以传入的第一个对象作为 this. 当这个新的函数以函数调用的方式调用时, 就会把this 指向之前绑定的对象上, 也就相当于对象 bobo 将 func()函数当做自己的方法来调用.</p>

<p>bind 方法不仅仅是将函数绑定到一个对象上, 还可以将传入的除对象之外的参数包裹起来, 返回函数调用的时候使用.比如下面的第二个参数23.</p>

<pre><code class="language-javascript">function func(age, job) {
  console.log(this.name);
  console.log(age);
  console.log(job);
}

var bobo = {name: "bobo"};
var bindFunc = func.bind(bobo, 23);
bindFunc("coder"); // bobo 23 coder

</code></pre>

<h2 id="bind-实现">bind 实现</h2>
<p>如果想要对 bind 函数更深层次的理解, 最好可以自己实现原生的 bind 函数.
bind 是 Function.prototype 上定义的方法, 因此每个函数作为 Function 的实例对象, 通过原型继承的方式都能够调用 bind 方法.
我可以在 Function.prototype 上实现自定义的 bind 方法.</p>

<h3 id="基础版本">基础版本</h3>

<pre><code class="language-javascript">
Function.prototype.myBind = function(context) {
  //!!这个 this 其实就是我们被绑定的函数. 因为被绑定的函数实际上就是 Function 的一个实例
  // 实例通过原型继承拥有 bind 方法, 因此 func.bind()运行时, this指向的就是 func.
  // 这里将 this 保存下来, 因为返回一个闭包时外层的 this 将不会得到保存.
  var self = this;
  return function() {
    self.apply(context);//apply可以将函数func 运行时的 this 绑定到传入的第一个参数上
  }
}

var obj = {
  name: 'bobo',
  age: 23
}

function func() {
  console.log(this.name + " " + this.age);
}

var bindFunc = func.myBind(obj);
bindFunc(); //bobo 23

</code></pre>

<h3 id="可以实现柯里化">可以实现柯里化</h3>
<p>我们可以在 bind 时传入一部分参数, 在调用返回的绑定函数时,将剩余的参数传入.
这个技术是一种常见的函数式编程, 被称为”柯里化”</p>

<pre><code class="language-javascript">
Function.prototype.myBind = function(context) {
  var self = this;
  //将除了第一个 context 参数保存到 args 变量中
  var args = Array.prototype.slice.call(arguments, 1); //返回值是一个数组

  return function() {
    var bindArgs = Array.prototype.slice.call(arguments); //返回值同样是一个数组
    self.apply(context, args.concat(bindArgs) )
  }
}

var bobo = {
  name: 'bobo',
}

function func(age, job) {
  console.log(this.name);
  console.log(age);
  console.log(job);
}

var bindFunc = func.myBind(bobo, 23);
bindFunc("coder");
// bobo
// 23
// coder

</code></pre>

<h3 id="绑定的函数可以作为构造函数使用">绑定的函数可以作为构造函数使用</h3>

<p>ECMAScript5定义的 bind 方法,可以使用 new操作符来创建新对象: 这种行为就是把原函数当成构造器.
我们提供的上下文对象被忽略, 但是剩下的参数还是可以提供给绑定函数使用的.
==&gt;当 bind 返回的函数作为构造函数使用时, bind 时指定的 this 就会失效, 此时的 this 应该是执行new绑定规则.</p>

<p>下面的代码最难理解的就是this的指向问题.</p>

<pre><code class="language-javascript">//this的指向是在函数调用时确定的, 一共有四种形式的绑定: 默认绑定, 隐式绑定, 显式绑定, new绑定.
//第一行的目的就是保存外部函数的this, 如果不保存的话,我们就无法在闭包中使用外部函数绑定的this.
var self = this;

//这一行更难理解, 难点在于容易将this和self混淆.
//此时的self就是第一行保存的this,self指向原始函数func, 第一个参数就是func需要绑定的对象.
//当内部闭包的this是func的一个实例时, func的调用形式是构造函数new bindFunc, this指向的是新创建的一个对象
//当内部闭包的this不是指向func的一个实例时, 说明调用的bindFunc是普通的函数调用, 此时bindFunc就绑定到传入的第一个参数
self.apply(this instanceof self ? this : context, args.concat(bindArgs));

//这一行让bindFunc的原型继承自func的原型, 当采用构造函数的调用形式调用binfFunc时,创建的新对象就会继承func.prototype上的方法
//当以普通形式调用bindFunc时,这一行代码自动忽略
bindFunc.prototype = this.prototype;

</code></pre>

<pre><code class="language-javascript">
Function.prototype.myBind = function(context) {
  // self指向的就是我们被绑定的函数, eg: func.bind(obj). self指向的是 func
  // bindFunc 为闭包,因为必须先把 self 保存下来作为一个变量传入 闭包.
  var self = this;
  var args = [].slice.call(arguments, 1);

  var bindFunc = function() {
    //闭包中的this取决于bindFunc运行时的情况

    var bindArgs = [].slice.call(arguments);
    //当通过new 构造出一个实例的时候, 会将 this 指向构造出的新对象.
    // 虽然我们最后构造对象时是采用new bindFunc的形式. 但是构造函数实际上是我们的被绑定函数 func
    // 构造函数调用四部曲
    // 1. 创建一个新的对象
    // 2. 新的对象的原型继承自构造函数的原型
    // 3. 构造函数中 this 执行这个新对象.!!!!此时就相当于新对象将构造函数当做自己的方法调用, 所以才会有 this.name = name 这种操作
    // 4. 构造函数返回值这个心对象

    // (this instanceof self) === true时, this 就是运行 new bindFunc 时 this 的指向对象, 它指向的就是新创建的实例对象
    // (this instanceof self) === false时,调用bindFunc的形式是直接调用, 此时让 this 指向我们传入的第一个参数
    self.apply(this instanceof self ? this : context, args.concat(bindArgs));
  }


  //绑定函数的 prototype 指向 this.prototype,也就是 func.prototype
  //在使用 new bindFunc 创建出的实例就可以继承构造函数原型中的值.
  // 这里的this和第一行var self = this;是一样的, 都是指向我们的原始函数func
  // 这里并不是上面的bindFunc作用域中!!!!
  bindFunc.prototype = this.prototype;

  return bindFunc;
}


var bobo = {
  name: 'bobo'
};

function func(age, job) {
  this.hobbit = "programming";
  console.log(this.name);
  this.age = age;
  this.job = job;
}
func.prototype.friend = "Mac";
func.prototype.sayHi = function() {
  console.log("Hi, " + this.friend);
};


var Func = func.myBind(bobo, 23);

//采用直接调用的形式调用Func, func中的this是指向的bobo对象
var hehe = Func("coder"); //打印bobo.name属性 --&gt; bobo
//以普通形式调用FUnc时, Func("coder")的返回值为undefined

//当我们采用 new 操作符调用 Func 时, 此时就创建了一个新的实例对象, 实例对象将构造函数作为自己的方法调用, 此时根据 this 的指向规则, this 指向调用方法的对象!!!!
var obj = new Func('coder');

console.log(obj.name);
console.log(obj.age);
console.log(obj.job);

console.log(obj.sayHi());

</code></pre>
<p>上面的自定义 bind 基本上可以完成我们的需求,但是有一个需要改进的地方就是返回的闭包函数的原型继承.
如果直接采用上述的方式:</p>

<pre><code class="language-javascript">bindFunc.prototype = this.prototype;
</code></pre>
<p>根据之前继承的几种方式,这种情况下如果我们修改 bindFunc 的原型,就会影响被绑定函数的 prototype.
这个时候就需要一个空对象来作为继承链的中间对象过渡.</p>

<pre><code class="language-javascript">
Function.prototype.myBind = function(context) {
  // self指向的就是我们被绑定的函数, eg: func.bind(obj). self指向的是 func
  var self = this;
  var args = [].slice.call(arguments, 1);

  var Ctor = function() {}

  // bindFunc 为闭包,因为必须先把 self 保存下来作为一个变量传入 闭包.
  var bindFunc = function() {
    var bindArgs = [].slice.call(arguments);
    //当通过new 构造出一个实例的时候, 会将 this 执行构造出的新对象.
    // 虽然我们最后构造对象时是采用new bindFunc的形式. 但是构造函数实际上是我们的被绑定函数 func
    // 构造函数调用四部曲
    // 1. 创建一个新的对象
    // 2. 新的对象的原型继承自构造函数的原型
    // 3. 构造函数中 this 执行这个新对象.!!!!此时就相当于新对象将构造函数当做自己的方法调用, 所以才会有 this.name = name 这种操作
    // 4. 构造函数返回值这个心对象
    self.apply(this instanceof self ? this : context, args.concat(bindArgs));
  }

  //典型的原型链继承形式. &lt;JavaScript 高级程序设计&gt; P169
  Ctor.prototype = this.prototype
  bindFunc.prototype = new Ctor();

  return bindFunc;
}

var bobo = {
  name: 'bobo'
};

function func(age, job) {
  this.hobbit = "programming";
  console.log(this.name);
  this.age = age;
  this.job = job;
}
func.prototype.friend = "Mac";
func.prototype.sayHi = function() {
  console.log("Hi, " + this.friend);
};

var Func = func.myBind(bobo, 23);
//当我们采用 new 操作符调用 Func 时, 此时就创建了一个新的实例对象, 实例对象将构造函数作为自己的方法调用, 此时根据 this 的指向规则, this 指向调用方法的对象!!!!
var obj = new Func('coder');

console.log(obj.name);
console.log(obj.age);
console.log(obj.job);

console.log(obj.sayHi());

</code></pre>

<h3 id="最终版本">最终版本</h3>
<ol>
  <li>调用 bind 时调用者不是函数如何处理?
  直接报错</li>
</ol>

<pre><code class="language-javascript">
if(typeof this != "function") {
  throw new Error("Function.prototype.bind--what is trying is not callable");
}

</code></pre>

<ol>
  <li>版本兼容
  如果存在原生的 bind 方法就采用原生bind方法, 否则采用我们自己定义的 bind方法</li>
</ol>

<pre><code class="language-javascript">
Function.prototype.bind = Function.prototype.bind || function() {
  ...
}
</code></pre>

<ol>
  <li>最终版本</li>
</ol>

<pre><code class="language-javascript">
Function.prototype.bind = function(context) {
  if(Function.prototype.bind) {
    return Function.prototype.bind;
  }

  if(typeof this != "function") {
    throw new Error("Function.prototype.bind--what is trying is not callable");
  }

  var self = this;
  var args = [].slice.call(arguments, 1);

  var Ctor = function() {}

  var bindFunc = function() {
    var bindArgs = [].slice.call(arguments);
    self.apply(this instanceof self ? this : context, args.concat(bindArgs));
  }

  //典型的原型链继承形式. &lt;JavaScript 高级程序设计&gt; P169
  Ctor.prototype = this.prototype
  bindFunc.prototype = new Ctor();

  return bindFunc;
}

</code></pre>

  ]]></description>
</item>

<item>
  <title>JavaScript 深入理解 执行上下文</title>
  <link>//javascript-execution-content</link>
  <author>nju520</author>
  <pubDate>2017-05-12T00:00:00+08:00</pubDate>
  <guid>//javascript-execution-content</guid>
  <description><![CDATA[
  <h2 id="什么是执行上下文执行环境">什么是执行上下文(执行环境)</h2>

<p>每次当控制器转到JS可执行代码的时候，就会进入到一个执行上下文。
“执行上下文”就是 <strong>当前代码的运行环境或者作用域</strong>。</p>

<p>javascript中代码运行环境分为三种:</p>
<ul>
  <li>全局级别的代码: 这个是默认的代码运行环境， 一旦代码被载入，javascript引擎最先进入的就是这个全局环境</li>
  <li>函数级别的代码: 当执行一个函数时， 运行函数体的代码</li>
  <li>eval的代码: 在eval函数内运行的代码</li>
</ul>

<p>下图示例包含了全局和函数级别的执行上下文:
<img src="&quot;execution_context.png&quot;" alt="execution_context" /></p>

<p>上图一共有四个执行上下文。从外至内分别是全局执行上下文，person函数内的上下文，firstName函数和lastName函数的执行上下文。
PS: 不管什么情况下， 只存在一个全局的上下文， 该上下文能被任何其他的上下文所访问到。也就是说，我们可以在person的上下文中访问到全局上下文的sayHello变量，在firstName或者lastName中同样可以访问到该变量。</p>

<p>函数上下文的个数是没有限制的。每当调用一个函数时，引擎就会自动新建出一个函数上下文.换句话说，就是新建一个局部作用域，可以在该局部作用域中声明变量等，在外部的上下文中无法访问到该局部作用域内的元素.</p>

<h2 id="执行上下文堆栈">执行上下文堆栈</h2>

<p>在浏览器中，javascript引擎的工作方式是单线程的，也就是说某一个时刻只有唯一的一个事件是被激活处理的， 其他的事件被放到队列中，等待处理。
<img src="&quot;context_stack.jpg&quot;" alt="context stack" /></p>

<ul>
  <li>
    <p>当javascript代码文件被浏览器载入后，默认最新进入的就是全局的执行上下文.</p>
  </li>
  <li>
    <p>当在全局上下文中调用调用一个函数时，程序流就进入该被调用函数内，此时引擎就会为该函数创建一个新的执行上下文，并且将其压入到执行上下文堆栈的顶部。</p>
  </li>
  <li>
    <p>如果调用当前函数内部的其他函数, 程序流就会进入内部函数, 并且创建一个新的执行上下文并将其将入执行栈的顶部.</p>
  </li>
  <li>
    <p>浏览器总是执行当前在堆栈顶部的上下文. 一旦执行完毕，该上下文就会从堆栈顶部被弹出。然后进入其下的上下文执行代码。</p>
  </li>
  <li>
    <p>这样堆栈中的上下文就会依次执行并且弹出堆栈，直到回到全局的上下文。</p>
  </li>
</ul>

<h2 id="执行上下文的建立过程">执行上下文的建立过程</h2>

<p><strong>每当调用一个函数时，一个新的执行上下文就会被创建出来</strong>。
在javascript引擎内部，这个上下文的创建过程具体分为两个阶段:</p>

<ol>
  <li>建立阶段(发生在当调用一个函数时，但是在执行函数体内的具体代码之前)
    <ul>
      <li>建立变量，函数，arguments 对象，参数</li>
      <li>建立作用域链(什么是作用域链)</li>
      <li>确定this的值</li>
    </ul>
  </li>
  <li>代码执行阶段:
    <ul>
      <li>变量赋值，函数引用，执行其他代码</li>
    </ul>
  </li>
</ol>

<p>实际上，到此为止，执行上下文还是有点抽象，可以把执行上下文看作一个对象，该对象包含以下三个属性:</p>

<pre><code class="language-javascript">executionContextObj = {
  //变量对象
  variableObject: {/*函数中的arguments对象，函数参数，内部的变量以及函数声明*/}

  //作用域链
  scopeChain: {/*variableObject以及所有父执行上下文中的variableObject*/}

  //执行上下文绑定的对象，这个对象和上下文对象是不一样的
  //绑定的对象具体是什么，放到this章节去阐述
  //如果不采用apply call bind new,this绑定就只有两种情况
  //1.当函数作为某个对象的属性调用时，比如obj.foo(),此时this就绑定到obj对象上
  //2. 当函数不采用任何修饰直接调用时，比如foo(),此时this就绑定到全局对象上(非限制模式下)
  this: {..}
}

</code></pre>
<h3 id="建立阶段以及代码执行阶段">建立阶段以及代码执行阶段</h3>

<p>执行上下文对象(上面的executionContextObj)是在函数被调用时，但是在函数体被真正执行以前所创建的。</p>

<p>函数被调用时，就是上述的第一个阶段–建立阶段。这个时间内，引擎会检查函数中的参数，声明的变量以及内部函数，然后基于这些信息建立<strong>执行上下文对象</strong>。在这个阶段，variableObject对象，作用域链，this所指向的对象都会被确定。</p>

<p>过程如下：</p>
<ol>
  <li>
    <p>找到当前上下文中的调用函数的代码</p>
  </li>
  <li>
    <p>在执行被调用的函数体中的代码以前，开始创建执行上下文对象</p>
  </li>
  <li>
    <p>进入第一个阶段-建立阶段:</p>
    <ul>
      <li>建立variableObject对象:</li>
    </ul>
    <ol>
      <li>建立arguments对象，检查当前上下文中的参数，建立该对象下的属性以及属性值</li>
      <li>检查当前上下文中的函数声明：
每找到一个函数声明，就在variableObject下面用函数名建立一个属性，属性值就是指向该函数在内存中的地址的一个引用。如果上述函数名已经存在于variableObject下，那么对应的属性值会被新的引用所覆盖。</li>
    </ol>
  </li>
</ol>

<ul>
  <li>
    <p>初始化作用域链
variableObject以及所有父执行上下文中的variableObject构成作用域链</p>
  </li>
  <li>
    <p>确定上下文中this的指向对象</p>
  </li>
</ul>

<ol>
  <li>代码执行阶段:
    <ul>
      <li>执行函数体中的代码，一行一行地运行代码，给variableObject中的变量属性赋值。</li>
    </ul>
  </li>
</ol>

<hr />
<p>解释器执行代码的伪逻辑</p>

<p>1、查找调用函数的代码。</p>

<p>2、执行代码之前，先进入创建上下文阶段：
初始化作用域链</p>

<p>创建变量对象：</p>

<p>创建arguments对象，检查上下文，初始化参数名称和值并创建引用的复制。</p>

<p>扫描上下文的函数声明（而非函数表达式）：
    为发现的每一个函数，在变量对象上创建一个属性——确切的说是函数的名字——其有一个指向函数在内存中的引用。如果函数的名字已经存在，引用指针将被重写。</p>

<p>扫描上下文的变量声明：
    为发现的每个变量声明，在变量对象上创建一个属性——就是变量的名字，并且将变量的值初始化为undefined.如果变量的名字已经在变量对象里存在，将不会进行任何操作并继续扫描。</p>

<p>求出上下文内部“this”的值。</p>

<p>3、激活/代码执行阶段：</p>

<p>在当前上下文上运行函数代码，并随着代码一行行执行指派变量的值。</p>

<hr />
<h4 id="具体实例">具体实例</h4>

<pre><code class="language-javascript">function foo(i) {
  var a = "hello";
  var b = function privateB() {
    console.log("hehe");
  };

  function c() {
    console.log("c");
  }
}

foo(100);

</code></pre>
<p>在调用foo(100)的时候，建立阶段如下：</p>

<pre><code class="language-javascript">fooExecutionContext = {
  variableObject: {
    arguments: {
      0: 100,
      length: 1
    },
    i: 100,
    c: pointer to function c() {},
    a: undefined,
    b: undefined
  },

  scopeChain: {...},
  this: {...}
}

</code></pre>

<p>在建立阶段，除了arguments,函数的声明，以及传入的参数被赋予了具体的属性值，其他的默认都是undefined.一旦建立阶段结束，引擎就会进入代码执行阶段，代码执行阶段运行完毕后，上下文对象如下:</p>
<pre><code class="language-javascript">fooExecutionContext = {
  variableObject: {
    arguments: {
      0: 100,
      length: 1
    },
    i: 100,
    c: pointer to function c() {},
    a: "hello",
    b: pointer to function privateB()
  },

  scopeChain: {...},
  this: {...}
}
//从上面可以看出，只有在代码执行阶段，变量属性才会被赋予具体的值
</code></pre>

<h2 id="局部变量作用域提升的原因">局部变量作用域提升的原因</h2>

<p><strong>在函数中声明的变量以及函数，其作用域会提升到函数顶部。也就是说，一进入函数体，就可以访问到其中声明的变量和函数</strong></p>

<pre><code class="language-javascript">(function() {
  console.log(typeof foo); // function pointer
  console.log(typeof bar); // undefined

  var foo = "hello",
      bar = function() {return "world";};

  function foo() {
    return "hello";
  }

  console.log(foo); //hello
  console.log(foo());// error, foo is not a funciton
}())
</code></pre>
<p>上述为一个立即执行的匿名函数，通过()强制执行。我们知道这时候就会有执行上下文被创建。</p>

<ol>
  <li>
    <p>上下文的建立阶段，先处理arguments,传入的参数，接着是函数的声明，最后是变量的声明。</p>
  </li>
  <li>
    <p>因为函数的声明会早于变量的声明处理，因此当引擎发现foo函数的什么时就会在variableObject下面建立一个foo属性，其值是一个指向函数的引用。当引擎处理变量声明的时候，发现有var foo的声明，可以foo已经被声明过，所以此声明直接跳过。</p>
  </li>
  <li>
    <p>为什么bar是undefined呢？因为在建立阶段，被赋予的默认值就是undefined，它只会在代码执行阶段才会被赋予具体的值。</p>
  </li>
  <li>
    <p>当进入代码执行阶段的时候，就可以访问到foo属性了。但是注意一点，如果我们在最后打印foo变量，发现foo为”hello”,而不是函数。因为虽然函数声明早于变量的声明，但是变量的赋值是可以覆盖之前的值。所以 foo = “hello”就会覆盖foo变量的值，最终foo为字符串而不是一个函数</p>
  </li>
</ol>

<h2 id="关于this">关于this</h2>

<p>函数执行时this的指向问题放到下一个文章具体阐述。</p>

  ]]></description>
</item>

<item>
  <title>JavaScript 深入理解 this</title>
  <link>//javascript-this</link>
  <author>nju520</author>
  <pubDate>2017-05-05T00:00:00+08:00</pubDate>
  <guid>//javascript-this</guid>
  <description><![CDATA[
  <h3 id="什么是this">什么是this</h3>
<ol>
  <li>
    <p>this: 顾名思义就是这个对象，this到底指向哪个对象呢?
  this的指向取决于函数执行上下文.
  当一个函数被调用时, 会创建一个执行上下文. 这个记录会包含函数在哪里被调用, 传入的参数, 函数内部的声明, 以及this的指向.</p>
  </li>
  <li>
    <p>要明确一点就是this只存在函数调用中，无法在对象中直接使用this.</p>
  </li>
  <li>
    <p>如果函数作为对象的方法调用，其this就执行这个对象；如果作为嵌套函数调用，其this值要么是全局对象(非严格模式)，要么是undefined(严格模式)。如果想访问外部函数的this值，需要将this值保存在一个变量中</p>
  </li>
  <li>
    <p>this是一个关键字， 不是变量， 也不是属性名。 JavaScript不允许给this赋值！！</p>
  </li>
</ol>

<h3 id="为什么需要this">为什么需要this?</h3>

<pre><code class="language-javascript">function identify() {
  return this.name.toUpperCase();
}

function speak() {
  var greeting = "Hello, I'm " + identify.call(this);
  console.log(greeting);
}

var me = {
  name: "bobo"
};

var her = {
  name: "yanzi"
};

identify.call(me); //BOBO
identify.call(her);//YANZI

speak.call(me); // Hello, I'm BOBO
speak.call(her);// Hello, I'm YANZI
</code></pre>
<p>speak.call(me);为例: 通过调用call方法，可以将this绑定到传入的对象中，也就是执行函数speak时，this绑定的对象是me.speak函数里面identify.call(this)其中的this也是绑定的me对象。
这段代码可以在不同的上下文对象(me和her)中重复使用函数identify()和speak(),不需要针对每个对象编写不同版本的函数。</p>

<p>如果不使用this，就需要给identify()和speak()函数显式传入一个上下文对象</p>

<pre><code class="language-javascript">function identify(context) {
  return context.name.toUpperCase();
}

function speak(context) {
  var greeting = "Hello, I'm " + identify(context);
  console.log(greeting);
}

var me = {
  name: "bobo"
};

var her = {
  name: "yanzi"
};

identify(me); //BOBO
identify(her);//YANZI

speak(me); // Hello, I'm BOBO
speak(her);// Hello, I'm YANZI
</code></pre>
<p>上面的代码是未采用this,必须得传入一个具体的上下文对象，然后才能操作对象的属性。</p>

<p>通过上面的对比可以看出，this提供了一种优雅的方式来隐式“传递”一个对象引用， 可以将API设计地更加简介且已用(这个暂时还未阅读过一些开源项目的API，还不清楚)。</p>

<h3 id="常见错误">常见错误</h3>

<h4 id="指向自身">指向自身</h4>
<p>虽然函数在JavaScript中也是一种对象，但是this并不是指向函数本身。</p>

<h4 id="this指向函数的作用域">this指向函数的作用域</h4>
<p>这个错误是最容易犯的了。我有时候也会想当然的this就会指向函数的作用域对象， 然后通过this.XX去获取一些属性。</p>
<ol>
  <li>this在任何情况下都不指向函数的词法作用域。在JavaScript内部，作用域(是不是就是我之前说的执行上下文对象)和对象比较相似，可见的标识符都是它的属性。但是作用域对象无法通过JavaScript代码访问，它存在与JavaScript引擎内部，供引擎访问。</li>
</ol>

<p>一个错误的例子:</p>
<pre><code class="language-javascript">function foo() {
  var a = 2;
  this.bar();
}

function bar() {
  console.log(this.a);
}

foo();//error: a is not defined

</code></pre>

<p>这个代码的错误不止一处。</p>
<ul>
  <li>首先，这堵代码试图通过this.bar()来引用bar函数，这样调用成功纯属意外。因为此时this执行的是全局对象，在全局环境定义的函数都是全局对象的属性。一般情况下，i调用bar()函数最直接的就是省略前面的this.</li>
  <li>开发者试图采用this联通foo()和bar()de的词法作用域，从而让 bar()可以访问foo()作用域的变量a.这是不可能实现的，使用this无法在词法作用域查到信息。</li>
</ul>

<ol>
  <li>this到底是什么？</li>
</ol>

<p>this是在函数运行时绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。</p>

<p>this的绑定和函数声明的位置没有关系， 只取决于函数的调用方式。</p>

<p>当一个函数被调用时，会创建一个活动记录(也就是执行上下文)。这个记录会包含函数在哪里调用(调用栈)，函数的调用方式，传入的参数等现象， this就是这个记录的一个属性， 它绑定一个对象，会在函数执行的过程中用到。this究竟绑定到那个对象，在下面的”如何使用this”会有详细说明.</p>

<p><strong>记住一点:this是在函数调用时发生的绑定，它指向什么完全取决于函数在哪里被调用</strong></p>

<h3 id="如何使用this">如何使用this</h3>

<h4 id="函数的调用位置">函数的调用位置</h4>
<p>理解this的绑定过程之前，首先要理解函数的调用位置，调用位置就是函数在代码中被调用的位置。</p>

<p>最重要的就是分析调用栈(就是为了到达当前执行位置所调用的所有函数)。我们关心的
<strong>调用位置(函数在哪里调用)</strong>
就是在当前正在执行的函数的前一个调用中。</p>
<pre><code class="language-javascript">
function baz() {
  //当前调用栈是baz
  // 因此当前调用位置是上一个调用，全局作用域中
  console.log("baz");
  bar(); //&lt;---- bar的调用位置(就是在函数baz中)
}

function bar() {
  //当前调用栈是baz- ---&gt;bar
  //因此当前的调用位置在baz中
  console.log("bar");
  foo(); //&lt;---- foo的调用位置
}

function foo() {
  //当前调用栈是baz ----&gt; bar ----&gt; foo
  //因此当前的调用位置在bar中
  debugger;
  console.log("foo");
}

baz(); //&lt;---- baz的调用位置

</code></pre>

<h4 id="绑定的规则">绑定的规则</h4>

<h5 id="1-默认绑定">1. 默认绑定</h5>
<p>首先是最常见的函数调用方式: 独立函数调用。</p>
<pre><code class="language-javascript">
function foo() {
  console.log(this.a);
}

var a = 2;

foo();//2

</code></pre>
<p>PS:声明在全局作用域的变量a就是全局对象的一个同名属性。</p>

<p>当我们调用foo()函数时，this.a被解析成全局变量a.为什么？因为在本例中，函数调用时调用位置是在全局作用域中，应用了this的默认绑定，因此this执行全局对象。</p>

<p>如何判断这里应用了默认绑定呢？分析调用位置来看foo()是如何调用的。foo()是直接使用不带任何修饰的函数引用进行的调用，因此只能使用默认绑定， 无法应用其他规则。</p>

<p>如果使用严格模式，则无法将全局对象应用于默认绑定，因此this会绑定到undefined</p>

<h5 id="2-隐式绑定">2. 隐式绑定</h5>
<p>调用位置是否有上下文对象，或者说是否被某个对象拥有或包含。</p>

<pre><code class="language-javascript">
function foo() {
  debugger;
  console.log(this.a);
}

var obj = {
  a: 2,
  foo: foo
}

obj.foo();
//当采用obj.foo()调用函数时，一个新的执行上下文被创建出来，通过之前的分析我们知道，创建一个执行上下文分为两个过程，一个是建立阶段，一个是代码执行阶段。this的绑定就发生在建立阶段。由于foo()函数的调用是通过obj.foo()实现的，所以此时this是绑定到obj对象上的。

//通过chrome代码调试工具我们也可以看到，只有进入了函数foo()内部，local Scope中的this才会变为obj对象，这也验证了我们之前的总结。
//

</code></pre>
<p>需要注意的是foo()函数的声明方式，以及之后是如何被当作引用属性添加到obj对象中的。
无论是直接在obj中定义还是先定义然后再为obj对象添加引用属性，这个foo函数严格意义上说都不属于obj对象。
然而调用位置会使用obj上下文来引用函数，因为我们可以认为函数被调用时obj对象”拥有”或者”包含”它。</p>

<p>当foo被调用时，它的前面确实加上了对obj的引用。当函数引用有上下文对象时，隐式绑定规则会把函数调用的this绑定到这个上下文对象。</p>

<p><strong>隐式丢失</strong>
常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说此函数会应用默认绑定，从而把this绑定到全局对象或者undefined上去。</p>
<pre><code class="language-javascript">function foo() {
  console.log(this.a);''
}

var obj = {
  a: 2,
  foo: foo
}

var bar = obj.foo;

var a = "oops, global";

bar(); // oops, global

</code></pre>
<p>虽然bar是obj.foo的一个引用，但是实际上 bar引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p>

<p><strong>嵌套函数this绑定</strong></p>
<pre><code class="language-javascript">
var name = "clever coder";
var person = {
    name : "foocoder",
    hello : function(sth){
        var sayhello = function(sth) {
            console.log(this.name + " says " + sth);
        };
    }
}
person.hello("hello world");
//clever coder says hello world

</code></pre>

<p>在内部函数中，this没有按预想的绑定到外层函数对象上，而是绑定到了全局对象。这里普遍被认为是JavaScript语言的设计错误，因为没有人想让内部函数中的this指向全局对象。一般的处理方式是将this作为变量保存下来，一般约定为that或者self：</p>

<pre><code class="language-javascript">
var name = "clever coder";
var person = {
    name : "foocoder",
    hello : function(sth){
        var that = this; // 将外部函数绑定的this保存下来，然后在内部函数sayhello中使用
        var sayhello = function(sth) {
            console.log(that.name + " says " + sth);
        };
        sayhello(sth);
    }
}
person.hello("hello world");
//foocoder says hello world
</code></pre>

<p><strong>回调函数丢失this绑定也是非常常见的</strong></p>

<pre><code class="language-javascript">
function foo() {
  console.log(this.a);
}

function doFoo(fn) {
  //fn其实引用的是foo

  fn();//&lt;---- 调用位置！
}

var obj = {
  a: 2,
  foo: foo
};

var a = "oops, global";

doFoo(obj.foo); // oops, global


</code></pre>
<p>将obj.foo作为参数传递给doFoo，实际上就相当于var  bar = obj.foo, doFoo(bar).参数传递其实就是一种隐式赋值， 实际传递的就是一个没有任何修饰的函数，所以最后的绑定方式为默认绑定.</p>

<p>可以通过bind绑定来修正上述问题。</p>
<pre><code class="language-javascript">//prototype.js源码中bind的实现：可以参考一下
Function.prototype.bind = function(){
  var fn = this；//因为bind函数调用者为一个函数fn,函数实际上都是通过new Function得到的一个函数对象，这里的this其实就是指向函数fn本身。
  var args = Array.prototype.slice.call(arguments);
  var object = args.shift();

  return function(){
    return fn.apply(object,
      args.concat(Array.prototype.slice.call(arguments)));
  };
};

var person = {
    name : "foocoder",
    hello : function(sth){
        var sayhello = function(sth) {
            console.log(this.name + " says " + sth);
        };
    }
}

$("#some-ele").click(person.hello.bind(person));
//相应元素被点击时，输出foocoder says hello world

</code></pre>

<h5 id="3-显式绑定call-apply-bind">3. 显式绑定(call apply bind)</h5>

<p>在分析隐式绑定时，我们必须在一个对象的内部包含一个指向函数的属性，通过这个属性间接引用函数，从而把this间接绑定到这个对象上。
如果我们不想在对象内部包含h函数引用，而想在某个对象上强制调用函数，此时就需要用到apply()函数或者call()函数了。</p>

<p>它们的第一个参数是一个对象，在调用函数时，将其绑定到this上。</p>
<pre><code class="language-javascript">
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2
};

foo.call(obj); // 2

</code></pre>
<p>通过foo.call(obj)我们可以在调用foo时强制把它的this绑定到obj上。</p>

<p>可以使用bind实现硬绑定</p>
<pre><code class="language-javascript">function bind(fn, obj) {
  return function() {
    return fn.apply(obj, arguments);
  }
}

// bind具体使用以后补充
</code></pre>

<h5 id="4-new绑定">4. new绑定</h5>
<p>在JavaScript中，构造函数只是一些使用new操作符时被调用的函数。它们不属于某个类，也不会实例化一个类。使用new函数来调用函数，会自动执行下面的操作:</p>

<ol>
  <li>创建一个全新的对象</li>
  <li>这个新对象会被执行[[Prototype]]连接</li>
  <li>这个新对象会绑定到函数调用的this</li>
  <li>如果函数没有返回其他对象，那么new表达式中的函数调用就会自动返回这个新对象。</li>
</ol>

<pre><code class="language-javascript">
function Person(name, age) {
  this.name = name;
  this.age = age;
}

var bobo = new Person("Hanwenbo", 26);
console.log(bobo.name);

</code></pre>

<h4 id="优先级">优先级</h4>

<p>new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>

<h3 id="总结">总结</h3>
<ol>
  <li>
    <p>当函数作为单独函数调用时，this指向全局对象（严格模式时，为undefined）</p>
  </li>
  <li>
    <p>当函数作为对象的方法调用时，this指向该对象。</p>
  </li>
  <li>
    <p>构造函数中的this指向新创建的对象</p>
  </li>
  <li>
    <p>嵌套函数中的this不会继承上层函数的this，如果需要，可以用一个变量保存上层函数的this。</p>
  </li>
  <li>
    <p>再总结的简单点，如果在函数中使用了this，只有在该函数直接被某对象调用时，该this才指向该对象。</p>
  </li>
  <li>
    <p>多看开源项目代码,就会熟悉 this 的使用,现在只是一些简单的使用方法,没有形成很深刻的印象.</p>
  </li>
</ol>

  ]]></description>
</item>

<item>
  <title>JavaScript 继承模式</title>
  <link>//javascript-inherit</link>
  <author>nju520</author>
  <pubDate>2016-12-27T00:00:00+08:00</pubDate>
  <guid>//javascript-inherit</guid>
  <description><![CDATA[
  <h2 id="继承">继承</h2>

<h3 id="原型链">原型链</h3>
<p><strong>利用原型让一个引用类型继承另一个引用类型的属性和方法</strong></p>

<h4 id="阐述原型继承连">阐述原型继承连</h4>

<p>JavaScript中的每个对象，都有一个内置的_proto_属性,它实际上是对另一个对象或者null的引用。</p>

<p>当一个对象需要引用一个属性时，JavaScript引擎首先会从这个对象自身的属性表中寻找这个属性标识，如果找到则进行相应读写操作，若没有在自身的属性表中找到，则在_proto_属性引用的对象的属性表中查找，如此往复，直到找到这个属性或者_proto_属性指向null为止。</p>

<p>这个_proto_的引用链，被称作原型链。</p>

<pre><code class="language-javascript">
function SuperType() {
  this.property = true;
}

SuperType.prototype.getSuperValue = function() {
  return this.property;
}

function SubType() {
  this.subproperty = false;
}

//SubType 继承了 SuperType
//实现的本质是重写了 SubType.prototype 原型对象
//但是有个问题是现在 SubType.prototype.constructor指向的是 SuperType,在 javascript 对象章节已经阐述过原因
//var obj =  new SuperType() 实例对象
// obj.__proto__.constructor == SuperType
//所以 SubType.prototype.constructor == SuperType
SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function() {
  return this.subproperty;
}

var instance = new SubType();
console.log(instance.getSuperValue());//true
console.log(instance.getSubValue());//false

</code></pre>

<p>如果需要添加方法,需谨慎</p>

<pre><code class="language-javascript">
function SuperType() {
  this.property = true;
}

SuperType.prototype.getSuperValue = function() {
  return this.property;
}

function SubType() {
  this.subproperty = false;
}

SubType.prototype = new SuperType();

//添加新方法
SubType.prototype.getSubValue = function() {
  return this.subproperty;
}

//重写超类型中的方法
SubType.prototype.getSuperValue = function() {
  return false;
}

//子类重写了超类的 getSuperValue
var instance = new SubType();
instance.getSuperValue();//false

//SuperType的实例还是调用原来的 getSuperValue 方法
var superInstance = new SuperType();
superInstance.getSuperValue();// true

</code></pre>

<h4 id="原型链继承的问题">原型链继承的问题</h4>
<ol>
  <li>包含引用类型值得原型, 原型属性会被所有实例共享</li>
  <li>在创建子类实例时,无法向超类的构造函数中传递参数.</li>
</ol>

<h3 id="借助构造函数实现继承经典继承">借助构造函数实现继承(经典继承)</h3>
<p><strong>在子类型构造函数的内部调用超类型的构造函数</strong>,函数只不过是在特定环境下执行代码的对象,因此可以通过 call 或者 apply 方法可以在(将来)新创建的对象上执行构造函数</p>
<pre><code class="language-javascript">
function SuperType() {
  this.colors = ["red", "blue", "green"];

  function SubType() {
    //继承了 SuperType
    //通过 call 或者 apply,在(未来将要)创建的 SubType 实例的环境下调用 SuperType 构造函数
    //这样一来,我们在新的 SubType对象上执行 SuperType()函数中定义的所有对象初始化代码.
    SuperType.call(this);
  }

  var instance = new SubType();
  instance.colors.push("black");
  alert(instance.colors); // red, blue, green, black

  var instance2 = new SubType();
  alert(instance.colors); // red, blue, green
}


</code></pre>

<ol>
  <li>可以传递参数</li>
</ol>

<p>在子类型构造函数中向超类构造函数传递参数.</p>

<pre><code class="language-javascript">
function SuperType(name) {
  this.name = name;
}
function SubType(name) {
  //继承了 SuperType
  SuperType.call(this, name);
}

var instance = new SubType("bobo");
alert(instance.name); // rbobo

}


</code></pre>

<h3 id="组合继承原型链构造函数">组合继承(原型链+构造函数)</h3>
<p>使用原型链实现对原型属性和方法的继承,通过借助构造函数实现实例属性的继承.</p>

<pre><code class="language-javascript">
function SuperType(name) {
  this.name = name;
  this.colors = ["red", "blue", "green"];
}

SuperType.prototype.sayName = function() {
  console.log(this.name);
}


function SubType(name, age) {
  SuperType.call(this, name);
  this.age = age;
}


SubType.prototype = new SuperType();

SubType.prototype.constructor = SubType;

SubType.prototype.sayAge = function() {
  console.log(this.age);
}

var instance = new SubType("bobo", 27);
instance.colors.push("black");
console.log(instance.colors);
console.log(instance.sayName());
console.log(instance.sayAge());


var instance2 = new SuperType("yanzi");
console.log(instance2.colors);
console.log(instance2.sayName());

</code></pre>

  ]]></description>
</item>

<item>
  <title>JavaScript 深入理解 prototype</title>
  <link>//javascript-prototype</link>
  <author>nju520</author>
  <pubDate>2016-11-20T00:00:00+08:00</pubDate>
  <guid>//javascript-prototype</guid>
  <description><![CDATA[
  <h2 id="原型对象">原型对象</h2>
<p>[[Prototype]]
 在面向对象语言中,类可以被复制(也就是实例化)多次,就像用模具制作东西一样.之所以会这样是因为实例化一个类就意味着”把类的行为复制到对象中”,对于每一个实例来说都会重复这个过程.</p>

<p>但是在 javascript 中,并没有类似的复制机制. 我只能创建多个对象,然后让他们的[[Prototype]]对象关联到同一个对象. 但是在默认情况下并不会进行复制,因此这些对象之间并不会完全失去联系, 他们是互相关联的.</p>

<pre><code class="language-javascript">
 function Person() {
   this.name = "hehe";
 }

 var xiaoming = new Person();
</code></pre>

<p>javascript 中采用 new Person()这种形式创建一个新对象,新对象的内部链接[[Prototype]]关联的是 Person.prototype对象.</p>

<p><strong>我们并没有初始化一个类,实际上我们并没有从”类”中复制任何行为到一个对象中,只是让两个对象互相关联</strong></p>

<p>==&gt; 我们可以采用 Object.create()方法直接实现一个对象关联到另外一个对象上,这样我们就可以充分发挥[[Prototype]]的威力(委托机制)并且避免不必要的麻烦(比如使用 new 的构造函数调用会生成.prototype 和.constructor引用)</p>

<pre><code class="language-javascript">
//create 方法的简易实现形式
if(!Object.create) {
  Object.create = function(obj) {
    function F();
    F.prototype = obj;
    return new F();
  };
}
</code></pre>

<p>这段 polyfill 代码使用了一个一次性函数 F,我们通过改写它的.prototype 属性使其指向想要关联的对象, 然后再使用 new F()来构造一个新对象关联.</p>

<p>==&gt; ES6可以采用 Object.setPrototypeOf(…)来直接修改对象的原型</p>
<pre><code class="language-javascript">
//ES6之前需要抛弃默认的 Bar.prototype
Bar.prototype = Object.create(Foo.prototype);

//ES6开始可以直接修改现有的 Bar.prototype
Object.setPrototypeOf(Bar.prototype, Foo.prototype)

</code></pre>

<h3 id="内省检查类的身份">内省(检查”类”的身份)</h3>

<p>__proto__属性大致实现过程如下</p>

<pre><code class="language-javascript">
 Object.defineProperty(Object.prototype, "__proto__", {
   get: function() {
     return Object.getPrototypeOf(this);
   },

   set: function(obj) {
     Object.setPrototypeOf(this, obj);
     return obj;
   }
 });

</code></pre>

<h2 id="对象的创建方式之原型模式">对象的创建方式之原型模式</h2>

<pre><code class="language-javascript">function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
}

Person.prototype.description = function() {
  console.log(this.name + this.age + this.job);
}

使用原型对象的好处就是让所有对象实例都共享它所包含的属性和方法

### 理解原型对象

**无论什么时候,只要创建了一个函数,就会根据一组特定的规则为该函数创建一个 prototype 属性,这个属性指向函数的原型对象.**
**在默认情况下,函数的原型对象都有一个 constructor 属性,这个 constructor 属性指向函数**

​```javascript

//测试一个属性是否属于原型属性
function hasPrototypeProperty(object, name) {
  return !object.hasOwnProperty(name) &amp;&amp;(name in object);
}
</code></pre>

<h3 id="更简单的原型语法以及需要注意的一点">更简单的原型语法以及需要注意的一点</h3>

<pre><code class="language-javascript">
function Person() {

}

Person.prototype = {
  name: "bobo",
  age: 22,
  job: "programmer",
  description: function() {
    console.log(this.name + this.age + this.job);
  }
};

var friend = new Person();
alert(friend instanceof Object);//true
alert(friend instanceof Person);//true

alert(friend.constructor == Person);//false
alert(friend.constructor == Object);//true

</code></pre>
<p>上面的代码中我们将 Person.prototype 设置为等于一个以字面量形式创建的对象,最终结果与上面的一样,但是有一个例外:
<strong>constructor属性不再指向 Person 了,而是指向 Object</strong>
原因: 当每创建一个函数时,系统就会同时创建它的 prototype 对象,这个对象也会自动获取 construcotr 属性,指向这个函数.也就是说,每一个原型对象都有一个 constructor 属性.</p>
<pre><code class="language-javascript">var obj = new Person();
obj.__proto__.constructor == Person;
Person.prototype.constructor == Person;
</code></pre>
<p>现在我们Person.prototype = {…}的形式,相当于重写了默认的原型对象,这个原型对象是Object对象实例的原型对象,因此这个原型对象的 constructor 属性指向的是Object函数,不再指向原来的构造函数 Person.
尽管 instanceof 能够返回正确的结果,但是 constructor 已经无法确认对象的类型了</p>
<pre><code class="language-javascript">
var obj = new Object();//等价于 var obj = {}
obj.__proto__.constructor == Object

</code></pre>

<p>可以显式地设定原型的 constructor 属性,这样就确保通过 constructor 属性访问到正确的构造函数.</p>
<pre><code class="language-javascript">

function Person() {

}

Person.prototype = {
  constructor: Person,
  name: "bobo",
  age: 22,
  job: "programmer",
  description: function() {
    console.log(this.name + this.age + this.job);
  }
};


</code></pre>
<p>显式定义的 constructor 属性会导致它的[[Enumerable]]特性被设置为 true.默认情况下,原生的 constructor 属性是不可枚举的,因此如果想让 Enumerable 为默认的 false, 可以使用 Object.defineProperty</p>

<pre><code class="language-javascript">


function Person() {

}

Person.prototype = {
  name: "bobo",
  age: 22,
  job: "programmer",
  description: function() {
    console.log(this.name + this.age + this.job);
  }
};

Object.defineProperty(Person.prototype, "constructor", {
  enumerable: false,
  value: Person
})
</code></pre>

<h3 id="原型的动态性">原型的动态性</h3>
<p>由于在原型上查找值的过程是一次搜索,因此我们对原型对象所做的任何修改都能够立即从实例中体现-即使是先创建了实例然后修改原型也是如此</p>
<pre><code class="language-javascript">
var friend = new Person();

Person.prototype.sayHi = function() {
  alert("Hi");
}

friend.sayHi();//Hi

</code></pre>
<p>尽管可以随时为原型添加属性和方法,并且修改能够立即在所有的实例中反映出来,但是如果是<strong>重写整个原型对象</strong>,那么情况就不一样.
调用构造函数时为实例添加一个指向最初原型的[[prototype]]指针,如果把原型对象修改为另外一个对象就切断了构造函数和最初原型之间的关系.
<strong>实例中的__ proto__指针仅仅指向原型,而不是指向构造函数</strong></p>

<pre><code class="language-javascript">

function Person() {

}

var friend = new Person();


Person.prototype = {
  name: "bobo",
  age: 22,
  job: "programmer",
  description: function() {
    console.log(this.name + this.age + this.job);
  }
};

var myself = new Person();

myself.description();//正常显示结果  bobo22programmer

friend.description();//error
//friend 指向的最初的原型,最初的原型并没有添加任何属性和方法
//之后我们手动修改了 Person.prototype
//但是实例对象并不指向这个最新的原型对象
</code></pre>

  ]]></description>
</item>

<item>
  <title>JavaScript 深入理解 对象 (一)</title>
  <link>//javascript-object</link>
  <author>nju520</author>
  <pubDate>2016-11-04T00:00:00+08:00</pubDate>
  <guid>//javascript-object</guid>
  <description><![CDATA[
  <h2 id="javascript对象">Javascript对象</h2>

<pre><code class="language-javascript">var person = {
  name: 'hanwenbo',
  age: 29,
  job: "code"
}

</code></pre>
<p>上面的代码就是创建了一个 person 对象, 并为其添加了三个属性: name age job.</p>

<h3 id="属性类型">属性类型</h3>
<p>ECMA 定义了一些只在内部采用的特性(attribute),这些特性描述了属性(property)的各种特征.
这些特性是为了实现Javascript 引擎用的内部属性. Javascript无法直接访问这些属性.我们采用[[ Enumerable]]的形式来表示对象的内部特性.</p>

<p>ECMA 中有两种属性: 数据属性和访问器属性</p>

<h4 id="数据属性">数据属性</h4>
<p>数据属性包含一个数据值的位置.在这个位置可以读取和写入值.通俗地讲,数据属性就是我们常见的对象的属性(另外一个是对象的方法)
数据属性有4个描述其行为的特性</p>

<ul>
  <li>[[configurable]]: 表示能否通过delete 删除属性从而重新定义属性,能够修改属性的特性,或者能否把属性修改为访问器属性.</li>
  <li>[[Enumerable]]: 能否通过 for-in 循环返回属性</li>
  <li>[[Writable]]: 表示能够修改属性的值.</li>
  <li>[[Value]]: 表示这个属性的数据值.</li>
</ul>

<pre><code class="language-javascript">var person = {}
Object.defineProperty(person, "name", {
  configurable: false,
  writable: false,
  value: "hanwenbo"
})
alert(person.name); //hawnenbo
person.name = "bobo";
alert(person.name); //hanwenbo

delete person.name;// 因为 configurable 设置为 false,因为无法删除对象的name 属性

//一旦把对象的属性设置为configurable: false,此时就不能再把它变回可配置了.
// 以下代码抛出错误
// VM633:1 Uncaught TypeError: Cannot redefine property: name
Object.defineProperty(person, "name", {
  configurable: true,
  value: "Hanwenbo"
})

</code></pre>
<p>可以通过Object.defineProperty修改对象的属性默认值.</p>
<ul>
  <li>在调用Object.defineProperty方法创建一个新的属性时,如果不明确指定, configurable enumerable writable 默认都是 false.</li>
  <li>如果在调用 Object.defineProperty 只是修改已经存在的属性,那么就无限制.</li>
</ul>

<h4 id="访问器属性">访问器属性</h4>

<p>访问器属性不包含数据值,他们是一对 getter setter 函数.</p>
<ul>
  <li>在读取访问器属性时,调用 getter 函数,这个函数负责返回有效的值</li>
  <li>在写入的访问器属性时,调用 setter 函数,这个函数决定如何处理数据.</li>
</ul>

<p>访问器属性也有四个特性( attribute):</p>
<ul>
  <li>[[Configurable]]: 能否通过删除属性从而重新定义属性.这个特性默认是 true</li>
  <li>[[Enumerable]]: 能否通过 for-in 循环返回属性.这个特性默认也是 true</li>
  <li>[[Get]]: 在读取属性时调用的函数,默认是 undefined</li>
  <li>[[Set]]: 在写入属性时调用的函数,默认是 undefined</li>
</ul>

<p>老版浏览器如果需要创建访问器属性,一般使用两种非标准的方法</p>
<ul>
  <li><strong>defineGetter</strong></li>
  <li><strong>defineSetter</strong></li>
</ul>

<p>访问器属性不能直接定义,必须通过 Object.defineProperty()来定义.</p>

<pre><code class="language-javascript">
var book = {
  //_year:表示只能通过对象方法访问的属性,但是我在浏览器console下可以直接访问 book._year
  _year: 2004,
  edition: 1
}

//设置访问器属性 year, 设置其 Get Set 特性
Object.defineProperty(book, "year", {
  get: function() {
    return this._year;
  }
  set: function(newValue) {
    if(newValue &gt; 2004) {
      this._year = newValue;
      this.edition += newValue - 2004;
    }
  }
})

book.year = 2005; //设置属性 year, 实际上调用的是 year 属性的 set 特性,修改属性_year 的 value
alert(book.year);//访问 book.year 实际上是调用的year属性的 get 特性
alert(book.edition); //访问器常见方式,即设置一个属性的值会导致其他属性发生变化.
</code></pre>

<h3 id="定义多个属性">定义多个属性</h3>

<pre><code>var book = {};

Object.defineProteries(book, {
  _year: {
    writable: true,
    value: 2004
  },

  edition: {
    writable: true,
    value: 1
  },

  year: {
    get: function() {
      return this._year;
    },

    set: function(newValue) {
      if(newValue &gt; 2004) {
        this._year = newValue;
        this.edition += newValue - 2004;
      }
    }
  }
});

</code></pre>

<h3 id="读取属性的特性">读取属性的特性</h3>

<p>使用 Object.getOwnProteryDescriptor()方法,可以取得给定属性的描述符.返回值是一个对象.如果是访问器属性,那么这个对象的属性有 configurable enumerable get set;如果是数据属性,这个对象的属性有 configurable enumerable writable value</p>

<pre><code class="language-javascript">var book = {}
Object.defineProperties(book, {
  _year: {
    value: 2004
  },

  edition: {
    value: 1
  },

  year: {
    get: function() {
      return this._year;
    },

    set: function(newValue) {
      if(newValue &gt; 2004) {
        this._year = newValue;
        this.edition += newValue - 2004;
      }
    }
  }
});

var description = Object.getOwnPropertyDescriptor(book, "_year");
alert(descriptor.value);  // 2004
alert(descriptor.configrable);  //false(首次用 Object.definePropery 创建属性时, configurable 默认是 false)
// writable: false, enumerable: false
alert(descriptor.get);  //undefinded

var descriptor = Object.getOwnPropertyDescriptor(book, "year");
alert(descriptor.value);  // undefined
// configurable enumerable 默认应该都是 false 吧
alert(descriptor.configrable);  // false
alert(descriptor.enumerable);  // false
alert(descriptor.get);  //"function"

</code></pre>

<h2 id="创建对象">创建对象</h2>

<h3 id="工厂模式">工厂模式</h3>

<pre><code class="language-javascript">
function createPerson(name, age, job) {
  var obj = new Object();
  //var obj = {};
  obj.name = name;
  obj.age = age;
  obj.job = job;
  obj.description = function() {
    console.log(this.name + this.age + this.job);
  }
  return obj;
}

var bobo = createPerson("hanwenbo", 27, "programmer");
bobo.description(); //hanwenbo27programmer

</code></pre>
<p>工厂模式无法获悉对象的类型</p>

<h3 id="构造函数模式">构造函数模式</h3>
<pre><code class="language-javascript">
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  //下面一行代码默认执行.也就是让新对象的原型的 constructor 属性指向 构造函数 Person
  //this.__proto__.constructor = Person;

  this.description = function() {
    console.log(this.name + this.age + this.job);
  }
}

var yanzi = new Person("yanzi", 22, "teacher");
yanzi.description();//yanzi22teacher

</code></pre>

<p>构造函数创建对象经过四个步骤:</p>
<ul>
  <li>创建一个新对象 obj, 将obj的原型对象指向构造函数的prototype属性</li>
  <li>将构造函数的作用域赋值给新对象 obj(因此 this 就指向这个新对象),换句话说,就是让新对象调用构造函数, eg: obj.Person(“yanzi”, 22, “teacher”),所以构造函数的 this 自然执行的是隐式绑定. (这样说虽然不甚严谨, 但是方便理解)</li>
  <li>执行构造函数中的代码,也就是为这个新对象添加属性和方法</li>
  <li>
    <p>如果构造函数没有显式地返回一个对象,默认就返回新创建的对象</p>
  </li>
  <li>每个新创建的对象都有一个属性 constructor,该属性指向 constructor. yanzi instanceof Person == true</li>
</ul>

<p><strong>创建自定义的构造函数意味着可以将它的实例标识为一种特定的类型</strong></p>

<h4 id="构造函数的缺点">构造函数的缺点</h4>
<p>每次构造实例时,都会重新建立实例上的方法,实例的方法本质上也是一种对象, 因此每定义一个函数,实际上就是实例化一个函数对象</p>
<pre><code>function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;

  this.description = new Function() {
    console.log(this.name + this.age + this.job);
  }

}
</code></pre>

  ]]></description>
</item>

<item>
  <title>JavaScript 与 事件</title>
  <link>//javascript-event</link>
  <author>nju520</author>
  <pubDate>2016-09-13T00:00:00+08:00</pubDate>
  <guid>//javascript-event</guid>
  <description><![CDATA[
  <h2 id="事件机制">事件机制</h2>
<p>与浏览器进行交互的时候浏览器就会触发各种事件。比如当我们打开某一个网页的时候，浏览器加载完成了这个网页，就会触发一个 load 事件；当我们点击页面中的某一个“地方”，浏览器就会在那个“地方”触发一个 click 事件。</p>

<p>这样，我们就可以编写 JavaScript，通过监听某一个事件，来实现某些功能扩展。例如监听 load 事件，显示欢迎信息，那么当浏览器加载完一个网页之后，就会显示欢迎信息。</p>

<p>JavaScript 与 HTML 之间的交互式通过事件实现的.</p>

<p>事件: 就是文档或者浏览器窗口中发生的一些特定的交互瞬间.简而言之,事件就是 Web 浏览器通知应用程序发生了什么事情.</p>

<p>JavaScript通过浏览器提供的事件 API和用户交互,接受用户的输入.用于用户的行为是无法预知的,也就是说不知道用户什么时候点击了按钮,什么时候滚动页面等操作.因此JavaScript 不可能一直等待用户操作完毕之后才去执行后面的代码.
下面的 NodeJS 代码中,接受用户的输入的方法是在’ readable’事件中调用的.后面的代码不会被阻塞.</p>

<pre><code class="language-javascript">'use strict';

process.stdin.on('readable', () =&gt; {
    var chunk = process.stdin.read();
    if (chunk !== null) {
        process.stdout.write(`Async output data: ${chunk}`);
    }
});

process.stdin.on('end', () =&gt; {
    process.stdout.write('end');
});

console.log('Will not be blocked');
</code></pre>

<p>可以使用处理程序来预订事件,当事件发生时就会执行相应的代码.这种在传统软件工程中被称之为观察者模型.</p>

<p>事件驱动程序模型基本的实现原理基本上都是使用 事件循环（Event Loop），这部分内容涉及浏览器事件模型、回调原理，https://www.youtube.com/watch?v=8aGhZQkoFbQ</p>

<h2 id="事件流">事件流</h2>

<p><strong>事件流描述的是从页面中接受事件的顺序</strong></p>

<h3 id="事件冒泡">事件冒泡</h3>
<p>IE 的事件流成为事件冒泡, 即事件开始时由最具体的元素接收,然后逐级向上传播到不具体的节点(文档).
IE9,FireFox,Chrome,Safari 将事件一直冒泡到 window对象.</p>

<h3 id="事件捕获">事件捕获</h3>
<p>Netscape 团队提出的另一种事件流叫做事件捕获.事件捕获的思想就是不太具体的节点应该更早接收到事件, 而最具体的节点应该最后接收到事件.
事件捕获的用意在事件到达预订目标前就捕获它.</p>

<p>尽管 “DOM2级事件”规范要求事件应该从 document 对象开始传播,但是基本上所有的浏览器都是从 window 对象开始捕获事件的.</p>

<h3 id="dom-事件流">DOM 事件流</h3>

<p><img src="/Users/bobo/Fight_FrontEnd/javascript_core/Event/images/event_stream.jpg" alt="event stream" /></p>

<p>“DOM2级事件”规定的事件流包括三个阶段:事件捕获阶段, 处于目标阶段, 事件冒泡阶段.</p>

<p>在 DOM 事件流中,实际的目标在捕获阶段不会接收到事件.这意味着在捕获阶段, 事件从 document 到 具体元素的父元素就停止了.
==&gt; 从 window 对象到目标元素的父元素这一过程就是”捕获阶段”</p>

<p>下一阶段是”处于目标”阶段,于是事件在<target>元素上发生,并在事件处理中被看做冒泡阶段的一部分.
==&gt; 捕获阶段结束时,事件到达了目标元素的父节点,最终达到目标节点,并在目标节点上触发这个事件,这就是"处于目标阶段"</target></p>

<p>最后冒泡阶段发生, 事件又传播到文档.
==&gt;当事件到达目标节点之后,就会原路返回,这个过程类似水泡从水底浮出水面的过程,所以此过程被称之为”冒泡阶段”</p>

<p>多数支持 DOM 事件流的浏览器都实现了一种特定的行为: 即使” DOM2级事件”规范明确要求捕获阶段不会涉及事件目标,但是很多浏览器仍然会在捕获阶段出发事件对象上的事件. 结果就是两个机会在目标对象上操作事件.</p>

<h2 id="事件处理程序">事件处理程序</h2>
<p>事件就是用户或者浏览器自身执行的某种动作. 诸如 click, load 和 mouseover 都是事件的名字.
响应某个事件的函数就是事件处理程序(事件侦听器).事件处理程序的名字都是以”on”开头. 为事件指定事件处理程序方式有一下几种方式:</p>

<h3 id="html内联属性">HTML内联属性</h3>
<p>某个元素支持的每种事件,都可以使用一个与相应事件处理程序同名的 HTML 特性来指定. 这个特性的值应该是能够执行的 JavaScript 代码.</p>

<pre><code class="language-html">&lt;input type="button" name="" value="Click me" onclick = "alert('clicked!')" /&gt;
</code></pre>
<p>当单击这个按钮时,就会显示一个警示窗.由于这个值是 JavaScript,因此不能在其中使用未经过转义的 HTML 语法字符, &amp; “” &lt; &gt;</p>

<h3 id="dom-属性绑定">DOM 属性绑定</h3>
<p>将一个函数赋值给一个事件处理程序属性.也就是直接设置某个 DOM节点的属性来指定事件和事件处理程序.
每个元素(包括 window 对象和 document对象)都有自己的事件处理程序属性, 这些属性通常为小写, 例如 onclick. 将这个属性的值设置为一个函数, 就可以指定事件处理程序.</p>

<pre><code class="language-javascript">var button = document.getElementById("myBtn");
button.onclick = function() {
  alert("Clicked");
  alert(this.id);//myBtn
}

</code></pre>
<p>我们通过文档对象取得了一个按钮的引用,然后为它指定了 onclick 事件处理程序.</p>

<p>使用 DOM0级方法指定的事件处理程序被认为是元素的方法.因此这时候的事件处理程序是在元素的作用域中运行,程序的 this 就是指向当前元素.
<strong>以这种形式添加的事件处理程序会在事件流的冒泡阶段被处理.</strong></p>

<h3 id="dom2级事件处理程序事件监听函数">DOM2级事件处理程序(事件监听函数)</h3>
<p>“DOM2级事件”定义了两个方法,用于处理指定和删除事件处理程序的操作: addEventListener()和 removeEventListener().
所有的 DOM 节点都包含这两个参数,它们都接收三个参数: 要处理的事件名, 作为事件处理程序的函数, 一个布尔值.
布尔值为 true 时表示在捕获阶段调用事件处理程序;为 false 时表示在冒泡阶段调用事件处理程序</p>

<pre><code class="language-javascript">var button = document.getElementById("myBtn");
var handler = function() {
  alert('Clicked');
  alert(this.id);
};
button.addEventListener('click', handler, false);

button.removeEventListener('click', handler, false);

</code></pre>
<p>上面的代码就是为一个按钮添加了 onclick事件处理程序,而且该事件会在冒泡阶段被触发(最后一个参数为 false).
可以使用 addEventListener()为一个元素添加多个处理程序.
通过 addEventListener()添加的事件处理程序只能使用 removeEventListener()来移除,移除时传入的参数与添加处理程序时使用的参数相同. 这意味着通过 addEventListener()添加的匿名函数无法被移除.</p>

<h3 id="ie事件处理程序">IE事件处理程序</h3>
<p>IE 采用的是 attachEvent()函数和 detachEvent()函数.
这两个方法接受相同的两个参数:事件处理程序名称和事件处理程序函数.
由于 IE8及更早的版本只支持事件冒泡,因此通过 attachEvent()添加的事件处理程序都会被添加到冒泡阶段.</p>

<pre><code class="language-javascript">
var button = document.getElementById('myBtn');
var handler = function() {
  alert('Clicked');
  //IE 的 attachEvent 方法下, 事件处理会在全局作用域中运行,此时 this 就是 window
  alert(this === window);
};

button.attachEvent('onclick', handler); //注意第一个参数是on 开头的事件名称
button.detachEvent('onclick', handler); //删除事件处理程序

</code></pre>

<h3 id="跨浏览器的事件处理程序">跨浏览器的事件处理程序</h3>
<p>见文件 eventUtil.js</p>

<h2 id="事件对象">事件对象</h2>
<p>在触发 DOM 上的某个事件时,会产生一个事件对象 event,这个对象包含着所有与事件有关的信息. 包括导致事件的元素, 事件的类型, 以及其他特定事件相关的信息.
例如,鼠标操作导致的事件对象中, 会包含鼠标的位置信息;键盘操作导致的事件对象中, 会包含与按下的键有关的信息.</p>

<p>所有的浏览器都支持 event 对象,但是支持方式有所区别.</p>

<h3 id="dom-中的事件对象">DOM 中的事件对象</h3>
<p>兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中. 无论指定事件处理程序时使用什么方法, 都会传入 event 对象.
我自己的理解:当事件被触发时,浏览器就会调用之前绑定的事件监听函数, 调用的时候给这个事件监听函数传入一个参数 event,如果定义事件监听函数时没有参数, event 就不会传入;如果定义事件监听函数时有一个参数, 那么就将 event 对象赋值给这个参数, 这个参数的名称并不重要.</p>

<pre><code class="language-javascript">
var button = document.getElementById('myBtn');
var handler = function(event) {
  alert(event.type);
};

button.addEventListener('click', handler, false);
</code></pre>
<p>在通过 HTML 属性指定事件处理程序时,变量 event 保存着 event 对象</p>

<pre><code class="language-html">&lt;input type="button" name="" value="Click me" onclick = "alert(event.type)" /&gt;
</code></pre>
<p><strong>event 对象包含与创建它的特定事件有关的属性和方法</strong></p>

<table>
  <tbody>
    <tr>
      <td>bubble</td>
      <td>事件是否冒泡</td>
    </tr>
    <tr>
      <td>cancelable</td>
      <td>是否可以取消事件的默认行为,如果为 true, 则可以调用 preventDefault()函数</td>
    </tr>
    <tr>
      <td>currentTarget</td>
      <td>事件处理程序当前正在处理的元素,也就是事件通过捕获或者冒泡的过程中所途径的元素节点</td>
    </tr>
    <tr>
      <td>defaultPrevented</td>
      <td> </td>
    </tr>
    <tr>
      <td>detail</td>
      <td> </td>
    </tr>
    <tr>
      <td>eventPhase</td>
      <td>调用事件处理程序的阶段</td>
    </tr>
    <tr>
      <td>preventDefault()</td>
      <td>取消事件的默认行为</td>
    </tr>
    <tr>
      <td>stopImmediatePropagation()</td>
      <td>取消事件的进一步捕获或者冒泡. 同时阻止任何事件处理程序被调用</td>
    </tr>
    <tr>
      <td>stopPropogation()</td>
      <td>只是取消了事件的进一步的捕获或者冒泡</td>
    </tr>
    <tr>
      <td>target</td>
      <td><strong>事件的目标,也就是事件触发时的元素</strong></td>
    </tr>
    <tr>
      <td>trusted</td>
      <td> </td>
    </tr>
    <tr>
      <td>type</td>
      <td>被触发事件的类型</td>
    </tr>
    <tr>
      <td>view</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><strong>只有在事件处理程序执行期间, event 对象才存在;一旦事件处理程序执行完成, event 对象就会被销毁</strong></p>

<h3 id="ie-中的事件对象">IE 中的事件对象</h3>

<table>
  <tbody>
    <tr>
      <td>cancelBubble</td>
      <td>取消事件冒泡</td>
    </tr>
    <tr>
      <td>returnValue</td>
      <td>默认值为 true,将其设置为 false 就可以取消事件的默认行为(与 preventDefault()方法的作用相同)</td>
    </tr>
    <tr>
      <td>srcElement</td>
      <td>事件的目标(与 DOM 中的 target 属性相同)</td>
    </tr>
  </tbody>
</table>

<h3 id="跨浏览器的事件对象">跨浏览器的事件对象</h3>
<p>见 eventUtil 文件2</p>

<h2 id="事件类型">事件类型</h2>

<ul>
  <li>UI(User Interaface, 用户界面)事件, 当用户与页面上的元素交互时触发</li>
  <li>焦点事件, 当元素获得或者失去焦点时触发</li>
  <li>鼠标事件</li>
  <li>滚轮事件</li>
  <li>文本事件: 当在文档中输入文本时触发</li>
  <li>键盘事件:</li>
  <li>合成事件: 当为 IME( 输入法编辑器)输入字符时触发</li>
  <li>变动事件: 当底层 DOM结构发生变化时触发</li>
</ul>

<p><strong>具体事件的用法需要进一步强化, 等看完基础知识的时候, 就需要多写页面来熟悉每个事件的使用</strong></p>

<h2 id="内存和性能">内存和性能</h2>

<p>事件委托: 利用了事件冒泡,只指定一个事件处理程序, 就可以管理某一类型的所有事件.</p>

<h2 id="模拟事件">模拟事件</h2>

<p>createEvent()
可以在 document 对象上使用 createEvent()方法来创建 event 对象. 这个方法接收一个参数, 即表示要创建的事件类型的字符串.
在创建 event 对象之后, 还需要使用与事件有关的信息对其进行初始化.</p>

<pre><code class="language-javascript">var button = document.getElementById('myBtn');

//创建事件对象
var event = document.createEvent('MouseEvents');

//初始化事件对象
event.initMouseEvent("click", ****);

button.dispatchEvent(event); //触发事件

</code></pre>

<h2 id="自定义事件">自定义事件</h2>

<pre><code class="language-javascript">var div = document.getElementById('myDiv');
var event;

EventUtil.addHandler(div, 'myevent', function() {
  alert('Div');
}, false);

EventUtil.addHandler(document, 'myevent',function() {
  alert("document");
}, false;)

if(document.implementaton.hasFeature("CustomEvents", "3.0")) {
  event = document.createEvent("myevent");
  event.document.initCustomEvent('myevent', true, false, "刹那芳华");
  div.dispatchEvent(event);
}
</code></pre>

<h3 id="事件调用顺序">事件调用顺序</h3>
<ol>
  <li>通过设置对象属性或者 HTML 属性注册的处理程序优先调用.</li>
  <li>使用 addEventListener()注册的处理程序按照它们注册的顺序调用</li>
  <li>使用 attachEvent()注册的处理程序可能按照任意顺序调用, 所以代码不应该依赖于调用顺序.</li>
</ol>

<h2 id="通用的事件处理库">通用的事件处理库</h2>

<p>通过以上的分析, 我们完全可以完成一个简略版的隔离浏览器差异的 JavaScript 事件处理库.</p>

<pre><code class="language-javascript">//EventUtil 库就是隔离浏览器差异的 JavaScript 事件处理库.

var EventUtil = {
  addHandler: function(element, type, handler) {
    if(element.addEventListener) {
      element.addEventListener(type, handler, false);
    } else if(element.attachEvent) {
      element.attachEvent('on' + type, function(event) {
        //把处理程序作为事件目标的方法调用传递给事件对象
        return handler.call(target, event);
      });
    } else {
      element['on' + type] = handler;
    }
  },

  getEvent: function(event) {
    return event ? event : window.event;
  },

  getTarget: function(event) {
    return event.target || event.srcElement;
  },

  preventDefault: function(event) {
    if(event.preventDefault) {
      event.preventDefault();
    } else {
      event.returnValue = false;
    }
  },



  removeHandler: function(element, type, handler) {
    if(element.removeEventListener) {
      element.removeEventListener(type, handler, false);
    } else if(element.detachEvent) {
      element.detachEvent('on' + type, handler);
    } else {
      element['on' + type] = null;
    }
  },

  stopPropogation: function() {
    if(event.stopPropogation) {
      event.stopPropogation();
    } else {
      event.cancelBubble = true;
    }
  }


}



// use EventUtil to add and remove event handler

var button = document.getElementById('myBtn');
var handler = function() {
  alert('Clicked');
}

EventUtil.addHandler(button, handler, false);

// balabala
EventUtil.removeHandler(button, handler, false);

//getEvent()方法: 它返回对 event对象的引用.在使用这个方法时,我们必须假定有一个事件对象传入到事件处理程序中, 而且要把该变量的值传给这个方法.


button.onclick = function(event) {
  event = EventUtil.getEvent(event);
}
//在兼容DOM的浏览器中, event 变量只是简单的传入和返回.在 IE 中, event 的参数未定义(undefined),因此就会返回 window.event.



//EventUtil 暂时还未考虑到所有浏览器问题, 譬如 IE 作用域的问题,后续优化.

</code></pre>


  ]]></description>
</item>

<item>
  <title>妙用JavaScript中的apply/call/bind</title>
  <link>//javascript-call-apply-bind</link>
  <author>nju520</author>
  <pubDate>2016-07-09T00:00:00+08:00</pubDate>
  <guid>//javascript-call-apply-bind</guid>
  <description><![CDATA[
  <h2 id="applycall">apply/call</h2>
<p><strong>call和apply都是为了改变某个函数运行时的上下文(context)而存在的.换句话说, 就是为了改变函数体内部的this指向.</strong></p>

<blockquote>
  <p>JavaScript的一大特点就是, 函数存在 定义时上下文/运行时上下文/上下文可以动态改变 这样的概念 –</p>
</blockquote>

<pre><code class="language-javascript">function Fruits() {}
// Fruits.prototype = {
//   color: 'red',
//   sayColor: function() {
//   console.log('My color is ' + this.color);
//   }
// }
Fruits.prototype.color = 'red'
Fruits.prototype.sayColor = function() {
  console.log('My color is ' + this.color);
}
var apple = new Fruits();
apple.sayColor();// My color is red
</code></pre>
<p>但是如果我们与一个对象 banana = {color: ‘yellow’}, 我并不想重新为它定义sayColor方法,那么我就可以使用call或者apply来调用apple的sayColor方法</p>
<pre><code class="language-javascript">var banana = {color: 'yellow'}
apple.sayColor.apply(banana);// My color is yellow
apple.sayColor.call(banana); // My color is yellow

</code></pre>
<p>从上面的示例可以看出, call或者apply是为了动态改变this而出现的,当一个object没有某个方法, 但是其他对象已经定义了实现某个功能的方法, 我就可以借助call或apply让此object调用指定对象的方法.</p>

<h2 id="call与apply的区别">call与apply的区别</h2>
<p>唯一区别就是接收的参数形式不太一样.
call  需要把参数按照顺序传递进去
apply 把参数放到一个数组(也包括类数组)中传入  array apply !!</p>
<pre><code class="language-javascript">var func = function(arg1, arg2) {

};
func.call(this, arg1, arg2);
func.apply(this, [arg1, arg2]);

</code></pre>
<p>其中this是我想要指定的上下文, 它可以是任何一个javascript对象</p>

<ul>
  <li>使用情景:
    <ul>
      <li>JavaScript中, 如果某个函数的参数数量是不固定的, 所以当我的参数是明确的, 就使用call, 而不确定参数数量的话 就使用apply, 然后把参数push进数组中</li>
      <li>当参数数量不确定时, 函数内部也可以通过arguments这个类数组对象来遍历所有的参数.</li>
    </ul>
  </li>
</ul>

<h2 id="更多示例">更多示例</h2>

<ol>
  <li>数组之间追加
    <pre><code class="language-javascript">var array1 = [12 , "foo" , {name "Joe"} , -2458];
var array2 = ["Doe" , 555 , 100];
// array1.push("Doe", 555, 100); // 正常调用
Array.prototype.push.apply(array1, array2);
/* array1 值为  [12 , "foo" , {name "Joe"} , -2458 , "Doe" , 555 , 100] */
</code></pre>
  </li>
  <li>获取数组中的最大值和最小值
    <pre><code class="language-javascript">var  numbers = [5, 458 , 120 , -215 ];
var max = Math.max.apply(Math, numbers);//458
// var max = Math.max(5,458,120,-215);//正常调用
var min = Math.min.apply(Math, numbers);//-215
// var min = Math.min(5,458,120,-215);//正常调用
//数组numbers本身没有max方法, 我可以借助apply使用Math中的max方法
</code></pre>
  </li>
  <li>验证对象是否是数组(前提是toString方法没有被重写)
    <pre><code class="language-javascript">function isArray(obj) {
  return Object.prototype.toString.call(obj) === '[object Array]'
}
</code></pre>
  </li>
</ol>

<p>4 类数组使用数组方法(比较常见的就是函数参数对象arguments)
Javascript中存在一种名为伪数组的对象结构。比较特别的是 arguments 对象，还有像调用 getElementsByTagName , document.childNodes 之类的，它们返回NodeList对象都属于伪数组, 不能应用 Array下的push, pop等方法。
但是我们能通过 Array.prototype.slice.call 转换为真正的数组的带有length属性的对象，这样domNodes就可以应用Array下的所有方法了。</p>
<pre><code class="language-javascript">var domNodes = Array.prototype.slice.call(document.getElementsByTagName('*'));
var domNodes = [].slice.call(document.getElementsByTagName('*'));

// 我还可以通过bind进行简化
var unboundSlice = Array.prototype.slice;
var slice = Function.prototype.call.bind(unboundSlice);
//这里function原型中的call方法绑定unboundSlice对象, 调用返回的函数就等价于 绑定对象unboundSlice调用Function下面的call方法
// 这与调用 [].slice.call(arguments) 是一样的.
// call方法是Function.prototype中的一个方法
var domNodes = slice(document.getElementsByTagName('*'));

</code></pre>
<p>5.一道面试题
定义一个log方法,让它可以代理console.log方法</p>
<pre><code class="language-javascript">function log(msg) {
  console.log(msg);
};
log(1);//1
log(1,2,3,);//1
</code></pre>
<p>当传入多个参数给上面的log方法时, 就要考虑使用apply或者call方法了, 注意这里传入的参数是不确定的,所以最好的选择是apply</p>
<pre><code class="language-javascript">function log() {
  console.log.apply(console, arguments);
}
log(1);//1
log(1,2,3);//1,2,3
</code></pre>
<p>接下来的要求是给每一个log消息添加一个(app)的前缀, 比如</p>
<pre><code class="language-javascript">log('hello world'); //(app)hello world
</code></pre>
<p>该怎么做才比较优雅呢?
函数参数对象arguments是类数组, 我可以通过上面的类数组转换为数组的方法, 再使用数组的方法unshift在数组的头部添加’(app)’</p>
<pre><code class="language-javascript">function log() {
  // var args = [].slice.apply(arguments); //arguments是类数组,所以这里也可以使用apply
  var args = [].slice.call(arguments);
  args.unshift('(app)');
  console.log.apply(console, args);
}
</code></pre>

<h2 id="bind">bind</h2>
<p>bind()方法与apply和call类似, 也是可以改变函数体内的this的指向.
MDN的解释:
<strong>bind()方法会创建一个新函数,称为绑定函数, 当调用这个绑定函数时,
绑定函数会以创建它时传入的bind()方法第一个参数作为this,
传入bind()方法第二个以及以后的参数+绑定函数运行时传入的参数,按照顺序作为原函数的参数来调用原函数</strong>
示例:</p>
<ol>
  <li>在常见的单体模式下, 我们通常会使用self等保存this, 这样我们可以在改变了上下文之后继续引用到它
    <pre><code class="language-javascript">var foo = {
  bar: 1,
  eventBind: function() {
 var self = this;
 $('.calss').on('click', function(event) {
   //Act on the event
   console.log(self.bar);//1
 });
  }
}
</code></pre>
    <p>由于 Javascript特有的机制，上下文环境在 eventBind:function(){ } 过渡到$(‘.class’).on(‘click’, function(event) {})发生了改变，上述使用变量保存this这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题：</p>
  </li>
</ol>

<pre><code class="language-javascript">var foo = {
  bar: 1,
  eventBind: function() {
    $('.class').on('click', function(event) {
      console.log(this.bar).bind(this);//匿名函数的绑定
    })
  }
}
</code></pre>
<p>上述代码中, bind()创建了一个函数,当这个click事件绑定在被调用的时候, 它的this关键词会被设置成传入的值, 因此这样我传入了想要的上下文this(其实就是foo)到bind方法中. 当回调函数被执行的时候, this便指向foo对象</p>

<ol>
  <li>分离函数（Partial Functions）
  bind()的另一个最简单的用法是使一个函数拥有预设的初始参数。这些参数（如果有的话）作为bind()的第二个参数跟在this（或其他对象）后面，之后它们会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们的后面。
```javascript
function list() {
  return Array.prototype.slice.call(arguments);
}</li>
</ol>

<p>var list1 = list(1, 2, 3); // [1, 2, 3]
// Create a function with a preset leading argument
var leadingThirtysevenList = list.bind(undefined, 37);
var list2 = leadingThirtysevenList(); // [37]
var list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]</p>
<pre><code>有个有趣的问题，如果连续 bind() 两次，亦或者是连续 bind() 三次那么输出的值是什么呢？
```javascript
var bar = function(){
    console.log(this.x);
}
var foo = {
    x:3
}
var sed = {
    x:4
}
var func = bar.bind(foo).bind(sed);
func(); //?

var fiv = {
    x:5
}
var func = bar.bind(foo).bind(sed).bind(fiv);
func(); //?
</code></pre>
<p>答案是两次输出都是3.
原因是在javascript中多次绑定bind是无效的.更深层的原因是, bind()方法的实现, 相当于使用函数内部包了一个call/apply, 此时的this已经确定了.第二次bind()相当于再包住第一次的bind(), 所以第二次的之后的bind()是无效的</p>

<ol>
  <li>实现currying
  除了第一个实参外，传入bind()的实参也会绑定到 this,这个应用就是一种常见的编程技术，柯里化
```javascript
function curry(fn) {
  var args = Array.prototype.slice.call(arguments, 1); //获取第一个参数之后的所有参数!!!
  return function() {
 var innerArgs = Array.prototype.slice.call(arguments);
 var finalArgs = args.concat(innerArgs); // 内部函数中innerArgs保存了传入的参数
 return fn.apply(null, finalArgs);
  }
}</li>
</ol>

<p>function add(num1, num2) {
  return num1 + num2;
}
var curriedAdd = curry(add, 5);
curriedAdd(3); //8</p>

<pre><code>
```javascript
var sum = function(y, z) {return this.x + y + z }
var obj = {x:100}
var g = sum.bind(obj, 2)
g(3);//=&gt;6 this.x 绑定到100， y绑定到2， z绑定到3
</code></pre>
<ol>
  <li>手动实现bind方法
    <pre><code class="language-javascript">if(!Function.prototype.bind) {
  Function.prototype.bind = function(obj) {
 var self = this;//self就是要绑定指定对象的函数
 var boundArgs = arguments;
 return function() {
   var args = [];
   var i;
   // for(i = 1; i &lt; boundArgs.length; i++) args.push(boundArgs[i]);
   // for(i = 0; i &lt; arguments.length; i++) args.push(boundArgs[i]);
   //将self作为obj的方法来调用， 传入整合之后的实参
   // return self.apply(obj, args);

   var outArgs = Array.prototype.slice.call(arguments, 1);
   F = function() {};
   functionToBind = this;
   fBound = functionToBind.apply(this, outArgs.concat(Array.prototype.slice.call(arguments)))
   F.prototype = this.prototype;
   functionToBind.prototype = new F();
   return functionToBind;
 }
  }
}
</code></pre>
    <h2 id="apply-call-bind-的比较">apply call bind 的比较</h2>
    <p>```javascript
var obj = {
 x: 81,
};</p>
  </li>
</ol>

<p>var foo = {
    getX: function() {
        return this.x;
    }
}</p>

<p>console.log(foo.getX.bind(obj)());  //81
console.log(foo.getX.call(obj));    //81
console.log(foo.getX.apply(obj));   //81
```
三个输出的都是81，但是注意看使用 bind() 方法的，他后面多了对括号。
也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。
而 apply/call 则会立即执行函数。</p>

<hr />
<ul>
  <li>再次总结一下:
    <ul>
      <li>apply call bind 三者都是用来改变函数的this对象的指向的</li>
      <li>apply call bind 三者的第一个参数都是this要指向的对象, 也就是想要指定的上下文</li>
      <li>apply call bind 三者都可以利用后续参数传参</li>
      <li>bind 返回的是一个函数, 便于稍后调用; apply call 则是立即调用</li>
    </ul>
  </li>
</ul>

  ]]></description>
</item>


  </channel>
</rss>
