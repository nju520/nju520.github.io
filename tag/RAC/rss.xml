<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    
    <title>nju520.me</title>
    
    <link>http://localhost:4000</link>
    <description>nju520's Blog</description>
    <language>en-uk</language>
    <managingEditor> nju520</managingEditor>
    <atom:link href="rss" rel="self" type="application/rss+xml" />
    
<item>
  <title>从代理到 RACSignal</title>
  <link>//racdelegateproxy</link>
  <author>nju520</author>
  <pubDate>2017-02-25T22:55:52+08:00</pubDate>
  <guid>//racdelegateproxy</guid>
  <description><![CDATA[
  <p>ReactiveCocoa 将 Cocoa 中的 Target-Action、KVO、通知中心以及代理等设计模式都桥接到了 RAC 的世界中，我们在随后的几篇文章中会介绍 RAC 如何做到了上面的这些事情，而本篇文章会介绍 ReactiveCocoa 是如何把<strong>代理</strong>转换为信号的。</p>

<p><img src="https://img.nju520.me/2017-02-25-Delegate-To-RACSignal.png-1000width" alt="Delegate-To-RACSigna" /></p>

<h2 id="racdelegateproxy">RACDelegateProxy</h2>

<p>从代理转换成信号所需要的核心类就是 <code>RACDelegateProxy</code>，这是一个设计的非常巧妙的类；虽然在类的头文件中，它被标记为私有类，但是我们仍然可以使用 <code>-initWithProtocol:</code> 方法直接初始化该类的实例。</p>

<pre><code class="language-objectivec">- (instancetype)initWithProtocol:(Protocol *)protocol {
	self = [super init];
	class_addProtocol(self.class, protocol);
	_protocol = protocol;
	return self;
}
</code></pre>

<p>从初始化方法中，我们可以看出 <code>RACDelegateProxy</code> 是一个包含实例变量 <code>_protocol</code> 的类：</p>

<p><img src="https://img.nju520.me/2017-02-25-RACDelegateProxy.png-1000width" alt="RACDelegateProxy" /></p>

<p>在整个 <code>RACDelegateProxy</code> 类的实现中，你都不太能看出与这个实例变量 <code>_protocol</code> 的关系；稍微对 iOS 有了解的人可能都知道，在 Cocoa 中有一个非常特别的根类 <code>NSProxy</code>，而从它的名字我们也可以推断出来，<code>NSProxy</code> 一般用于实现代理（主要是对消息进行转发），但是 ReactiveCocoa 中这个 <code>delegate</code> 的代理 <code>RACDelegateProxy</code> 并没有继承这个 <code>NSProxy</code> 根类：</p>

<pre><code class="language-objectivec">@interface RACDelegateProxy : NSObject

@end
</code></pre>

<p>那么 <code>RACDelegateProxy</code> 是如何作为 Cocoa 中组件的代理，并为原生组件添加 <code>RACSignal</code> 的支持呢？我们以 <code>UITableView</code> 为例来展示 <code>RACDelegateProxy</code> 是如何与 UIKit 组件互动的，我们需要实现的是以下功能：</p>

<p><img src="https://img.nju520.me/2017-02-25-RACDelegateProxy-UITableView.gif" alt="RACDelegateProxy-UITableVie" /></p>

<p>在点击所有的 <code>UITableViewCell</code> 时都会自动取消点击状态，通常情况下，我们可以直接在代理方法 <code>-tableView:didSelectRowAtIndexPath:</code> 中执行 <code>-deselectRowAtIndexPath:animated:</code> 方法：</p>

<pre><code class="language-objectivec">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {
    [tableView deselectRowAtIndexPath:indexPath animated:YES];
}
</code></pre>

<p>使用信号的话相比而言就比较麻烦了：</p>

<pre><code class="language-objectivec">RACDelegateProxy *proxy = [[RACDelegateProxy alloc] initWithProtocol:@protocol(UITableViewDelegate)];
objc_setAssociatedObject(self, _cmd, proxy, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
proxy.rac_proxiedDelegate = self;
[[proxy rac_signalForSelector:@selector(tableView:didSelectRowAtIndexPath:)]
 subscribeNext:^(RACTuple *value) {
     [value.first deselectRowAtIndexPath:value.second animated:YES];
 }];
self.tableView.delegate = (id&lt;UITableViewDelegate&gt;)proxy;
</code></pre>

<ol>
  <li>初始化 <code>RACDelegateProxy</code> 实例，传入 <code>UITableViewDelegate</code> 协议，并将实例存入视图控制器以<strong>确保实例不会被意外释放</strong>造成崩溃；</li>
  <li>设置代理的 <code>rac_proxiedDelegate</code> 属性为视图控制器；</li>
  <li>使用 <code>-rac_signalForSelector:</code> 方法生成一个 <code>RACSignal</code>，在 <code>-tableView:didSelectRowAtIndexPath:</code> 方法调用时将方法的参数打包成 <code>RACTuple</code> 向信号中发送新的 <code>next</code> 消息；</li>
  <li>重新设置 <code>UITableView</code> 的代理；</li>
</ol>

<p>在 <code>UITableViewDelgate</code> 中的代理方法执行时，实际上会被 <code>RACDelegateProxy</code> 拦截，并根据情况决定是处理还是转发：</p>

<p><img src="https://img.nju520.me/2017-02-25-UITableViewDelegate-With-RACDelegateProxy.png-1000width" alt="UITableViewDelegate-With-RACDelegateProxy" /></p>

<p>如果 <code>RACDelegateProxy</code> 实现了该代理方法就会交给它处理，如：<code>-tableView:didSelectRowAtIndexPath:</code>；否则，当前方法就会被转发到原 <code>delegate</code> 上，在这里就是 <code>UIViewController</code> 对象。</p>

<p><code>RACDelegateProxy</code> 中有两个值得特别注意的问题，一是 <code>RACDelegateProxy</code> 是如何进行消息转发的，有事如何将自己无法实现的消息交由原代理处理，第二是 <code>RACDelegateProxy</code> 如何通过方法 <code>-rac_signalForSelector:</code> 在原方法调用时以 <code>RACTuple</code> 的方式发送到 <code>RACSignal</code> 上。</p>

<h2 id="消息转发的实现">消息转发的实现</h2>

<p>首先，我们来看 <code>RACDelegateProxy</code> 是如何在无法响应方法时，将方法转发给原有的代理的；<code>RACDelegateProxy</code> 通过覆写几个方法来实现，最关键的就是 <code>-forwardInvocation:</code> 方法：</p>

<pre><code class="language-objectivec">- (void)forwardInvocation:(NSInvocation *)invocation {
	[invocation invokeWithTarget:self.rac_proxiedDelegate];
}
</code></pre>

<p>当然，作为消息转发流程的一部分 <code>-methodSignatureForSelector:</code> 方法也需要在 <code>RACDelegateProxy</code> 对象中实现：</p>

<pre><code class="language-objectivec">- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector {
	struct objc_method_description methodDescription = protocol_getMethodDescription(_protocol, selector, NO, YES);
	if (methodDescription.name == NULL) {
		methodDescription = protocol_getMethodDescription(_protocol, selector, YES, YES);
		if (methodDescription.name == NULL) return [super methodSignatureForSelector:selector];
	}
	return [NSMethodSignature signatureWithObjCTypes:methodDescription.types];
}
</code></pre>

<p>我们会从协议的方法中尝试获取其中的可选方法和必须实现的方法，最终获取方法的签名 <code>NSMethodSignature</code> 对象。</p>

<p>整个方法决议和消息转发的过程如下图所示，在整个方法决议和消息转发的过程中 Objective-C 运行时会再次提供执行该方法的机会。</p>

<p><img src="https://img.nju520.me/2017-02-25-Message-Forwarding.png-1000width" alt="Message-Forwarding" /></p>

<p>例子中的代理方法最后也被 <code>-forwardInvocation:</code> 方法成功的转发到了 <code>UITableView</code> 的原代理上。</p>

<h2 id="从代理到信号">从代理到信号</h2>

<p>在 <code>RACDelegateProxy</code> 中的另一个非常神奇的方法就是将某一个代理方法转换成信号的 <code>-signalForSelector:</code>：</p>

<pre><code class="language-objectivec">- (RACSignal *)signalForSelector:(SEL)selector {
	return [self rac_signalForSelector:selector fromProtocol:_protocol];
}

- (RACSignal *)rac_signalForSelector:(SEL)selector fromProtocol:(Protocol *)protocol {
	return NSObjectRACSignalForSelector(self, selector, protocol);
}
</code></pre>

<p>该方法会在传入的协议方法被调用时，将协议方法中的所有参数以 <code>RACTuple</code> 的形式发送到返回的信号上，使用者可以通过订阅这个信号来获取所有的参数；而方法 <code>NSObjectRACSignalForSelector</code> 的实现还是比较复杂的。</p>

<pre><code class="language-objectivec">static RACSignal *NSObjectRACSignalForSelector(NSObject *self, SEL selector, Protocol *protocol) {
	SEL aliasSelector = RACAliasForSelector(selector);

    RACSubject *subject = objc_getAssociatedObject(self, aliasSelector);
    if (subject != nil) return subject;

    Class class = RACSwizzleClass(self);
    subject = [RACSubject subject];
    objc_setAssociatedObject(self, aliasSelector, subject, OBJC_ASSOCIATION_RETAIN);

    Method targetMethod = class_getInstanceMethod(class, selector);
    if (targetMethod == NULL) {
        const char *typeEncoding;
        if (protocol == NULL) {
            typeEncoding = RACSignatureForUndefinedSelector(selector);
        } else {
            struct objc_method_description methodDescription = protocol_getMethodDescription(protocol, selector, NO, YES);
            if (methodDescription.name == NULL) {
                methodDescription = protocol_getMethodDescription(protocol, selector, YES, YES);
            }
            typeEncoding = methodDescription.types;
        }
        class_addMethod(class, selector, _objc_msgForward, typeEncoding);
    } else if (method_getImplementation(targetMethod) != _objc_msgForward) {
        const char *typeEncoding = method_getTypeEncoding(targetMethod);

        class_addMethod(class, aliasSelector, method_getImplementation(targetMethod), typeEncoding);
        class_replaceMethod(class, selector, _objc_msgForward, method_getTypeEncoding(targetMethod));
    }
    return subject;
}
</code></pre>

<p>这个 C 函数总共做了两件非常重要的事情，第一个是将传入的选择子对应的实现变为 <code>_objc_msgForward</code>，也就是在调用该方法时，会直接进入消息转发流程，第二是用 <code>RACSwizzleClass</code> 调剂当前类的一些方法。</p>

<p><img src="https://img.nju520.me/2017-02-25-NSObjectRACSignalForSelector.png-1000width" alt="NSObjectRACSignalForSelecto" /></p>

<h3 id="从-selector-到-_objc_msgforward">从 selector 到 _objc_msgForward</h3>

<p>我们具体看一下这部分代码是如何实现的，在修改选择子对应的实现之前，我们会先做一些准备工作：</p>

<pre><code class="language-objectivec">SEL aliasSelector = RACAliasForSelector(selector);

RACSubject *subject = objc_getAssociatedObject(self, aliasSelector);
if (subject != nil) return subject;

Class class = RACSwizzleClass(self);

subject = [RACSubject subject];
objc_setAssociatedObject(self, aliasSelector, subject, OBJC_ASSOCIATION_RETAIN);

Method targetMethod = class_getInstanceMethod(class, selector);
</code></pre>

<ol>
  <li>获取选择子的别名，在这里我们通过为选择子加前缀 <code>rac_alias_</code> 来实现；</li>
  <li>尝试以 <code>rac_alias_selector</code> 为键获取一个热信号 <code>RACSubject</code>；</li>
  <li>使用 <code>RACSwizzleClass</code> 调剂当前类的一些方法（我们会在下一节中介绍）；</li>
  <li>从当前类中获取目标方法的结构体 <code>targetMethod</code>；</li>
</ol>

<p>在进行了以上的准备工作之后，我们就开始修改选择子对应的实现了，整个的修改过程会分为三种情况：</p>

<p><img src="https://img.nju520.me/2017-02-25-Swizzle-objc_msgForward.png-1000width" alt="Swizzle-objc_msgForward" /></p>

<p>下面会按照这三种情况依次介绍在不同情况下，如何将对应选择子的实现改为 <code>_objc_msgForward</code> 完成消息转发的。</p>

<h4 id="targetmethod--null--protocol--null">targetMethod == NULL &amp;&amp; protocol == NULL</h4>

<p>在找不到选择子对应的方法并且没有传入协议时，这时执行的代码最为简单：</p>

<pre><code class="language-objectivec">typeEncoding = RACSignatureForUndefinedSelector(selector);
class_addMethod(class, selector, _objc_msgForward, typeEncoding);
</code></pre>

<p>我们会通过 <code>RACSignatureForUndefinedSelector</code> 生成一个当前方法默认的类型编码。</p>

<blockquote>
  <p>对类型编码不了解的可以阅读苹果的官方文档 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encodings · Apple Developer</a>，其中详细解释了类型编码是什么，它在整个 Objective-C 运行时有什么作用。</p>
</blockquote>

<pre><code class="language-objectivec">static const char *RACSignatureForUndefinedSelector(SEL selector) {
	const char *name = sel_getName(selector);
	NSMutableString *signature = [NSMutableString stringWithString:@"v@:"];

	while ((name = strchr(name, ':')) != NULL) {
		[signature appendString:@"@"];
		name++;
	}

	return signature.UTF8String;
}
</code></pre>

<p>该方法在生成类型编码时，会按照 <code>:</code> 的个数来为 <code>v@:</code> 这个类型编码添加 <code>@</code> 字符；简单说明一下它的意思，ReactiveCocoa 默认所有的方法的返回值类型都为空 <code>void</code>，都会传入 <code>self</code> 以及当前方法的选择子 <code>SEL</code>，它们的类型编码可以在下图中找到，分别是 <code>v@:</code>；而 <code>@</code> 代表 <code>id</code> 类型，也就是我们默认代理方法中的所有参数都是 <code>NSObject</code> 类型的。</p>

<p><img src="https://img.nju520.me/2017-02-25-TypeEncoding.png-1000width" alt="TypeEncoding" /></p>

<p>生成了类型编码之后，由于我们并没有在当前类中找到该选择子对应的方法，所以会使用 <code>class_addMethod</code> 为当前类提供一个方法的实现，直接将当前选择子的实现改为 <code>_objc_msgForward</code>。</p>

<p><img src="https://img.nju520.me/2017-02-25-Selector-To-ObjC-Message-Forward.png-1000width" alt="Selector-To-ObjC-Message-Forward" /></p>

<h4 id="targetmethod--null--protocol--null-1">targetMethod == NULL &amp;&amp; protocol != NULL</h4>

<p>当类中不存在当前选择子对应的方法 <code>targetMethod</code>，但是向当前函数中传入了协议时，我们会尝试从协议中获取方法描述：</p>

<pre><code class="language-objectivec">struct objc_method_description methodDescription = protocol_getMethodDescription(protocol, selector, NO, YES);

if (methodDescription.name == NULL) {
    methodDescription = protocol_getMethodDescription(protocol, selector, YES, YES);
}
typeEncoding = methodDescription.types;
class_addMethod(class, selector, _objc_msgForward, typeEncoding);
</code></pre>

<p>这里会使用 <code>protocol_getMethodDescription</code> 两次从协议中获取可选和必须实现的方法的描述，并从结构体中拿出类型编码，最后为类添加这个之前不存在的方法：</p>

<p><img src="https://img.nju520.me/2017-02-25-Selector-To-ObjC-Message-Forward.png-1000width" alt="Selector-To-ObjC-Message-Forward" /></p>

<p>在这种情况下，其最后的结果与上一种的完全相同，因为它们都是对不存在该方法，只需要获得方法的类型编码并将实现添加为 <code>_objc_msgForward</code>，交给消息转发流程进行处理即可。</p>

<h4 id="targetmethod--null">targetMethod != NULL</h4>

<p>在目标方法的实现不为空并且它的实现并不是 <code>_objc_msgForward</code> 时，我们就会进入以下流程修改原有方法的实现：</p>

<pre><code class="language-objectivec">const char *typeEncoding = method_getTypeEncoding(targetMethod);

class_addMethod(class, aliasSelector, method_getImplementation(targetMethod), typeEncoding);
class_replaceMethod(class, selector, _objc_msgForward, method_getTypeEncoding(targetMethod));
</code></pre>

<p>同样，我们需要获得目标方法的方法签名、添加 <code>aliasSelector</code> 这个新方法，最后在修改原方法的实现到 <code>_objc_msgForward</code>。</p>

<p><img src="https://img.nju520.me/2017-02-25-Selector-To-ObjC-Message-Forward-With-RACSelector.png-1000width" alt="Selector-To-ObjC-Message-Forward-With-RACSelecto" /></p>

<p>上图展示了在目标方法不为空并且其实现不为 <code>_objc_msgForward</code> 时，<code>NSObjectRACSignalForSelector</code> 是如何修改原方法实现的。</p>

<h3 id="调剂类的方法">调剂类的方法</h3>

<p><code>NSObjectRACSignalForSelector</code> 在修改原选择子方法实现的之前就已经修改了当前类很多方法的实现：</p>

<ul>
  <li><code>-methodSignatureForSelector:</code></li>
  <li><code>-class</code></li>
  <li><code>-respondsToSelector</code></li>
  <li><code>-forwardInvocation:</code></li>
</ul>

<p>整个调剂方法的过程 <code>RACSwizzleClass</code> 还是比较复杂的，我们可以分三部分看下面的代码：</p>

<pre><code class="language-objectivec">static Class RACSwizzleClass(NSObject *self) {
	Class statedClass = self.class;
	Class baseClass = object_getClass(self);

	NSString *className = NSStringFromClass(baseClass);
	const char *subclassName = [className stringByAppendingString:RACSubclassSuffix].UTF8String;
	Class subclass = objc_getClass(subclassName);

	if (subclass == nil) {
		subclass = objc_allocateClassPair(baseClass, subclassName, 0);
		if (subclass == nil) return nil;

		RACSwizzleForwardInvocation(subclass);
		RACSwizzleRespondsToSelector(subclass);
		RACSwizzleGetClass(subclass, statedClass);
		RACSwizzleGetClass(object_getClass(subclass), statedClass);
		RACSwizzleMethodSignatureForSelector(subclass);

		objc_registerClassPair(subclass);
	}
	object_setClass(self, subclass);
	return subclass;
}
</code></pre>

<ol>
  <li>从当前类 <code>RACDelegateProxy</code> 衍生出一个子类 <code>RACDelegateProxy_RACSelectorSignal</code>；</li>
  <li>调用各种 <code>RACSwizzleXXX</code> 方法修改当前子类的一些表现；</li>
  <li>将 <code>RACDelegateProxy</code> 对象的类设置成自己，这样就会在查找方法时，找到 <code>RACDelegateProxy_RACSelectorSignal</code> 中的实现；</li>
</ol>

<p>在修改的几个方法中最重要的就是 <code>-forwardInvocation:</code>：</p>

<pre><code class="language-objectivec">static void RACSwizzleForwardInvocation(Class class) {
	SEL forwardInvocationSEL = @selector(forwardInvocation:);
	Method forwardInvocationMethod = class_getInstanceMethod(class, forwardInvocationSEL);

	void (*originalForwardInvocation)(id, SEL, NSInvocation *) = NULL;
	if (forwardInvocationMethod != NULL) {
		originalForwardInvocation = (__typeof__(originalForwardInvocation))method_getImplementation(forwardInvocationMethod);
	}

	id newForwardInvocation = ^(id self, NSInvocation *invocation) {
		BOOL matched = RACForwardInvocation(self, invocation);
		if (matched) return;

		if (originalForwardInvocation == NULL) {
			[self doesNotRecognizeSelector:invocation.selector];
		} else {
			originalForwardInvocation(self, forwardInvocationSEL, invocation);
		}
	};

	class_replaceMethod(class, forwardInvocationSEL, imp_implementationWithBlock(newForwardInvocation), "v@:@");
}
</code></pre>

<p>这个方法中大部分的内容都是平淡无奇的，在新的 <code>-forwardInvocation:</code> 方法中，执行的 <code>RACForwardInvocation</code> 是实现整个消息转发的关键内容：</p>

<pre><code class="language-objectivec">static BOOL RACForwardInvocation(id self, NSInvocation *invocation) {
	SEL aliasSelector = RACAliasForSelector(invocation.selector);
	RACSubject *subject = objc_getAssociatedObject(self, aliasSelector);

	Class class = object_getClass(invocation.target);
	BOOL respondsToAlias = [class instancesRespondToSelector:aliasSelector];
	if (respondsToAlias) {
		invocation.selector = aliasSelector;
		[invocation invoke];
	}

	if (subject == nil) return respondsToAlias;

	[subject sendNext:invocation.rac_argumentsTuple];
	return YES;
}
</code></pre>

<p>在 <code>-rac_signalForSelector:</code> 方法返回的 <code>RACSignal</code> 上接收到的参数信号，就是从这个方法发送过去的，新的实现 <code>RACForwardInvocation</code> 改变了原有的 <code>selector</code> 到 <code>aliasSelector</code>，然后使用 <code>-invoke</code> 完成该调用，而所有的参数会以 <code>RACTuple</code> 的方式发送到信号上。</p>

<p>像其他的方法 <code>-respondToSelector:</code> 等等，它们的实现就没有这么复杂并且重要了：</p>

<pre><code class="language-objectivec">id newRespondsToSelector = ^ BOOL (id self, SEL selector) {
    Method method = rac_getImmediateInstanceMethod(class, selector);

    if (method != NULL &amp;&amp; method_getImplementation(method) == _objc_msgForward) {
        SEL aliasSelector = RACAliasForSelector(selector);
        if (objc_getAssociatedObject(self, aliasSelector) != nil) return YES;
    }

    return originalRespondsToSelector(self, respondsToSelectorSEL, selector);
};
</code></pre>

<p><code>rac_getImmediateInstanceMethod</code> 从当前类获得方法的列表，并从中找到与当前 <code>selector</code> 同名的方法 <code>aliasSelector</code>，然后根据不同情况判断方法是否存在。</p>

<p>对 <code>class</code> 的修改，是为了让对象对自己的身份『说谎』，因为我们子类化了 <code>RACDelegateProxy</code>，并且重新设置了对象的类，将所有的方法都转发到了这个子类上，如果不修改 <code>class</code> 方法，那么当开发者使用它自省时就会得到错误的类，而这是我们不希望看到的。</p>

<pre><code class="language-objectivec">static void RACSwizzleGetClass(Class class, Class statedClass) {
	SEL selector = @selector(class);
	Method method = class_getInstanceMethod(class, selector);
	IMP newIMP = imp_implementationWithBlock(^(id self) {
		return statedClass;
	});
	class_replaceMethod(class, selector, newIMP, method_getTypeEncoding(method));
}
</code></pre>

<p>在最后我们会对获得方法签名的 <code>-methodSignatureForSelector:</code> 方法进行修改：</p>

<pre><code class="language-objectivec">IMP newIMP = imp_implementationWithBlock(^(id self, SEL selector) {
    Class actualClass = object_getClass(self);
    Method method = class_getInstanceMethod(actualClass, selector);
    if (method == NULL) {
        struct objc_super target = {
            .super_class = class_getSuperclass(class),
            .receiver = self,
        };
        NSMethodSignature * (*messageSend)(struct objc_super *, SEL, SEL) = (__typeof__(messageSend))objc_msgSendSuper;
        return messageSend(&amp;target, @selector(methodSignatureForSelector:), selector);
    }

    char const *encoding = method_getTypeEncoding(method);
    return [NSMethodSignature signatureWithObjCTypes:encoding];
});
</code></pre>

<p>在方法不存在时，通过 <code>objc_msgSendSuper</code> 调用父类的 <code>-methodSignatureForSelector:</code> 方法获取方法签名。</p>

<h2 id="方法调用的过程">方法调用的过程</h2>

<p>在一般情况下，Objective-C 中某一消息被发送到一个对象时，它会先获取当前对象对应的类，然后从类的选择子表查找该方法对应的实现并执行。</p>

<p><img src="https://img.nju520.me/2017-02-25-Selector-To-IMP.png-1000width" alt="Selector-To-IMP" /></p>

<p>与正常的方法实现查找以及执行过程的简单不同，如果我们对某一个方法调用了 <code>-rac_signalForSelector:</code> 方法，那么对于同一个对象对应的类的所有方法，它们的执行过程会变得非常复杂：</p>

<p><img src="https://img.nju520.me/2017-02-25-After-Call-RACSignalForSelector.png-1000width" alt="After-Call-RACSignalForSelecto" /></p>

<ol>
  <li>由于当前对象对应的类已经被改成了 <code>Subclass</code>，即 <code>Class_RACSelectorSignal</code>，所以会在子类中查找方法的实现；</li>
  <li>方法对应的实现已经被改成了 <code>-forwardInvocation:</code>，会直接进入消息转发流程中处理；</li>
  <li>根据传入的选择子获取同名选择子 <code>rac_alias_selector</code>；</li>
  <li>拿到当前 <code>NSInvocation</code> 对象中 <code>target</code> 的类，判断是否可以响应该选择子；</li>
  <li>将 <code>NSInvocation</code> 对象中的选择子改为 <code>rac_alias_selector</code> 并执行其实现；</li>
  <li>从 <code>NSInvocation</code> 对象中获取参数并打包成 <code>RACTuple</code>，以 <code>next</code> 消息的形式发送到持有的 <code>RACSubject</code> 热信号上；</li>
</ol>

<p>这时所有的订阅者才会在该方法被调用时收到消息，完成相应的任务。</p>

<h2 id="总结">总结</h2>

<p>ReactiveCocoa 使用了一种非常神奇的办法把原有的代理模式成功的桥接到 <code>RACSignal</code> 的世界中，并为我们提供了 <code>RACDelegateProxy</code> 这一接口，能够帮助我们以信号的形式监听所有的代理方法，可以用 block 的形式去代替原有的方法，为我们减少一些工作量。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encodings · Apple Developer</a></li>
</ul>

<blockquote>
  <p>Github Repo：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://nju520.me/racdelegateproxy</p>
</blockquote>

  ]]></description>
</item>

<item>
  <title>理解 RACScheduler 的实现</title>
  <link>//racscheduler</link>
  <author>nju520</author>
  <pubDate>2017-02-17T20:10:43+08:00</pubDate>
  <guid>//racscheduler</guid>
  <description><![CDATA[
  <p><code>RACScheduler</code> 是一个线性执行队列，ReactiveCocoa 中的信号可以在 <code>RACScheduler</code> 上执行任务、发送结果；它的实现并不复杂，由多个简单的方法和类组成整个 <code>RACScheduler</code> 模块，是整个 ReactiveCocoa 中非常易于理解的部分。</p>

<h2 id="racscheduler-简介">RACScheduler 简介</h2>

<p><code>RACScheduler</code> 作为 ReactiveCocoa 中唯一的用于调度的模块，它包含很多个性化的子类：</p>

<p><img src="https://img.nju520.me/2017-02-17-RACScheduler-Subclasses.png-1000width" alt="RACScheduler-Subclasses" /></p>

<p><code>RACScheduler</code> 类的内部只有一个用于追踪标记和 debug 的属性 <code>name</code>，头文件和实现文件中的其它内容都是各种各样的方法；我们可以把其中的方法分为两类，一类是用于初始化 <code>RACScheduler</code> 实例的初始化方法：</p>

<p><img src="https://img.nju520.me/2017-02-17-RACScheduler-Initializers.png-1000width" alt="RACScheduler-Initializers" /></p>

<p>另一类就是用于调度、执行任务的 <code>+schedule:</code> 等方法：</p>

<p><img src="https://img.nju520.me/2017-02-17-RACScheduler-Schedule.png-1000width" alt="RACScheduler-Schedule" /></p>

<p>在图中都省略了一些参数缺省的方法，以及一些调用其他方法的调度方法或者初始化方法，用以减少我们分析和理解整个 <code>RACScheduler</code> 类的难度。</p>

<p>在 <code>RACScheduler</code> 中，大部分的调度方法都是需要子类覆写，它本身只提供少数的功能，比如递归 block 的执行：</p>

<pre><code class="language-objectivec">- (RACDisposable *)scheduleRecursiveBlock:(RACSchedulerRecursiveBlock)recursiveBlock {
	RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];
	[self scheduleRecursiveBlock:[recursiveBlock copy] addingToDisposable:disposable];
	return disposable;
}
</code></pre>

<p>该方法会递归的执行传入的 <code>recursiveBlock</code>，使用的方式非常简单：</p>

<pre><code class="language-objectivec">[scheduler scheduleRecursiveBlock:^(void (^reschedule)(void)) {
    if (needTerminated) return;

    // do something

    reschedule();
}];
</code></pre>

<p>如果需要递归就执行方法中的 <code>reschedule()</code>，就会再次执行当前的 block；<code>-scheduleRecursiveBlock:</code> 中调用的 <code>-scheduleRecursiveBlock:addingToDisposable:</code> 实现比较复杂：</p>

<pre><code class="language-objectivec">- (void)scheduleRecursiveBlock:(RACSchedulerRecursiveBlock)recursiveBlock addingToDisposable:(RACCompoundDisposable *)disposable {
    ...
    RACDisposable *schedulingDisposable = [self schedule:^{
        void (^reallyReschedule)(void) = ^{
            [self scheduleRecursiveBlock:recursiveBlock addingToDisposable:disposable];
        };

        recursiveBlock(^{
            reallyReschedule();
        });
    }];
    ...
}
</code></pre>

<blockquote>
  <p>方法使用了 <code>NSLock</code> 保证在并发情况下并不会出现任何问题，不过在这里展示的代码中，我们将它省略了，一并省略的还有 <code>RACDisposable</code> 相关的代码，以保证整个方法逻辑的清晰，方法的原实现可以查看这里 <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/9164a24abfbb7d6b2280d78f9c9308a9842bfcfe/ReactiveObjC/RACScheduler.m#L130-L187">RACScheduler.m#L130-L187</a>。</p>
</blockquote>

<p>在每次执行 <code>recursiveBlock</code> 时，都会传入一个 <code>reallyReschedule</code> 用于递归执行传入的 block。</p>

<p>其他的方法包括 <code>+schedule:</code>、<code>+after:schedule:</code> 以及 <code>after:repeatingEvery:withLeeway:schedule:</code> 方法都需要子类覆写：</p>

<pre><code class="language-objectivec">- (RACDisposable *)schedule:(void (^)(void))block;
- (RACDisposable *)after:(NSDate *)date schedule:(void (^)(void))block;
- (RACDisposable *)after:(NSDate *)date repeatingEvery:(NSTimeInterval)interval withLeeway:(NSTimeInterval)leeway schedule:(void (^)(void))block {
	NSCAssert(NO, @"%@ must be implemented by subclasses.", NSStringFromSelector(_cmd));
	return nil;
}
</code></pre>

<p>而接下来我们就按照初始化方法的顺序依次介绍 <code>RACScheduler</code> 的子类了。</p>

<h3 id="racimmediatescheduler">RACImmediateScheduler</h3>

<p><code>RACImmediateScheduler</code> 是一个会立即执行传入的代码块的调度器，我们可以使用 <code>RACScheduler</code> 的类方法 <code>+immediateScheduler</code> 返回一个它的实例：</p>

<pre><code class="language-objectivec">+ (RACScheduler *)immediateScheduler {
	static dispatch_once_t onceToken;
	static RACScheduler *immediateScheduler;
	dispatch_once(&amp;onceToken, ^{
		immediateScheduler = [[RACImmediateScheduler alloc] init];
	});
	return immediateScheduler;
}
</code></pre>

<p>由于 <code>RACImmediateScheduler</code> 是一个私有类，全局只能通过该方法返回它的实例，所以整个程序的运行周期内，我们通过『合法』手段只能获得唯一一个单例。</p>

<p>作为 <code>RACScheduler</code> 的子类，它必须对父类的调度方法进行覆写，不过因为本身的职能原因，<code>RACImmediateScheduler</code> 对于父类的覆写还是非常简单的：</p>

<pre><code class="language-objectivec">- (RACDisposable *)schedule:(void (^)(void))block {
	block();
	return nil;
}

- (RACDisposable *)after:(NSDate *)date schedule:(void (^)(void))block {
	[NSThread sleepUntilDate:date];
	block();
	return nil;
}

- (RACDisposable *)after:(NSDate *)date repeatingEvery:(NSTimeInterval)interval withLeeway:(NSTimeInterval)leeway schedule:(void (^)(void))block {
	NSCAssert(NO, @"+[RACScheduler immediateScheduler] does not support %@.", NSStringFromSelector(_cmd));
	return nil;
}
</code></pre>

<ul>
  <li><code>+schedule</code> 方法会立刻执行传入的 block；</li>
  <li><code>+after:schedule:</code> 方法会将当前线程休眠到指定时间后执行 block；</li>
  <li>而对于 <code>+after:repeatingEvery:withLeeway:schedule:</code> 方法就干脆不支持。</li>
</ul>

<p>这确实非常符合 <code>RACImmediateScheduler</code> 类的名字以及功能，虽然没有要求对递归执行 block 的方法进行覆写，不过它依然做了这件事情：</p>

<pre><code class="language-objectivec">- (RACDisposable *)scheduleRecursiveBlock:(RACSchedulerRecursiveBlock)recursiveBlock {
	for (__block NSUInteger remaining = 1; remaining &gt; 0; remaining--) {
		recursiveBlock(^{
			remaining++;
		});
	}
	return nil;
}
</code></pre>

<p>实现的过程非常简洁，甚至没有什么值得解释的地方了。</p>

<h3 id="ractargetqueuescheduler">RACTargetQueueScheduler</h3>

<p><code>RACTargetQueueScheduler</code> 继承自 <code>RACQueueScheduler</code>，但是由于后者是抽象类，我们并不会直接使用它，它只是为前者提供必要的方法支持，将一部分逻辑抽离出来：</p>

<p><img src="https://img.nju520.me/2017-02-17-RACTargetQueueScheduler.png-1000width" alt="RACTargetQueueSchedule" /></p>

<p>这里我们先简单看一下 <code>RACTargetQueueScheduler</code> 的实现，整个 <code>RACTargetQueueScheduler</code> 类中只有一个初始化方法：</p>

<pre><code class="language-objectivec">- (instancetype)initWithName:(NSString *)name targetQueue:(dispatch_queue_t)targetQueue {
	dispatch_queue_t queue = dispatch_queue_create(name.UTF8String, DISPATCH_QUEUE_SERIAL);
	dispatch_set_target_queue(queue, targetQueue);
	return [super initWithName:name queue:queue];
}
</code></pre>

<p>初始化方法 <code>-initWithName:targetQueue:</code> 使用 <code>dispatch_queue_create</code> 创建了一个串行队列，然后通过 <code>dispatch_set_target_queue</code>  根据传入的 <code>targetQueue</code> 设置队列的优先级，最后调用父类的指定构造器完成整个初始化过程。</p>

<p><code>RACTargetQueueScheduler</code> 在使用时，将待执行的任务加入一个私有的串行队列中，其优先级与传入的 targetQueue 完全相同；不过提到 <code>RACTargetQueueScheduler</code> 中队列的优先级，对 GCD 稍有了解的人应该都知道在 GCD 中有着四种不同优先级的全局并行队列，而在 <code>RACScheduler</code> 中也有一一对应的枚举类型：</p>

<p><img src="https://img.nju520.me/2017-02-17-RACScheduler-Priority.png-1000width" alt="RACScheduler-Priority" /></p>

<p>在使用 <code>+schedulerWithPriority:</code> 方法创建 <code>RACTargetQueueScheduler</code> 时，就需要传入上面的优先级，方法会通过 GCD 的内置方法 <code>dispatch_get_global_queue</code> 获取全局的并行队列，最终返回一个新的实例。</p>

<pre><code class="language-objectivec">+ (RACScheduler *)schedulerWithPriority:(RACSchedulerPriority)priority name:(NSString *)name {
	return [[RACTargetQueueScheduler alloc] initWithName:name targetQueue:dispatch_get_global_queue(priority, 0)];
}
</code></pre>

<p>在 <code>RACScheduler</code> 接口中另一个获得主线程调度器的方法 <code>+mainThreadScheduler</code>，其实现也是返回一个 <code>RACTargetQueueScheduler</code> 对象：</p>

<pre><code class="language-objectivec">+ (RACScheduler *)mainThreadScheduler {
	static dispatch_once_t onceToken;
	static RACScheduler *mainThreadScheduler;
	dispatch_once(&amp;onceToken, ^{
		mainThreadScheduler = [[RACTargetQueueScheduler alloc] initWithName:@"org.reactivecocoa.ReactiveObjC.RACScheduler.mainThreadScheduler" targetQueue:dispatch_get_main_queue()];
	});

	return mainThreadScheduler;
}
</code></pre>

<p>与前者不同的是，后者通过单例模式每次调用时返回一个相同的主线程队列。</p>

<h4 id="抽象类-racqueuescheduler">抽象类 RACQueueScheduler</h4>

<p>在我们对 <code>RACTargetQueueScheduler</code> 有一定了解之后，再看它的抽象类就非常简单了；<code>RACImmediateScheduler</code> 会立即执行传入的任务，而 <code>RACQueueScheduler</code> 其实就是对 GCD 的封装，相信各位读者从它的子类的实现就可以看出来。</p>

<p><code>RACQueueScheduler</code> 对三个需要覆写的方法都进行了重写，其实现完全基于 GCD，以 <code>-schedule:</code> 方法为例：</p>

<pre><code class="language-objectivec">- (RACDisposable *)schedule:(void (^)(void))block {
	RACDisposable *disposable = [[RACDisposable alloc] init];

	dispatch_async(self.queue, ^{
		if (disposable.disposed) return;
		[self performAsCurrentScheduler:block];
	});

	return disposable;
}
</code></pre>

<p>使用 <code>dispatch_async</code> 方法直接将需要执行的任务<strong>异步派发</strong>到它所持有的队列上；而 <code>-after:schedule:</code> 方法的实现相信各位读者也能猜到：</p>

<pre><code class="language-objectivec">- (RACDisposable *)after:(NSDate *)date schedule:(void (^)(void))block {
	RACDisposable *disposable = [[RACDisposable alloc] init];

	dispatch_after([self.class wallTimeWithDate:date], self.queue, ^{
		if (disposable.disposed) return;
		[self performAsCurrentScheduler:block];
	});

	return disposable;
}
</code></pre>

<p>哪怕不使用 <code>RACScheduler</code>，我们也能够想到利用 <code>dispatch_after</code> 完成一些需要延迟执行的任务，最后的 <code>+after:repeatingEvery:withLeeway:schedule:</code> 方法的实现就稍微复杂一些了：</p>

<pre><code class="language-objectivec">- (RACDisposable *)after:(NSDate *)date repeatingEvery:(NSTimeInterval)interval withLeeway:(NSTimeInterval)leeway schedule:(void (^)(void))block {
	uint64_t intervalInNanoSecs = (uint64_t)(interval * NSEC_PER_SEC);
	uint64_t leewayInNanoSecs = (uint64_t)(leeway * NSEC_PER_SEC);

	dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, self.queue);
	dispatch_source_set_timer(timer, [self.class wallTimeWithDate:date], intervalInNanoSecs, leewayInNanoSecs);
	dispatch_source_set_event_handler(timer, block);
	dispatch_resume(timer);

	return [RACDisposable disposableWithBlock:^{
		dispatch_source_cancel(timer);
	}];
}
</code></pre>

<p>方法使用 <code>dispatch_source_t</code> 以及定时器，完成了每隔一段时间需要执行任务的需求。</p>

<h3 id="racsubscriptionscheduler">RACSubscriptionScheduler</h3>

<p>最后的 <code>RACSubscriptionScheduler</code> 是 ReactiveCocoa 中一个比较特殊的调度器，所有 ReactiveCocoa 中的订阅事件都会在 <code>RACSubscriptionScheduler</code> 调度器上进行；而它是通过封装两个调度器实现的：</p>

<p><img src="https://img.nju520.me/2017-02-17-RACSubscriptionScheduler.png-1000width" alt="RACSubscriptionSchedule" /></p>

<blockquote>
  <p><code>backgroundScheduler</code> 是一个优先级为 <code>RACSchedulerPriorityDefault</code> 的串行队列。</p>
</blockquote>

<p><code>RACSubscriptionScheduler</code> 本身不提供任何的调度功能，它会根据当前状态选择持有的两个调度器中的一个执行任务；首先判断当前线程是否存在 <code>currentScheduler</code>，如果不存在的话才会在 <code>backgroundScheduler</code> 执行任务。</p>

<pre><code class="language-objectivec">- (RACDisposable *)schedule:(void (^)(void))block {
	if (RACScheduler.currentScheduler == nil) return [self.backgroundScheduler schedule:block];
	block();
	return nil;
}

- (RACDisposable *)after:(NSDate *)date schedule:(void (^)(void))block {
	RACScheduler *scheduler = RACScheduler.currentScheduler ?: self.backgroundScheduler;
	return [scheduler after:date schedule:block];
}

- (RACDisposable *)after:(NSDate *)date repeatingEvery:(NSTimeInterval)interval withLeeway:(NSTimeInterval)leeway schedule:(void (^)(void))block {
	RACScheduler *scheduler = RACScheduler.currentScheduler ?: self.backgroundScheduler;
	return [scheduler after:date repeatingEvery:interval withLeeway:leeway schedule:block];
}
</code></pre>

<p><code>RACSubscriptionScheduler</code> 作为一个私有类，我们并不能直接在 ReactiveCocoa 外部使用它，需要通过私有方法 <code>+subscriptionScheduler</code> 获取这个调度器：</p>

<pre><code class="language-objectivec">+ (RACScheduler *)subscriptionScheduler {
	static dispatch_once_t onceToken;
	static RACScheduler *subscriptionScheduler;
	dispatch_once(&amp;onceToken, ^{
		subscriptionScheduler = [[RACSubscriptionScheduler alloc] init];
	});

	return subscriptionScheduler;
}
</code></pre>

<h2 id="总结">总结</h2>

<p><code>RACScheduler</code> 在某些方面与 GCD 中的队列十分相似，与 GCD 中的队列不同的有两点，第一，它可以通过 <code>RACDisposable</code> 对执行中的任务进行取消，第二是 <code>RACScheduler</code> 中任务的执行都是线性的；与此同时 <code>RACScheduler</code> 也与 <code>NSOperationQueue</code> 非常类似，但是它并不支持对调度的任务进行<strong>重排序</strong>以及实现任务与任务之间的<strong>依赖</strong>关系。</p>

<h2 id="references">References</h2>

<blockquote>
  <p>Github Repo：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://nju520.me/racscheduler</p>
</blockquote>

  ]]></description>
</item>

<item>
  <title>RAC 中的双向数据绑定 RACChannel</title>
  <link>//racchannel</link>
  <author>nju520</author>
  <pubDate>2017-02-16T19:59:14+08:00</pubDate>
  <guid>//racchannel</guid>
  <description><![CDATA[
  <p>之前讲过了 ReactiveCocoa 中的一对一的单向数据流 <code>RACSignal</code> 和一对多的单向数据流 <code>RACMulticastConnection</code>，这一篇文章分析的是一对一的双向数据流 <code>RACChannel</code>。</p>

<p><img src="https://img.nju520.me/2017-02-16-What-is-RACChannel.png-1000width" alt="What-is-RACChanne" /></p>

<p><code>RACChannel</code> 其实是一个相对比较复杂的类，但是，对其有一定了解之后合理运用的话，会在合适的业务中提供非常强大的支持能够极大的简化业务代码。</p>

<h2 id="racchannel-简介">RACChannel 简介</h2>

<p><code>RACChannel</code> 可以被理解为一个双向的连接，这个连接的两端都是 <code>RACSignal</code> 实例，它们可以向彼此发送消息，如果我们在视图和模型之间通过 <code>RACChannel</code> 建立这样的连接：</p>

<p><img src="https://img.nju520.me/2017-02-16-Connection-Between-View-Model.png-1000width" alt="Connection-Between-View-Mode" /></p>

<p>那么从模型发出的消息，最后会发送到视图上；反之，用户对视图进行的操作最后也会体现在模型上。这种通信方式的实现是基于信号的，<code>RACChannel</code> 内部封装了两个 <code>RACChannelTerminal</code> 对象，它们都是 <code>RACSignal</code> 的子类：</p>

<p><img src="https://img.nju520.me/2017-02-16-RACChannel-Interface.png-1000width" alt="RACChannel-Interface" /></p>

<p>对模型进行的操作最后都会发送给 <code>leadingTerminal</code> 再通过内部的实现发送给 <code>followingTerminal</code>，由于视图是 <code>followingTerminal</code> 的订阅者，所以消息最终会发送到视图上。</p>

<p><img src="https://img.nju520.me/2017-02-16-Messages-Send-From-Model.png-1000width" alt="Messages-Send-From-Mode" /></p>

<p>在上述情况下，<code>leadingTerminal</code> 的订阅者（模型）并不会收到消息，它的订阅者（视图）只会在 <code>followingTerminal</code> 收到消息时才会接受到新的值。</p>

<p>同时，<code>RACChannel</code> 的绑定都是双向的，视图收到用户的动作，例如点击等事件时，会将消息发送给 <code>followingTerminal</code>，而 <code>followingTerminal</code> 并<strong>不会</strong>将消息发送给自己的订阅者（视图），而是会发送给 <code>leadingTerminal</code>，并通过 <code>leadingTerminal</code> 发送给其订阅者，即模型。</p>

<p><img src="https://img.nju520.me/2017-02-16-Terminals-Between-View-Model.png-1000width" alt="Terminals-Between-View-Mode" /></p>

<p>上图描述了信息在 <code>RACChannel</code> 之间的传递过程，无论是模型属性的改变还是用户对视图进行的操作都会通过这两个 <code>RACChannelTerminal</code> 传递到另一端；同时，由于消息不会发送给自己的订阅者，所以不会造成信息的循环发送。</p>

<h2 id="racchannel-和-racchannelterminal">RACChannel 和 RACChannelTerminal</h2>

<p><code>RACChannel</code> 和 <code>RACChannelTerminal</code> 的关系非常密切，前者可以理解为一个网络连接，后者可以理解为 <code>socket</code>，表示网络连接的一端，下图描述了 <code>RACChannel</code> 与网络连接中概念的一一对应关系。</p>

<p><img src="https://img.nju520.me/2017-02-16-Channel-And-Network-Connection.png-1000width" alt="Channel-And-Network-Connection" /></p>

<ul>
  <li>在客户端使用 <code>write</code> 向 <code>socket</code> 中发送消息时，<code>socket</code> 的持有者客户端不会收到消息，只有在 <code>socket</code> 上调用 <code>read</code> 的服务端才会收到消息；反之亦然。</li>
  <li>在模型使用 <code>sendNext</code> 向<code>leadingTerminal</code> 中发送消息时，<code>leadingTerminal</code> 的订阅者模型不会收到消息，只有在 <code>followingTerminal</code> 上调用 <code>subscribe</code> 的视图才会收到消息；反之亦然。</li>
</ul>

<h3 id="racchannelterminal-的实现">RACChannelTerminal 的实现</h3>

<p>为什么向 <code>RACChannelTerminal</code> 发送消息，它的订阅者获取不到？先来看一下它在头文件中的定义：</p>

<pre><code class="language-objectivec">@interface RACChannelTerminal : RACSignal &lt;RACSubscriber&gt;
@end
</code></pre>

<p><code>RACChannelTerminal</code> 是一个信号的子类，同时它还遵循了 <code>RACSubscriber</code> 协议，也就是可以向它调用 <code>-sendNext:</code> 等方法；<code>RAChannelTerminal</code> 中持有了两个对象：</p>

<p><img src="https://img.nju520.me/2017-02-16-RACChannelTerminal-Interface.png-1000width" alt="RACChannelTerminal-Interface" /></p>

<p>在初始化时，需要传入 <code>values</code> 和 <code>otherTerminal</code> 这两个属性，其中 <code>values</code> 表示当前断点，<code>otherTerminal</code> 表示远程端点：</p>

<pre><code class="language-objectivec">- (instancetype)initWithValues:(RACSignal *)values otherTerminal:(id&lt;RACSubscriber&gt;)otherTerminal {
	self = [super init];
	_values = values;
	_otherTerminal = otherTerminal;
	return self;
}
</code></pre>

<p>当然，作为 <code>RACSignal</code> 的子类，<code>RACChannelTerminal</code> 必须覆写 <code>-subscribe:</code> 方法：</p>

<pre><code class="language-objectivec">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber {
	return [self.values subscribe:subscriber];
}
</code></pre>

<p>在订阅者调用 <code>-subscribeNext:</code> 等方法发起订阅时，实际上订阅的是当前端点；如果向当前端点发送消息，会被转发到远程端点上，而这也就是当前端点的订阅者不会接收到向当前端点发送消息的原因：</p>

<pre><code class="language-objectivec">- (void)sendNext:(id)value {
	[self.otherTerminal sendNext:value];
}
- (void)sendError:(NSError *)error {
	[self.otherTerminal sendError:error];
}
- (void)sendCompleted {
	[self.otherTerminal sendCompleted];
}
</code></pre>

<h3 id="racchannel-的初始化">RACChannel 的初始化</h3>

<p>我们在任何情况下都不应该直接使用 <code>-init</code> 方法初始化 <code>RACChannelTerminal</code> 的实例，而是应该以创建 <code>RACChannel</code> 的方式生成它：</p>

<pre><code class="language-objectivec">- (instancetype)init {
	self = [super init];

	RACReplaySubject *leadingSubject = [RACReplaySubject replaySubjectWithCapacity:0];
	RACReplaySubject *followingSubject = [RACReplaySubject replaySubjectWithCapacity:1];

	[[leadingSubject ignoreValues] subscribe:followingSubject];
	[[followingSubject ignoreValues] subscribe:leadingSubject];

	_leadingTerminal = [[RACChannelTerminal alloc] initWithValues:leadingSubject otherTerminal:followingSubject];
	_followingTerminal = [[RACChannelTerminal alloc] initWithValues:followingSubject otherTerminal:leadingSubject];

	return self;
}
</code></pre>

<p>两个 <code>RACChannelTerminal</code> 中包装的其实是两个 <code>RACSubject</code> 热信号，它们既可以作为订阅者，也可以接收其他对象发送的消息；我们并不希望 <code>leadingSubject</code> 有任何的初始值，但是我们需要 <code>error</code> 和 <code>completed</code> 信息可以被重播。</p>

<p><img src="https://img.nju520.me/2017-02-16-Sending-Errors-And-Completed-Messages.png-1000width" alt="Sending-Errors-And-Completed-Messages" /></p>

<p>通过 <code>-ignoreValues</code> 和 <code>-subscribe:</code> 方法，<code>leadingSubject</code> 和 <code>followingSubject</code> 两个热信号中产生的错误会互相发送，这是为了防止连接的两端一边发生了错误，另一边还继续工作的情况的出现。</p>

<p>在初始化方法的最后，生成两个 <code>RACChannelTerminal</code> 实例的过程就不多说了。</p>

<h2 id="racchannel-与-uikit-组件">RACChannel 与 UIKit 组件</h2>

<p>如果在整个 ReactiveCocoa 工程中搜索 <code>RACChannel</code>，你会发现以下的 UIKit 组件都与 <code>RACChannel</code> 有着非常密切的关系：</p>

<p><img src="https://img.nju520.me/2017-02-16-RACChannel-Hierachy.png-1000width" alt="RACChannel-Hierachy" /></p>

<p>UIKit 中的这些组件都提供了使用 <code>RACChannel</code> 的接口，用以降低数据双向绑定的复杂度，我们以 <code>UITextField</code> 为例，它在分类的接口中提供了 <code>rac_newTextChannel</code> 方法：</p>

<pre><code class="language-objectivec">- (RACChannelTerminal *)rac_newTextChannel {
	return [self rac_channelForControlEvents:UIControlEventAllEditingEvents key:@keypath(self.text) nilValue:@""];
}
</code></pre>

<p>上述方法用于返回一个一端绑定 <code>UIControlEventAllEditingEvents</code> 事件的 <code>RACChannelTerminal</code> 对象。</p>

<p><img src="https://img.nju520.me/2017-02-16-UITextField-RACChannel-Interface.png-1000width" alt="UITextField-RACChannel-Interface" /></p>

<p><code>UIControlEventAllEditingEvents</code> 事件发生时，它会将自己的 <code>text</code> 属性作为信号发送到 <code>followingTerminal -&gt; leadingTerminal</code> 管道中，最后发送给 <code>leadingTerminal</code> 的订阅者。</p>

<p>在 <code>rac_newTextChannel</code> 中调用的方法 <code>-rac_channelForControlEvents:key:nilValue:</code> 是一个 <code>UIControl</code> 的私有方法：</p>

<pre><code class="language-objectivec">- (RACChannelTerminal *)rac_channelForControlEvents:(UIControlEvents)controlEvents key:(NSString *)key nilValue:(id)nilValue {
	key = [key copy];
	RACChannel *channel = [[RACChannel alloc] init];

	RACSignal *eventSignal = [[[self
		rac_signalForControlEvents:controlEvents]
		mapReplace:key]
		takeUntil:[[channel.followingTerminal
			ignoreValues]
			catchTo:RACSignal.empty]];
	[[self
		rac_liftSelector:@selector(valueForKey:) withSignals:eventSignal, nil]
		subscribe:channel.followingTerminal];

	RACSignal *valuesSignal = [channel.followingTerminal
		map:^(id value) {
			return value ?: nilValue;
		}];
	[self rac_liftSelector:@selector(setValue:forKey:) withSignals:valuesSignal, [RACSignal return:key], nil];

	return channel.leadingTerminal;
}
</code></pre>

<p>这个方法为所有的 <code>UIControl</code> 子类，包括 <code>UITextField</code>、<code>UISegmentedControl</code> 等等，它的主要作用就是当传入的 <code>controlEvents</code> 事件发生时，将 UIKit 组件的属性 <code>key</code> 发送到返回的 <code>RACChannelTerminal</code> 实例中；同时，在向返回的 <code>RACChannelTerminal</code> 实例中发送消息时，也会自动更新 UIKit 组件的属性。</p>

<p>上面的代码在初始化 <code>RACChannel</code> 之后做了两件事情，首先是在 <code>UIControlEventAllEditingEvents</code> 事件发生时，将 <code>text</code> 属性发送到 <code>followingTerminal</code> 中：</p>

<pre><code class="language-objectivec">RACSignal *eventSignal = [[[self
    rac_signalForControlEvents:controlEvents]
    mapReplace:key]
    takeUntil:[[channel.followingTerminal
        ignoreValues]
        catchTo:RACSignal.empty]];
[[self
    rac_liftSelector:@selector(valueForKey:) withSignals:eventSignal, nil]
    subscribe:channel.followingTerminal];
</code></pre>

<p>第二个是在 <code>followingTerminal</code> 接收到来自 <code>leadingTerminal</code> 的消息时，更新 <code>UITextField</code> 的 <code>text</code> 属性。</p>

<pre><code class="language-objectivec">RACSignal *valuesSignal = [channel.followingTerminal
    map:^(id value) {
        return value ?: nilValue;
    }];
[self rac_liftSelector:@selector(setValue:forKey:) withSignals:valuesSignal, [RACSignal return:key], nil];
</code></pre>

<p>这两件事情都是通过 <code>-rac_liftSelector:withSignals:</code> 方法来完成的，不过，我们不会在这篇文章中介绍这个方法。</p>

<h2 id="racchannel-与-kvo">RACChannel 与 KVO</h2>

<p><code>RACChannel</code> 不仅为 UIKit 组件提供了接口，还为键值观测提供了 <code>RACKVOChannel</code> 来高效地完成双向绑定；<code>RACKVOChannel</code> 是 <code>RACChannel</code> 的子类：</p>

<p><img src="https://img.nju520.me/2017-02-16-RACKVOChannel.png-1000width" alt="RACKVOChanne" /></p>

<p>在 <code>RACKVOChannel</code> 提供的接口中，我们一般都会使用 <code>RACChannelTo</code> 来观测某一个对象的对应属性，三个参数依次为对象、属性和默认值：</p>

<pre><code class="language-objectivec">RACChannelTerminal *integerChannel = RACChannelTo(self, integerProperty, @42);
</code></pre>

<p>而 <code>RACChannelTo</code> 是 <code>RACKVOChannel</code> 头文件中的一个宏，上面的表达式可以展开成为：</p>

<pre><code class="language-objectivec">RACChannelTerminal *integerChannel = [[RACKVOChannel alloc] initWithTarget:self keyPath:@"integerProperty" nilValue:@42][@"followingTerminal"];
</code></pre>

<p>该宏初始化了一个 <code>RACKVOChannel</code> 对象，并通过方括号的方式获取其中的 <code>followingTerminal</code>，这种获取类属性的方式是通过覆写以下的两个方法实现的：</p>

<pre><code class="language-objectivec">- (RACChannelTerminal *)objectForKeyedSubscript:(NSString *)key {
	RACChannelTerminal *terminal = [self valueForKey:key];
	return terminal;
}

- (void)setObject:(RACChannelTerminal *)otherTerminal forKeyedSubscript:(NSString *)key {
	RACChannelTerminal *selfTerminal = [self objectForKeyedSubscript:key];
	[otherTerminal subscribe:selfTerminal];
	[[selfTerminal skip:1] subscribe:otherTerminal];
}
</code></pre>

<p>又由于覆写了这两个方法，在 <code>-setObject:forKeyedSubscript:</code> 时会自动调用 <code>-subscribe:</code> 方法完成双向绑定，所以我们可以使用 <code>=</code> 来对两个 <code>RACKVOChannel</code> 进行双向绑定：</p>

<pre><code class="language-objectivec">RACChannelTo(view, property) = RACChannelTo(model, property);

[[RACKVOChannel alloc] initWithTarget:view keyPath:@"property" nilValue:nil][@"followingTerminal"] = [[RACKVOChannel alloc] initWithTarget:model keyPath:@"property" nilValue:nil][@"followingTerminal"];
</code></pre>

<p>以上的两种方式是完全等价的，它们都会在对方的属性更新时更新自己的属性。</p>

<p><img src="https://img.nju520.me/2017-02-16-RACChannelTo-Model-View.png-1000width" alt="RACChannelTo-Model-Vie" /></p>

<p>实现的方式其实与 <code>RACChannel</code> 差不多，这里不会深入到代码中进行介绍，与 <code>RACChannel</code> 的区别是，<code>RACKVOChannel</code> 并没有暴露出 <code>leadingTerminal</code> 而是 <code>followingTerminal</code>：</p>

<p><img src="https://img.nju520.me/2017-02-16-RACChannelTo-And-Property.png-1000width" alt="RACChannelTo-And-Property" /></p>

<h2 id="racchannel-实战">RACChannel 实战</h2>

<p>这一小节通过一个简单的例子来解释如何使用 <code>RACChannel</code> 进行双向数据绑定。</p>

<p><img src="https://img.nju520.me/2017-02-16-TextField-With-Channel.gif" alt="TextField-With-Channe" /></p>

<p>在整个视图上有两个 <code>UITextField</code>，我们想让这两个 <code>UITextField</code> <code>text</code> 的值相互绑定，在一个 <code>UITextField</code> 编辑时也改变另一个 <code>UITextField</code> 中的内容：</p>

<pre><code class="language-objectivec">@property (weak, nonatomic) IBOutlet UITextField *textField;
@property (weak, nonatomic) IBOutlet UITextField *anotherTextField;
</code></pre>

<p>实现的过程非常简单，分别获取两个 <code>UITextField</code> 的 <code>rac_newTextChannel</code> 属性，并让它们订阅彼此的内容：</p>

<pre><code class="language-objectivec">[self.textField.rac_newTextChannel subscribe:self.anotherTextField.rac_newTextChannel];
[self.anotherTextField.rac_newTextChannel subscribe:self.textField.rac_newTextChannel];
</code></pre>

<p>这样在使用两个文本输入框时就能达到预期的效果了，这是一个非常简单的例子，可以得到如下的结构图。</p>

<p><img src="https://img.nju520.me/2017-02-16-Two-UITextField-With-RACChannel.png-1000width" alt="Two-UITextField-With-RACChanne" /></p>

<p>两个 <code>UITextField</code> 通过 <code>RACChannel</code> 互相影响，在对方属性更新时同时更新自己的属性。</p>

<h2 id="总结">总结</h2>

<p><code>RACChannel</code> 非常适合于视图和模型之间的双向绑定，在对方的属性或者状态更新时及时通知自己，达到预期的效果；我们可以使用 ReactiveCocoa 中内置的很多与 <code>RACChannel</code> 有关的方法，来获取开箱即用的 <code>RACChannelTerminal</code>，当然也可以使用 <code>RACChannelTo</code> 通过 <code>RACKVOChannel</code> 来快速绑定类与类的属性。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://spin.atomicobject.com/2015/05/04/bi-directional-data-bindings-reactivecocoa/">Bi-directional Data Bindings in ReactiveCocoa with RACChannel</a></li>
  <li><a href="http://tech.meituan.com/ReactiveCocoaSignalFlow.html">ReactiveCocoa 核心元素与信号流</a></li>
</ul>

<blockquote>
  <p>Github Repo：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://nju520.me/racchannel</p>
</blockquote>

  ]]></description>
</item>

<item>
  <title>用于多播的 RACMulticastConnection</title>
  <link>//racconnection</link>
  <author>nju520</author>
  <pubDate>2017-02-15T15:21:01+08:00</pubDate>
  <guid>//racconnection</guid>
  <description><![CDATA[
  <p>ReactiveCocoa 中的信号信号在默认情况下都是冷的，每次有新的订阅者订阅信号时都会执行信号创建时传入的 block；这意味着对于任意一个订阅者，所需要的数据都会<strong>重新计算</strong>，这在大多数情况下都是开发者想看到的情况，但是这在信号中的 block 有副作用或者较为昂贵时就会有很多问题。</p>

<p><img src="https://img.nju520.me/2017-02-15-RACMulticastConnection.png-1000width" alt="RACMulticastConnection" /></p>

<p>我们希望有一种模型能够将冷信号转变成热信号，并在合适的时间触发，向所有的订阅者发送消息；而今天要介绍的 <code>RACMulticastConnection</code> 就是用于解决上述问题的。</p>

<h2 id="racmulticastconnection-简介">RACMulticastConnection 简介</h2>

<p><code>RACMulticastConnection</code> 封装了将一个信号的订阅分享给多个订阅者的思想，它的每一个对象都持有两个 <code>RACSignal</code>：</p>

<p><img src="https://img.nju520.me/2017-02-15-RACMulticastConnection-Interface.png-1000width" alt="RACMulticastConnection-Interface" /></p>

<p>一个是私有的源信号 <code>sourceSignal</code>，另一个是用于广播的信号 <code>signal</code>，其实是一个 <code>RACSubject</code> 对象，不过对外只提供 <code>RACSignal</code> 接口，用于使用者通过 <code>-subscribeNext:</code> 等方法进行订阅。</p>

<h2 id="racmulticastconnection-的初始化">RACMulticastConnection 的初始化</h2>

<p><code>RACMulticastConnection</code> 有一个非常简单的初始化方法 <code>-initWithSourceSignal:subject:</code>，不过这个初始化方法是私有的：</p>

<pre><code class="language-objectivec">- (instancetype)initWithSourceSignal:(RACSignal *)source subject:(RACSubject *)subject {
	self = [super init];

	_sourceSignal = source;
	_serialDisposable = [[RACSerialDisposable alloc] init];
	_signal = subject;

	return self;
}
</code></pre>

<p>在 <code>RACMulticastConnection</code> 的头文件的注释中，对它的初始化有这样的说明：</p>

<blockquote>
  <p>Note that you shouldn’t create RACMulticastConnection manually. Instead use -publish or -multicast:.</p>
</blockquote>

<p>我们不应该直接使用 <code>-initWithSourceSignal:subject:</code> 来初始化一个对象，我们应该通过 <code>RACSignal</code> 的实例方法初始化 <code>RACMulticastConnection</code> 实例。</p>

<pre><code class="language-objectivec">- (RACMulticastConnection *)publish {
	RACSubject *subject = [RACSubject subject];
	RACMulticastConnection *connection = [self multicast:subject];
	return connection;
}

- (RACMulticastConnection *)multicast:(RACSubject *)subject {
	RACMulticastConnection *connection = [[RACMulticastConnection alloc] initWithSourceSignal:self subject:subject];
	return connection;
}
</code></pre>

<p>这两个方法 <code>-publish</code> 和 <code>-multicast:</code> 都是对初始化方法的封装，并且都会返回一个 <code>RACMulticastConnection</code> 对象，传入的 <code>sourceSignal</code> 就是当前信号，<code>subject</code> 就是用于对外广播的 <code>RACSubject</code> 对象。</p>

<h2 id="racsignal-和-racmulticastconnection">RACSignal 和 RACMulticastConnection</h2>

<p>网络请求在客户端其实是一个非常昂贵的操作，也算是多级缓存中最慢的一级，在使用 ReactiveCocoa 处理业务需求中经常会遇到下面的情况：</p>

<pre><code class="language-objectivec">RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
    NSLog(@"Send Request");
    NSURL *url = [NSURL URLWithString:@"http://localhost:3000"];
    AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:url];
    NSString *URLString = [NSString stringWithFormat:@"/api/products/1"];
    NSURLSessionDataTask *task = [manager GET:URLString parameters:nil progress:nil
                                      success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) {
                                          [subscriber sendNext:responseObject];
                                          [subscriber sendCompleted];
                                      } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
                                          [subscriber sendError:error];
                                      }];
    return [RACDisposable disposableWithBlock:^{
        [task cancel];
    }];
}];

[requestSignal subscribeNext:^(id  _Nullable x) {
    NSLog(@"product: %@", x);
}];

[requestSignal subscribeNext:^(id  _Nullable x) {
    NSNumber *productId = [x objectForKey:@"id"];
    NSLog(@"productId: %@", productId);
}];
</code></pre>

<p>通过订阅发出网络请求的信号经常会被多次订阅，以满足不同 UI 组件更新的需求，但是以上代码却有非常严重的问题。</p>

<p><img src="https://img.nju520.me/2017-02-15-RACSignal-And-Subscribe.png-1000width" alt="RACSignal-And-Subscribe" /></p>

<p>每一次在 <code>RACSignal</code> 上执行 <code>-subscribeNext:</code> 以及类似方法时，都会发起一次新的网络请求，我们希望避免这种情况的发生。</p>

<p>为了解决上述问题，我们使用了 <code>-publish</code> 方法获得一个多播对象 <code>RACMulticastConnection</code>，更改后的代码如下：</p>

<pre><code class="language-objectivec">RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
    NSLog(@"Send Request");
    ...
}] publish];

[connection.signal subscribeNext:^(id  _Nullable x) {
    NSLog(@"product: %@", x);
}];
[connection.signal subscribeNext:^(id  _Nullable x) {
    NSNumber *productId = [x objectForKey:@"id"];
    NSLog(@"productId: %@", productId);
}];

[connection connect];
</code></pre>

<p>在这个例子中，我们使用 <code>-publish</code> 方法生成实例，订阅者不再订阅源信号，而是订阅 <code>RACMulticastConnection</code> 中的 <code>RACSubject</code> 热信号，最后通过 <code>-connect</code> 方法触发源信号中的任务。</p>

<p><img src="https://img.nju520.me/2017-02-15-RACSignal-RACMulticastConnection-Connect.png-1000width" alt="RACSignal-RACMulticastConnection-Connect" /></p>

<blockquote>
  <p>对于热信号不了解的读者，可以阅读这篇文章 <a href="https://github.com/nju520/iOS-Source-Code-Analyze/blob/master/contents/ReactiveObjC/RACSubject.md">『可变』的热信号 RACSubject</a>。</p>
</blockquote>

<h3 id="publish-和-multicast-方法">publish 和 multicast 方法</h3>

<p>我们再来看一下 <code>-publish</code> 和 <code>-multicast:</code> 这两个方法的实现：</p>

<pre><code class="language-objectivec">- (RACMulticastConnection *)publish {
	RACSubject *subject = [RACSubject subject];
	RACMulticastConnection *connection = [self multicast:subject];
	return connection;
}

- (RACMulticastConnection *)multicast:(RACSubject *)subject {
	RACMulticastConnection *connection = [[RACMulticastConnection alloc] initWithSourceSignal:self subject:subject];
	return connection;
}
</code></pre>

<p>当 <code>-publish</code> 方法调用时相当于向 <code>-multicast:</code> 传入了 <code>RACSubject</code>。</p>

<p><img src="https://img.nju520.me/2017-02-15-publish-and-multicast.png-1000width" alt="publish-and-multicast" /></p>

<p><code>-publish</code> 只是对 <code>-multicast:</code> 方法的简单封装，它们都是通过 <code>RACMulticastConnection</code> 私有的初始化方法 <code>-initWithSourceSignal:subject:</code> 创建一个新的实例。</p>

<p>在使用 <code>-multicast:</code> 方法时，传入的信号其实就是用于广播的信号；这个信号必须是一个 <code>RACSubject</code> 本身或者它的子类：</p>

<p><img src="https://img.nju520.me/2017-02-15-RACSubject - Subclasses.png-1000width" alt="RACSubject - Subclasses" /></p>

<p>传入 <code>-multicast:</code> 方法的一般都是 <code>RACSubject</code> 或者 <code>RACReplaySubject</code> 对象。</p>

<h3 id="订阅源信号的时间点">订阅源信号的时间点</h3>

<p>订阅 <code>connection.signal</code> 中的数据流时，其实只是向多播对象中的热信号 <code>RACSubject</code> 持有的数组中加入订阅者，而这时刚刚创建的 <code>RACSubject</code> 中并没有任何的消息。</p>

<p><img src="https://img.nju520.me/2017-02-15-SubscribeNext-To-RACSubject-Before-Connect.png-1000width" alt="SubscribeNext-To-RACSubject-Before-Connect" /></p>

<p>只有在调用 <code>-connect</code> 方法之后，<code>RACSubject</code> 才会<strong>订阅</strong>源信号 <code>sourceSignal</code>。</p>

<pre><code class="language-objectivec">- (RACDisposable *)connect {
	self.serialDisposable.disposable = [self.sourceSignal subscribe:_signal];
	return self.serialDisposable;
}
</code></pre>

<p>这时源信号的 <code>didSubscribe</code> 代码块才会执行，向 <code>RACSubject</code> 推送消息，消息向下继续传递到 <code>RACSubject</code> 所有的订阅者中。</p>

<p><img src="https://img.nju520.me/2017-02-15-Values-From-RACSignal-To-Subscribers.png-1000width" alt="Values-From-RACSignal-To-Subscribers" /></p>

<p><code>-connect</code> 方法通过 <code>-subscribe:</code> 实际上建立了 <code>RACSignal</code> 和 <code>RACSubject</code> 之间的连接，这种方式保证了 <code>RACSignal</code> 中的 <code>didSubscribe</code> 代码块只执行了一次。</p>

<p>所有的订阅者不再订阅原信号，而是订阅 <code>RACMulticastConnection</code> 持有的热信号 <code>RACSubject</code>，实现对冷信号的一对多传播。</p>

<p>在 <code>RACMulticastConnection</code> 中还有另一个用于连接 <code>RACSignal</code> 和 <code>RACSubject</code> 信号的 <code>-autoconnect</code> 方法：</p>

<pre><code class="language-objectivec">- (RACSignal *)autoconnect {
	__block volatile int32_t subscriberCount = 0;
	return [RACSignal
		createSignal:^(id&lt;RACSubscriber&gt; subscriber) {
			OSAtomicIncrement32Barrier(&amp;subscriberCount);
			RACDisposable *subscriptionDisposable = [self.signal subscribe:subscriber];
			RACDisposable *connectionDisposable = [self connect];

			return [RACDisposable disposableWithBlock:^{
				[subscriptionDisposable dispose];
				if (OSAtomicDecrement32Barrier(&amp;subscriberCount) == 0) {
					[connectionDisposable dispose];
				}
			}];
		}];
}
</code></pre>

<p>它保证了在 <code>-autoconnect</code> 方法返回的对象被第一次订阅时，就会建立源信号与热信号之间的连接。</p>

<h3 id="使用-racreplaysubject-订阅源信号">使用 RACReplaySubject 订阅源信号</h3>

<p>虽然使用 <code>-publish</code> 方法已经能够解决大部分问题了，但是在 <code>-connect</code> 方法调用之后才订阅的订阅者并不能收到消息。</p>

<p>如何才能保存 <code>didSubscribe</code> 执行过程中发送的消息，并在 <code>-connect</code> 调用之后也可以收到消息？这时，我们就要使用 <code>-multicast:</code> 方法和 <code>RACReplaySubject</code> 来完成这个需求了。</p>

<pre><code class="language-objectivec">RACSignal *sourceSignal = [RACSignal createSignal:...];
RACMulticastConnection *connection = [sourceSignal multicast:[RACReplaySubject subject]];
[connection.signal subscribeNext:^(id  _Nullable x) {
    NSLog(@"product: %@", x);
}];
[connection connect];
[connection.signal subscribeNext:^(id  _Nullable x) {
    NSNumber *productId = [x objectForKey:@"id"];
    NSLog(@"productId: %@", productId);
}];
</code></pre>

<p>除了使用上述的代码，也有一个更简单的方式创建包含 <code>RACReplaySubject</code> 对象的 <code>RACMulticastConnection</code>：</p>

<pre><code class="language-objectivec">RACSignal *signal = [[RACSignal createSignal:...] replay];
[signal subscribeNext:^(id  _Nullable x) {
    NSLog(@"product: %@", x);
}];
[signal subscribeNext:^(id  _Nullable x) {
    NSNumber *productId = [x objectForKey:@"id"];
    NSLog(@"productId: %@", productId);
}];
</code></pre>

<p><code>-replay</code> 方法和 <code>-publish</code> 差不多，只是内部封装的热信号不同，并在方法调用时就连接原信号：</p>

<pre><code class="language-objectivec">- (RACSignal *)replay {
	RACReplaySubject *subject = [RACReplaySubject subject];
	RACMulticastConnection *connection = [self multicast:subject];
	[connection connect];
	return connection.signal;
}
</code></pre>

<p>除了 <code>-replay</code> 方法，<code>RACSignal</code> 中还定义了与 <code>RACMulticastConnection</code> 中相关的其它 <code>-replay</code> 方法：</p>

<pre><code class="language-objectivec">- (RACSignal&lt;ValueType&gt; *)replay;
- (RACSignal&lt;ValueType&gt; *)replayLast;
- (RACSignal&lt;ValueType&gt; *)replayLazily;
</code></pre>

<p>三个方法都会在 <code>RACMulticastConnection</code> 初始化时传入一个 <code>RACReplaySubject</code> 对象，不过却有一点细微的差别：</p>

<p><img src="https://img.nju520.me/2017-02-15-Difference-Between-Replay-Methods.png-1000width" alt="Difference-Between-Replay-Methods" /></p>

<p>相比于 <code>-replay</code> 方法，<code>-replayLast</code> 方法生成的 <code>RACMulticastConnection</code> 中热信号的容量为 <code>1</code>：</p>

<pre><code class="language-objectivec">- (RACSignal *)replayLast {
	RACReplaySubject *subject = [RACReplaySubject replaySubjectWithCapacity:1];
	RACMulticastConnection *connection = [self multicast:subject];
	[connection connect];
	return connection.signal;
}
</code></pre>

<p>而 <code>replayLazily</code> 会在返回的信号被<strong>第一次订阅</strong>时，才会执行 <code>-connect</code> 方法：</p>

<pre><code class="language-objectivec">- (RACSignal *)replayLazily {
	RACMulticastConnection *connection = [self multicast:[RACReplaySubject subject]];
	return [RACSignal
		defer:^{
			[connection connect];
			return connection.signal;
		}];
}
</code></pre>

<h2 id="总结">总结</h2>

<p><code>RACMulticastConnection</code> 在处理冷热信号相互转换时非常好用，在 <code>RACSignal</code> 中也提供了很多将原有的冷信号通过 <code>RACMulticastConnection</code> 转换成热信号的方法。</p>

<p><img src="https://img.nju520.me/2017-02-15-RACMulticastConnection.png-1000width" alt="RACMulticastConnection" /></p>

<p>在遇到冷信号中的行为有副作用后者非常昂贵时，我们就可以使用这些方法将单播变成多播，提高执行效率，减少副作用。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://github.com/nju520/iOS-Source-Code-Analyze/blob/master/contents/ReactiveObjC/RACSubject.md">『可变』的热信号 RACSubject</a></li>
  <li><a href="http://williamzang.com/blog/2015/08/18/talk-about-reactivecocoas-cold-signal-and-hot-signal/">细说 ReactiveCocoa 的冷信号与热信号</a></li>
</ul>

<blockquote>
  <p>Github Repo：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://nju520.me/racconnection</p>
</blockquote>

  ]]></description>
</item>

<item>
  <title>优雅的 RACCommand</title>
  <link>//raccommand</link>
  <author>nju520</author>
  <pubDate>2017-02-10T20:35:23+08:00</pubDate>
  <guid>//raccommand</guid>
  <description><![CDATA[
  <p><code>RACCommand</code> 是一个在 ReactiveCocoa 中比较复杂的类，大多数使用 ReactiveCocoa 的人，尤其是初学者并不会经常使用它。</p>

<p>在很多情况下，虽然使用 <code>RACSignal</code> 和 <code>RACSubject</code> 就能解决绝大部分问题，但是 <code>RACCommand</code> 的使用会为我们带来巨大的便利，尤其是在与副作用相关的操作中。</p>

<p><img src="https://img.nju520.me/2017-02-10-What-is-RACCommand.png-1000width" alt="What-is-RACCommand" /></p>

<blockquote>
  <p>文章中不会讨论 <code>RACCommand</code> 中的并行执行问题，也就是忽略了 <code>allowsConcurrentExecution</code> 以及 <code>allowsConcurrentExecutionSubject</code> 的存在，不过它们确实在 <code>RACCommand</code> 中非常重要，这里只是为了减少不必要的干扰因素。</p>
</blockquote>

<h2 id="raccommand-简介">RACCommand 简介</h2>

<p>与前面几篇文章中介绍的 <code>RACSignal</code> 等元素不同，<code>RACCommand</code> 并不表示数据流，它只是一个继承自 <code>NSObject</code> 的类，但是它却可以用来创建和订阅用于响应某些事件的信号。</p>

<pre><code class="language-objectivec">@interface RACCommand&lt;__contravariant InputType, __covariant ValueType&gt; : NSObject

@end
</code></pre>

<p>它本身并不是一个 <code>RACStream</code> 或者 <code>RACSignal</code> 的子类，而是一个用于管理 <code>RACSignal</code> 的创建与订阅的类。</p>

<p>在 ReactiveCocoa 中的 FrameworkOverview 部分对 <code>RACCommand</code> 有这样的解释：</p>

<blockquote>
  <p>A command, represented by the RACCommand class, creates and subscribes to a signal in response to some action. This makes it easy to perform side-effecting work as the user interacts with the app.</p>
</blockquote>

<p>在用于与 UIKit 组件进行交互或者执行包含副作用的操作时，<code>RACCommand</code> 能够帮助我们更快的处理并且响应任务，减少编码以及工程的复杂度。</p>

<h2 id="raccommand-的初始化与执行">RACCommand 的初始化与执行</h2>

<p>在 <code>-initWithSignalBlock:</code> 方法的方法签名上，你可以看到在每次 <code>RACCommand</code> 初始化时都会传入一个类型为 <code>RACSignal&lt;ValueType&gt; * (^)(InputType _Nullable input)</code> 的 <code>signalBlock</code>：</p>

<pre><code class="language-objectivec">- (instancetype)initWithSignalBlock:(RACSignal&lt;ValueType&gt; * (^)(InputType _Nullable input))signalBlock;
</code></pre>

<p>输入为 <code>InputType</code> 返回值为 <code>RACSignal&lt;ValueType&gt; *</code>，而 <code>InputType</code> 也就是在调用 <code>-execute:</code> 方法时传入的对象：</p>

<pre><code class="language-objectivec">- (RACSignal&lt;ValueType&gt; *)execute:(nullable InputType)input;
</code></pre>

<p>这也就是 <code>RACCommand</code> 将外部变量（或『副作用』）传入 ReactiveCocoa 内部的方法，你可以理解为 <code>RACCommand</code> 将外部的变量 <code>InputType</code> 转换成了使用 <code>RACSignal</code> 包裹的 <code>ValueType</code> 对象。</p>

<p><img src="https://img.nju520.me/2017-02-10-Execute-For-RACCommand.png-1000width" alt="Execute-For-RACCommand" /></p>

<p>我们以下面的代码为例，先来看一下 <code>RACCommand</code> 是如何工作的：</p>

<pre><code class="language-objectivec">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(NSNumber * _Nullable input) {
    return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
        NSInteger integer = [input integerValue];
        for (NSInteger i = 0; i &lt; integer; i++) {
            [subscriber sendNext:@(i)];
        }
        [subscriber sendCompleted];
        return nil;
    }];
}];
[[command.executionSignals switchToLatest] subscribeNext:^(id  _Nullable x) {
    NSLog(@"%@", x);
}];

[command execute:@1];
[RACScheduler.mainThreadScheduler afterDelay:0.1
                                    schedule:^{
                                        [command execute:@2];
                                    }];
[RACScheduler.mainThreadScheduler afterDelay:0.2
                                    schedule:^{
                                        [command execute:@3];
                                    }];
</code></pre>

<p>首先使用 <code>-initWithSignalBlock:</code> 方法创建一个 <code>RACCommand</code> 的对象，传入一个类型为 <code>InputType -&gt; RACSignal&lt;ValueType&gt;</code> 的 block，这个信号根据输入会发送对应次数的消息，如果运行上面的代码，会打印出：</p>

<pre><code class="language-objectivec">0
0
1
0
1
2
</code></pre>

<blockquote>
  <p><code>-switchToLatest</code> 方法只能操作<strong>信号的信号</strong>。</p>
</blockquote>

<p>每次 <code>executionSignals</code> 中发送了新的信号时，<code>switchToLatest</code> 方法返回的信号都会订阅这个最新的信号，这里也就保证了每次都会打印出最新的信号中的值。</p>

<p><img src="https://img.nju520.me/2017-02-10-Multiple-Executes.png-1000width" alt="Multiple-Executes" /></p>

<p>在上面代码中还有最后一个问题需要回答，为什么要使用 <code>RACScheduler.mainThreadScheduler</code> 延迟调用之后的 <code>-execute:</code> 方法？由于在默认情况下 <code>RACCommand</code> 都是不支持并发操作的，需要在上一次命令执行之后才可以发送下一次操作，否则就会返回错误信号 <code>RACErrorSignal</code>，这些错误可以通过订阅 <code>command.errors</code> 获得。</p>

<p>如果使用如下的方式执行几次 <code>-execute:</code> 方法：</p>

<pre><code class="language-objectivec">[command execute:@1];
[command execute:@2];
[command execute:@3];
</code></pre>

<p>笔者相信，不出意外的话，你只能在控制台中看到输出 <code>0</code>。</p>

<h3 id="最重要的内部信号">最重要的内部『信号』</h3>

<p><code>RACCommand</code> 中最重要的内部『信号』就是 <code>addedExecutionSignalsSubject</code>：</p>

<pre><code class="language-objectivec">@property (nonatomic, strong, readonly) RACSubject *addedExecutionSignalsSubject;
</code></pre>

<p>这个 <code>RACSubject</code> 对象通过各种操作衍生了几乎所有 <code>RACCommand</code> 中的其他信号，我们会在下一节中具体介绍；</p>

<p>既然 <code>addedExecutionSignalsSubject</code> 是一个 <code>RACSubject</code>，它不能在创建时预设好对订阅者发送的消息，它会在哪里接受数据并推送给订阅者呢？答案就在 <code>-execute:</code> 方法中：</p>

<pre><code class="language-objectivec">- (RACSignal *)execute:(id)input {
	BOOL enabled = [[self.immediateEnabled first] boolValue];
	if (!enabled) {
		NSError *error = [NSError errorWithDomain:RACCommandErrorDomain code:RACCommandErrorNotEnabled userInfo:@{
			NSLocalizedDescriptionKey: NSLocalizedString(@"The command is disabled and cannot be executed", nil),
			RACUnderlyingCommandErrorKey: self
		}];

		return [RACSignal error:error];
	}

	RACSignal *signal = self.signalBlock(input);
	RACMulticastConnection *connection = [[signal
		subscribeOn:RACScheduler.mainThreadScheduler]
		multicast:[RACReplaySubject subject]];

	[self.addedExecutionSignalsSubject sendNext:connection.signal];

	[connection connect];
	return [connection.signal setNameWithFormat:@"%@ -execute: %@", self, RACDescription(input)];
}
</code></pre>

<p>在方法中这里你也能看到连续几次执行 <code>-execute:</code> 方法不能成功的原因：每次执行这个方法时，都会从另一个信号 <code>immediateEnabled</code> 中读取是否能执行当前命令的 <code>BOOL</code> 值，如果不可以执行的话，就直接返回 <code>RACErrorSignal</code>。</p>

<p><img src="https://img.nju520.me/2017-02-10-Execute-on-RACCommand.png-1000width" alt="Execute-on-RACCommand" /></p>

<blockquote>
  <p><code>-execute:</code> 方法是唯一一个为 <code>addedExecutionSignalsSubject</code> 生产信息的方法。</p>
</blockquote>

<p>在执行 <code>signalBlock</code> 返回一个 <code>RACSignal</code> 之后，会将当前信号包装成一个 <code>RACMulticastConnection</code>，然后调用 <code>-sendNext:</code> 方法发送到 <code>addedExecutionSignalsSubject</code> 上，执行 <code>-connect</code> 方法订阅原有的信号，最后返回。</p>

<h3 id="复杂的初始化">复杂的初始化</h3>

<p>与简单的 <code>-execute:</code> 方法相比，<code>RACCommand</code> 的初始化方法就复杂多了，虽然我们在方法中传入了 <code>signalBlock</code>，但是 <code>-initWithEnabled:signalBlock:</code> 方法只是对这个 block 进行了简单的 <code>copy</code>，真正使用这个 block 的还是上一节中的 <code>-execute:</code> 方法中。</p>

<p>由于 <code>RACCommand</code> 在初始化方法中初始化了七个高阶信号，它的实现非常复杂：</p>

<pre><code class="language-objectivec">- (instancetype)initWithEnabled:(RACSignal *)enabledSignal signalBlock:(RACSignal&lt;id&gt; * (^)(id input))signalBlock {
	self = [super init];

	_addedExecutionSignalsSubject = [RACSubject new];
	_signalBlock = [signalBlock copy];

	_executionSignals = ...;
	_errors = ...;
	RACSignal *immediateExecuting = ...;
	_executing = ...;
	RACSignal *moreExecutionsAllowed = ...;
	_immediateEnabled =...;
	_enabled = ...;

	return self;
}
</code></pre>

<p>这一小节并不能完全介绍全部的七个信号的实现，只会介绍其中的 <code>immediateExecuting</code> 和 <code>moreExecutionsAllowed</code> 两个临时信号，剩下的信号都会在下一节中分析。</p>

<h4 id="表示当前有操作执行的信号">表示当前有操作执行的信号</h4>

<p>首先是 <code>immediateExecuting</code> 信号：</p>

<pre><code class="language-objectivec">RACSignal *immediateExecuting = [[[[self.addedExecutionSignalsSubject
    flattenMap:^(RACSignal *signal) {
        return [[[signal
            catchTo:[RACSignal empty]]
            then:^{
                return [RACSignal return:@-1];
            }]
            startWith:@1];
    }]
    scanWithStart:@0 reduce:^(NSNumber *running, NSNumber *next) {
        return @(running.integerValue + next.integerValue);
    }]
    map:^(NSNumber *count) {
        return @(count.integerValue &gt; 0);
    }]
    startWith:@NO];
</code></pre>

<p><code>immediateExecuting</code> 是一个用于表示当前是否有任务执行的信号，如果输入的 <code>addedExecutionSignalsSubject</code> 等价于以下的信号：</p>

<pre><code class="language-objectivec">[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
    [subscriber sendNext:[RACSignal error:[NSError errorWithDomain:@"Error" code:1 userInfo:nil]]];
    [subscriber sendNext:[RACSignal return:@1]];
    [subscriber sendNext:[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
        [RACScheduler.mainThreadScheduler afterDelay:1
                                            schedule:^
         {
             [subscriber sendCompleted];
         }];
        return nil;
    }]];
    [subscriber sendNext:[RACSignal return:@3]];
    [subscriber sendCompleted];
    return nil;
}];
</code></pre>

<blockquote>
  <p>在本文的所有章节中都会假设输入的 <code>addedExecutionSignalsSubject</code> 信号跟上面的代码返回的完全相同。</p>
</blockquote>

<p>那么，最后生成的高阶信号 <code>immediateExecuting</code> 如下：</p>

<p><img src="https://img.nju520.me/2017-02-10-immediateExecuting-Signal-in-RACCommand.png-1000width" alt="immediateExecuting-Signal-in-RACCommand" /></p>

<ol>
  <li><code>-catchTo:</code> 将所有的错误转换成 <code>RACEmptySignal</code> 信号；</li>
  <li><code>-flattenMap:</code> 将每一个信号的开始和结束的时间点转换成 <code>1</code> 和 <code>-1</code> 两个信号；</li>
  <li><code>-scanWithStart:reduce:</code> 从 <code>0</code> 开始累加原有的信号；</li>
  <li><code>-map:</code> 将大于 <code>1</code> 的信号转换为 <code>@YES</code>；</li>
  <li><code>-startWith:</code> 在信号序列最前面加入 <code>@NO</code>，表示在最开始时，没有任何动作在执行。</li>
</ol>

<p><code>immediateExecuting</code> 使用几个 <code>RACSignal</code> 的操作成功将原有的信号流转换成了表示是否有操作执行的信号流。</p>

<h4 id="表示是否允许更多操作执行的信号">表示是否允许更多操作执行的信号</h4>

<p>相比于 <code>immediateExecuting</code> 信号的复杂，<code>moreExecutionsAllowed</code> 就简单多了：</p>

<pre><code class="language-objectivec">RACSignal *moreExecutionsAllowed = [RACSignal
    if:[self.allowsConcurrentExecutionSubject startWith:@NO]
    then:[RACSignal return:@YES]
    else:[immediateExecuting not]];
</code></pre>

<p>因为文章中不准备介绍与并发执行有关的内容，所以这里的 <code>then</code> 语句永远不会执行，既然 <code>RACCommand</code> 不支持并行操作，那么这段代码就非常好理解了，当前 <code>RACCommand</code> 能否执行操作就是 <code>immediateExecuting</code> 取反：</p>

<p><img src="https://img.nju520.me/2017-02-10-MoreExecutionAllowed-Signal.png-1000width" alt="MoreExecutionAllowed-Signa" /></p>

<p>到这里所有初始化方法中的临时信号就介绍完了，在下一节中会继续介绍初始化方法中的其它高阶信号。</p>

<h2 id="raccommand-接口中的高阶信号">RACCommand 接口中的高阶信号</h2>

<p>每一个 <code>RACCommand</code> 对象中都管理着多个信号，它在接口中暴露出的四个信号是这一节关注的重点：</p>

<p><img src="https://img.nju520.me/2017-02-10-RACCommand-Interface.png-1000width" alt="RACCommand-Interface" /></p>

<p>这一小节会按照顺序图中从上到下的顺序介绍 <code>RACCommand</code> 接口中暴露出来的信号，同时会涉及一些为了生成这些信号的中间产物。</p>

<h3 id="executionsignals">executionSignals</h3>

<p><code>executionSignals</code> 是 <code>RACCommand</code> 中最重要的信号；从类型来看，它是一个<strong>包含信号的信号</strong>，在每次执行 <code>-execute:</code> 方法时，最终都会向 <code>executionSignals</code> 中传入一个最新的信号。</p>

<p>虽然它最重要，但是<code>executionSignals</code> 是这个几个高阶信号中实现最简单的：</p>

<pre><code class="language-objectivec">_executionSignals = [[[self.addedExecutionSignalsSubject
    map:^(RACSignal *signal) {
        return [signal catchTo:[RACSignal empty]];
    }]
    deliverOn:RACScheduler.mainThreadScheduler]
    setNameWithFormat:@"%@ -executionSignals", self];
</code></pre>

<p>它只是将信号中的所有的错误 <code>NSError</code> 转换成了 <code>RACEmptySignal</code> 对象，并派发到主线程上。</p>

<p><img src="https://img.nju520.me/2017-02-10-Execution-Signals.png-1000width" alt="Execution-Signals" /></p>

<p>如果你只订阅了 <code>executionSignals</code>，那么其实你不会收到任何的错误，所有的错误都会以 <code>-sendNext:</code> 的形式被发送到 <code>errors</code> 信号中，这会在后面详细介绍。</p>

<h3 id="executing">executing</h3>

<p><code>executing</code> 是一个表示当前是否有任务执行的信号，这个信号使用了在上一节中介绍的临时变量作为数据源：</p>

<pre><code class="language-objectivec">_executing = [[[[[immediateExecuting
    deliverOn:RACScheduler.mainThreadScheduler]
    startWith:@NO]
    distinctUntilChanged]
    replayLast]
    setNameWithFormat:@"%@ -executing", self];
</code></pre>

<p>这里对 <code>immediateExecuting</code> 的变换还是非常容易理解的：</p>

<p><img src="https://img.nju520.me/2017-02-10-Executing-Signal.png-1000width" alt="Executing-Signa" /></p>

<p>最后的 <code>replayLast</code> 方法将原有的信号变成了容量为 <code>1</code> 的 <code>RACReplaySubject</code> 对象，这样在每次有订阅者订阅 <code>executing</code> 信号时，都只会发送最新的状态，因为订阅者并不关心过去的 <code>executing</code> 的值。</p>

<h3 id="enabled">enabled</h3>

<p><code>enabled</code> 信号流表示当前的命令是否可以再次被执行，也就是 <code>-execute:</code> 方法能否可以成功执行新的任务；该信号流依赖于另一个私有信号 <code>immediateEnabled</code>：</p>

<pre><code class="language-objectivec">RACSignal *enabledSignal = [RACSignal return:@YES];

_immediateEnabled = [[[[RACSignal
    combineLatest:@[ enabledSignal, moreExecutionsAllowed ]]
    and]
    takeUntil:self.rac_willDeallocSignal]
    replayLast];
</code></pre>

<p>虽然这个信号的实现比较简单，不过它同时与三个信号有关，<code>enabledSignal</code>、<code>moreExecutionsAllowed</code> 以及 <code>rac_willDeallocSignal</code>：</p>

<p><img src="https://img.nju520.me/2017-02-10-Immediate-Enabled-Signal.png-1000width" alt="Immediate-Enabled-Signa" /></p>

<p>虽然图中没有体现出方法 <code>-takeUntil:self.rac_willDeallocSignal</code> 的执行，不过你需要知道，这个信号在当前 <code>RACCommand</code> 执行 <code>dealloc</code> 之后就不会再发出任何消息了。</p>

<p>而 <code>enabled</code> 信号其实与 <code>immediateEnabled</code> 相差无几：</p>

<pre><code class="language-objectivec">_enabled = [[[[[self.immediateEnabled
    take:1]
    concat:[[self.immediateEnabled skip:1] deliverOn:RACScheduler.mainThreadScheduler]]
    distinctUntilChanged]
    replayLast]
    setNameWithFormat:@"%@ -enabled", self];
</code></pre>

<p>从名字你可以看出来，<code>immediateEnabled</code> 在每次原信号发送消息时都会重新计算，而 <code>enabled</code> 调用了 <code>-distinctUntilChanged</code> 方法，所以如果连续几次值相同就不会再次发送任何消息。</p>

<p>除了调用 <code>-distinctUntilChanged</code> 的区别之外，你可以看到 <code>enabled</code> 信号在最开始调用了 <code>-take:</code>和 <code>-concat:</code> 方法：</p>

<pre><code class="language-objectivec">[[self.immediateEnabled
		take:1]
		concat:[[self.immediateEnabled skip:1] deliverOn:RACScheduler.mainThreadScheduler]]
</code></pre>

<p>虽然序列并没有任何的变化，但是在这种情况下，<code>enabled</code> 信号流中的第一个值会在订阅线程上到达，剩下的所有的值都会在主线程上派发；如果你知道，在一般情况下，我们都会使用 <code>enabled</code> 信号来控制 UI 的改变（例如 <code>UIButton</code>），相信你就会明白这么做的理由了。</p>

<h3 id="errors">errors</h3>

<p>错误信号是 <code>RACCommand</code> 中比较简单的信号；为了保证 <code>RACCommand</code> 对此执行 <code>-execute:</code> 方法也可以继续运行，我们只能将所有的错误以其它的形式发送到 <code>errors</code> 信号中，防止向 <code>executionSignals</code> 发送错误信号后，<code>executionSignals</code> 信号就会中止的问题。</p>

<p>我们使用如下的方式创建 <code>errors</code> 信号：</p>

<pre><code class="language-objectivec">RACMulticastConnection *errorsConnection = [[[self.addedExecutionSignalsSubject
    flattenMap:^(RACSignal *signal) {
        return [[signal
            ignoreValues]
            catch:^(NSError *error) {
                return [RACSignal return:error];
            }];
    }]
    deliverOn:RACScheduler.mainThreadScheduler]
    publish];

_errors = [errorsConnection.signal setNameWithFormat:@"%@ -errors", self];
[errorsConnection connect];
</code></pre>

<p>信号的创建过程是把所有的错误消息重新打包成 <code>RACErrorSignal</code> 并在主线程上进行派发：</p>

<p><img src="https://img.nju520.me/2017-02-10-Errors-Signals.png-1000width" alt="Errors-Signals" /></p>

<p>使用者只需要调用 <code>-subscribeNext:</code> 就可以从这个信号中获取所有执行过程中发生的错误。</p>

<h2 id="raccommand-的使用">RACCommand 的使用</h2>

<p><code>RACCommand</code> 非常适合封装网络请求，我们可以使用下面的代码封装一个网络请求：</p>

<pre><code class="language-objectivec">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id  _Nullable input) {
    return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
        NSURL *url = [NSURL URLWithString:@"http://localhost:3000"];
        AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:url];
        NSString *URLString = [NSString stringWithFormat:@"/api/products/%@", input ?: @1];
        NSURLSessionDataTask *task = [manager GET:URLString parameters:nil progress:nil
             success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) {
                 [subscriber sendNext:responseObject];
                 [subscriber sendCompleted];
             } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
                 [subscriber sendError:error];
             }];
        return [RACDisposable disposableWithBlock:^{
            [task cancel];
        }];
    }];
}];
</code></pre>

<p>上面的 <code>RACCommand</code> 对象可以通过 <code>-execute:</code> 方法执行，同时，订阅 <code>executionSignals</code> 以及 <code>errors</code> 来获取网络请求的结果。</p>

<pre><code class="language-objectivec">[[command.executionSignals switchToLatest] subscribeNext:^(id  _Nullable x) {
    NSLog(@"%@", x);
}];
[command.errors subscribeNext:^(NSError * _Nullable x) {
    NSLog(@"%@", x);
}];
[command execute:@1];
</code></pre>

<p>向方法 <code>-execute:</code> 中传入了 <code>@1</code> 对象，从服务器中获取了 <code>id = 1</code> 的商品对象；当然，我们也可以传入不同的 <code>id</code> 来获取不同的模型，所有的网络请求以及 JSON 转换模型的逻辑都可以封装到这个 <code>RACCommand</code> 的 block 中，外界只是传入一个 <code>id</code>，最后就从 <code>executionSignals</code> 信号中获取了开箱即用的对象。</p>

<h2 id="总结">总结</h2>

<p>使用 <code>RACCommand</code> 能够优雅地将包含副作用的操作和与副作用无关的操作分隔起来；整个 <code>RACCommand</code> 相当于一个黑箱，从 <code>-execute:</code> 方法中获得输入，最后以向信号发送消息的方式，向订阅者推送结果。</p>

<p><img src="https://img.nju520.me/2017-02-10-RACCommand-Side-Effect.png-1000width" alt="RACCommand-Side-Effect" /></p>

<p>这种执行任务的方式就像是一个函数，根据输入的不同，有着不同的输出，非常适合与 UI、网络操作的相关的任务，这也是 <code>RACCommand</code> 的设计的优雅之处。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="http://codeblog.shape.dk/blog/2013/12/05/reactivecocoa-essentials-understanding-and-using-raccommand/">ReactiveCocoa Essentials: Understanding and Using RACCommand</a></li>
  <li><a href="https://halfrost.com/reactivecocoa_raccommand/">ReactiveCocoa 中 RACCommand 底层实现分析</a></li>
</ul>

<blockquote>
  <p>Github Repo：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://nju520.me/raccommand</p>
</blockquote>

  ]]></description>
</item>

<item>
  <title>『可变』的热信号 RACSubject</title>
  <link>//racsubject</link>
  <author>nju520</author>
  <pubDate>2017-02-07T19:46:08+08:00</pubDate>
  <guid>//racsubject</guid>
  <description><![CDATA[
  <p>在 ReactiveCocoa 中除了不可变的信号 <code>RACSignal</code>，也有用于桥接非 RAC 代码到 ReactiveCocoa 世界的『可变』信号 <code>RACSubject</code>。</p>

<p><img src="https://img.nju520.me/2017-02-07-“Mutable” RACSignal — RACSubject.png-1000width" alt="“Mutable” RACSignal — RACSubject" /></p>

<p><code>RACSubject</code> 到底是什么？根据其字面意思，可以将它理解为一个可以订阅的主题，我们在订阅主题之后，向主题发送新的消息时，<strong>所有</strong>的订阅者都会接收到最新的消息。</p>

<p>但是这么解释确实有点晦涩，也不易于理解，ReactiveCocoa 团队对 <code>RACSubject</code> 的解释是，<code>RACSubject</code> 其实就是一个可以<code>手动</code>控制的信号（感觉这么解释更难理解了）。</p>

<blockquote>
  <p>A subject, represented by the RACSubject class, is a signal that can be manually controlled.</p>
</blockquote>

<h2 id="racsubject-简介">RACSubject 简介</h2>

<p><code>RACSubject</code> 是 <code>RACSignal</code> 的子类，与 <code>RACSignal</code> 以及 <code>RACSequence</code> 有着众多的类簇不同，<code>RACSubject</code> 在整个工程中并没有多少子类；不过，在大多数情况下，我们也只会使用 <code>RACSubject</code> 自己或者 <code>RACReplaySubject</code>。</p>

<p><img src="https://img.nju520.me/2017-02-07-RACSubject - Subclasses.png-1000width" alt="RACSubject - Subclasses" /></p>

<p>相比于 <code>RACSignal</code> 丰富的头文件 ，<code>RACSubject</code> 对外的接口并没有提供太多的方法：</p>

<pre><code class="language-objectivec">@interface RACSubject : RACSignal &lt;RACSubscriber&gt;

+ (instancetype)subject;

@end
</code></pre>

<p>唯一提供的接口就是用于返回一个新实例的 <code>+subject</code> 方法；除此之外，在笔者看来它与 <code>RACSignal</code> 最大的不同就是：<code>RACSubject</code> 实现了 <code>RACSubscriber</code> 协议，也就是下面的这些方法：</p>

<pre><code class="language-objectivec">@protocol RACSubscriber &lt;NSObject&gt;
@required

- (void)sendNext:(nullable id)value;
- (void)sendError:(nullable NSError *)error;
- (void)sendCompleted;
- (void)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable;

@end
</code></pre>

<p>我们并不能在一个 <code>RACSignal</code> 对象上执行这些方法，只能在创建信号的 block 里面向遵循 <code>RACSubscriber</code> 协议的对象发送新的值或者错误，这也是 <code>RACSubject</code> 和父类最大的不同：在 <code>RACSubject</code> 实例初始化之后，也可以通过这个实例向所有的订阅者发送消息。</p>

<h2 id="冷信号与热信号">冷信号与热信号</h2>

<p>提到 <code>RACSubject</code> 就不得不提 ReactiveCocoa 中的另一对概念，冷信号和热信号。</p>

<blockquote>
  <p>其实解释这两者之间区别的文章已经很多了，我相信各位读者能找到很多的资料，在这里就简单介绍一下冷热信号的概念，如果想要了解更多的内容可以在 <a href="#references">References</a> 中找到更多的文章。</p>
</blockquote>

<p>对于冷热信号概念，我们借用 Rx 中的描述：</p>

<p><img src="https://img.nju520.me/2017-02-07-Hot-Signal-And-Cold-Signal.png-1000width" alt="Hot-Signal-And-Cold-Signa" /></p>

<blockquote>
  <p>Cold signal is sequences that are passive and start producing notifications on request (when subscribed to), and hot signal is sequences that are active and produce notifications regardless of subscriptions. —- <a href="http://www.introtorx.com/content/v1.0.10621.0/14_HotAndColdObservables.html">Hot and Cold observables</a></p>
</blockquote>

<p>冷信号是被动的，只会在被订阅时向订阅者发送通知；热信号是主动的，它会在任意时间发出通知，与订阅者的订阅时间无关。</p>

<p>也就是说冷信号所有的订阅者会在订阅时收到完全相同的序列；而订阅热信号之后，只会收到在订阅之后发出的序列。</p>

<blockquote>
  <p>热信号的订阅者能否收到消息取决于订阅的时间。</p>
</blockquote>

<p>热信号在我们生活中有很多的例子，比如订阅杂志时并不会把之前所有的期刊都送到我们手中，只会接收到订阅之后的期刊；而对于冷信号的话，举一个不恰当的例子，每一年的高考考生在『订阅』高考之后，收到往年所有的试卷，并在高考之后会取消订阅。</p>

<h2 id="热信号-racsubject">热信号 RACSubject</h2>

<p>在 ReactiveCocoa 中，我们使用 <code>RACSignal</code> 来表示冷信号，也就是每一个订阅者在订阅信号时都会收到完整的序列；<code>RACSubject</code> 用于表示热信号，订阅者接收到多少值取决于它订阅的时间。</p>

<p>前面的文章中已经对 <code>RACSignal</code> 冷信号有了很多的介绍，这里也就不会多说了；这一小节主要的内容是想通过一个例子，简单展示 <code>RACSubject</code> 的订阅者收到的内容与订阅时间的关系：</p>

<pre><code class="language-objectivec">RACSubject *subject = [RACSubject subject];

// Subscriber 1
[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@"1st Sub: %@", x);
}];
[subject sendNext:@1];

// Subscriber 2
[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@"2nd Sub: %@", x);
}];
[subject sendNext:@2];

// Subscriber 3
[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@"3rd Sub: %@", x);
}];
[subject sendNext:@3];
[subject sendCompleted];
</code></pre>

<p>这里以图的方式来展示整个订阅与订阅者接收消息的过程：</p>

<p><img src="https://img.nju520.me/2017-02-07-Track-RACSubject-Subscription-Process.png-1000width" alt="Track-RACSubject-Subscription-Process" /></p>

<p>从图中我们可以清楚的看到，几个订阅者根据<strong>订阅时间</strong>的不同收到了不同的数字序列，<code>RACSubject</code> 是<strong>时间相关</strong>的，它在发送消息时只会向已订阅的订阅者推送消息。</p>

<h2 id="racsubject-的实现">RACSubject 的实现</h2>

<p><code>RACSubject</code> 的实现并不复杂，它『可变』的特性都来源于持有的订阅者数组 <code>subscribers</code>，在每次执行 <code>subscribeNext:error:completed:</code> 一类便利方法时，都会将传入的 <code>id&lt;RACSubscriber&gt;</code> 对象加入数组：</p>

<pre><code class="language-objectivec">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber {
	RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];
	subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];

	NSMutableArray *subscribers = self.subscribers;
	@synchronized (subscribers) {
		[subscribers addObject:subscriber];
	}

	[disposable addDisposable:[RACDisposable disposableWithBlock:^{
		@synchronized (subscribers) {
			NSUInteger index = [subscribers indexOfObjectWithOptions:NSEnumerationReverse passingTest:^ BOOL (id&lt;RACSubscriber&gt; obj, NSUInteger index, BOOL *stop) {
				return obj == subscriber;
			}];

			if (index != NSNotFound) [subscribers removeObjectAtIndex:index];
		}
	}]];

	return disposable;
}
</code></pre>

<p>订阅的过程分为三个部分：</p>

<ol>
  <li>初始化一个 <code>RACPassthroughSubscriber</code> 实例；</li>
  <li>将 <code>subscriber</code> 加入 <code>RACSubject</code> 持有的数组中；</li>
  <li>创建一个 <code>RACDisposable</code> 对象，在当前 <code>subscriber</code> 销毁时，将自身从数组中移除。</li>
</ol>

<p><img src="https://img.nju520.me/2017-02-07-Send-Subscibe-to-RACSubject.png-1000width" alt="Send-Subscibe-to-RACSubject" /></p>

<p><code>-subscribe:</code> 将所有遵循 <code>RACSubscriber</code> 协议的对象全部加入当前 <code>RACSubject</code> 持有的数组 <code>subscribers</code> 中。</p>

<p>在上一节的例子中，我们能对 <code>RACSubject</code> 发送 <code>-sendNext:</code> 等消息也都取决于它实现了 <code>RACSubscriber</code> 协议：</p>

<pre><code class="language-objectivec">- (void)sendNext:(id)value {
	[self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) {
		[subscriber sendNext:value];
	}];
}

- (void)sendError:(NSError *)error {
	[self.disposable dispose];

	[self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) {
		[subscriber sendError:error];
	}];
}

- (void)sendCompleted {
	[self.disposable dispose];

	[self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) {
		[subscriber sendCompleted];
	}];
}
</code></pre>

<p><code>RACSubject</code> 会在自身接受到这些方法时，下发给持有的全部的 <code>subscribers</code>。</p>

<p><img src="https://img.nju520.me/2017-02-07-Send-Messages-to-RACSubject.png-1000width" alt="Send-Messages-to-RACSubject" /></p>

<p>代码中的 <code>-enumerateSubscribersUsingBlock:</code> 只是一个使用 <code>for</code> 循环遍历 <code>subscribers</code> 的安全方法：</p>

<pre><code class="language-objectivec">- (void)enumerateSubscribersUsingBlock:(void (^)(id&lt;RACSubscriber&gt; subscriber))block {
	NSArray *subscribers;
	@synchronized (self.subscribers) {
		subscribers = [self.subscribers copy];
	}

	for (id&lt;RACSubscriber&gt; subscriber in subscribers) {
		block(subscriber);
	}
}
</code></pre>

<p><code>RACSubject</code> 就是围绕一个 <code>NSMutableArray</code> 数组实现的，实现还是非常简单的，只是在需要访问 <code>subscribers</code> 的方法中使用 <code>@synchronized</code> 避免线程竞争。</p>

<pre><code class="language-objectivec">@interface RACSubject ()

@property (nonatomic, strong, readonly) NSMutableArray *subscribers;

@end
</code></pre>

<p><code>RACSubject</code> 提供的初始化类方法 <code>+subject</code> 也只是初始化了几个成员变量：</p>

<pre><code class="language-objectivec">+ (instancetype)subject {
	return [[self alloc] init];
}

- (instancetype)init {
	self = [super init];
	if (self == nil) return nil;

	_disposable = [RACCompoundDisposable compoundDisposable];
	_subscribers = [[NSMutableArray alloc] initWithCapacity:1];

	return self;
}
</code></pre>

<p>至此，对于 <code>RACSubject</code> 的分析就结束了，接下来会分析更多的子类。</p>

<h2 id="racbehaviorsubject-与-racreplaysubject">RACBehaviorSubject 与 RACReplaySubject</h2>

<p>这一节会介绍 <code>RACSubject</code> 的两个子类 <code>RACBehaviorSubject</code> 和 <code>RACReplaySubject</code>，前者在订阅时会向订阅者发送最新的消息，后者在订阅之后<strong>可以</strong>重新发送之前的<strong>所有</strong>消息序列。</p>

<h3 id="racbehaviorsubject">RACBehaviorSubject</h3>

<p>先来介绍两者中实现较简单的 <code>RACBehaviorSubject</code>，它在内部会保存一个 <code>currentValue</code> 对象，也就是最后一次发送的消息：</p>

<pre><code class="language-objectivec">@interface RACBehaviorSubject ()

@property (nonatomic, strong) id currentValue;

@end
</code></pre>

<p>在每次执行 <code>-sendNext:</code> 时，都会对 <code>RACBehaviorSubject</code> 中保存的 <code>currentValue</code> 进行更新，并使用父类的 <code>-sendNext:</code> 方法，向所有的订阅者发送最新的消息：</p>

<pre><code class="language-objectivec">- (void)sendNext:(id)value {
	@synchronized (self) {
		self.currentValue = value;
		[super sendNext:value];
	}
}
</code></pre>

<p><code>RACBehaviorSubject</code> 最重要的特性就是在订阅时，向最新的订阅者发送之前的消息，这是通过覆写 <code>-subscribe:</code> 方法实现的。</p>

<p>在调用子类的 <code>-subscribe:</code> 方法之后，会在 <code>subscriber</code> 对象上执行 <code>-sendNext:</code> 方法：</p>

<pre><code class="language-objectivec">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber {
	RACDisposable *subscriptionDisposable = [super subscribe:subscriber];

	RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^{
		@synchronized (self) {
			[subscriber sendNext:self.currentValue];
		}
	}];

	return [RACDisposable disposableWithBlock:^{
		[subscriptionDisposable dispose];
		[schedulingDisposable dispose];
	}];
}
</code></pre>

<p>接下来，通过一个简单的例子来演示 <code>RACBehaviorSubject</code> 到底是如何工作的：</p>

<pre><code class="language-objectivec">RACBehaviorSubject *subject = [RACBehaviorSubject subject];

[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@"1st Sub: %@", x);
}];
[subject sendNext:@1];

[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@"2nd Sub: %@", x);
}];
[subject sendNext:@2];

[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@"3rd Sub: %@", x);
}];
[subject sendNext:@3];
[subject sendCompleted];
</code></pre>

<p>上面的代码其实与 <code>RACSubject</code> 一节中的代码差不多，只将 <code>RACSubject</code> 转换成了 <code>RACBehaviorSubject</code> 对象。</p>

<p><img src="https://img.nju520.me/2017-02-07-Track-RACBehaviorSubject-Subscription-Process.png-1000width" alt="Track-RACBehaviorSubject-Subscription-Process" /></p>

<p>在每次订阅者订阅 <code>RACBehaviorSubject</code> 之后，都会向该订阅者发送<strong>最新</strong>的消息，这也就是 <code>RACBehaviorSubject</code> 最重要的行为。</p>

<p><code>RACBehaviorSubject</code> 有一个用于创建包含默认值的类方法 <code>+behaviorSubjectWithDefaultValue:</code>，如果将上面的第一行代码改成：</p>

<pre><code class="language-objectivec">RACBehaviorSubject *subject = [RACBehaviorSubject behaviorSubjectWithDefaultValue:@0];
</code></pre>

<p>那么在第一个订阅者刚订阅 <code>RACBehaviorSubject</code> 时就会收到 <code>@0</code> 对象。</p>

<p><img src="https://img.nju520.me/2017-02-07-Track-RACBehaviorSubject-Subscription-Process-With-Default-Value.png-1000width" alt="Track-RACBehaviorSubject-Subscription-Process-With-Default-Value" /></p>

<h3 id="racreplaysubject">RACReplaySubject</h3>

<p><code>RACReplaySubject</code> 相当于一个自带 <code>buffer</code> 的 <code>RACBehaviorSubject</code>，它可以在每次有新的订阅者订阅之后发送之前的全部消息。</p>

<pre><code class="language-objectivec">@interface RACReplaySubject ()

@property (nonatomic, assign, readonly) NSUInteger capacity;
@property (nonatomic, strong, readonly) NSMutableArray *valuesReceived;

@end
</code></pre>

<p>实现的方式是通过持有一个 <code>valuesReceived</code> 的数组和能够存储的对象的上限 <code>capacity</code>，默认值为：</p>

<pre><code class="language-objectivec">const NSUInteger RACReplaySubjectUnlimitedCapacity = NSUIntegerMax;
</code></pre>

<p>当然你可以用 <code>+replaySubjectWithCapacity:</code> 初始化一个其它大小的 <code>RACReplaySubject</code> 对象：</p>

<pre><code class="language-objectivec">+ (instancetype)replaySubjectWithCapacity:(NSUInteger)capacity {
	return [(RACReplaySubject *)[self alloc] initWithCapacity:capacity];
}

- (instancetype)initWithCapacity:(NSUInteger)capacity {
	self = [super init];

	_capacity = capacity;
	_valuesReceived = (capacity == RACReplaySubjectUnlimitedCapacity ? [NSMutableArray array] : [NSMutableArray arrayWithCapacity:capacity]);

	return self;
}
</code></pre>

<p>在每次调用 <code>-sendNext:</code> 方法发送消息时，都会将其加入 <code>valuesReceived</code> 数组中，并踢出之前的元素：</p>

<pre><code class="language-objectivec">- (void)sendNext:(id)value {
	@synchronized (self) {
		[self.valuesReceived addObject:value ?: RACTupleNil.tupleNil];
		[super sendNext:value];

		if (self.capacity != RACReplaySubjectUnlimitedCapacity &amp;&amp; self.valuesReceived.count &gt; self.capacity) {
			[self.valuesReceived removeObjectsInRange:NSMakeRange(0, self.valuesReceived.count - self.capacity)];
		}
	}
}
</code></pre>

<p>需要注意的有两点，一是对 <code>valuesReceived</code> 的数组的操作必须使用 <code>@synchronized</code> 加锁；第二，如果 <code>value</code> 为空的话，也需要将其转换成 <code>RACTupleNil.tupleNil</code> 对象进行保存。</p>

<p><img src="https://img.nju520.me/2017-02-07-Send-Messages-to-RACReplaySubject.png-1000width" alt="Send-Messages-to-RACReplaySubject" /></p>

<p><code>-sendError:</code> 和 <code>-sendCompleted</code> 方法都会标记对应 <code>flag</code>，即 <code>hasCompleted</code> 和 <code>hasError</code>，这里就不介绍了；同样的，<code>RACReplaySubject</code> 也覆写了 <code>-subscribe:</code> 方法，在每次有订阅者订阅时重新发送所有的序列：</p>

<pre><code class="language-objectivec">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber {
	RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];

	RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^{
		@synchronized (self) {
			for (id value in self.valuesReceived) {
				if (compoundDisposable.disposed) return;

				[subscriber sendNext:(value == RACTupleNil.tupleNil ? nil : value)];
			}

			if (compoundDisposable.disposed) return;

			if (self.hasCompleted) {
				[subscriber sendCompleted];
			} else if (self.hasError) {
				[subscriber sendError:self.error];
			} else {
				RACDisposable *subscriptionDisposable = [super subscribe:subscriber];
				[compoundDisposable addDisposable:subscriptionDisposable];
			}
		}
	}];

	[compoundDisposable addDisposable:schedulingDisposable];

	return compoundDisposable;
}
</code></pre>

<p>我们仍然使用上一节中的例子来展示 <code>RACReplaySubject</code> 是如何工作的，只修改第一行代码：</p>

<pre><code class="language-objectivec">RACReplaySubject *subject = [RACReplaySubject subject];

[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@"1st Subscriber: %@", x);
}];
[subject sendNext:@1];

[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@"2nd Subscriber: %@", x);
}];
[subject sendNext:@2];

[subject subscribeNext:^(id  _Nullable x) {
    NSLog(@"3rd Subscriber: %@", x);
}];
[subject sendNext:@3];
[subject sendCompleted];
</code></pre>

<p>运行这段代码之后，会得到如下图的结果：</p>

<p><img src="https://img.nju520.me/2017-02-07-Track-RACReplaySubject-Subscription-Process.png-1000width" alt="Track-RACReplaySubject-Subscription-Process" /></p>

<p>所有订阅 <code>RACReplaySubject</code> 的对象（默认行为）都能获得完整的序列，而这个特性在与 <code>RACMulticastConnection</code> 一起使用也有着巨大威力，我们会在之后的文章中介绍。</p>

<h2 id="总结">总结</h2>

<p><code>RACSubject</code> 在 <code>RACSignal</code> 对象之上进行了简单的修改，将原有的冷信号改造成了热信号，将不可变变成了可变。</p>

<p>虽然 <code>RACSubject</code> 的实现并不复杂，只是存储了一个遵循 <code>RACSubscriber</code> 协议的对象列表以及所有的消息，但是在解决实际问题时却能够很好地解决很多与网络操作相关的问题。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="http://williamzang.com/blog/2015/08/18/talk-about-reactivecocoas-cold-signal-and-hot-signal/">细说 ReactiveCocoa 的冷信号与热信号</a></li>
  <li><a href="http://www.introtorx.com/content/v1.0.10621.0/14_HotAndColdObservables.html">Hot and Cold observables</a></li>
</ul>

<blockquote>
  <p>Github Repo：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://nju520.me/racsubject</p>
</blockquote>

  ]]></description>
</item>

<item>
  <title>Pull-Driven 的数据流 RACSequence</title>
  <link>//racsequence</link>
  <author>nju520</author>
  <pubDate>2017-02-04T22:15:57+08:00</pubDate>
  <guid>//racsequence</guid>
  <description><![CDATA[
  <p>ReactiveCocoa 在设计上很大程度借鉴了 Reactive Extension 中的概念，可以说 ReactiveCocoa 是 Rx 在 Objective-C 语言中的实现。</p>

<p>在 Rx 中主要的两个概念<em>信号</em>和<em>序列</em>都在 ReactiveCocoa 中有着相对应的组件 <code>RACSignal</code> 和 <code>RACSequence</code>，上一篇文章已经对前者有一个简单的介绍，而这篇文章主要会介绍后者，也就是 <code>RACSequence</code>。</p>

<h2 id="push-driven--pull-driven">Push-Driven &amp; Pull-Driven</h2>

<p>虽然这篇文章主要介绍 <code>RACSequence</code>，但是在介绍它之前，笔者想先就推驱动（push-driven）和拉驱动（pull-driven）这两个概念做一点简单的说明。</p>

<p><code>RACSignal</code> 和 <code>RACSequence</code> 都是 <code>RACStream</code> 的子类，它们不仅共享了来自父类的很多方法，也都表示数据流。</p>

<p><img src="https://img.nju520.me/2017-02-04-RACSignal - RACSequence.png-1000width" alt="RACSignal - RACSequence" /></p>

<p><code>RACSignal</code> 和 <code>RACSequence</code> 最大区别就是：</p>

<ul>
  <li><code>RACSignal</code> 是推驱动的，也就是在每次信号中的出现新的数据时，所有的订阅者都会自动接受到最新的值；</li>
  <li><code>RACSequence</code> 作为推驱动的数据流，在改变时并不会通知使用当前序列的对象，只有使用者再次从这个 <code>RACSequence</code> 对象中获取数据才能更新，它的更新是需要使用者自己拉取的。</li>
</ul>

<p>由于拉驱动在数据改变时，并不会主动推送给『订阅者』，所以往往适用于简化集合类对象等操作，相比于推驱动，它的适应场合较少。</p>

<p><img src="https://img.nju520.me/2017-02-04-Usage for RACSignal - RACSequence Copy.png-1000width" alt="Usage for RACSignal - RACSequence Copy" /></p>

<blockquote>
  <p>图片中的内容来自 <a href="http://nshipster.com/reactivecocoa/">Reactive​Cocoa · NSHipster</a> 中。</p>
</blockquote>

<h2 id="预加载与延迟加载">预加载与延迟加载</h2>

<p>在 <code>RACSequence</code> 中还涉及到另外一对概念，也就是预加载和延迟加载（也叫懒加载）；如果你之前学习过 Lisp 这门编程语言，那么你一定知道 Lisp 中有两种列表，一种是正常的列表 List，另一种叫做流 Stream，这两者的主要区别就是<strong>流的加载是延迟加载的</strong>，只有在真正使用数据时才会计算数据的内容。</p>

<p><img src="https://img.nju520.me/2017-02-04-List-and-Stream.png-1000width" alt="List-and-Strea" /></p>

<blockquote>
  <p>由于流是懒加载的，这也就是说它可以<strong>表示无穷长度的列表</strong>。</p>
</blockquote>

<p>Stream 由两部分组成，分别是 <code>head</code> 和 <code>tail</code>，两者都是在访问时才会计算，在上图前者是一个数字，而后者会是另一个 Stream 或者 <code>nil</code>。</p>

<pre><code class="language-objectivec">@interface RACSequence&lt;__covariant ValueType&gt; : RACStream &lt;NSCoding, NSCopying, NSFastEnumeration&gt;

@property (nonatomic, strong, readonly, nullable) ValueType head;
@property (nonatomic, strong, readonly, nullable) RACSequence&lt;ValueType&gt; *tail;

@end
</code></pre>

<p><code>RACSequence</code> 头文件的中定义能够帮助我们更好理解递归的序列以及 <code>head</code> 和 <code>tail</code> 的概念，<code>head</code> 是一个值，<code>tail</code> 是一个 <code>RACSequence</code> 对象。</p>

<h2 id="racsequence-简介">RACSequence 简介</h2>

<p>了解了几个比较重要的概念之后，就可以进入正题了，先看一下在 ReactiveCocoa 中，<code>RACSequence</code> 都有哪些子类：</p>

<p><img src="https://img.nju520.me/2017-02-04-RACSequence - Subclasses.png-1000width" alt="RACSequence - Subclasses" /></p>

<p><code>RACSequence</code> 总共有九个子类，这篇文章不会覆盖其中所有的内容，只会简单介绍其中的几个；不过，我们先从父类 <code>RACSequence</code> 开始。</p>

<h3 id="return-和-bind-方法">return 和 bind 方法</h3>

<p>与介绍 <code>RACSignal</code> 时一样，这里我们先介绍两个 <code>RACSequence</code> 必须覆写的方法，第一个就是 <code>+return:</code></p>

<pre><code class="language-objectivec">+ (RACSequence *)return:(id)value {
	return [RACUnarySequence return:value];
}
</code></pre>

<p><code>+return:</code> 方法用到了 <code>RACSequence</code> 的子类 <code>RACUnarySequence</code> 私有类，这个类在外界是不可见的，其实现非常简单，只是将原来的 <code>value</code> 包装成了一个简单的 <code>RACUnarySequence</code> 对象：</p>

<pre><code class="language-objectivec">+ (RACUnarySequence *)return:(id)value {
	RACUnarySequence *sequence = [[self alloc] init];
	sequence.head = value;
	return [sequence setNameWithFormat:@"+return: %@", RACDescription(value)];
}
</code></pre>

<p>这样在访问 <code>head</code> 时可以获取到传入的 <code>value</code>；在访问 <code>tail</code> 时只需要返回 <code>nil</code>：</p>

<pre><code class="language-objectivec">- (RACSequence *)tail {
	return nil;
}
</code></pre>

<p>整个 <code>RACUnarySequence</code> 也只是对 <code>value</code> 简单封装成一个 <code>RACSequence</code> 对象而已：</p>

<p><img src="https://img.nju520.me/2017-02-04-RACUnarySequence.png-1000width" alt="RACUnarySequence" /></p>

<p>相比于 <code>+return:</code> 方法的简单实现，<code>-bind:</code> 的实现就复杂多了：</p>

<pre><code class="language-objectivec">- (RACSequence *)bind:(RACSequenceBindBlock (^)(void))block {
	RACSequenceBindBlock bindBlock = block();
	return [[self bind:bindBlock passingThroughValuesFromSequence:nil] setNameWithFormat:@"[%@] -bind:", self.name];
}
</code></pre>

<p>首先是对 <code>-bind:</code> 方法进行一次转发，将控制权交给 <code>-bind:passingThroughValuesFromSequence:</code> 方法中：</p>

<pre><code class="language-objectivec">- (RACSequence *)bind:(RACSequenceBindBlock)bindBlock passingThroughValuesFromSequence:(RACSequence *)passthroughSequence {
	__block RACSequence *valuesSeq = self;
	__block RACSequence *current = passthroughSequence;
	__block BOOL stop = NO;

	RACSequence *sequence = [RACDynamicSequence sequenceWithLazyDependency:^ id {
		while (current.head == nil) {
			if (stop) return nil;
			id value = valuesSeq.head;
			if (value == nil) {
				stop = YES;
				return nil;
			}
			current = (id)bindBlock(value, &amp;stop);
			if (current == nil) {
				stop = YES;
				return nil;
			}

			valuesSeq = valuesSeq.tail;
		}
		return nil;
	} headBlock:^(id _) {
		return current.head;
	} tailBlock:^ id (id _) {
		if (stop) return nil;

		return [valuesSeq bind:bindBlock passingThroughValuesFromSequence:current.tail];
	}];

	sequence.name = self.name;
	return sequence;
}
</code></pre>

<p>这个非常复杂的方法实际作用就是创建了一个私有类 <code>RACDynamicSequence</code> 对象，使用的初始化方法也都是私有的 <code>+sequenceWithLazyDependency:headBlock:tailBlock:</code>：</p>

<pre><code class="language-objectivec">+ (RACSequence *)sequenceWithLazyDependency:(id (^)(void))dependencyBlock headBlock:(id (^)(id dependency))headBlock tailBlock:(RACSequence *(^)(id dependency))tailBlock {
	RACDynamicSequence *seq = [[RACDynamicSequence alloc] init];
	seq.headBlock = [headBlock copy];
	seq.tailBlock = [tailBlock copy];
	seq.dependencyBlock = [dependencyBlock copy];
	seq.hasDependency = YES;
	return seq;
}
</code></pre>

<p>在使用 <code>RACDynamicSequence</code> 中的元素时，无论是 <code>head</code> 还是 <code>tail</code> 都会用到在初始化方法中传入的三个 block：</p>

<pre><code class="language-objectivec">- (id)head {
	@synchronized (self) {
		id untypedHeadBlock = self.headBlock;
		if (untypedHeadBlock == nil) return _head;

		if (self.hasDependency) {
			if (self.dependencyBlock != nil) {
				_dependency = self.dependencyBlock();
				self.dependencyBlock = nil;
			}

			id (^headBlock)(id) = untypedHeadBlock;
			_head = headBlock(_dependency);
		} else {
			id (^headBlock)(void) = untypedHeadBlock;
			_head = headBlock();
		}

		self.headBlock = nil;
		return _head;
	}
}
</code></pre>

<p><code>head</code> 的计算依赖于 <code>self.headBlock</code> 和 <code>self.dependencyBlock</code>；</p>

<p>而 <code>tail</code> 的计算也依赖于 <code>self.headBlock</code> 和 <code>self.dependencyBlock</code>，只是 <code>tail</code> 会执行 <code>tailBlock</code> 返回另一个 <code>RACDynamicSequence</code> 的实例：</p>

<pre><code class="language-objectivec">^ id (id _) {
    return [valuesSeq bind:bindBlock passingThroughValuesFromSequence:current.tail];
}
</code></pre>

<p>这里通过一段代码更好的了解 <code>-bind:</code> 方法是如何使用的：</p>

<pre><code class="language-objectivec">RACSequence *sequence = [RACSequence sequenceWithHeadBlock:^id _Nullable{
    return @1;
} tailBlock:^RACSequence * _Nonnull{
    return [RACSequence sequenceWithHeadBlock:^id _Nullable{
        return @2;
    } tailBlock:^RACSequence * _Nonnull{
        return [RACSequence return:@3];
    }];
}];
RACSequence *bindSequence = [sequence bind:^RACSequenceBindBlock _Nonnull{
    return ^(NSNumber *value, BOOL *stop) {
        NSLog(@"RACSequenceBindBlock: %@", value);
        value = @(value.integerValue * 2);
        return [RACSequence return:value];
    };
}];
NSLog(@"sequence:     head = (%@), tail=(%@)", sequence.head, sequence.tail);
NSLog(@"BindSequence: head = (%@), tail=(%@)", bindSequence.head, bindSequence.tail);
</code></pre>

<p>在上面的代码中，我们使用 <code>+sequenceWithHeadBlock:tailBlock:</code> 这个唯一暴露出来的初始化方法创建了一个如下图所示的 <code>RACSequence</code>：</p>

<p><img src="https://img.nju520.me/2017-02-04-RACSequence-Instance.png-1000width" alt="RACSequence-Instance" /></p>

<blockquote>
  <p>图中展示了完整的 <code>RACSequence</code> 对象的值，其中的内容暂时都是 <code>unresolved</code> 的。</p>
</blockquote>

<p>上述代码在运行之后，会打印出如下内容：</p>

<pre><code class="language-objectivec">sequence:     head = (1), tail=(&lt;RACDynamicSequence: 0x60800009eb40&gt;{ name = , head = (unresolved), tail = (unresolved) })
RACSequenceBindBlock: 1
BindSequence: head = (2), tail=(&lt;RACDynamicSequence: 0x608000282940&gt;{ name = , head = (unresolved), tail = (unresolved) })
</code></pre>

<p>无论是 <code>sequence</code> 还是 <code>bindSequence</code>，其中的 <code>tail</code> 部分都是一个 <code>RACDynamicSequence</code> 对象，并且其中的 <code>head</code> 和 <code>tail</code> 部分都是 <code>unresolved</code>。</p>

<p><img src="https://img.nju520.me/2017-02-04-Unsolved-RACSequence-Instance.png-1000width" alt="Unsolved-RACSequence-Instance" /></p>

<p>在上面的代码中 <code>RACSequenceBindBlock</code> 的执行也是惰性的，只有在获取 <code>bindSequence.head</code> 时，才会执行将数字转换成 <code>RACUnarySequence</code> 对象，最后通过 <code>head</code> 属性取出来。</p>

<h3 id="lazysequence-和-eagersequence">lazySequence 和 eagerSequence</h3>

<p>上一节的代码中展示的所有序列都是惰性的，而在整个 ReactiveCocoa 中，所有的 <code>RACSequence</code> 对象在<strong>默认情况</strong>下都是惰性的，序列中的值只有在真正需要使用时才会被展开，在其他时间都是 <strong>unresolved</strong>。</p>

<p><code>RACSequence</code> 中定义了两个分别获取 <code>lazySequence</code> 和 <code>eagerSequence</code> 的属性：</p>

<pre><code class="language-objectivec">@property (nonatomic, copy, readonly) RACSequence&lt;ValueType&gt; *eagerSequence;
@property (nonatomic, copy, readonly) RACSequence&lt;ValueType&gt; *lazySequence;
</code></pre>

<blockquote>
  <p>笔者一直认为在大多数情况下，在客户端上的惰性求值都是没有太多意义的，如果一个序列的<strong>长度没有达到比较庞大的数量级或者说计算量比较小</strong>，我们完全都可以使用贪婪求值（Eager Evaluation）的方式尽早获得结果；</p>

  <p>同样，在数量级和计算量不需要考虑时，我们也不需要考虑是否应该设计成哪种求值方式，只需要使用默认行为。</p>
</blockquote>

<p>与上一节相同，在这里使用相同的代码创建一个 <code>RACSequence</code> 对象：</p>

<pre><code class="language-objectivec">RACSequence *sequence = [RACSequence sequenceWithHeadBlock:^id _Nullable{
    return @1;
} tailBlock:^RACSequence * _Nonnull{
    return [RACSequence sequenceWithHeadBlock:^id _Nullable{
        return @2;
    } tailBlock:^RACSequence * _Nonnull{
        return [RACSequence return:@3];
    }];
}];

NSLog(@"Lazy:  %@", sequence.lazySequence);
NSLog(@"Eager: %@", sequence.eagerSequence);
NSLog(@"Lazy:  %@", sequence.lazySequence);
</code></pre>

<p>然后分别三次打印出当前对象的 <code>lazySequence</code> 和 <code>eagerSequence</code> 中的值：</p>

<pre><code class="language-objectivec">Lazy:  &lt;RACDynamicSequence: 0x608000097160&gt;
{ name = , head = (unresolved), tail = (unresolved) }
Eager: &lt;RACEagerSequence: 0x600000035de0&gt;
{ name = , array = (
    1,
    2,
    3
) }
Lazy:  &lt;RACDynamicSequence: 0x608000097160&gt;
{ name = , head = 1, tail = &lt;RACDynamicSequence: 0x600000097070&gt;
    { name = , head = 2, tail = &lt;RACUnarySequence: 0x600000035f00&gt;
        { name = , head = 3 } } }
</code></pre>

<p>在第一调用 <code>sequence.lazySequence</code> 时，因为元素没有被使用，惰性序列的 <code>head</code> 和 <code>tail</code> 都为 unresolved；而在 <code>sequence.eagerSequence</code> 调用后，访问了序列中的所有元素，在这之后再打印 <code>sequence.lazySequence</code> 中的值就都不是 unresolved 的了。</p>

<p><img src="https://img.nju520.me/2017-02-04-RACSequence-Status-Before-And-After-Executed.png-1000width" alt="RACSequence-Status-Before-And-After-Executed" /></p>

<p>这种情况的出现不难理解，不过因为 <code>lazySequence</code> 和 <code>eagerSequence</code> 是 <code>RACSequence</code> 的方法，所以我们可以在任意子类的实例包括 <code>RACEagerSequence</code> 和非惰性序列上调用它们，这就会出现以下的多种情况：</p>

<p><img src="https://img.nju520.me/2017-02-04-EagerSequence - LazySequence.png-1000width" alt="EagerSequence - LazySequence" /></p>

<p>总而言之，调用过 <code>eagerSequence</code> 的序列的元素已经不再是 <code>unresolved</code> 了，哪怕再调用 <code>lazySequence</code> 方法，读者可以自行实验验证这里的结论。</p>

<h3 id="操作-racsequence">操作 RACSequence</h3>

<p><code>RACStream</code> 为 <code>RACSequence</code> 提供了很多基本的操作，<code>-map:</code>、<code>-filter:</code>、<code>-ignore:</code> 等等，因为这些方法的实现都基于 <code>-bind:</code>，而 <code>-bind:</code> 方法的执行是惰性的，所以在调用上述方法之后返回的 <code>RACSequence</code> 中所有的元素都是 unresolved 的，需要在访问之后才会计算并展开：</p>

<pre><code class="language-objectivec">RACSequence *sequence = [@[@1, @2, @3].rac_sequence map:^id _Nullable(NSNumber * _Nullable value) {
    return @(value.integerValue * value.integerValue);
}];
NSLog(@"%@", sequence); -&gt; &lt;RACDynamicSequence: 0x60800009ad10&gt;{ name = , head = (unresolved), tail = (unresolved) }
NSLog(@"%@", sequence.eagerSequence); -&gt; &lt;RACEagerSequence: 0x60800002bfc0&gt;{ name = , array = (1, 4, 9) }
</code></pre>

<p>除了从 <code>RACStream</code> 中继承的一些方法，在 <code>RACSequence</code> 类中也有一些自己实现的方法，比如说 <code>-foldLeftWithStart:reduce:</code> 方法：</p>

<pre><code class="language-objectivec">- (id)foldLeftWithStart:(id)start reduce:(id (^)(id, id))reduce {
	if (self.head == nil) return start;

	for (id value in self) {
		start = reduce(start, value);
	}

	return start;
}
</code></pre>

<p>使用简单的 <code>for</code> 循环，将序列中的数据进行『折叠』，最后返回一个结果：</p>

<pre><code class="language-objectivec">RACSequence *sequence = @[@1, @2, @3].rac_sequence;
NSNumber *sum = [sequence foldLeftWithStart:0 reduce:^id _Nullable(NSNumber * _Nullable accumulator, NSNumber * _Nullable value) {
    return @(accumulator.integerValue + value.integerValue);
}];
NSLog(@"%@", sum);
</code></pre>

<p>与上面方法相似的是 <code>-foldRightWithStart:reduce:</code> 方法，从右侧开始向左折叠整个序列，虽然过程有一些不同，但是结果还是一样的。</p>

<p><img src="https://img.nju520.me/2017-02-04-FoldLeft - FoldRight.png-1000width" alt="FoldLeft - FoldRight" /></p>

<p>从两次方法的调用栈上来看，就能看出两者实现过程的明显区别：</p>

<p><img src="https://img.nju520.me/2017-02-04-Call-Stacks-of-FoldLeft-FoldRight.png-1000width" alt="Call-Stacks-of-FoldLeft-FoldRight" /></p>

<ul>
  <li><code>foldLeft</code> 由于其实现是通过 <code>for</code> 循环遍历序列，所以调用栈不会展开，在循环结束之后就返回了，调用栈中只有当前方法；</li>
  <li><code>foldRight</code> 的调用栈<strong>递归</strong>的调用自己，直到出现了边界条件 <code>self.tail == nil</code> 后停止，左侧的调用栈也是其调用栈最深的时候，在这时调用栈的规模开始按照箭头方向缩小，直到方法返回。</li>
</ul>

<p>在源代码中，你也可以看到方法在创建 <code>RACSequence</code> 的 block 中递归调用了当前的方法：</p>

<pre><code class="language-objectivec">- (id)foldRightWithStart:(id)start reduce:(id (^)(id, RACSequence *))reduce {
	if (self.head == nil) return start;

	RACSequence *rest = [RACSequence sequenceWithHeadBlock:^{
		if (self.tail) {
			return [self.tail foldRightWithStart:start reduce:reduce];
		} else {
			return start;
		}
	} tailBlock:nil];

	return reduce(self.head, rest);
}
</code></pre>

<h3 id="racsequence-与-racsignal">RACSequence 与 RACSignal</h3>

<p>虽然 <code>RACSequence</code> 与 <code>RACSignal</code> 有很多不同，但是在 ReactiveCocoa 中 <code>RACSequence</code> 与 <code>RACSignal</code> 却可以双向转换。</p>

<p><img src="https://img.nju520.me/2017-02-04-Transform Between RACSequence - RACSignal.png-1000width" alt="Transform Between RACSequence - RACSigna" /></p>

<h4 id="将-racsequence-转换成-racsignal">将 RACSequence 转换成 RACSignal</h4>

<p>将 <code>RACSequence</code> 转换成 <code>RACSignal</code> 对象只需要调用一个方法。</p>

<p><img src="https://img.nju520.me/2017-02-04-Transform-RACSequence-To-RACSignal.png-1000width" alt="Transform-RACSequence-To-RACSigna" /></p>

<p>分析其实现之前先看一下如何使用 <code>-signal</code> 方法将 <code>RACSequence</code> 转换成 <code>RACSignal</code> 对象的：</p>

<pre><code class="language-objectivec">RACSequence *sequence = @[@1, @2, @3].rac_sequence;
RACSignal *signal = sequence.signal;
[signal subscribeNext:^(id  _Nullable x) {
    NSLog(@"%@", x);
}];
</code></pre>

<p>其实过程非常简单，原序列 <code>@[@1, @2, @3]</code> 中的元素会按照次序发送，可以理解为依次调用 <code>-sendNext:</code>，它可以等价于下面的代码：</p>

<pre><code class="language-objectivec">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
    [subscriber sendNext:@1];
    [subscriber sendNext:@2];
    [subscriber sendNext:@3];
    [subscriber sendCompleted];
    return nil;
}];
[signal subscribeNext:^(id  _Nullable x) {
    NSLog(@"%@", x);
}];
</code></pre>

<p><code>-signal</code> 方法的实现依赖于另一个实例方法 <code>-signalWithScheduler:</code>，它会在一个 <code>RACScheduler</code> 对象上发送序列中的所有元素：</p>

<pre><code class="language-objectivec">- (RACSignal *)signal {
	return [[self signalWithScheduler:[RACScheduler scheduler]] setNameWithFormat:@"[%@] -signal", self.name];
}

- (RACSignal *)signalWithScheduler:(RACScheduler *)scheduler {
	return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) {
		__block RACSequence *sequence = self;

		return [scheduler scheduleRecursiveBlock:^(void (^reschedule)(void)) {
			if (sequence.head == nil) {
				[subscriber sendCompleted];
				return;
			}
			[subscriber sendNext:sequence.head];
			sequence = sequence.tail;
			reschedule();
		}];
	}] setNameWithFormat:@"[%@] -signalWithScheduler: %@", self.name, scheduler];
}
</code></pre>

<p><code>RACScheduler</code> 并不是这篇文章准备介绍的内容，这里的代码其实相当于递归调用了 <code>reschedule</code> block，不断向 <code>subscriber</code> 发送 <code>-sendNext:</code>，直到 <code>RACSequence</code> 为空为止。</p>

<h4 id="将-racsignal-转换成-racsequence">将 RACSignal 转换成 RACSequence</h4>

<p>反向转换 <code>RACSignal</code> 的过程相比之下就稍微复杂一点了，我们需要连续调用两个方法，才能将它转换成 <code>RACSequence</code>。</p>

<p><img src="https://img.nju520.me/2017-02-04-Transform RACSignal to RACSequence.png-1000width" alt="Transform RACSignal to RACSequence" /></p>

<p>通过一段代码来看转换过程是如何进行的：</p>

<pre><code class="language-objectivec">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
    [subscriber sendNext:@1];
    [subscriber sendNext:@2];
    [subscriber sendNext:@3];
    [subscriber sendCompleted];
    return nil;
}];
NSLog(@"%@", signal.toArray.rac_sequence);
</code></pre>

<p>运行上面的代码，会得到一个如下的 <code>RACArraySequence</code> 对象：</p>

<pre><code class="language-objectivec">&lt;RACArraySequence: 0x608000024e80&gt;{ name = , array = (
    1,
    2,
    3
) }
</code></pre>

<p>在这里不想过多介绍其实现原理，我们只需要知道这里使用了 <code>RACStream</code> 提供的操作『收集』了信号发送过程中的发送的所有对象 <code>@1</code>、<code>@2</code>、<code>@3</code> 就可以了。</p>

<h2 id="总结">总结</h2>

<p>相比于 <code>RACSignal</code> 来说，虽然 <code>RACSequence</code> 有很多的子类，但是它的用途和实现复杂度都少很多，这主要是因为它是 Pull-Driven 的，只有在使用时才会更新，所以我们一般只会使用 <code>RACSequence</code> 操作数据流，使用 <code>map</code>、<code>filter</code>、<code>flattenMap</code> 等方法快速操作数据。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="http://nshipster.com/reactivecocoa/">Reactive​Cocoa · NSHipster</a></li>
  <li><a href="http://stackoverflow.com/questions/28952900/what-is-the-difference-between-racsequence-and-racsignal">What is the difference between RACSequence and RACSignal</a></li>
  <li><a href="http://rcdp.io/Signal.html">ReactiveCocoa Design Patterns</a></li>
</ul>

<blockquote>
  <p>Github Repo：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://nju520.me/racsignal</p>
</blockquote>

  ]]></description>
</item>

<item>
  <title>『状态』驱动的世界：ReactiveCocoa</title>
  <link>//racsignal</link>
  <author>nju520</author>
  <pubDate>2017-01-30T21:06:48+08:00</pubDate>
  <guid>//racsignal</guid>
  <description><![CDATA[
  <p>这篇以及之后的文章主要会对 ReactiveObjc v2.1.2 的实现进行分析，从最简单的例子中了解 ReactiveCocoa 的工作原理以及概念，也是笔者个人对于 RAC 学习的总结与理解。本文主要会围绕 RAC 中核心概念 <code>RACSignal</code> 展开，详细了解其底层实现。</p>

<h2 id="状态驱动">状态驱动</h2>

<p>2015 年的夏天的时候，做了几个简单的开源框架，想做点其它更有意思的框架却没什么思路，就开始看一些跟编程没有太大关系的书籍。</p>

<p><img src="https://img.nju520.me/2017-01-30-out-of-control.jpg-1000width" alt="out-of-contro" /></p>

<p>其中一本叫做《失控》给了我很大的启发，其中有一则故事是这样的：</p>

<blockquote>
  <p>布鲁克斯开展了一个雄心勃勃的研究生课题项目，研发更接近昆虫而非恐龙的机器人。</p>

  <p>布鲁克斯的设想在一个叫「成吉思」的机巧装置上成形。成吉思有橄榄球大小，像只蟑螂似的。布鲁克斯把他的精简理念发挥到了极致。小成吉思有 6 条腿却没有一丁点儿可以称为「脑」的东西。所有 12 个电机和 21 个传感器分布在没有中央处理器的可解耦网络上。然而这 12 个充当肌肉的电机和 21 个传感器之间的交互作用居然产生了令人惊叹的复杂性和类似生命体的行为。</p>

  <p>成吉思的每条小细腿都在自顾自地工作，和其余的腿毫无关系。每条腿都通过自己的一组神经元——一个微型处理器——来控制其动作。每条腿只需管好自己！对成吉思来说，走路是一个团队合作项目，至少有六个小头脑在工作。它体内其余更微小的脑力则负责腿与腿之间的通讯。昆虫学家说这正是蚂蚁和蟑螂的解决之道——这些爬行昆虫的足肢上的神经元负责为该足肢进行思考。</p>

  <p>—— 《失控》第三章·第二节 快速、廉价、失控</p>
</blockquote>

<p>书中对于机器人的介绍比较冗长，在这里就简单总结一下：机器人的每一条腿都单独进行工作，通过传感器感应的<strong>状态</strong>做出响应：</p>

<ul>
  <li>如果腿抬起来了，那么它要落下去；</li>
  <li>如果腿在向前动，要让另外五条腿距离它远一点；</li>
</ul>

<p>这种去中心化的方式，简化了整个系统的构造，使得各个组件只需要关心状态，以及状态对应的动作；不再需要一个中枢系统来组织、管理其它的组件，并负责大多数的业务逻辑。这种自底向下的、状态驱动的构建方式能够使用多个较小的组件，减少臃肿的中枢出现的可能性，从而降低系统的复杂度。</p>

<h2 id="reactivecocoa-与信号">ReactiveCocoa 与信号</h2>

<p>ReactiveCocoa 对于状态的理解与《失控》一书中十分类似，将原有的各种设计模式，包括代理、Target/Action、通知中心以及观察者模式各种『输入』，都抽象成了信号（也可以理解为状态流）让单一的组件能够对自己的响应动作进行控制，简化了视图控制器的负担。</p>

<p>在 ReactiveCocoa 中最重要的信号，也就是 <code>RACSignal</code> 对象是这一篇文章介绍的核心；文章中主要会介绍下面的代码片段出现的内容：</p>

<pre><code class="language-objectivec">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
    [subscriber sendNext:@1];
    [subscriber sendNext:@2];
    [subscriber sendCompleted];
    return [RACDisposable disposableWithBlock:^{
        NSLog(@"dispose");
    }];
}];
[signal subscribeNext:^(id  _Nullable x) {
    NSLog(@"%@", x);
}];
</code></pre>

<p>在上述代码执行时，会在控制台中打印出以下内容：</p>

<pre><code class="language-c">1
2
dispose
</code></pre>

<p>代码片段基本都是围绕 <code>RACSignal</code> 类进行的，文章会分四部分对上面的代码片段的工作流程进行简单的介绍：</p>

<ul>
  <li>简单了解 <code>RACSignal</code></li>
  <li>信号的创建</li>
  <li>信号的订阅与发送</li>
  <li>订阅的回收过程</li>
</ul>

<h2 id="racsignal-简介">RACSignal 简介</h2>

<p><code>RACSignal</code> 其实是抽象类 <code>RACStream</code> 的子类，在整个 ReactiveObjc 工程中有另一个类 <code>RACSequence</code> 也继承自抽象类 <code>RACStream</code>：</p>

<p><img src="https://img.nju520.me/2017-01-30-RACSignal-Hierachy.png-1000width" alt="RACSignal-Hierachy" /></p>

<p><code>RACSignal</code> 可以说是 ReactiveCocoa 中的核心类，也是最重要的概念，整个框架围绕着 <code>RACSignal</code> 的概念进行组织，对 <code>RACSignal</code> 最简单的理解就是它表示一连串的状态：</p>

<p><img src="https://img.nju520.me/2017-01-30-What-is-RACSignal.png-1000width" alt="What-is-RACSigna" /></p>

<p>在状态改变时，对应的订阅者 <code>RACSubscriber</code> 就会收到通知执行相应的指令，在 ReactiveCocoa 的世界中所有的消息都是通过信号的方式来传递的，原有的设计模式都会简化为一种模型，这篇文章作为 ReactiveCocoa 系列的第一篇文章并不会对这些问题进行详细的展开和介绍，只会对 <code>RACSignal</code> 使用过程的原理进行简单的分析。</p>

<p>这一小节会对 <code>RACStream</code> 以及 <code>RACSignal</code> 中与 <code>RACStream</code> 相关的部分进行简单的介绍。</p>

<h3 id="racstream">RACStream</h3>

<p><code>RACStream</code> 作为抽象类本身不提供方法的实现，其实现内部原生提供的而方法都是抽象方法，会在调用时直接抛出异常：</p>

<pre><code class="language-objectivec">+ (__kindof RACStream *)empty {
	NSString *reason = [NSString stringWithFormat:@"%@ must be overridden by subclasses", NSStringFromSelector(_cmd)];
	@throw [NSException exceptionWithName:NSInternalInconsistencyException reason:reason userInfo:nil];
}

- (__kindof RACStream *)bind:(RACStreamBindBlock (^)(void))block;
+ (__kindof RACStream *)return:(id)value;
- (__kindof RACStream *)concat:(RACStream *)stream;
- (__kindof RACStream *)zipWith:(RACStream *)stream;
</code></pre>

<p><img src="https://img.nju520.me/2017-01-30-RACStream-AbstractMethod.png-1000width" alt="RACStream-AbstractMethod" /></p>

<p>上面的这些抽象方法都需要子类覆写，不过 <code>RACStream</code> 在 <code>Operations</code> 分类中使用上面的抽象方法提供了丰富的内容，比如说 <code>-flattenMap:</code> 方法：</p>

<pre><code class="language-objectivec">- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(id value))block {
	Class class = self.class;

	return [[self bind:^{
		return ^(id value, BOOL *stop) {
			id stream = block(value) ?: [class empty];
			NSCAssert([stream isKindOfClass:RACStream.class], @"Value returned from -flattenMap: is not a stream: %@", stream);

			return stream;
		};
	}] setNameWithFormat:@"[%@] -flattenMap:", self.name];
}
</code></pre>

<p>其他方法比如 <code>-skip:</code>、<code>-take:</code>、<code>-ignore：</code> 等等实例方法都构建在这些抽象方法之上，只要子类覆写了所有抽象方法就能自动获得所有的 <code>Operation</code> 分类中的方法。</p>

<p><img src="https://img.nju520.me/2017-01-30-RACStream-Operation.png-1000width" alt="RACStream-Operation" /></p>

<h3 id="racsignal-与-monad">RACSignal 与 Monad</h3>

<blockquote>
  <p>如果你对 Monad 有所了解，那么你应该知道 <code>bind</code> 和 <code>return</code> 其实是 Monad 中的概念，但 Monad 并不是本篇文章所覆盖的内容，并不会具体解释它到底是什么。</p>
</blockquote>

<p>ReactiveCocoa 框架中借鉴了很多其他平台甚至语言中的概念，包括微软中的 Reactive Extension 以及 Haskell 中的 Monad，<code>RACStream</code> 提供的抽象方法中的 <code>+return:</code> 和 <code>-bind:</code> 就与 Haskell 中 Monad 完全一样。</p>

<blockquote>
  <p>很多人都说 Monad 只是一个自函子范畴上的一个幺半群而已；在笔者看来这种说法虽然是正确的，不过也很扯淡，这句话解释了还是跟没解释一样，如果有人再跟你用这句话解释 Monad，我觉得你最好的回应就是买一本范畴论糊他一脸。如果真的想了解 Haskell 中的 Monad 到底是什么？可以从代码的角度入手，多写一些代码就明白了，这个概念理解起来其实根本没什么困难的，当然也可以看一下 <a href="http://learnyouahaskell.com/a-fistful-of-monads">A Fistful of Monads</a>，写写其中的代码，会对 Monad 有自己的认知，当然，请不要再写一篇解释 Monad 的教程了（手动微笑）。</p>
</blockquote>

<p>首先来看一下 <code>+return</code> 方法的 <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/1180ab256000573ef82141e5d40e9b9c35dfd69c/ReactiveObjC/RACSignal.m#L89-L91">实现</a>：</p>

<pre><code class="language-objectivec">+ (RACSignal *)return:(id)value {
	return [RACReturnSignal return:value];
}
</code></pre>

<p>该方法接受一个 <code>NSObject</code> 对象，并返回一个 <code>RACSignal</code> 的实例，它会将一个 UIKit 世界的对象 <code>NSObject</code> 转换成 ReactiveCocoa 中的 <code>RACSignal</code>：</p>

<p><img src="https://img.nju520.me/2017-01-30-RACSignal-Return.png-1000width" alt="RACSignal-Return" /></p>

<p>而 <code>RACReturnSignal</code> 也仅仅是把 <code>NSObject</code> 对象包装一下，并没有做什么复杂的事情：</p>

<pre><code class="language-objectivec">+ (RACSignal *)return:(id)value {
	RACReturnSignal *signal = [[self alloc] init];
	signal-&gt;_value = value;
	return signal;
}
</code></pre>

<p>但是 <code>-bind:</code> 方法的 <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/1180ab256000573ef82141e5d40e9b9c35dfd69c/ReactiveObjC/RACSignal.m#L93-L176">实现</a> 相比之下就十分复杂了：</p>

<pre><code class="language-objectivec">- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block {
    return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) {
        RACSignalBindBlock bindingBlock = block();
        return [self subscribeNext:^(id x) {
            BOOL stop = NO;
            id signal = bindingBlock(x, &amp;stop);

            if (signal != nil) {
                [signal subscribeNext:^(id x) {
                    [subscriber sendNext:x];
                } error:^(NSError *error) {
                    [subscriber sendError:error];
                } completed:^{
                    [subscriber sendCompleted];
                }];
            }
            if (signal == nil || stop) {
                [subscriber sendCompleted];
            }
        } error:^(NSError *error) {
            [subscriber sendError:error];
        } completed:^{
            [subscriber sendCompleted];
        }];
    }] setNameWithFormat:@"[%@] -bind:", self.name];
}
</code></pre>

<blockquote>
  <p>笔者在这里对 <code>-bind:</code> 方法进行了大量的省略，省去了其中对各种 <code>RACDisposable</code> 的处理过程。</p>
</blockquote>

<p><code>-bind:</code> 方法会在原信号每次发出消息时，都执行 <code>RACSignalBindBlock</code> 对原有的信号中的消息进行<strong>变换</strong>生成一个新的信号：</p>

<p><img src="https://img.nju520.me/2017-01-30-RACSignal-Bind.png-1000width" alt="RACSignal-Bind" /></p>

<blockquote>
  <p>在原有的 <code>RACSignal</code> 对象上调用 <code>-bind:</code> 方法传入 <code>RACSignalBindBlock</code>，图示中的右侧就是具体的执行过程，原信号在变换之后变成了新的蓝色的 <code>RACSignal</code> 对象。</p>
</blockquote>

<p><code>RACSignalBindBlock</code> 可以简单理解为一个接受 <code>NSObject</code> 对象返回 <code>RACSignal</code> 对象的函数：</p>

<pre><code class="language-objectivec">typedef RACSignal * _Nullable (^RACSignalBindBlock)(id _Nullable value, BOOL *stop);
</code></pre>

<p>其函数签名可以理解为 <code>id -&gt; RACSignal</code>，然而这种函数是无法直接对 <code>RACSignal</code> 对象进行变换的；不过通过 <code>-bind:</code> 方法就可以使用这种函数操作 <code>RACSignal</code>，其实现如下：</p>

<ol>
  <li>将 <code>RACSignal</code> 对象『解包』出 <code>NSObject</code> 对象；</li>
  <li>将 <code>NSObject</code> 传入 <code>RACSignalBindBlock</code> 返回 <code>RACSignal</code>。</li>
</ol>

<p>如果在不考虑 <code>RACSignal</code> 会发出错误或者完成信号时，<code>-bind:</code> 可以简化为更简单的形式：</p>

<pre><code class="language-objectivec">- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block {
    return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) {
        RACSignalBindBlock bindingBlock = block();
        return [self subscribeNext:^(id x) {
            BOOL stop = NO;
            [bindingBlock(x, &amp;stop) subscribeNext:^(id x) {
                [subscriber sendNext:x];
            }];
        }];
    }] setNameWithFormat:@"[%@] -bind:", self.name];
}
</code></pre>

<p>调用 <code>-subscribeNext:</code> 方法订阅当前信号，将信号中的状态解包，然后将原信号中的状态传入 <code>bindingBlock</code> 中并订阅返回的新的信号，将生成的新状态 <code>x</code> 传回原信号的订阅者。</p>

<p>这里通过两个简单的例子来了解 <code>-bind:</code> 方法的作用：</p>

<pre><code class="language-objectivec">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
    [subscriber sendNext:@1];
    [subscriber sendNext:@2];
    [subscriber sendNext:@3];
    [subscriber sendNext:@4];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *bindSignal = [signal bind:^RACSignalBindBlock _Nonnull{
    return ^(NSNumber *value, BOOL *stop) {
        value = @(value.integerValue * value.integerValue);
        return [RACSignal return:value];
    };
}];
[signal subscribeNext:^(id  _Nullable x) {
    NSLog(@"signal: %@", x);
}];
[bindSignal subscribeNext:^(id  _Nullable x) {
    NSLog(@"bindSignal: %@", x);
}];
</code></pre>

<p>上面的代码中直接使用了 <code>+return:</code> 方法将 <code>value</code> 打包成了 <code>RACSignal *</code> 对象：</p>

<p><img src="https://img.nju520.me/2017-01-30-Before-After-Bind-RACSignal.png-1000width" alt="Before-After-Bind-RACSigna" /></p>

<blockquote>
  <p>在 BindSignal 中的每一个数字其实都是由一个 <code>RACSignal</code> 包裹的，这里没有画出，在下一个例子中，读者可以清晰地看到其中的区别。</p>
</blockquote>

<p>上图简要展示了变化前后的信号中包含的状态，在运行上述代码时，会在终端中打印出：</p>

<pre><code class="language-objectivec">signal: 1
signal: 2
signal: 3
signal: 4
bindSignal: 1
bindSignal: 4
bindSignal: 9
bindSignal: 16
</code></pre>

<p>这是一个最简单的例子，直接使用 <code>-return:</code> 打包 <code>NSObject</code> 返回一个 <code>RACSignal</code>，接下来用一个更复杂的例子来帮助我们更好的了解 <code>-bind:</code> 方法：</p>

<pre><code class="language-objectivec">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
    [subscriber sendNext:@1];
    [subscriber sendNext:@2];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *bindSignal = [signal bind:^RACSignalBindBlock _Nonnull{
    return ^(NSNumber *value, BOOL *stop) {
        NSNumber *returnValue = @(value.integerValue * value.integerValue);
        return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
            for (NSInteger i = 0; i &lt; value.integerValue; i++) [subscriber sendNext:returnValue];
            [subscriber sendCompleted];
            return nil;
        }];
    };
}];
[bindSignal subscribeNext:^(id  _Nullable x) {
    NSLog(@"%@", x);
}];
</code></pre>

<p>下图相比上面例子中的图片更能精确的表现出 <code>-bind:</code> 方法都做了什么：</p>

<p><img src="https://img.nju520.me/2017-01-30-Before-After-Bind-RACSignal-Complicated.png-1000width" alt="Before-After-Bind-RACSignal-Complicated" /></p>

<p>信号中原有的状态经过 <code>-bind:</code> 方法中传入 <code>RACSignalBindBlock</code> 的处理实际上返回了<strong>多个</strong> <code>RACSignal</code>。</p>

<p>在源代码的注释中清楚地写出了方法的实现过程：</p>

<ol>
  <li>订阅原信号中的值；</li>
  <li>将原信号发出的值传入 <code>RACSignalBindBlock</code> 进行转换；</li>
  <li>如果 <code>RACSignalBindBlock</code> 返回一个信号，就会订阅该信号并将信号中的所有值传给订阅者 <code>subscriber</code>；</li>
  <li>如果 <code>RACSignalBindBlock</code> 请求终止信号就会向<strong>原</strong>信号发出 <code>-sendCompleted</code> 消息；</li>
  <li>当<strong>所有</strong>信号都完成时，会向订阅者发送 <code>-sendCompleted</code>；</li>
  <li>无论何时，如果信号发出错误，都会向订阅者发送 <code>-sendError:</code> 消息。</li>
</ol>

<p>如果想要了解 <code>-bind:</code> 方法在执行的过程中是如何处理订阅的清理和销毁的，可以阅读文章最后的 <a href="">-bind: 中对订阅的销毁</a> 部分。</p>

<h2 id="信号的创建">信号的创建</h2>

<p>信号的创建过程十分简单，<code>-createSignal:</code> 是推荐的创建信号的方法，方法其实只做了一次转发：</p>

<pre><code class="language-objectivec">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe {
	return [RACDynamicSignal createSignal:didSubscribe];
}

+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe {
	RACDynamicSignal *signal = [[self alloc] init];
	signal-&gt;_didSubscribe = [didSubscribe copy];
	return [signal setNameWithFormat:@"+createSignal:"];
}
</code></pre>

<p>该方法其实只是创建了一个 <code>RACDynamicSignal</code> 实例并保存了传入的 <code>didSubscribe</code> 代码块，在每次有订阅者订阅当前信号时，都会执行一遍，向订阅者发送消息。</p>

<h3 id="racsignal-类簇">RACSignal 类簇</h3>

<p>虽然 <code>-createSignal:</code> 的方法签名上返回的是 <code>RACSignal</code> 对象的实例，但是实际上这里返回的是 <code>RACDynamicSignal</code>，也就是 <code>RACSignal</code> 的子类；同样，在 ReactiveCocoa 中也有很多其他的 <code>RACSignal</code> 子类。</p>

<p>使用类簇的方式设计的 <code>RACSignal</code> 在创建实例时可能会返回 <code>RACDynamicSignal</code>、<code>RACEmptySignal</code>、<code>RACErrorSignal</code> 和 <code>RACReturnSignal</code> 对象：</p>

<p><img src="https://img.nju520.me/2017-01-30-RACSignal-Subclasses.png-1000width" alt="RACSignal-Subclasses" /></p>

<p>其实这几种子类并没有对原有的 <code>RACSignal</code> 做出太大的改变，它们的创建过程也不是特别的复杂，只需要调用 <code>RACSignal</code> 不同的类方法：</p>

<p><img src="https://img.nju520.me/2017-01-30-RACSignal-Instantiate-Object.png-1000width" alt="RACSignal-Instantiate-Object" /></p>

<p><code>RACSignal</code> 只是起到了一个代理的作用，最后的实现过程还是会指向对应的子类：</p>

<pre><code class="language-objectivec">+ (RACSignal *)error:(NSError *)error {
	return [RACErrorSignal error:error];
}

+ (RACSignal *)empty {
	return [RACEmptySignal empty];
}

+ (RACSignal *)return:(id)value {
	return [RACReturnSignal return:value];
}
</code></pre>

<p>以 <code>RACReturnSignal</code> 的创建过程为例：</p>

<pre><code class="language-objectivec">+ (RACSignal *)return:(id)value {
	RACReturnSignal *signal = [[self alloc] init];
	signal-&gt;_value = value;
	return signal;
}
</code></pre>

<p>这个信号的创建过程和 <code>RACDynamicSignal</code> 的初始化过程一样，都非常简单；只是将传入的 <code>value</code> 简单保存一下，在有其他订阅者 <code>-subscribe:</code> 时，向订阅者发送 <code>value</code>：</p>

<pre><code class="language-objectivec">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber {
	return [RACScheduler.subscriptionScheduler schedule:^{
		[subscriber sendNext:self.value];
		[subscriber sendCompleted];
	}];
}
</code></pre>

<p><code>RACEmptySignal</code> 和 <code>RACErrorSignal</code> 的创建过程也异常的简单，只是对传入的数据进行简单的存储，然后在订阅时发送出来：</p>

<pre><code class="language-objectivec">// RACEmptySignal
+ (RACSignal *)empty {
	return [[[self alloc] init] setNameWithFormat:@"+empty"];
}

- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber {
	return [RACScheduler.subscriptionScheduler schedule:^{
		[subscriber sendCompleted];
	}];
}

// RACErrorSignal
+ (RACSignal *)error:(NSError *)error {
	RACErrorSignal *signal = [[self alloc] init];
	signal-&gt;_error = error;
	return signal;
}

- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber {
	return [RACScheduler.subscriptionScheduler schedule:^{
		[subscriber sendError:self.error];
	}];
}
</code></pre>

<p>这两个创建过程的唯一区别就是一个发送的是『空值』，另一个是 <code>NSError</code> 对象。</p>

<h2 id="信号的订阅与信息的发送">信号的订阅与信息的发送</h2>

<p>ReactiveCocoa 中信号的订阅与信息的发送过程主要是由 <code>RACSubscriber</code> 类来处理的，而这也是信号的处理过程中最重要的一部分，这一小节会先分析整个工作流程，之后会深入代码的实现。</p>

<p><img src="https://img.nju520.me/2017-01-30-RACSignal-Subcribe-Process.png-1000width" alt="RACSignal-Subcribe-Process" /></p>

<p>在信号创建之后调用 <code>-subscribeNext:</code> 方法返回一个 <code>RACDisposable</code>，然而这不是这一流程关心的重点，在订阅过程中生成了一个 <code>RACSubscriber</code> 对象，向这个对象发送消息 <code>-sendNext:</code> 时，就会向所有的订阅者发送消息。</p>

<h3 id="信号的订阅">信号的订阅</h3>

<p>信号的订阅与 <code>-subscribe:</code> 开头的一系列方法有关：</p>

<p><img src="https://img.nju520.me/2017-01-30-RACSignal-Subscribe-Methods.png-1000width" alt="RACSignal-Subscribe-Methods" /></p>

<p>订阅者可以选择自己想要感兴趣的信息类型 <code>next/error/completed</code> 进行关注，并在对应的信息发生时调用 block 进行处理回调。</p>

<p>所有的方法其实只是对 <code>nextBlock</code>、<code>completedBlock</code> 以及 <code>errorBlock</code> 的组合，这里以其中最长的 <code>-subscribeNext:error:completed:</code> 方法的实现为例（也只需要介绍这一个方法）：</p>

<pre><code class="language-objectivec">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock error:(void (^)(NSError *error))errorBlock completed:(void (^)(void))completedBlock {
	RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:errorBlock completed:completedBlock];
	return [self subscribe:o];
}
</code></pre>

<blockquote>
  <p>方法中传入的所有 block 参数都应该是非空的。</p>
</blockquote>

<p>拿到了传入的 block 之后，使用 <code>+subscriberWithNext:error:completed:</code> 初始化一个 <code>RACSubscriber</code> 对象的实例：</p>

<pre><code class="language-objectivec">+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError *error))error completed:(void (^)(void))completed {
	RACSubscriber *subscriber = [[self alloc] init];

	subscriber-&gt;_next = [next copy];
	subscriber-&gt;_error = [error copy];
	subscriber-&gt;_completed = [completed copy];

	return subscriber;
}
</code></pre>

<p>在拿到这个对象之后，调用 <code>RACSignal</code> 的 <code>-subscribe:</code> 方法传入订阅者对象：</p>

<pre><code class="language-objectivec">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber {
	NSCAssert(NO, @"This method must be overridden by subclasses");
	return nil;
}
</code></pre>

<p><code>RACSignal</code> 类中其实并没有实现这个实例方法，需要在上文提到的四个子类对这个方法进行覆写，这里仅分析 <code>RACDynamicSignal</code> 中的方法：</p>

<pre><code class="language-objectivec">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber {
    RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];
    subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];

    RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^{
        RACDisposable *innerDisposable = self.didSubscribe(subscriber);
        [disposable addDisposable:innerDisposable];
    }];

    [disposable addDisposable:schedulingDisposable];

    return disposable;
}
</code></pre>

<blockquote>
  <p>这里暂时不需要关注与 <code>RACDisposable</code> 有关的任何内容，我们会在下一节中详细介绍。</p>
</blockquote>

<p><code>RACPassthroughSubscriber</code> 就像它的名字一样，只是对上面创建的订阅者对象进行简单的包装，将所有的消息转发给内部的 <code>innerSubscriber</code>，也就是传入的 <code>RACSubscriber</code> 对象：</p>

<pre><code class="language-objectivec">- (instancetype)initWithSubscriber:(id&lt;RACSubscriber&gt;)subscriber signal:(RACSignal *)signal disposable:(RACCompoundDisposable *)disposable {
	self = [super init];

	_innerSubscriber = subscriber;
	_signal = signal;
	_disposable = disposable;

	[self.innerSubscriber didSubscribeWithDisposable:self.disposable];
	return self;
}
</code></pre>

<p>如果直接简化 <code>-subscribe:</code> 方法的实现，你可以看到一个看起来极为敷衍的代码：</p>

<pre><code class="language-objectivec">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber {
    return self.didSubscribe(subscriber);
}
</code></pre>

<p>方法只是执行了在创建信号时传入的 <code>RACSignalBindBlock</code>：</p>

<pre><code class="language-objectivec">[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
    [subscriber sendNext:@1];
    [subscriber sendNext:@2];
    [subscriber sendCompleted];
    return [RACDisposable disposableWithBlock:^{
        NSLog(@"dispose");
    }];
}];
</code></pre>

<p>总而言之，信号的订阅过程就是初始化 <code>RACSubscriber</code> 对象，然后执行 <code>didSubscribe</code> 代码块的过程。</p>

<p><img src="https://img.nju520.me/2017-01-30-Principle-of-Subscribing-Signals.png-1000width" alt="Principle-of-Subscribing-Signals" /></p>

<h3 id="信息的发送">信息的发送</h3>

<p>在 <code>RACSignalBindBlock</code> 中，订阅者可以根据自己的兴趣选择自己想要订阅哪种消息；我们也可以按需发送三种消息：</p>

<p><img src="https://img.nju520.me/2017-01-30-RACSignal-Subcription-Messages-Sending.png-1000width" alt="RACSignal-Subcription-Messages-Sending" /></p>

<p>而现在只需要简单看一下这三个方法的实现，就能够明白信息的发送过程了（真是没啥好说的，不过为了<del>凑字数</del>完整性）：</p>

<pre><code class="language-objectivec">- (void)sendNext:(id)value {
	@synchronized (self) {
		void (^nextBlock)(id) = [self.next copy];
		if (nextBlock == nil) return;

		nextBlock(value);
	}
}
</code></pre>

<p><code>-sendNext:</code> 只是将方法传入的值传入 <code>nextBlock</code> 再调用一次，并没有什么值得去分析的地方，而剩下的两个方法实现也差不多，会调用对应的 block，在这里就省略了。</p>

<h2 id="订阅的回收过程">订阅的回收过程</h2>

<p>在创建信号时，我们向 <code>-createSignal:</code> 方法中传入了 <code>didSubscribe</code> 信号，这个 block 在执行结束时会返回一个 <code>RACDisposable</code> 对象，用于在订阅结束时进行必要的清理，同样也可以用于取消因为订阅创建的<strong>正在执行</strong>的任务。</p>

<p>而处理这些事情的核心类就是 <code>RACDisposable</code> 以及它的子类：</p>

<p><img src="https://img.nju520.me/2017-01-30-RACDisposable-And-Subclasses.png-1000width" alt="RACDisposable-And-Subclasses" /></p>

<blockquote>
  <p>这篇文章中主要关注的是左侧的三个子类，当然 <code>RACDisposable</code> 的子类不止这三个，还有用于处理 KVO 的 <code>RACKVOTrampoline</code>，不过在这里我们不会讨论这个类的实现。</p>
</blockquote>

<h3 id="racdisposable">RACDisposable</h3>

<p>在继续分析讨论订阅的回收过程之前，笔者想先对 <code>RACDisposable</code> 进行简要的剖析和介绍：</p>

<p><img src="https://img.nju520.me/2017-01-30-RACDisposable.png-1000width" alt="RACDisposable" /></p>

<p>类 <code>RACDisposable</code> 是以 <code>_disposeBlock</code> 为核心进行组织的，几乎所有的方法以及属性其实都是对 <code>_disposeBlock</code> 进行的操作。</p>

<h4 id="关于-_disposeblock-中的-self">关于 _disposeBlock 中的 self</h4>

<blockquote>
  <p>这一小节的内容是可选的，跳过不影响整篇文章阅读的连贯性。</p>
</blockquote>

<p><code>_disposeBlock</code> 是一个私有的指针变量，当 <code>void (^)(void)</code> 类型的 block 被传入之后都会转换成 CoreFoundation 中的类型并以 <code>void *</code> 的形式存入 <code>_disposeBlock</code> 中：</p>

<pre><code class="language-objectivec">
+ (instancetype)disposableWithBlock:(void (^)(void))block {
	return [[self alloc] initWithBlock:block];
}

- (instancetype)initWithBlock:(void (^)(void))block {
	self = [super init];

	_disposeBlock = (void *)CFBridgingRetain([block copy]);
	OSMemoryBarrier();

	return self;
}
</code></pre>

<p>奇怪的是，<code>_disposeBlock</code> 中不止会存储代码块 block，还有可能存储桥接之后的 <code>self</code>：</p>

<pre><code class="language-objectivec">- (instancetype)init {
	self = [super init];

	_disposeBlock = (__bridge void *)self;
	OSMemoryBarrier();

	return self;
}
</code></pre>

<p>这里，刚开始看到可能会觉得比较奇怪，有两个疑问需要解决：</p>

<ol>
  <li>为什么要提供一个 <code>-init</code> 方法来初始化 <code>RACDisposable</code> 对象？</li>
  <li>为什么要向 <code>_disposeBlock</code> 中传入当前对象？</li>
</ol>

<p>对于 <code>RACDisposable</code> 来说，虽然一个不包含 <code>_disposeBlock</code> 的对象没什么太多的意义，但是对于 <code>RACSerialDisposable</code> 等子类来说，却不完全是这样，因为 <code>RACSerialDisposable</code> 在 <code>-dispose</code> 时，并不需要执行 <code>disposeBlock</code>，这样就浪费了内存和 CPU 时间；但是同时我们需要一个合理的方法准确地判断当前对象的 <code>isDisposed</code>：</p>

<pre><code class="language-objectivec">- (BOOL)isDisposed {
	return _disposeBlock == NULL;
}
</code></pre>

<p>所以，使用向 <code>_disposeBlock</code> 中传入 <code>NULL</code> 的方式来判断 <code>isDisposed</code>；在 <code>-init</code> 调用时传入 <code>self</code> 而不是 <code>NULL</code> 防止状态被误判，这样就在不引入其他实例变量、增加对象的设计复杂度的同时，解决了这两个问题。</p>

<p>如果仍然不理解上述的两个问题，在这里举一个错误的例子，如果 <code>_disposeBlock</code> 在使用时只传入 <code>NULL</code> 或者 <code>block</code>，那么在 <code>RACCompoundDisposable</code> 初始化时，是应该向 <code>_disposeBlock</code> 中传入什么呢？</p>

<ul>
  <li>传入 <code>NULL</code> 会导致在初始化之后 <code>isDisposed == YES</code>，然而当前对象根本没有被回收；</li>
  <li>传入 <code>block</code> 会导致无用的 block 的执行，浪费内存以及 CPU 时间；</li>
</ul>

<p>这也就是为什么要引入 <code>self</code> 来作为 <code>_disposeBlock</code> 内容的原因。</p>

<h4 id="-dispose-方法的实现">-dispose: 方法的实现</h4>

<p>这个只有不到 20 行的 <code>-dispose:</code> 方法已经是整个 <code>RACDisposable</code> 类中最复杂的方法了：</p>

<pre><code class="language-objectivec">- (void)dispose {
	void (^disposeBlock)(void) = NULL;

	while (YES) {
		void *blockPtr = _disposeBlock;
		if (OSAtomicCompareAndSwapPtrBarrier(blockPtr, NULL, &amp;_disposeBlock)) {
			if (blockPtr != (__bridge void *)self) {
				disposeBlock = CFBridgingRelease(blockPtr);
			}

			break;
		}
	}

	if (disposeBlock != nil) disposeBlock();
}
</code></pre>

<p>但是其实它的实现也没有复杂到哪里去，从 <code>_disposeBlock</code> 实例变量中调用 <code>CFBridgingRelease</code> 取出一个 <code>disposeBlock</code>，然后执行这个 block，整个方法就结束了。</p>

<h3 id="racserialdisposable">RACSerialDisposable</h3>

<p><code>RACSerialDisposable</code> 是一个用于持有 <code>RACDisposable</code> 的容器，它一次只能持有一个 <code>RACDisposable</code> 的实例，并可以原子地换出容器中保存的对象：</p>

<pre><code class="language-objectivec">- (RACDisposable *)swapInDisposable:(RACDisposable *)newDisposable {
	RACDisposable *existingDisposable;
	BOOL alreadyDisposed;

	pthread_mutex_lock(&amp;_mutex);
	alreadyDisposed = _disposed;
	if (!alreadyDisposed) {
		existingDisposable = _disposable;
		_disposable = newDisposable;
	}
	pthread_mutex_unlock(&amp;_mutex);

	if (alreadyDisposed) {
		[newDisposable dispose];
		return nil;
	}

	return existingDisposable;
}
</code></pre>

<p>线程安全的 <code>RACSerialDisposable</code> 使用 <code>pthred_mutex_t</code> 互斥锁来保证在访问关键变量时不会出现线程竞争问题。</p>

<p><code>-dispose</code> 方法的处理也十分简单：</p>

<pre><code class="language-objectivec">- (void)dispose {
	RACDisposable *existingDisposable;

	pthread_mutex_lock(&amp;_mutex);
	if (!_disposed) {
		existingDisposable = _disposable;
		_disposed = YES;
		_disposable = nil;
	}
	pthread_mutex_unlock(&amp;_mutex);

	[existingDisposable dispose];
}
</code></pre>

<p>使用锁保证线程安全，并在内部的 <code>_disposable</code> 换出之后在执行 <code>-dispose</code> 方法对订阅进行处理。</p>

<h3 id="raccompounddisposable">RACCompoundDisposable</h3>

<p>与 <code>RACSerialDisposable</code> 只负责一个 <code>RACDisposable</code> 对象的释放不同；<code>RACCompoundDisposable</code> 同时负责多个 <code>RACDisposable</code> 对象的释放。</p>

<p>相比于只管理一个 <code>RACDisposable</code> 对象的 <code>RACSerialDisposable</code>，<code>RACCompoundDisposable</code> 由于管理多个对象，其实现更加复杂，而且为了<strong>性能和内存占用之间的权衡</strong>，其实现方式是通过持有两个实例变量：</p>

<pre><code class="language-objectivec">@interface RACCompoundDisposable () {
    ...
    RACDisposable *_inlineDisposables[RACCompoundDisposableInlineCount];

    CFMutableArrayRef _disposables;
    ...
}
</code></pre>

<p>在对象持有的 <code>RACDisposable</code> 不超过 <code>RACCompoundDisposableInlineCount</code> 时，都会存储在 <code>_inlineDisposables</code> 数组中，而更多的实例都会存储在 <code>_disposables</code> 中：</p>

<p><img src="https://img.nju520.me/2017-01-30-RACCompoundDisposable.png-1000width" alt="RACCompoundDisposable" /></p>

<p><code>RACCompoundDisposable</code> 在使用 <code>-initWithDisposables:</code>初始化时，会初始化两个 <code>RACDisposable</code> 的位置用于加速销毁订阅的过程，同时为了不浪费内存空间，在默认情况下只占用两个位置：</p>

<pre><code class="language-objectivec">- (instancetype)initWithDisposables:(NSArray *)otherDisposables {
	self = [self init];

	[otherDisposables enumerateObjectsUsingBlock:^(RACDisposable *disposable, NSUInteger index, BOOL *stop) {
		self-&gt;_inlineDisposables[index] = disposable;
		if (index == RACCompoundDisposableInlineCount - 1) *stop = YES;
	}];

	if (otherDisposables.count &gt; RACCompoundDisposableInlineCount) {
		_disposables = RACCreateDisposablesArray();

		CFRange range = CFRangeMake(RACCompoundDisposableInlineCount, (CFIndex)otherDisposables.count - RACCompoundDisposableInlineCount);
		CFArrayAppendArray(_disposables, (__bridge CFArrayRef)otherDisposables, range);
	}

	return self;
}
</code></pre>

<p>如果传入的 <code>otherDisposables</code> 多于 <code>RACCompoundDisposableInlineCount</code>，就会创建一个新的 <code>CFMutableArrayRef</code> 引用，并将剩余的 <code>RACDisposable</code> 全部传入这个数组中。</p>

<p>在 <code>RACCompoundDisposable</code> 中另一个值得注意的方法就是 <code>-addDisposable:</code></p>

<pre><code class="language-objectivec">- (void)addDisposable:(RACDisposable *)disposable {
	if (disposable == nil || disposable.disposed) return;

	BOOL shouldDispose = NO;

	pthread_mutex_lock(&amp;_mutex);
	{
		if (_disposed) {
			shouldDispose = YES;
		} else {
			for (unsigned i = 0; i &lt; RACCompoundDisposableInlineCount; i++) {
				if (_inlineDisposables[i] == nil) {
					_inlineDisposables[i] = disposable;
					goto foundSlot;
				}
			}

			if (_disposables == NULL) _disposables = RACCreateDisposablesArray();
			CFArrayAppendValue(_disposables, (__bridge void *)disposable);
		foundSlot:;
		}
	}
	pthread_mutex_unlock(&amp;_mutex);
	if (shouldDispose) [disposable dispose];
}
</code></pre>

<p>在向 <code>RACCompoundDisposable</code> 中添加新的 <code>RACDisposable</code> 对象时，会先尝试在 <code>_inlineDisposables</code> 数组中寻找空闲的位置，如果没有找到，就会加入到 <code>_disposables</code> 中；但是，在添加 <code>RACDisposable</code> 的过程中也难免遇到当前 <code>RACCompoundDisposable</code> 已经 <code>dispose</code> 的情况，而这时就会直接 <code>-dispose</code> 刚刚加入的对象。</p>

<h3 id="订阅的销毁过程">订阅的销毁过程</h3>

<p>在了解了 ReactiveCocoa 中与订阅销毁相关的类，我们就可以继续对 <code>-bind:</code> 方法的分析了，之前在分析该方法时省略了 <code>-bind:</code> 在执行过程中是如何处理订阅的清理和销毁的，所以会省略对于正常值和错误的处理过程，首先来看一下简化后的代码：</p>

<pre><code class="language-objectivec">- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block {
    return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) {
        RACSignalBindBlock bindingBlock = block();
        __block volatile int32_t signalCount = 1;
        RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];

        void (^completeSignal)(RACDisposable *) = ...
        void (^addSignal)(RACSignal *) = ...

        RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];
        [compoundDisposable addDisposable:selfDisposable];
        RACDisposable *bindingDisposable = [self subscribeNext:^(id x) {
            BOOL stop = NO;
            id signal = bindingBlock(x, &amp;stop);

            if (signal != nil) addSignal(signal);
            if (signal == nil || stop) {
                [selfDisposable dispose];
                completeSignal(selfDisposable);
            }
        } completed:^{
            completeSignal(selfDisposable);
        }];
        selfDisposable.disposable = bindingDisposable;
        return compoundDisposable;
    }] setNameWithFormat:@"[%@] -bind:", self.name];
}
</code></pre>

<p>在简化的代码中，订阅的清理是由一个 <code>RACCompoundDisposable</code> 的实例负责的，向这个实例中添加 <code>RACSerialDisposable</code> 以及 <code>RACDisposable</code> 对象，并在 <code>RACCompoundDisposable</code> 销毁时销毁。</p>

<p><code>completeSignal</code> 和 <code>addSignal</code> 两个 block 主要负责处理新创建信号的清理工作：</p>

<pre><code class="language-objectivec">void (^completeSignal)(RACDisposable *) = ^(RACDisposable *finishedDisposable) {
    if (OSAtomicDecrement32Barrier(&amp;signalCount) == 0) {
        [subscriber sendCompleted];
        [compoundDisposable dispose];
    } else {
        [compoundDisposable removeDisposable:finishedDisposable];
    }
};

void (^addSignal)(RACSignal *) = ^(RACSignal *signal) {
    OSAtomicIncrement32Barrier(&amp;signalCount);
    RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];
    [compoundDisposable addDisposable:selfDisposable];
    RACDisposable *disposable = [signal completed:^{
        completeSignal(selfDisposable);
    }];
    selfDisposable.disposable = disposable;
};
</code></pre>

<p>先通过一个例子来看一下 <code>-bind:</code> 方法调用之后，订阅是如何被清理的：</p>

<pre><code class="language-objectivec">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
    [subscriber sendNext:@1];
    [subscriber sendNext:@2];
    [subscriber sendCompleted];
    return [RACDisposable disposableWithBlock:^{
        NSLog(@"Original Signal Dispose.");
    }];
}];
RACSignal *bindSignal = [signal bind:^RACSignalBindBlock _Nonnull{
    return ^(NSNumber *value, BOOL *stop) {
        NSNumber *returnValue = @(value.integerValue);
        return [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
            for (NSInteger i = 0; i &lt; value.integerValue; i++) [subscriber sendNext:returnValue];
            [subscriber sendCompleted];
            return [RACDisposable disposableWithBlock:^{
                NSLog(@"Binding Signal Dispose.");
            }];
        }];
    };
}];
[bindSignal subscribeNext:^(id  _Nullable x) {
    NSLog(@"%@", x);
}];
</code></pre>

<p>在每个订阅创建以及所有的值发送之后，订阅就会被就地销毁，调用 <code>disposeBlock</code>，并从 <code>RACCompoundDisposable</code> 实例中移除：</p>

<pre><code class="language-objectivec">1
Binding Signal Dispose.
2
2
Binding Signal Dispose.
Original Signal Dispose.
</code></pre>

<p>原订阅的销毁时间以及绑定信号的控制是由 <code>SignalCount</code> 控制的，其表示 <code>RACCompoundDisposable</code> 中的 <code>RACSerialDisposable</code> 实例的个数，在每次有新的订阅被创建时都会向 <code>RACCompoundDisposable</code> 加入一个新的 <code>RACSerialDisposable</code>，并在订阅发送结束时从数组中移除，整个过程用图示来表示比较清晰：</p>

<p><img src="https://img.nju520.me/2017-01-30-RACSignal-Bind-Disposable.png-1000width" alt="RACSignal-Bind-Disposable" /></p>

<blockquote>
  <p>紫色的 <code>RACSerialDisposable</code> 为原订阅创建的对象，灰色的为新信号订阅的对象。</p>
</blockquote>

<h2 id="总结">总结</h2>

<p>这是整个 ReactiveCocoa 源代码分析系列文章的第一篇，想写一个跟这个系列有关的代码已经很久了，文章中对于 <code>RACSignal</code> 进行了一些简单的介绍，项目中绝大多数的方法都是很简洁的，行数并不多，代码的组织方式也很易于理解。虽然没有太多让人意外的东西，不过整个工程还是很值得阅读的。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="http://learnyouahaskell.com/a-fistful-of-monads">A Fistful of Monads</a></li>
  <li><a href="http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming/1030631#1030631">What is (functional) reactive programming?</a></li>
</ul>

<h2 id="方法实现对照表">方法实现对照表</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">方法</th>
      <th style="text-align: center">实现</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code>+return:</code></td>
      <td style="text-align: center"><a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/1180ab256000573ef82141e5d40e9b9c35dfd69c/ReactiveObjC/RACSignal.m#L89-L91">RACSignal.m#L89-L91</a></td>
    </tr>
    <tr>
      <td style="text-align: center"><code>-bind:</code></td>
      <td style="text-align: center"><a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/1180ab256000573ef82141e5d40e9b9c35dfd69c/ReactiveObjC/RACSignal.m#L93-L176">RACSignal.m#L93-176</a></td>
    </tr>
  </tbody>
</table>

<blockquote>

  <p>Source: http://nju520.me/racsignal</p>
</blockquote>

  ]]></description>
</item>


  </channel>
</rss>
