<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    
    <title>nju520.me</title>
    
    <link>http://localhost:4000</link>
    <description>nju520's Blog</description>
    <language>en-uk</language>
    <managingEditor> nju520</managingEditor>
    <atom:link href="rss" rel="self" type="application/rss+xml" />
    
<item>
  <title>预加载与智能预加载（iOS）</title>
  <link>//preload</link>
  <author>nju520</author>
  <pubDate>2016-11-04T12:24:50+08:00</pubDate>
  <guid>//preload</guid>
  <description><![CDATA[
  <blockquote>
  <p>前两次的分享分别介绍了 ASDK 对于渲染的优化以及 ASDK 中使用的另一种布局模型；这两个新机制的引入分别解决了 iOS 在主线程渲染视图以及 Auto Layout 的性能问题，而这一次讨论的主要内容是 ASDK 如何预先请求服务器数据，达到看似无限滚动列表的效果的。</p>
</blockquote>

<p>这篇文章是 ASDK 系列中的最后一篇，文章会介绍 iOS 中几种<em>预加载</em>的方案，以及 ASDK 中是如何处理预加载的。</p>

<p>不过，在介绍 ASDK 中实现<strong>智能预加载</strong>的方式之前，文章中会介绍几种简单的预加载方式，方便各位开发者进行对比，选择合适的机制实现预加载这一功能。</p>

<h2 id="网络与性能">网络与性能</h2>

<p>ASDK 通过在渲染视图和布局方面的优化已经可以使应用在任何用户的疯狂操作下都能保持 60 FPS 的流畅程度，也就是说，我们已经充分的利用了当前设备的性能，调动各种资源加快视图的渲染。</p>

<p>但是，仅仅在 CPU 以及 GPU 方面的优化往往是远远不够的。在目前的软件开发中，很难找到一个<strong>没有任何网络请求</strong>的应用，哪怕是一个记账软件也需要服务器来同步保存用户的信息，防止资料的丢失；所以，只在渲染这一层面进行优化还不能让用户的体验达到最佳，因为网络请求往往是一个应用<strong>最为耗时以及昂贵</strong>的操作。</p>

<p><img src="https://img.nju520.me/2016-11-04-network.jpg-1000width" alt="network" /></p>

<p>每一个应用程序在运行时都可以看做是 CPU 在底层利用各种资源疯狂做加减法运算，其中最耗时的操作并不是进行加减法的过程，而是资源转移的过程。</p>

<blockquote>
  <p>举一个不是很恰当的例子，主厨（CPU）在炒一道菜（计算）时往往需要的时间并不多，但是菜的采购以及准备（资源的转移）会占用大量的时间，如果在每次炒菜之前，都由帮厨提前准备好所有的食材（缓存），那么做一道菜的时间就大大减少了。</p>
</blockquote>

<p>而提高资源转移的效率的最佳办法就是使用多级缓存：</p>

<p><img src="https://img.nju520.me/2016-11-04-multi-layer.jpg-1000width" alt="multi-laye" /></p>

<p>从上到下，虽然容量越来越大，直到 Network 层包含了整个互联网的内容，但是访问时间也是直线上升；在 Core 或者三级缓存中的资源可能访问只需要几个或者几十个时钟周期，但是网络中的资源就<strong>远远</strong>大于这个数字，几分钟、几小时都是有可能的。</p>

<p>更糟糕的是，因为天朝的网络情况及其复杂，运营商劫持 DNS、404 无法访问等问题导致网络问题极其严重；而如何加速网络请求成为了很多移动端以及 Web 应用的重要问题。</p>

<h2 id="预加载">预加载</h2>

<p>本文就会提供一种<strong>缓解网络请求缓慢导致用户体验较差</strong>的解决方案，也就是预加载；在本地真正需要渲染界面之前就通过网络请求获取资源存入内存或磁盘。</p>

<blockquote>
  <p>预加载并不能彻底解决网络请求缓慢的问题，而是通过提前发起网络请求<strong>缓解</strong>这一问题。</p>
</blockquote>

<p>那么，预加载到底要关注哪些方面的问题呢？总结下来，有以下两个关注点：</p>

<ul>
  <li>需要预加载的资源</li>
  <li>预加载发出的时间</li>
</ul>

<p>文章会根据上面的两个关注点，分别分析四种预加载方式的实现原理以及优缺点：</p>

<ol>
  <li>无限滚动列表</li>
  <li>threshold</li>
  <li>惰性加载</li>
  <li>智能预加载</li>
</ol>

<h3 id="无限滚动列表">无限滚动列表</h3>

<p>其实，无限滚动列表并不能算是一种预加载的实现原理，它只是提供一种分页显示的方法，在每次滚动到 <code>UITableView</code> 底部时，才会开始发起网络请求向服务器获取对应的资源。</p>

<p>虽然这种方法并不是预加载方式的一种，放在这里的主要作用是作为对比方案，看看如果不使用预加载的机制，用户体验是什么样的。</p>

<p><img src="https://img.nju520.me/2016-11-04-infinite-list.jpg-1000width" alt="infinite-list" /></p>

<p>很多客户端都使用了分页的加载方式，并没有添加额外的预加载的机制来提升用户体验，虽然这种方式并不是不能接受，不过每次滑动到视图底部之后，总要等待网络请求的完成确实对视图的流畅性有一定影响。</p>

<p>虽然仅仅使用无限滚动列表而不提供预加载机制会在一定程度上影响用户体验，不过，这种<strong>需要用户等待几秒钟</strong>的方式，在某些时候确实非常好用，比如：投放广告。</p>

<p><img src="https://img.nju520.me/2016-11-04-advertise.jpg-1000width" alt="advertise" /></p>

<blockquote>
  <p>QQ 空间就是这么做的，它们<strong>投放的广告基本都是在整个列表的最底端</strong>，这样，当你滚动到列表最下面的时候，就能看到你急需的租房、租车、同城交友、信用卡办理、只有 iPhone 能玩的游戏以及各种奇奇怪怪的辣鸡广告了，很好的解决了我们的日常生活中的各种需求。（哈哈哈哈哈哈哈哈哈哈哈哈哈）</p>
</blockquote>

<h3 id="threshold">Threshold</h3>

<p>使用 Threshold 进行预加载是一种最为常见的预加载方式，知乎客户端就使用了这种方式预加载条目，而其原理也非常简单，根据当前 <code>UITableView</code> 的所在位置，除以目前整个 <code>UITableView.contentView</code> 的高度，来判断当前是否需要发起网络请求：</p>

<pre><code class="language-swift">let threshold: CGFloat = 0.7
var currentPage = 0

override func scrollViewDidScroll(_ scrollView: UIScrollView) {
    let current = scrollView.contentOffset.y + scrollView.frame.size.height
    let total = scrollView.contentSize.height
    let ratio = current / total

    if ratio &gt;= threshold {
        currentPage += 1
        print("Request page \(currentPage) from server.")
    }
}
</code></pre>

<p>上面的代码在当前页面已经划过了 70% 的时候，就请求新的资源，加载数据；但是，仅仅使用这种方法会有另一个问题，尤其是当列表变得很长时，十分明显，比如说：用户从上向下滑动，总共加载了 5 页数据：</p>

<p><img src="https://img.nju520.me/2016-11-04-threshold-table.png-1000width" alt="threshold-table" /></p>

<ul>
  <li>Page 当前总页数；</li>
  <li>Total 当前 <code>UITableView</code> 总元素个数；</li>
  <li>Threshold 网络请求触发时间；</li>
  <li>Diff 表示最新加载的页面被浏览了多少；</li>
</ul>

<p>当 Threshold 设置为 70% 的时候，其实并不是单页 70%，这就会导致<strong>新加载的页面都没有看，应用就会发出另一次请求，获取新的资源</strong>。</p>

<h4 id="动态的-threshold">动态的 Threshold</h4>

<p>解决这个问题的办法，还是比较简单的，通过修改上面的代码，将 Threshold 变成一个动态的值，随着页数的增长而增长：</p>

<pre><code class="language-swift">let threshold:   CGFloat = 0.7
let itemPerPage: CGFloat = 10
var currentPage: CGFloat = 0

override func scrollViewDidScroll(_ scrollView: UIScrollView) {
    let current = scrollView.contentOffset.y + scrollView.frame.size.height
    let total = scrollView.contentSize.height
    let ratio = current / total

    let needRead = itemPerPage * threshold + currentPage * itemPerPage
    let totalItem = itemPerPage * (currentPage + 1)
    let newThreshold = needRead / totalItem

    if ratio &gt;= newThreshold {
        currentPage += 1
        print("Request page \(currentPage) from server.")
    }
}
</code></pre>

<p>通过这种方法获取的 <code>newThreshold</code> 就会随着页数的增长而动态的改变，解决了上面出现的问题：</p>

<p><img src="https://img.nju520.me/2016-11-04-dynamic-threshold.jpeg" alt="dynamic-threshold" /></p>

<h3 id="惰性加载">惰性加载</h3>

<p>使用 Threshold 进行预加载其实已经适用于大多数应用场景了；但是，下面介绍的方式，<em>惰性加载</em>能够有针对性的加载用户“会看到的” Cell。</p>

<blockquote>
  <p><em>惰性加载</em>，就是在用户滚动的时候会对用户滚动结束的区域进行计算，只加载目标区域中的资源。</p>
</blockquote>

<p>用户在飞速滚动中会看到巨多的空白条目，因为用户并不想阅读这些条目，所以，我们并不需要真正去加载这些内容，只需要在 <code>ASTableView/ASCollectionView</code> 中只根据用户滚动的目标区域惰性加载资源。</p>

<p><img src="https://img.nju520.me/2016-11-04-lazy-loading.png-1000width" alt="lazy-loading" /></p>

<p>惰性加载的方式不仅仅减少了网络请求的冗余资源，同时也减少了渲染视图、数据绑定的耗时。</p>

<p>计算用户滚动的目标区域可以直接使用下面的代理方法获取：</p>

<pre><code class="language-swift">let markedView = UIView()
let rowHeight: CGFloat = 44.0

override func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer&lt;CGPoint&gt;) {
    let targetOffset = targetContentOffset.pointee
    let targetRect = CGRect(origin: targetOffset, size: scrollView.frame.size)

    markedView.frame = targetRect
    markedView.backgroundColor = UIColor.black.withAlphaComponent(0.1)
    tableView.addSubview(markedView)

    var indexPaths: [IndexPath] = []

    let startIndex = Int(targetRect.origin.y / rowHeight)
    let endIndex = Int((targetRect.origin.y + tableView.frame.height) / rowHeight)

    for index in startIndex...endIndex {
        indexPaths.append(IndexPath(row: index, section: 0))
    }

    print("\(targetRect) \(indexPaths)")
}
</code></pre>

<blockquote>
  <p>以上代码只会大致计算出目标区域内的 <code>IndexPath</code> 数组，并不会展开新的 page，同时会使用浅黑色标记目标区域。</p>
</blockquote>

<p>当然，惰性加载的实现也并不只是这么简单，不仅需要客户端的工作，同时因为需要<strong>加载特定 offset 资源</strong>，也需要服务端提供相应 API 的支持。</p>

<p>虽然惰性加载的方式能够按照用户的需要请求对应的资源，但是，在用户滑动 <code>UITableView</code> 的过程中会看到大量的空白条目，这样的用户体验是否可以接受又是值得考虑的问题了。</p>

<h3 id="智能预加载">智能预加载</h3>

<p>终于到了智能预加载的部分了，当我第一次得知 ASDK 可以通过滚动的方向预加载不同数量的内容，感觉是非常神奇的。</p>

<p>&lt;img src=”https://img.nju520.me/2016-11-04-intelligent-preloading-ranges-with-names.png-1000width” height=500&gt;</p>

<p>如上图所示 ASDK 把正在滚动的 ` ASTableView/ASCollectionView` 划分为三种状态：</p>

<ul>
  <li>Fetch Data</li>
  <li>Display</li>
  <li>Visible</li>
</ul>

<p>上面的这三种状态都是由 ASDK 来管理的，而每一个 <code>ASCellNode</code> 的状态都是由 <code>ASRangeController</code> 控制，所有的状态都对应一个 <code>ASInterfaceState</code>：</p>

<ul>
  <li><code>ASInterfaceStatePreload</code> 当前元素貌似要显示到屏幕上，需要从磁盘或者网络请求数据；</li>
  <li><code>ASInterfaceStateDisplay</code> 当前元素非常可能要变成可见的，需要进行异步绘制；</li>
  <li><code>ASInterfaceStateVisible</code> 当前元素最少在屏幕上显示了 1px</li>
</ul>

<p>当用户滚动当前视图时，<code>ASRangeController</code> 就会修改不同区域内元素的状态：</p>

<p>&lt;img src=”https://img.nju520.me/2016-11-04-intelligent-preloading-ranges-screenfuls.png-1000width” height=500&gt;</p>

<p>上图是用户在向下滑动时，<code>ASCellNode</code> 是如何被标记的，假设<strong>当前视图可见的范围高度为 1</strong>，那么在默认情况下，五个区域会按照上图的形式进行划分：</p>

<p><img src="https://img.nju520.me/2016-11-04-buffer-size.png-1000width" alt="buffer-size" /></p>

<p>在滚动方向（Leading）上 Fetch Data 区域会是非滚动方向（Trailing）的两倍，ASDK 会根据滚动方向的变化实时改变缓冲区的位置；在向下滚动时，下面的 Fetch Data 区域就是上面的两倍，向上滚动时，上面的 Fetch Data 区域就是下面的两倍。</p>

<blockquote>
  <p>这里的两倍并不是一个确定的数值，ASDK 会根据当前设备的不同状态，改变不同区域的大小，但是<strong>滚动方向的区域总会比非滚动方向大一些</strong>。</p>
</blockquote>

<p>智能预加载能够根据当前的滚动方向，自动改变当前的工作区域，选择合适的区域提前触发请求资源、渲染视图以及异步布局等操作，让视图的滚动达到真正的流畅。</p>

<h4 id="原理">原理</h4>

<p>在 ASDK 中整个智能预加载的概念是由三个部分来统一协调管理的：</p>

<ul>
  <li><code>ASRangeController</code></li>
  <li><code>ASDataController</code></li>
  <li><code>ASTableView</code> 与 <code>ASTableNode</code></li>
</ul>

<p>对智能预加载实现的分析，也是根据这三个部分来介绍的。</p>

<h4 id="工作区域的管理">工作区域的管理</h4>

<p><code>ASRangeController</code> 是 <code>ASTableView</code> 以及 <code>ASCollectionView</code> 内部使用的控制器，主要用于监控视图的可见区域、维护工作区域、触发网络请求以及绘制、单元格的异步布局。</p>

<p>以 <code>ASTableView</code> 为例，在视图进行滚动时，会触发 <code>-[UIScrollView scrollViewDidScroll:]</code> 代理方法：</p>

<pre><code class="language-objectivec">- (void)scrollViewDidScroll:(UIScrollView *)scrollView {
  ASInterfaceState interfaceState = [self interfaceStateForRangeController:_rangeController];
  if (ASInterfaceStateIncludesVisible(interfaceState)) {
    [_rangeController updateCurrentRangeWithMode:ASLayoutRangeModeFull];
  }
  ...
}
</code></pre>

<blockquote>
  <p>每一个 <code>ASTableView</code> 的实例都持有一个 <code>ASRangeController</code> 以及 <code>ASDataController</code> 用于管理工作区域以及数据更新。</p>
</blockquote>

<p>ASRangeController 最重要的私有方法 <code>-[ASRangeController _updateVisibleNodeIndexPaths]</code> 一般都是因为上面的方法间接调用的：</p>

<pre><code class="language-objectivec">-[ASRangeController updateCurrentRangeWithMode:]
    -[ASRangeController setNeedsUpdate]
        -[ASRangeController updateIfNeeded]
            -[ASRangeController _updateVisibleNodeIndexPaths]
</code></pre>

<p>调用栈中间的过程其实并不重要，最后的私有方法的主要工作就是计算不同区域内 Cell 的 <code>NSIndexPath</code> 数组，然后更新对应 Cell 的状态 <code>ASInterfaceState</code> 触发对应的操作。</p>

<p>我们将这个私有方法的实现分开来看：</p>

<pre><code class="language-objectivec">- (void)_updateVisibleNodeIndexPaths {
  NSArray&lt;NSArray *&gt; *allNodes = [_dataSource completedNodes];
  NSUInteger numberOfSections = [allNodes count];

  NSArray&lt;NSIndexPath *&gt; *visibleNodePaths = [_dataSource visibleNodeIndexPathsForRangeController:self];

  ASScrollDirection scrollDirection = [_dataSource scrollDirectionForRangeController:self];
  if (_layoutControllerImplementsSetViewportSize) {
    [_layoutController setViewportSize:[_dataSource viewportSizeForRangeController:self]];
  }

  if (_layoutControllerImplementsSetVisibleIndexPaths) {
    [_layoutController setVisibleNodeIndexPaths:visibleNodePaths];
  }
  ...
}
</code></pre>

<p>当前 <code>ASRangeController</code> 的数据源以及代理就是 <code>ASTableView</code>，这段代码首先就获取了完成计算和布局的 <code>ASCellNode</code> 以及可见的 <code>ASCellNode</code> 的 <code>NSIndexPath</code>：</p>

<pre><code class="language-objectivec">- (void)_updateVisibleNodeIndexPaths {  
  NSArray&lt;ASDisplayNode *&gt; *currentSectionNodes = nil;
  NSInteger currentSectionIndex = -1;
  NSUInteger numberOfNodesInSection = 0;

  NSSet&lt;NSIndexPath *&gt; *visibleIndexPaths = [NSSet setWithArray:visibleNodePaths];
  NSSet&lt;NSIndexPath *&gt; *displayIndexPaths = nil;
  NSSet&lt;NSIndexPath *&gt; *preloadIndexPaths = nil;

  NSMutableOrderedSet&lt;NSIndexPath *&gt; *allIndexPaths = [[NSMutableOrderedSet alloc] initWithSet:visibleIndexPaths];

  ASLayoutRangeMode rangeMode = _currentRangeMode;

  ASRangeTuningParameters parametersPreload = [_layoutController tuningParametersForRangeMode:rangeMode
                                                                                      rangeType:ASLayoutRangeTypePreload];
  if (ASRangeTuningParametersEqualToRangeTuningParameters(parametersPreload, ASRangeTuningParametersZero)) {
    preloadIndexPaths = visibleIndexPaths;
  } else {
    preloadIndexPaths = [_layoutController indexPathsForScrolling:scrollDirection
                                                          rangeMode:rangeMode
                                                          rangeType:ASLayoutRangeTypePreload];
  }

  #: displayIndexPaths 的计算和 preloadIndexPaths 非常类似

  [allIndexPaths unionSet:displayIndexPaths];
  [allIndexPaths unionSet:preloadIndexPaths];
  ...
}
</code></pre>

<p>预加载以及展示部分的 <code>ASRangeTuningParameters</code> 都是以二维数组的形式保存在 <code>ASAbstractLayoutController</code> 中的：</p>

<p><img src="https://img.nju520.me/2016-11-04-aslayout-range-mode-display-preload.jpeg" alt="aslayout-range-mode-display-preload" /></p>

<p>在获取了 <code>ASRangeTuningParameters</code> 之后，ASDK 也会通过 <code>ASFlowLayoutController</code> 的方法 <code>-[ASFlowLayoutController indexPathsForScrolling:rangeMode:rangeType:]</code> 获取 <code>NSIndexPath</code> 对象的集合：</p>

<pre><code class="language-objectivec">- (NSSet *)indexPathsForScrolling:(ASScrollDirection)scrollDirection rangeMode:(ASLayoutRangeMode)rangeMode rangeType:(ASLayoutRangeType)rangeType {
  #: 获取 directionalBuffer 以及 viewportDirectionalSize
  ASIndexPath startPath = [self findIndexPathAtDistance:(-directionalBuffer.negativeDirection * viewportDirectionalSize)
                                          fromIndexPath:_visibleRange.start];
  ASIndexPath endPath   = [self findIndexPathAtDistance:(directionalBuffer.positiveDirection * viewportDirectionalSize)
                                          fromIndexPath:_visibleRange.end];

  NSMutableSet *indexPathSet = [[NSMutableSet alloc] init];
  NSArray *completedNodes = [_dataSource completedNodes];
  ASIndexPath currPath = startPath;
  while (!ASIndexPathEqualToIndexPath(currPath, endPath)) {
    [indexPathSet addObject:[NSIndexPath indexPathWithASIndexPath:currPath]];
    currPath.row++;

    while (currPath.row &gt;= [(NSArray *)completedNodes[currPath.section] count] &amp;&amp; currPath.section &lt; endPath.section) {
      currPath.row = 0;
      currPath.section++;
    }
  }
  [indexPathSet addObject:[NSIndexPath indexPathWithASIndexPath:endPath]];
  return indexPathSet;
}
</code></pre>

<p>方法的执行过程非常简单，根据 <code>ASRangeTuningParameters</code> 获取该滚动方向上的缓冲区大小，在区域内遍历所有的 <code>ASCellNode</code> 查看其是否在当前区域内，然后加入数组中。</p>

<p>到这里，所有工作区域 <code>visibleIndexPaths</code> <code>displayIndexPaths</code> 以及 <code>preloadIndexPaths</code> 都已经获取到了；接下来，就到了遍历 <code>NSIndexPath</code>，修改结点状态的过程了；</p>

<pre><code class="language-objectivec">- (void)_updateVisibleNodeIndexPaths {
  ...
  for (NSIndexPath *indexPath in allIndexPaths) {
    ASInterfaceState interfaceState = ASInterfaceStateMeasureLayout;

    if (ASInterfaceStateIncludesVisible(selfInterfaceState)) {
      if ([visibleIndexPaths containsObject:indexPath]) {
        interfaceState |= (ASInterfaceStateVisible | ASInterfaceStateDisplay | ASInterfaceStatePreload);
      } else {
        if ([preloadIndexPaths containsObject:indexPath]) {
          interfaceState |= ASInterfaceStatePreload;
        }
        if ([displayIndexPaths containsObject:indexPath]) {
          interfaceState |= ASInterfaceStateDisplay;
        }
      }
    }
</code></pre>

<p>根据当前 <code>ASTableView</code> 的状态以及 <code>NSIndexPath</code> 所在的区域，打开 <code>ASInterfaceState</code> 对应的位。</p>

<pre><code class="language-objectivec">    NSInteger section = indexPath.section;
    NSInteger row     = indexPath.row;

    if (section &gt;= 0 &amp;&amp; row &gt;= 0 &amp;&amp; section &lt; numberOfSections) {
      if (section != currentSectionIndex) {
        currentSectionNodes = allNodes[section];
        numberOfNodesInSection = [currentSectionNodes count];
        currentSectionIndex = section;
      }

      if (row &lt; numberOfNodesInSection) {
        ASDisplayNode *node = currentSectionNodes[row];

        if (node.interfaceState != interfaceState) {
          BOOL nodeShouldScheduleDisplay = [node shouldScheduleDisplayWithNewInterfaceState:interfaceState];
          [node recursivelySetInterfaceState:interfaceState];

          if (nodeShouldScheduleDisplay) {
            [self registerForNodeDisplayNotificationsForInterfaceStateIfNeeded:selfInterfaceState];
            if (_didRegisterForNodeDisplayNotifications) {
              _pendingDisplayNodesTimestamp = CFAbsoluteTimeGetCurrent();
            }
          }
        }
      }
    }
  }
  ...
}
</code></pre>

<p>后面的一部分代码就会递归的设置结点的 <code>interfaceState</code>，并且在当前 <code>ASRangeController</code> 的 <code>ASLayoutRangeMode</code> 发生改变时，发出通知，调用 <code>-[ASRangeController _updateVisibleNodeIndexPaths]</code> 私有方法，更新结点的状态。</p>

<pre><code class="language-objectivec">- (void)scheduledNodesDidDisplay:(NSNotification *)notification {
  CFAbsoluteTime notificationTimestamp = ((NSNumber *) notification.userInfo[ASRenderingEngineDidDisplayNodesScheduledBeforeTimestamp]).doubleValue;
  if (_pendingDisplayNodesTimestamp &lt; notificationTimestamp) {
    [[NSNotificationCenter defaultCenter] removeObserver:self name:ASRenderingEngineDidDisplayScheduledNodesNotification object:nil];
    _didRegisterForNodeDisplayNotifications = NO;

    [self setNeedsUpdate];
  }
}
</code></pre>

<h4 id="数据的加载和更新">数据的加载和更新</h4>

<p><code>ASTableNode</code> 既然是对 <code>ASTableView</code> 的封装，那么表视图中显示的数据仍然需要数据源来提供，而在 ASDK 中这一机制就比较复杂：</p>

<p><img src="https://img.nju520.me/2016-11-04-astableview-data.png-1000width" alt="astableview-data" /></p>

<p>整个过程是由四部分协作完成的，<code>Controller</code>、<code>ASTableNode</code>、<code>ASTableView</code> 以及 <code>ASDataController</code>，网络请求发起并返回数据之后，会调用 <code>ASTableNode</code> 的 API 执行插入行的方法，最后再通过 <code>ASTableView</code> 的同名方法，执行管理和更新节点数据的 <code>ASDataController</code> 的方法：</p>

<pre><code class="language-objectivec">- (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withAnimationOptions:(ASDataControllerAnimationOptions)animationOptions {
  dispatch_group_wait(_editingTransactionGroup, DISPATCH_TIME_FOREVER);

  NSArray *sortedIndexPaths = [indexPaths sortedArrayUsingSelector:@selector(compare:)];
  NSMutableArray&lt;ASIndexedNodeContext *&gt; *contexts = [[NSMutableArray alloc] initWithCapacity:indexPaths.count];

  __weak id&lt;ASEnvironment&gt; environment = [self.environmentDelegate dataControllerEnvironment];

  for (NSIndexPath *indexPath in sortedIndexPaths) {
    ASCellNodeBlock nodeBlock = [_dataSource dataController:self nodeBlockAtIndexPath:indexPath];
    ASSizeRange constrainedSize = [self constrainedSizeForNodeOfKind:ASDataControllerRowNodeKind atIndexPath:indexPath];
    [contexts addObject:[[ASIndexedNodeContext alloc] initWithNodeBlock:nodeBlock
                                                              indexPath:indexPath
                                               supplementaryElementKind:nil
                                                        constrainedSize:constrainedSize
                                                            environment:environment]];
  }
  ASInsertElementsIntoMultidimensionalArrayAtIndexPaths(_nodeContexts[ASDataControllerRowNodeKind], sortedIndexPaths, contexts);
  dispatch_group_async(_editingTransactionGroup, _editingTransactionQueue, ^{
    [self _batchLayoutAndInsertNodesFromContexts:contexts withAnimationOptions:animationOptions];
  });
}
</code></pre>

<p>上面的方法总共做了几件事情：</p>

<ol>
  <li>遍历所有要插入的 <code>NSIndexPath</code> 数组，然后从数据源中获取对应的 <code>ASCellNodeBlock</code>；</li>
  <li>获取每一个 <code>NSIndexPath</code> 对应的单元的大小 <code>constrainedSize</code>（在图中没有表现出来）；</li>
  <li>初始化一堆 <code>ASIndexedNodeContext</code> 实例，然后加入到控制器维护的 <code>_nodeContexts</code> 数组中；</li>
  <li>将节点插入到 <code>_completedNodes</code> 中，用于之后的缓存，以及提供给 <code>ASTableView</code> 的数据源代理方法使用；</li>
</ol>

<p><code>ASTableView</code> 会将数据源协议的代理设置为自己，而最常见的数据源协议在 <code>ASTableView</code> 中的实现是这样的：</p>

<pre><code class="language-objectivec">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
  _ASTableViewCell *cell = [self dequeueReusableCellWithIdentifier:kCellReuseIdentifier forIndexPath:indexPath];
  cell.delegate = self;

  ASCellNode *node = [_dataController nodeAtCompletedIndexPath:indexPath];
  if (node) {
    [_rangeController configureContentView:cell.contentView forCellNode:node];
    cell.node = node;
    cell.backgroundColor = node.backgroundColor;
    cell.selectionStyle = node.selectionStyle;
    cell.clipsToBounds = node.clipsToBounds;
  }

  return cell;
}
</code></pre>

<p>上面的方法会从 <code>ASDataController</code> 中的 <code>_completedNodes</code> 中获取元素的数量信息：</p>

<p><img src="https://img.nju520.me/2016-11-04-cellforrowatindexpath.jpg-1000width" alt="cellforrowatindexpath" /></p>

<blockquote>
  <p>在内部 <code>_externalCompletedNodes</code> 与 <code>_completedNodes</code> 作用基本相同，在这里我们不对它们的区别进行分析以及解释。</p>
</blockquote>

<p>当 <code>ASTableView</code> 向数据源请求数据时，ASDK 就会从对应的 <code>ASDataController</code> 中取回最新的 <code>node</code>，添加在 <code>_ASTableViewCell</code> 的实例上显示出来。</p>

<h4 id="astableview-和-astablenode">ASTableView 和 ASTableNode</h4>

<p><code>ASTableView</code> 和 <code>ASTableNode</code> 的关系，其实就相当于 <code>CALayer</code> 和 <code>UIView</code> 的关系一样，后者都是前者的一个包装：</p>

<p><img src="https://img.nju520.me/2016-11-04-astableview-astablenode.jpg-1000width" alt="astableview-astablenode" /></p>

<p><code>ASTableNode</code> 为开发者提供了非常多的接口，其内部实现往往都是直接调用 <code>ASTableView</code> 的对应方法，在这里简单举几个例子：</p>

<pre><code class="language-objectivec">- (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation {
  [self.view insertSections:sections withRowAnimation:animation];
}

- (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation {
  [self.view deleteSections:sections withRowAnimation:animation];
}
</code></pre>

<p>如果你再去看 <code>ASTableView</code> 中方法的实现的话，会发现很多方法都是由 <code>ASDataController</code> 和 <code>ASRangeController</code> 驱动的，上面的两个方法的实现就是这样的：</p>

<pre><code class="language-objectivec">- (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation {
  if (sections.count == 0) { return; }
  [_dataController insertSections:sections withAnimationOptions:animation];
}

- (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation {
  if (sections.count == 0) { return; }
  [_dataController deleteSections:sections withAnimationOptions:animation];
}
</code></pre>

<p>到这里，整个智能预加载的部分就结束了，从<em>需要预加载的资源</em>以及<em>预加载发出的时间</em>两个方面来考虑，ASDK 在不同工作区域中合理标记了需要预加载的资源，并在节点状态改变时就发出请求，在用户体验上是非常优秀的。</p>

<h2 id="总结">总结</h2>

<p>ASDK 中的表视图以及智能预加载其实都是通过下面这四者共同实现的，上层只会暴露出 <code>ASTableNode</code> 的接口，所有的数据的批量更新、工作区域的管理都是在幕后由 <code>ASDataController</code> 以及 <code>ASRangeController</code> 这两个控制器协作完成。</p>

<p><img src="https://img.nju520.me/2016-11-04-multi-layer-asdk.jpg-1000width" alt="multi-layer-asdk" /></p>

<p>智能预加载的使用相比其它实现可能相对复杂，但是在笔者看来，ASDK 对于这一套机制的实现还是非常完善的，同时也提供了极其优秀的用户体验，不过同时带来的也是相对较高的学习成本。</p>

<p>如果真正要选择预加载的机制，笔者觉得最好从 Threshold 以及智能预加载两种方式中选择：</p>

<p><img src="https://img.nju520.me/2016-11-04-pros-cons.jpg-1000width" alt="pros-cons" /></p>

<p>这两种方式的选择，其实也就是实现复杂度和用户体验之间的权衡了。</p>

<blockquote>
  <p>Github Repo：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://nju520.me/preload</p>
</blockquote>

  ]]></description>
</item>

<item>
  <title>从 Auto Layout 的布局算法谈性能</title>
  <link>//layout-performance</link>
  <author>nju520</author>
  <pubDate>2016-08-31T21:52:25+08:00</pubDate>
  <guid>//layout-performance</guid>
  <description><![CDATA[
  <blockquote>
  <p>这是使用 ASDK 性能调优系列的第二篇文章，前一篇文章中讲到了如何提升 iOS 应用的渲染性能，你可以点击 <a href="https://github.com/nju520/iOS-Source-Code-Analyze/blob/master/contents/AsyncDisplayKit/提升%20iOS%20界面的渲染性能.md">这里</a> 了解这部分的内容。</p>
</blockquote>

<p>在上一篇文章中，我们提到了 iOS 界面的渲染过程以及如何对渲染过程进行优化。ASDK 的做法是将渲染绘制的工作抛到后台线程进行，并在每次 Runloop 结束时，将绘制结果交给 <code>CALayer</code> 进行展示。</p>

<p>而这篇文章就要从 iOS 中影响性能的另一大杀手，也就是万恶之源 Auto Layout（自动布局）来分析如何对 iOS 应用的性能进行优化以及 Auto Layout 到底为什么会影响性能？</p>

<p><img src="https://img.nju520.me/2016-08-31-box-layout.jpg-1000width" alt="box-layout" /></p>

<h2 id="把-auto-layout-批判一番">把 Auto Layout 批判一番</h2>

<p>由于在 2012 年苹果发布了 4.0 寸的 iPhone5，在 iOS 平台上出现了不同尺寸的移动设备，使得原有的 <code>frame</code> 布局方式无法很好地适配不同尺寸的屏幕，所以，为了解决这一问题 Auto Layout 就诞生了。</p>

<p>Auto Layout 的诞生并没有如同苹果的其它框架一样收到开发者的好评，它自诞生的第一天起就饱受 iOS 开发者的批评，其蹩脚、冗长的语法使得它在刚刚面世就被无数开发者吐槽，写了几个屏幕的代码都不能完成一个简单的布局，哪怕是 VFL（Visual Format Language）也拯救不了它。</p>

<p>真正使 Auto Layout 大规模投入使用的应该还是 <a href="https://github.com/SnapKit/Masonry">Masonry</a>，它使用了链式的语法对 Auto Layout 进行了很好的封装，使得 Auto Layout 更加简单易用；时至今日，开发者也在日常使用中发现了 Masonry 的各种问题，于是出现了各种各样的布局框架，不过这都是后话了。</p>

<p><img src="https://img.nju520.me/2016-08-31-masonry.jpg-1000width" alt="masonry" /></p>

<h2 id="auto-layout-的原理和-cassowary">Auto Layout 的原理和 Cassowary</h2>

<p>Auto Layout 的原理其实非常简单，在这里通过一个例子先简单的解释一下：</p>

<p><img src="https://img.nju520.me/2016-08-31-view-demonstrate.png-1000width" alt="view-demonstrate" /></p>

<p>iOS 中视图所需要的布局信息只有两个，分别是 <code>origin/center</code> 和 <code>size</code>，在这里我们以 <code>origin &amp; size</code> 为例，也就是 <code>frame</code> 时代下布局的需要的两个信息；这两个信息由四部分组成：</p>

<ul>
  <li><code>x</code> &amp; <code>y</code></li>
  <li><code>width</code> &amp; <code>height</code></li>
</ul>

<p>以左上角的 <code>(0, 0)</code> 为坐标的原点，找到坐标 <code>(x, y)</code>，然后绘制一个大小为 <code>(width, height)</code> 的矩形，这样就完成了一个最简单的布局。而 Auto Layout 的布局方式与上面所说的 <code>frame</code> 有些不同，<code>frame</code> 表示与父视图之间的绝对距离，但是 Auto Layout 中大部分的约束都是<strong>描述性的</strong>，表示视图间相对距离，以上图为例：</p>

<pre><code class="language-objectivec">A.left = Superview.left + 50
A.top  = Superview.top + 30
A.width  = 100
A.height = 100

B.left = (A.left + A.width)/(A.right) + 30
B.top  = A.top
B.width  = A.width
B.height = A.height
</code></pre>

<p>虽然上面的约束很好的表示了各个视图之间的关系，但是 Auto Layout 实际上并没有改变原有的 Hard-Coded 形式的布局方式，只是将原有没有太多意义的 <code>(x, y)</code> 值，变成了描述性的代码。</p>

<p>我们仍然需要知道布局信息所需要的四部分 <code>x</code>、<code>y</code>、<code>width</code> 以及 <code>height</code>。换句话说，我们要求解上述的<strong>八元一次</strong>方程组，将每个视图所需要的信息解出来；Cocoa 会在运行时求解上述的方程组，最终使用 <code>frame</code> 来绘制视图。</p>

<p><img src="https://img.nju520.me/2016-08-31-layout-phase.png-1000width" alt="layout-phase" /></p>

<h3 id="cassowary-算法">Cassowary 算法</h3>

<p>在上世纪 90 年代，一个名叫 <a href="https://en.wikipedia.org/wiki/Cassowary_(software)">Cassowary</a> 的布局算法解决了用户界面的布局问题，它通过将布局问题抽象成线性等式和不等式约束来进行求解。</p>

<p>Auto Layout 其实就是对 Cassowary 算法的一种实现，但是这里并不会对它展开介绍，有兴趣的读者可以在文章最后的 Reference 中了解一下 Cassowary 算法相关的文章。</p>

<blockquote>
  <p>Auto Layout 的原理就是对<strong>线性方程组或者不等式</strong>的求解。</p>
</blockquote>

<h2 id="auto-layout-的性能">Auto Layout 的性能</h2>

<p>在使用 Auto Layout 进行布局时，可以指定一系列的约束，比如视图的高度、宽度等等。而每一个约束其实都是一个简单的线性等式或不等式，整个界面上的所有约束在一起就<strong>明确地（没有冲突）</strong>定义了整个系统的布局。</p>

<blockquote>
  <p>在涉及冲突发生时，Auto Layout 会尝试 break 一些优先级低的约束，尽量满足最多并且优先级最高的约束。</p>
</blockquote>

<p>因为布局系统在最后仍然需要通过 <code>frame</code> 来进行，所以 Auto Layout 虽然为开发者在描述布局时带来了一些好处，不过它相比原有的布局系统加入了从约束计算 <code>frame</code> 的过程，而在这里，我们需要了解 Auto Layout 的布局性能如何。</p>

<p><img src="https://img.nju520.me/2016-08-31-performance-loss.jpeg" alt="performance-loss" /></p>

<p>因为使用 Cassowary 算法解决约束问题就是对线性等式或不等式求解，所以其时间复杂度就是<strong>多项式时间</strong>的，不难推测出，在处理极其复杂的 UI 界面时，会造成性能上的巨大损失。</p>

<p>在这里我们会对 Auto Layout 的性能进行测试，为了更明显的展示  Auto Layout 的性能，我们通过 <code>frame</code> 的性能建立一条基准线<strong>以消除对象的创建和销毁、视图的渲染、视图层级的改变带来的影响</strong>。</p>

<blockquote>
  <p>你可以在 <a href="https://github.com/nju520/iOS-Source-Code-Analyze/tree/master/contents/AsyncDisplayKit/Layout">这里</a> 找到这次对 Layout 性能测量使用的代码。</p>
</blockquote>

<p>代码分别使用 Auto Layout 和 <code>frame</code> 对 N 个视图进行布局，测算其运行时间。</p>

<p>使用 AutoLayout 时，每个视图会随机选择两个视图对它的 <code>top</code> 和 <code>left</code> 进行约束，随机生成一个数字作为 <code>offset</code>；同时，还会用几个优先级高的约束保证视图的布局不会超出整个 <code>keyWindow</code>。</p>

<p>而下图就是对 100~1000 个视图布局所需要的时间的折线图。</p>

<blockquote>
  <p>这里的数据是在 OS X EL Captain，Macbook Air (13-inch Mid 2013）上的 iPhone 6s Plus 模拟器上采集的， Xcode 版本为 7.3.1。在其他设备上可能不会获得一致的信息，由于笔者的 iPhone 升级到了 iOS 10，所以没有办法真机测试，最后的结果可能会有一定的偏差。</p>
</blockquote>

<p><img src="https://img.nju520.me/2016-08-31-performance-chart-100-1000.jpeg" alt="performance-chart-100-1000" /></p>

<p>从图中可以看到，使用 Auto Layout 进行布局的时间会是只使用 <code>frame</code> 的 <strong>16 倍</strong>左右，虽然这里的测试结果可能<strong>受外界条件影响差异</strong>比较大，不过 Auto Layout 的性能相比 <code>frame</code> 确实差很多，如果去掉设置 <code>frame</code> 的过程消耗的时间，Auto Layout 过程进行的计算量也是非常巨大的。</p>

<p>在上一篇文章中，我们曾经提到，想要让 iOS 应用的视图保持 60 FPS 的刷新频率，我们必须在 <strong>1/60 = 16.67 ms</strong> 之内完成包括布局、绘制以及渲染等操作。</p>

<p>也就是说如果当前界面上的视图大于 100 的话，使用 Auto Layout 是很难达到绝对流畅的要求的；而在使用 <code>frame</code> 时，同一个界面下哪怕有 500 个视图，也是可以在 16.67 ms 之内完成布局的。不过在一般情况下，在 iOS 的整个 <code>UIWindow</code> 中也不会一次性出现如此多的视图。</p>

<p>我们更关心的是，在日常开发中难免会使用 Auto Layout 进行布局，既然有 16.67 ms 这个限制，那么在界面上出现了多少个视图时，我才需要考虑其它的布局方式呢？在这里，我们将需要布局的视图数量减少一个量级，重新绘制一个图表：</p>

<p><img src="https://img.nju520.me/2016-08-31-performance-layout-10-90.jpeg" alt="performance-layout-10-90" /></p>

<p>从图中可以看出，当对 <strong>30 个左右视图</strong>使用 Auto Layout 进行布局时，所需要的时间就会在 16.67 ms 左右，当然这里不排除一些其它因素的影响；到目前为止，会得出一个大致的结论，使用 Auto Layout 对复杂的 UI 界面进行布局时（大于 30 个视图）就会对性能有严重的影响（同时与设备有关，文章中不会考虑设备性能的差异性）。</p>

<p>上述对 Auto Layout 的使用还是比较简单的，而在日常使用中，使用嵌套的视图层级又非常正常。</p>

<blockquote>
  <p>在笔者对嵌套视图层级中使用 Auto Layout 进行布局时，当视图的数量超过了 500 时，模拟器直接就 crash 了，所以这里没有超过 500 个视图的数据。</p>
</blockquote>

<p>我们对嵌套视图数量在 100~500 之间布局时间进行测量，并与 Auto Layout 进行比较：</p>

<p><img src="https://img.nju520.me/2016-08-31-performance-nested-autolayout-frame.jpeg" alt="performance-nested-autolayout-frame" /></p>

<p>在视图数量大于 200 之后，随着视图数量的增加，使用 Auto Layout 对嵌套视图进行布局的时间相比非嵌套的布局成倍增长。</p>

<p>虽然说 Auto Layout 为开发者在多尺寸布局上提供了遍历，而且<strong>支持跨越视图层级</strong>的约束，但是由于其实现原理导致其时间复杂度为<strong>多项式时间</strong>，其性能损耗是仅使用 <code>frame</code> 的十几倍，所以在处理庞大的 UI 界面时表现差强人意。</p>

<blockquote>
  <p>在三年以前，有一篇关于 Auto Layout 性能分析的文章，可以点击这里了解这篇文章的内容 <a href="http://floriankugler.com/2013/04/22/auto-layout-performance-on-ios/">Auto Layout Performance on iOS</a>。</p>
</blockquote>

<h2 id="asdk-的布局引擎">ASDK 的布局引擎</h2>

<p>Auto Layout 不止在复杂 UI 界面布局的表现不佳，它还会强制视图在主线程上布局；所以在 ASDK 中提供了另一种可以在后台线程中运行的布局引擎，它的结构大致是这样的：</p>

<p><img src="https://img.nju520.me/2016-08-31-layout-hierarchy.png-1000width" alt="layout-hierarchy" /></p>

<p><code>ASLayoutSpec</code> 与下面的所有的 Spec 类都是继承关系，在视图需要布局时，会调用 <code>ASLayoutSpec</code> 或者它的子类的 <code>- measureWithSizeRange:</code> 方法返回一个用于布局的对象 <a href="#aslayout">ASLayout</a>。</p>

<blockquote>
  <p><code>ASLayoutable</code> 是 ASDK 中一个协议，遵循该协议的类实现了一系列的布局方法。</p>
</blockquote>

<p>当我们使用 ASDK 布局时，需要做下面四件事情中的一件：</p>

<ul>
  <li>提供 <code>layoutSpecBlock</code></li>
  <li>覆写 <code>- layoutSpecThatFits:</code> 方法</li>
  <li>覆写 <code>- calculateSizeThatFits:</code> 方法</li>
  <li>覆写 <code>- calculateLayoutThatFits:</code> 方法</li>
</ul>

<p>只有做上面四件事情中的其中一件才能对 ASDK 中的视图或者说结点进行布局。</p>

<p>方法 <code>- calculateSizeThatFits:</code> 提供了手动布局的方式，通过在该方法内对 <code>frame</code> 进行计算，返回一个当前视图的 <code>CGSize</code>。</p>

<p>而 <code>- layoutSpecThatFits:</code> 与 <code>layoutSpecBlock</code> 其实没什么不同，只是前者通过覆写方法返回 <code>ASLayoutSpec</code>；后者通过 block 的形式提供一种不需要子类化就可以完成布局的方法，两者可以看做是完全等价的。</p>

<p><code>- calculateLayoutThatFits:</code> 方法有一些不同，它把上面的两种布局方式：手动布局和 Spec 布局封装成了一个接口，这样，无论是 <code>CGSize</code> 还是 <code>ASLayoutSpec</code> 最后都会以 <code>ASLayout</code> 的形式返回给方法调用者。</p>

<h3 id="手动布局">手动布局</h3>

<p>这里简单介绍一下手动布局使用的 <code>-[ASDisplayNode calculatedSizeThatFits:]</code> 方法，这个方法与 <code>UIView</code> 中的 <code>-[UIView sizeThatFits:]</code> 非常相似，其区别只是在 ASDK 中，所有的计算出的大小都会通过缓存来提升性能。</p>

<pre><code class="language-objectivec">- (CGSize)calculateSizeThatFits:(CGSize)constrainedSize {
  return _preferredFrameSize;
}
</code></pre>

<p>子类可以在这个方法中进行计算，通过覆写这个方法返回一个合适的大小，不过一般情况下都不会使用手动布局的方式。</p>

<h3 id="使用-aslayoutspec-布局">使用 ASLayoutSpec 布局</h3>

<p>在 ASDK 中，更加常用的是使用 <code>ASLayoutSpec</code> 布局，在上面提到的 <code>ASLayout</code> 是一个保存布局信息的媒介，而真正计算视图布局的代码都在 <code>ASLayoutSpec</code> 中；所有 ASDK 中的布局（手动 / Spec）都是由 <code>-[ASLayoutable measureWithSizeRange:]</code> 方法触发的，在这里我们以 <code>ASDisplayNode</code> 的调用栈为例看一下方法的执行过程：</p>

<pre><code class="language-objectivec">-[ASDisplayNode measureWithSizeRange:]
	-[ASDisplayNode shouldMeasureWithSizeRange:]
	-[ASDisplayNode calculateLayoutThatFits:]
		-[ASDisplayNode layoutSpecThatFits:]
		-[ASLayoutSpec measureWithSizeRange:]
		+[ASLayout layoutWithLayoutableObject:constrainedSizeRange:size:sublayouts:]
		-[ASLayout filteredNodeLayoutTree]
</code></pre>

<p>ASDK 的文档中推荐在子类中覆写 <code>- layoutSpecThatFits:</code> 方法，返回一个用于布局的 <code>ASLayoutSpec</code> 对象，然后使用 <code>ASLayoutSpec</code> 中的 <code>- measureWithSizeRange:</code> 方法对它指定的视图进行布局，不过通过覆写 <a href="#asdk-的布局引擎">ASDK 的布局引擎</a> 一节中的其它方法也都是可以的。</p>

<p>如果我们使用 <code>ASStackLayoutSpec</code> 对视图进行布局的话，方法调用栈大概是这样的：</p>

<pre><code class="language-objectivec">-[ASDisplayNode measureWithSizeRange:]
	-[ASDisplayNode shouldMeasureWithSizeRange:]
	-[ASDisplayNode calculateLayoutThatFits:]
		-[ASDisplayNode layoutSpecThatFits:]
		-[ASStackLayoutSpec measureWithSizeRange:]
			ASStackUnpositionedLayout::compute
			ASStackPositionedLayout::compute			ASStackBaselinePositionedLayout::compute		+[ASLayout layoutWithLayoutableObject:constrainedSizeRange:size:sublayouts:]
		-[ASLayout filteredNodeLayoutTree]
</code></pre>

<p>这里只是执行了 <code>ASStackLayoutSpec</code> 对应的 <code>- measureWithSizeRange:</code> 方法，对其中的视图进行布局。在 <code>- measureWithSizeRange:</code> 中调用了一些 C++ 方法 <code>ASStackUnpositionedLayout</code>、<code>ASStackPositionedLayout</code> 以及 <code>ASStackBaselinePositionedLayout</code> 的 <code>compute</code> 方法，这些方法完成了对 <code>ASStackLayoutSpec</code> 中视图的布局。</p>

<p>相比于 Auto Layout，ASDK 实现了一种完全不同的布局方式；比较类似与前端开发中的 <code>Flexbox</code> 模型，而 ASDK 其实就实现了 <code>Flexbox</code> 的一个子集。</p>

<p>在 ASDK 1.0 时代，很多开发者都表示希望 ASDK 中加入 ComponentKit 的布局引擎；而现在，ASDK 布局引擎的大部分代码都是从 <a href="http://componentkit.org">ComponentKit</a> 中移植过来的（ComponentKit 是另一个 Facebook 团队开发的用于布局的框架）。</p>

<h4 id="aslayout">ASLayout</h4>

<p><code>ASLayout</code> 表示当前的结点在布局树中的大小和位置；当然，它还有一些其它的奇怪的属性：</p>

<pre><code class="language-objectivec">@interface ASLayout : NSObject

@property (nonatomic, weak, readonly) id&lt;ASLayoutable&gt; layoutableObject;
@property (nonatomic, readonly) CGSize size;
@property (nonatomic, readwrite) CGPoint position;
@property (nonatomic, readonly) NSArray&lt;ASLayout *&gt; *sublayouts;
@property (nonatomic, readonly) CGRect frame;

...

@end
</code></pre>

<p>代码中的 <code>layoutableObject</code> 表示当前的对象，<code>sublayouts</code> 表示当前视图的子布局 <code>ASLayout</code> 数组。</p>

<p>整个类的实现都没有什么值得多说的，除了大量的构造方法，唯一一个做了一些事情的就是 <code>-[ASLayout filteredNodeLayoutTree]</code> 方法了：</p>

<pre><code class="language-objectivec">- (ASLayout *)filteredNodeLayoutTree {
  NSMutableArray *flattenedSublayouts = [NSMutableArray array];
  struct Context {
	ASLayout *layout;
	CGPoint absolutePosition;
  };
  std::queue&lt;Context&gt; queue;
  queue.push({self, CGPointMake(0, 0)});
  while (!queue.empty()) {
	Context context = queue.front();
	queue.pop();

	if (self != context.layout &amp;&amp; context.layout.type == ASLayoutableTypeDisplayNode) {
	  ASLayout *layout = [ASLayout layoutWithLayout:context.layout position:context.absolutePosition];
	  layout.flattened = YES;
	  [flattenedSublayouts addObject:layout];
	}

	for (ASLayout *sublayout in context.layout.sublayouts) {
	  if (sublayout.isFlattened == NO) queue.push({sublayout, context.absolutePosition + sublayout.position});
  }

  return [ASLayout layoutWithLayoutableObject:_layoutableObject
						 constrainedSizeRange:_constrainedSizeRange
										 size:_size
								   sublayouts:flattenedSublayouts];
}
</code></pre>

<p>而这个方法也只是将 <code>sublayouts</code> 中的内容展平，然后实例化一个新的 <code>ASLayout</code> 对象。</p>

<h4 id="aslayoutspec">ASLayoutSpec</h4>

<p><code>ASLayoutSpec</code> 的作用更像是一个抽象类，在真正使用 ASDK 的布局引擎时，都不会直接使用这个类，而是会用类似 <code>ASStackLayoutSpec</code>、<code>ASRelativeLayoutSpec</code>、<code>ASOverlayLayoutSpec</code> 以及 <code>ASRatioLayoutSpec</code> 等子类。</p>

<p>笔者不打算一行一行代码深入讲解其内容，简单介绍一下最重要的 <code>ASStackLayoutSpec</code>。</p>

<p><img src="https://img.nju520.me/2016-08-31-stack.jpg-1000width" alt="stack" /></p>

<p><code>ASStackLayoutSpec</code> 从 <code>Flexbox</code> 中获得了非常多的灵感，比如说 <code>justifyContent</code>、<code>alignItems</code> 等属性，它和苹果的 <code>UIStackView</code> 比较类似，不过底层并没有使用 Auto Layout 进行计算。如果没有接触过 <code>ASStackLayoutSpec</code> 的开发者，可以通过这个小游戏 <a href="http://nguyenhuy.github.io/froggy-asdk-layout/">Foggy-ASDK-Layout</a> 快速学习 <code>ASStackLayoutSpec</code> 的使用。</p>

<h3 id="关于缓存以及异步并发">关于缓存以及异步并发</h3>

<p>因为计算视图的 <code>CGRect</code> 进行布局是一种非常昂贵的操作，所以 ASDK 在这里面加入了缓存机制，在每次执行 <code>- measureWithSizeRange:</code> 方法时，都会通过 <code>-shouldMeasureWithSizeRange:</code> 判断是否需要重新计算布局：</p>

<pre><code class="language-objectivec">- (BOOL)shouldMeasureWithSizeRange:(ASSizeRange)constrainedSize {
  return [self _hasDirtyLayout] || !ASSizeRangeEqualToSizeRange(constrainedSize, _calculatedLayout.constrainedSizeRange);
}

- (BOOL)_hasDirtyLayout {
  return _calculatedLayout == nil || _calculatedLayout.isDirty;
}
</code></pre>

<p>在一般情况下，只有当前结点被标记为 <code>dirty</code> 或者这一次布局传入的 <code>constrainedSize</code> 不同时，才需要进行重新计算。在不需要重新计算布局的情况下，只需要直接返回 <code>_calculatedLayout</code> 布局对象就可以了。</p>

<p>因为 ASDK 实现的布局引擎其实只是对 <code>frame</code> 的计算，所以无论是在主线程还是后台的异步并发进程中都是可以执行的，也就是说，你可以在任意线程中调用 <code>- measureWithSizeRange:</code> 方法，ASDK 中的一些 <code>ViewController</code> 比如：<code>ASDataViewController</code> 就会在后台并发进程中执行该方法：</p>

<pre><code class="language-objectivec">- (NSArray&lt;ASCellNode *&gt; *)_layoutNodesFromContexts:(NSArray&lt;ASIndexedNodeContext *&gt; *)contexts {
  ...

  dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
  dispatch_apply(nodeCount, queue, ^(size_t i) {
	ASIndexedNodeContext *context = contexts[i];
	ASCellNode *node = [context allocateNode];
	if (node == nil) node = [[ASCellNode alloc] init];

	CGRect frame = CGRectZero;
	frame.size = [node measureWithSizeRange:context.constrainedSize].size;
	node.frame = frame;

	[ASDataController _didLayoutNode];
  });

  ...

  return nodes;
}
</code></pre>

<blockquote>
  <p>上述代码做了比较大的修改，将原有一些方法调用放到了当前方法中，并省略了大量的代码。</p>
</blockquote>

<h3 id="关于性能的对比">关于性能的对比</h3>

<p>由于 ASDK 的布局引擎的问题，其性能比较难以测试，在这里只对 ASDK 使用 <code>ASStackLayoutSpec</code> 的<strong>布局计算时间</strong>进行了测试，不包括视图的渲染以及其它时间：</p>

<p><img src="https://img.nju520.me/2016-08-31-async-node-calculate.jpeg" alt="async-node-calculate" /></p>

<p>测试结果表明 <code>ASStackLayoutSpec</code> 花费的布局时间与结点的数量成正比，哪怕计算 100 个视图的布局也只需要 <strong>8.89 ms</strong>，虽然这里没有包括视图的渲染时间，不过与 Auto Layout 相比性能还是有比较大的提升。</p>

<h2 id="总结">总结</h2>

<p>其实 ASDK 的布局引擎大部分都是对 ComponentKit 的封装，不过由于摆脱了 Auto Layout 这一套低效但是通用的布局方式，ASDK 的布局计算不仅在后台并发线程中进行、而且通过引入 <code>Flexbox</code> 提升了布局的性能，但是 ASDK 的使用相对比较复杂，如果只想对布局性能进行优化，更推荐单独使用 ComponentKit 框架。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="http://stacks.11craft.com/cassowary-cocoa-Auto Layout-and-enaml-constraints.html">Cassowary, Cocoa Auto Layout, and enaml constraints</a></li>
  <li><a href="http://cassowary.readthedocs.io/en/latest/topics/theory.html">Solving constraint systems</a></li>
  <li><a href="http://floriankugler.com/2013/04/22/auto-layout-performance-on-ios/">Auto Layout Performance on iOS</a></li>
  <li><a href="https://constraints.cs.washington.edu/cassowary/cassowary-tr.pdf">The Cassowary Linear Arithmetic Constraint Solving Algorithm: Interface and Implementation</a></li>
  <li><a href="http://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf">The Cassowary Linear Arithmetic Constraint Solving Algorithm</a></li>
  <li><a href="http://constraints.cs.washington.edu/solvers/uist97.pdf">Solving Linear Arithmetic Constraints for User Interface Applications</a></li>
  <li><a href="https://medium.com/@jasonyuh/asyncdisplaykit介绍-二-布局系统-1f1a674cf644#.8jskykm15">AsyncDisplayKit 介绍（二）布局系统</a></li>
</ul>

<blockquote>
  <p>Github Repo：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://nju520.me/layout-performance</p>
</blockquote>

  ]]></description>
</item>

<item>
  <title>使用 ASDK 性能调优 - 提升 iOS 界面的渲染性能</title>
  <link>//asdk-rendering</link>
  <author>nju520</author>
  <pubDate>2016-08-22T20:57:31+08:00</pubDate>
  <guid>//asdk-rendering</guid>
  <description><![CDATA[
  <blockquote>
  <p>这一系列的文章会从几个方面对 <a href="http://asyncdisplaykit.org">ASDK</a> 在性能调优方面策略的实现进行分析，帮助读者理解 ASDK 如何做到使复杂的 UI 界面达到 60 FPS 的刷新频率的；本篇文章会从视图的渲染层面讲解 ASDK 对于渲染过程的优化并对 ASDK 进行概述。</p>
</blockquote>

<p>在客户端或者前端开发中，对于性能的优化，尤其是 UI，往往都不是最先考虑的问题。</p>

<p>因为在大多数场景下，使用更加复杂的高性能代码替代可用的代码经常会导致代码的可维护性下降，所以更需要我们开发者对优化的时间点以及原因有一个比较清楚的认识，避免过度优化带来的问题。</p>

<p>对 iOS 开发比较熟悉的开发者都知道，iOS 中的性能问题大多是阻塞主线程导致用户的交互反馈出现可以感知的延迟。</p>

<p><img src="https://img.nju520.me/2016-08-22-scrollview-demo.png-1000width" alt="scrollview-demo" /></p>

<p>详细说起来，大体有三种原因：</p>

<ol>
  <li>UI 渲染需要时间较长，无法按时提交结果；</li>
  <li>一些需要<strong>密集计算</strong>的处理放在了主线程中执行，导致主线程被阻塞，无法渲染 UI 界面；</li>
  <li>网络请求由于网络状态的问题响应较慢，UI 层由于没有模型返回无法渲染。</li>
</ol>

<p>上面的这些问题都会影响应用的性能，最常见的表现就是 <code>UITableView</code> 在滑动时没有达到 <strong>60 FPS</strong>，用户能感受到明显的卡顿。</p>

<h2 id="屏幕的渲染">屏幕的渲染</h2>

<p>相信点开这篇文章的大多数开发者都知道 FPS 是什么，那么如果才能优化我们的 App 使其达到 60 FPS 呢？在具体了解方法之前，我们先退一步，提出另一个问题，屏幕是如何渲染的？</p>

<blockquote>
  <p>对于第一个问题，可能需要几篇文章来回答，希望整个系列的文章能给你一个满意的答案。3</p>
</blockquote>

<h3 id="crt-和-lcd">CRT 和 LCD</h3>

<p>屏幕的渲染可能要从 <a href="https://en.wikipedia.org/wiki/Cathode_ray_tube">CRT（Cathode ray tube） 显示器</a>和 <a href="https://en.wikipedia.org/wiki/Liquid-crystal_display">LCD（Liquid-crystal display） 显示器</a>讲起。</p>

<p><img src="https://img.nju520.me/2016-08-22-CRT.png-1000width" alt="CRT" /></p>

<p>CRT 显示器是比较古老的技术，它使用阴极电子枪发射电子，在阴极高压的作用下，电子由电子枪射向荧光屏，使荧光粉发光，将图像显示在屏幕上，这也就是用磁铁靠近一些老式电视机的屏幕会让它们变色的原因。</p>

<p>而 FPS 就是 CRT 显示器的刷新频率，电子枪每秒会对显示器上内容进行 60 - 100 次的刷新，哪怕在我们看来没有任何改变。</p>

<p><img src="https://img.nju520.me/2016-08-22-lcd.png-1000width" alt="lcd" /></p>

<p>但是 LCD 的原理与 CRT 非常不同，LCD 的成像原理跟光学有关：</p>

<ul>
  <li>在不加电压下，光线会沿着液晶分子的间隙前进旋转 90°，所以光可以通过；</li>
  <li>在加入电压之后，光沿着液晶分子的间隙直线前进，被滤光板挡住。</li>
</ul>

<p>如果你可以翻墙，相信下面的视频会更好得帮助你理解 LCD 的工作原理：</p>

<p><a href="https://www.youtube.com/watch?v=Bf3547WB5qs"><img src="http://img.youtube.com/vi/Bf3547WB5qs/hqdefault.jpg" /></a></p>

<p>LCD 的成像原理虽然与 CRT 截然不同，每一个像素的颜色可以<strong>在需要改变时</strong>才去改变电压，也就是不需要刷新频率，但是由于一些历史原因，LCD 仍然需要按照一定的刷新频率向 GPU 获取新的图像用于显示。</p>

<h3 id="屏幕撕裂">屏幕撕裂</h3>

<p>但是显示器只是用于将图像显示在屏幕上，谁又是图像的提供者呢？图像都是我们经常说的 GPU 提供的。</p>

<p>而这导致了另一个问题，由于 GPU 生成图像的频率与显示器刷新的频率是不相关的，那么在显示器刷新时，GPU 没有准备好需要显示的图像怎么办；或者 GPU 的渲染速度过快，显示器来不及刷新，GPU 就已经开始渲染下一帧图像又该如何处理？</p>

<p><img src="https://img.nju520.me/2016-08-22-screen-tearing.jpg-1000width" alt="screen-tearing" /></p>

<p>如果解决不了这两个问题，就会出现上图中的<em>屏幕撕裂</em>（Screen Tearing）现象，屏幕中一部分显示的是上一帧的内容，另一部分显示的是下一帧的内容。</p>

<p>我们用两个例子来说明可能出现屏幕撕裂的两种情况：</p>

<ul>
  <li>如果显示器的刷新频率为 75 Hz，GPU 的渲染速度为 100 Hz，那么在两次屏幕刷新的间隔中，GPU 会渲染 4/3 个帧，后面的 1/3 帧会覆盖已经渲染好的帧栈，最终会导致屏幕在 1/3 或者 2/3 的位置出现屏幕撕裂效果；</li>
  <li>那么 GPU 的渲染速度小于显示器呢，比如说 50 Hz，那么在两次屏幕刷新的间隔中，GPU 只会渲染 2/3 帧，剩下的 1/3 会来自上一帧，与上面的结果完全相同，在同样的位置出现撕裂效果。</li>
</ul>

<p>到这里，有人会说，如果显示器的刷新频率与 GPU 的渲染速度完全相同，应该就会解决屏幕撕裂的问题了吧？其实并不是。显示器从 GPU 拷贝帧的过程依然需要消耗一定的时间，如果屏幕在拷贝图像时刷新，仍然会导致屏幕撕裂问题。</p>

<p><img src="https://img.nju520.me/2016-08-22-how-to-solve-tearing-problem.jpg-1000width" alt="how-to-solve-tearing-proble" /></p>

<p>引入多个缓冲区可以有效地<strong>缓解</strong>屏幕撕裂，也就是同时使用一个<em>帧缓冲区</em>（frame buffer）和多个<em>后备缓冲区</em>（back buffer）；在每次显示器请求内容时，都会从<strong>帧缓冲区</strong>中取出图像然后渲染。</p>

<p>虽然缓冲区可以减缓这些问题，但是却不能解决；如果后备缓冲区绘制完成，而帧缓冲区的图像没有被渲染，后备缓冲区中的图像就会覆盖帧缓冲区，仍然会导致屏幕撕裂。</p>

<p>解决这个问题需要另一个机制的帮助，也就是垂直同步（Vertical synchronization），简称 V-Sync 来解决。</p>

<h3 id="v-sync">V-Sync</h3>

<p>V-Sync 的主要作用就是保证<strong>只有在帧缓冲区中的图像被渲染之后，后备缓冲区中的内容才可以被拷贝到帧缓冲区中</strong>，理想情况下的 V-Sync 会按这种方式工作：</p>

<p><img src="https://img.nju520.me/2016-08-22-normal-vsync.png-1000width" alt="normal-vsyn" /></p>

<p>每次 V-Sync 发生时，CPU 以及 GPU 都已经完成了对图像的处理以及绘制，显示器可以直接拿到缓冲区中的帧。但是，如果 CPU 或者 GPU 的处理需要的时间较长，就会发生掉帧的问题：</p>

<p><img src="https://img.nju520.me/2016-08-22-lag-vsync.png-1000width" alt="lag-vsyn" /></p>

<p>在 V-Sync 信号发出时，CPU 和 GPU 并没有准备好需要渲染的帧，显示器就会继续使用当前帧，这就<strong>加剧</strong>了屏幕的显示问题，而每秒显示的帧数会少于 60。</p>

<p>由于会发生很多次掉帧，在开启了 V-Sync 后，40 ~ 50 FPS 的渲染频率意味着显示器输出的画面帧率会从 60 FPS 急剧下降到 30 FPS，原因在这里不会解释，读者可以自行思考。</p>

<p>其实到这里关于屏幕渲染的内容就已经差不多结束了，根据 V-Sync 的原理，优化应用性能、提高 App 的 FPS 就可以从两个方面来入手，优化 CPU 以及 GPU 的处理时间。</p>

<blockquote>
  <p>读者也可以从 <a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a>这篇文章中了解更多的相关内容。</p>
</blockquote>

<h2 id="性能调优的策略">性能调优的策略</h2>

<p>CPU 和 GPU 在每次 V-Sync 时间点到达之前都在干什么？如果，我们知道了它们各自负责的工作，通过优化代码就可以提升性能。</p>

<p><img src="https://img.nju520.me/2016-08-22-cpu-gpu.jpg-1000width" alt="cpu-gpu" /></p>

<p>很多 CPU 的操作都会延迟 GPU 开始渲染的时间：</p>

<ul>
  <li>布局的计算 - 如果你的视图层级太过于复杂，或者视图需要重复多次进行布局，尤其是在使用 Auto Layout 进行自动布局时，对性能影响尤为严重；</li>
  <li>视图的惰性加载 - 在 iOS 中只有当视图控制器的视图显示到屏幕时才会加载；</li>
  <li>解压图片 - iOS 通常会在真正绘制时才会解码图片，对于一个较大的图片，无论是直接或间接使用 <code>UIImageView</code> 或者绘制到 Core Graphics 中，都需要对图片进行解压；</li>
  <li>…</li>
</ul>

<p>宽泛的说，大多数的 <code>CALayer</code> 的属性都是由 GPU 来绘制的，比如图片的圆角、变换、应用纹理；但是过多的几何结构、重绘、离屏绘制（Offscrren）以及过大的图片都会导致 GPU 的性能明显降低。</p>

<blockquote>
  <p>上面的内容出自 <a href="https://zsisme.gitbooks.io/ios-/content/chapter12/cpu-versus-gpu.html">CPU vs GPU · iOS 核心动画高级技巧</a>，你可以在上述文章中对 CPU 和 GPU 到底各自做了什么有一个更深的了解。</p>
</blockquote>

<p>也就是说，如果我们解决了上述问题，就能加快应用的渲染速度，大大提升用户体验。</p>

<h2 id="asyncdisplaykit">AsyncDisplayKit</h2>

<p>文章的前半部分已经从屏幕的渲染原理讲到了性能调优的几个策略；而 <a href="http://asyncdisplaykit.org">AsyncDisplayKit</a> 就根据上述的策略帮助我们对应用性能进行优化。</p>

<p><img src="https://img.nju520.me/2016-08-22-asdk-logo.png-1000width" alt="asdk-logo" /></p>

<p>AsyncDisplayKit（以下简称 ASDK）是由 Facebook 开源的一个 iOS 框架，能够帮助最复杂的 UI 界面保持流畅和快速响应。</p>

<p>ASDK 从开发到开源大约经历了一年多的时间，它其实并不是一个简单的框架<del>它是一个复杂的框架</del>，更像是对 UIKit 的重新实现，把整个 UIKit 以及 CALayer 层封装成一个一个 <code>Node</code>，<strong>将昂贵的渲染、图片解码、布局以及其它 UI 操作移出主线程</strong>，这样主线程就可以对用户的操作及时做出反应。</p>

<p>很多分析 ASDK 的文章都会有这么一张图介绍框架中的最基本概念：</p>

<p><img src="https://img.nju520.me/2016-08-22-asdk-hierarchy.png-1000width" alt="asdk-hierarchy" /></p>

<p>在 ASDK 中最基本的单位就是 <code>ASDisplayNode</code>，每一个 node 都是对 <code>UIView</code> 以及 <code>CALayer</code> 的抽象。但是与 <code>UIView</code> 不同的是，<code>ASDisplayNode</code> 是线程安全的，它可以在后台线程中完成初始化以及配置工作。</p>

<p>如果按照 60 FPS 的刷新频率来计算，每一帧的渲染时间只有 16ms，在 16ms 的时间内要完成对 <code>UIView</code> 的创建、布局、绘制以及渲染，CPU 和 GPU 面临着巨大的压力。</p>

<p><img src="https://img.nju520.me/2016-08-22-apple-a9.jpg-1000width" alt="apple-a9" /></p>

<p>但是从 A5 处理器之后，多核的设备成为了主流，原有的将所有操作放入主线程的实践已经不能适应复杂的 UI 界面，所以 <strong>ASDK 将耗时的 CPU 操作以及 GPU 渲染纹理（Texture）的过程全部放入后台进程，使主线程能够快速响应用户操作</strong>。</p>

<p>ASDK 通过独特的渲染技巧、代替 AutoLayout 的布局系统、智能的预加载方式等模块来实现对 App 性能的优化。</p>

<h2 id="asdk-的渲染过程">ASDK 的渲染过程</h2>

<p>ASDK 中到底使用了哪些方法来对视图进行渲染呢？本文主要会从渲染的过程开始分析，了解 ASDK 底层如何提升界面的渲染性能。</p>

<p>在 ASDK 中的渲染围绕 <code>ASDisplayNode</code> 进行，其过程总共有四条主线：</p>

<ul>
  <li>初始化 <code>ASDisplayNode</code> 对应的 <code>UIView</code> 或者 <code>CALayer</code>；</li>
  <li>在当前视图进入视图层级时执行 <code>setNeedsDisplay</code>；</li>
  <li><code>display</code> 方法执行时，向后台线程派发绘制事务；</li>
  <li>注册成为 <code>RunLoop</code> 观察者，在每个 <code>RunLoop</code> 结束时回调。</li>
</ul>

<h3 id="uiview-和-calayer-的加载">UIView 和 CALayer 的加载</h3>

<p>当我们运行某一个使用 ASDK 的工程时，<code>-[ASDisplayNode _loadViewOrLayerIsLayerBacked:]</code> 总是 ASDK 中最先被调用的方法，而这个方法执行的原因往往就是 <code>ASDisplayNode</code> 对应的 <code>UIView</code> 和 <code>CALayer</code> 被引用了：</p>

<pre><code class="language-objectivec">- (CALayer *)layer {
	if (!_layer) {
		ASDisplayNodeAssertMainThread();

		if (!_flags.layerBacked) return self.view.layer;
		[self _loadViewOrLayerIsLayerBacked:YES];
	}
	return _layer;
}

- (UIView *)view {
	if (_flags.layerBacked) return nil;
	if (!_view) {
		ASDisplayNodeAssertMainThread();
		[self _loadViewOrLayerIsLayerBacked:NO];
	}
	return _view;
}
</code></pre>

<p>这里涉及到一个 ASDK 中比较重要的概念，如果 <code>ASDisplayNode</code> 是 <code>layerBacked</code> 的，它不会渲染对应的 <code>UIView</code> 以此来提升性能：</p>

<pre><code class="language-objectivec">- (void)_loadViewOrLayerIsLayerBacked:(BOOL)isLayerBacked {
	if (isLayerBacked) {
		_layer = [self _layerToLoad];
		_layer.delegate = (id&lt;CALayerDelegate&gt;)self;
	} else {
		_view = [self _viewToLoad];
		_view.asyncdisplaykit_node = self;
		_layer = _view.layer;
	}
	_layer.asyncdisplaykit_node = self;

	self.asyncLayer.asyncDelegate = self;
}
</code></pre>

<p>因为 <code>UIView</code> 和 <code>CALayer</code> 虽然都可以用于展示内容，不过由于 <code>UIView</code> 可以用于处理用户的交互，所以如果不需要使用 <code>UIView</code> 的特性，直接使用 <code>CALayer</code> 进行渲染，能够节省大量的渲染时间。</p>

<blockquote>
  <p>如果你使用 Xcode 查看过视图的层级，那么你应该知道，<code>UIView</code> 在 Debug View Hierarchy 中是有层级的；而 <code>CALayer</code> 并没有，它门的显示都在一个平面上。</p>
</blockquote>

<p>上述方法中的 <code>-[ASDisplayNode _layerToLoad]</code> 以及 <code>[ASDisplayNode _viewToLoad]</code> 都只会根据当前节点的 <code>layerClass</code> 或者 <code>viewClass</code> 初始化一个对象。</p>

<blockquote>
  <p><a href="http://floriankugler.com/2013/05/24/layer-trees-vs-flat-drawing-graphics-performance-across-ios-device-generations/">Layer Trees vs. Flat Drawing – Graphics Performance Across iOS Device Generations</a> 这篇文章比较了 <code>UIView</code> 和 <code>CALayer</code> 的渲染时间。</p>
</blockquote>

<p><img src="https://img.nju520.me/2016-08-22-view-layer-cg-compare.png-1000width" alt="view-layer-cg-compare" /></p>

<p><code>-[ASDisplayNode asyncLayer]</code> 只是对当前 <code>node</code> 持有的 <code>layer</code> 进行封装，确保会返回一个 <code>_ASDisplayLayer</code> 的实例：</p>

<pre><code class="language-objectivec">- (_ASDisplayLayer *)asyncLayer {
	ASDN::MutexLocker l(_propertyLock);
	return [_layer isKindOfClass:[_ASDisplayLayer class]] ? (_ASDisplayLayer *)_layer : nil;
}
</code></pre>

<p>最重要的是 <code>-[ASDisplayNode _loadViewOrLayerIsLayerBacked:]</code> 方法会将当前节点设置为 <code>asyncLayer</code> 的代理，在后面会使用 <code>ASDisplayNode</code> 为 <code>CALayer</code> 渲染内容。</p>

<h3 id="视图层级">视图层级</h3>

<p>在初始化工作完成之后，当 <code>ASDisplayNode</code> 第一次被加入到视图的层级时，<code>-[_ASDisplayView willMoveToWindow:]</code> 就会被调用。</p>

<h4 id="_asdisplayview-和-_asdisplaylayer">_ASDisplayView 和 _ASDisplayLayer</h4>

<p><code>_ASDisplayView</code> 和 <code>_ASDisplayLayer</code> 都是私有类，它们之间的对应关系其实和 <code>UIView</code> 与 <code>CALayer</code> 完全相同。</p>

<pre><code class="language-objectivec">+ (Class)layerClass {
	return [_ASDisplayLayer class];
}
</code></pre>

<p><code>_ASDisplayView</code> 覆写了很多跟视图层级改变有关的方法：</p>

<ul>
  <li><code>-[_ASDisplayView willMoveToWindow:]</code></li>
  <li><code>-[_ASDisplayView didMoveToWindow]</code></li>
  <li><code>-[_ASDisplayView willMoveToSuperview:]</code></li>
  <li><code>-[_ASDisplayView didMoveToSuperview]</code></li>
</ul>

<p>它们用于在视图的层级改变时，通知对应 <code>ASDisplayNode</code> 作出相应的反应，比如 <code>-[_ASDisplayView willMoveToWindow:]</code> 方法会在视图被加入层级时调用：</p>

<pre><code class="language-objectivec">- (void)willMoveToWindow:(UIWindow *)newWindow {
	BOOL visible = (newWindow != nil);
	if (visible &amp;&amp; !_node.inHierarchy) {
		[_node __enterHierarchy];
	}
}
</code></pre>

<h4 id="setneedsdisplay">setNeedsDisplay</h4>

<p>当前视图如果不在视图层级中，就会通过 <code>_node</code> 的实例方法 <code>-[ASDisplayNode __enterHierarchy]</code> 加入视图层级：</p>

<pre><code class="language-objectivec">- (void)__enterHierarchy {
	if (!_flags.isInHierarchy &amp;&amp; !_flags.visibilityNotificationsDisabled &amp;&amp; ![self __selfOrParentHasVisibilityNotificationsDisabled]) {
		_flags.isEnteringHierarchy = YES;
		_flags.isInHierarchy = YES;

		if (_flags.shouldRasterizeDescendants) {
			[self _recursiveWillEnterHierarchy];
		} else {
			[self willEnterHierarchy];
		}
		_flags.isEnteringHierarchy = NO;

		# 更新 layer 显示的内容
	}
}

</code></pre>

<blockquote>
  <p><code>_flags</code> 是 <code>ASDisplayNodeFlags</code> 结构体，用于标记当前 <code>ASDisplayNode</code> 的一些 BOOL 值，比如，异步显示、栅格化子视图等等，你不需要知道都有什么，根据这些值的字面意思理解就已经足够了。</p>
</blockquote>

<p>上述方法的前半部分只是对 <code>_flags</code> 的标记，如果需要将当前视图的子视图栅格化，也就是<strong>将它的全部子视图与当前视图压缩成一个图层</strong>，就会向这些视图递归地调用 <code>-[ASDisplayNode willEnterHierarchy]</code> 方法通知目前的状态：</p>

<pre><code class="language-objectivec">- (void)_recursiveWillEnterHierarchy {
  _flags.isEnteringHierarchy = YES;
  [self willEnterHierarchy];
  _flags.isEnteringHierarchy = NO;

  for (ASDisplayNode *subnode in self.subnodes) {
	[subnode _recursiveWillEnterHierarchy];
  }
}
</code></pre>

<p>而 <code>-[ASDisplayNode willEnterHierarchy]</code> 会修改当前节点的 <code>interfaceState</code> 到 <code>ASInterfaceStateInHierarchy</code>，表示当前节点不包含在 <code>cell</code> 或者其它，但是在 <code>window</code> 中。</p>

<pre><code class="language-objectivec">- (void)willEnterHierarchy {
  if (![self supportsRangeManagedInterfaceState]) {
	self.interfaceState = ASInterfaceStateInHierarchy;
  }
}
</code></pre>

<p>当前结点需要被显示在屏幕上时，如果其内容 <code>contents</code> 为空，就会调用 <code>-[CALayer setNeedsDisplay]</code> 方法将 <code>CALayer</code> 标记为脏的，通知系统需要在下一个绘制循环中重绘视图：</p>

<pre><code class="language-objectivec">- (void)__enterHierarchy {
	 if (!_flags.isInHierarchy &amp;&amp; !_flags.visibilityNotificationsDisabled &amp;&amp; ![self __selfOrParentHasVisibilityNotificationsDisabled]) {

		# 标记节点的 flag

		if (self.contents == nil) {
			CALayer *layer = self.layer;
			[layer setNeedsDisplay];

			if ([self _shouldHavePlaceholderLayer]) {
				[CATransaction begin];
				[CATransaction setDisableActions:YES];
				[self _setupPlaceholderLayerIfNeeded];
				_placeholderLayer.opacity = 1.0;
				[CATransaction commit];
				[layer addSublayer:_placeholderLayer];
			}
		}
	}
}
</code></pre>

<p>在将 <code>CALayer</code> 标记为 dirty 之后，在绘制循环中就会执行 <code>-[CALayer display]</code> 方法，对它要展示的内容进行绘制；如果当前视图需要一些占位图，那么就会在这里的代码中，为当前 <code>node</code> 对应的 <code>layer</code> 添加合适颜色的占位层。</p>

<p><img src="https://img.nju520.me/2016-08-22-placeholder-layer.png-1000width" alt="placeholder-laye" /></p>

<h3 id="派发异步绘制事务">派发异步绘制事务</h3>

<p>在上一节中调用 <code>-[CALayer setNeedsDisplay]</code> 方法将当前节点标记为 dirty 之后，在下一个绘制循环时就会对所有需要重绘的 <code>CALayer</code> 执行 <code>-[CALayer display]</code>，这也是这一小节需要分析的方法的入口：</p>

<pre><code class="language-objectivec">- (void)display {
  [self _hackResetNeedsDisplay];

  ASDisplayNodeAssertMainThread();
  if (self.isDisplaySuspended) return;

  [self display:self.displaysAsynchronously];
}
</code></pre>

<p>这一方法的调用栈比较复杂，在具体分析之前，笔者会先给出这个方法的调用栈，给读者一个关于该方法实现的简要印象：</p>

<pre><code class="language-objectivec">-[_ASDisplayLayer display]
	-[_ASDisplayLayer display:] // 将绘制工作交给 ASDisplayNode 处理
		-[ASDisplayNode(AsyncDisplay) displayAsyncLayer:asynchronously:]
			-[ASDisplayNode(AsyncDisplay) _displayBlockWithAsynchronous:isCancelledBlock:rasterizing:]
				-[ASDisplayNode(AsyncDisplay) _recursivelyRasterizeSelfAndSublayersWithIsCancelledBlock:displayBlocks:]            
			-[CALayer(ASDisplayNodeAsyncTransactionContainer) asyncdisplaykit_parentTransactionContainer]
			-[CALayer(ASDisplayNodeAsyncTransactionContainer) asyncdisplaykit_asyncTransaction]
				-[_ASAsyncTransaction initWithCallbackQueue:completionBlock:]
				-[_ASAsyncTransactionGroup addTransactionContainer:]
			-[_ASAsyncTransaction addOperationWithBlock:priority:queue:completion:]
				ASAsyncTransactionQueue::GroupImpl::schedule(NSInteger priority, dispatch_queue_t queue, dispatch_block_t block)
					void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);
</code></pre>

<p><code>-[_ASDisplayLayer display]</code> 在调用栈中其实会创建一个 <code>displayBlock</code>，它其实是一个使用 Core Graphics 进行图像绘制的过程，整个绘制过程是通过事务的形式进行管理的；而 <code>displayBlock</code> 会被 GCD 分发到后台的并发进程来处理。</p>

<p>调用栈中的第二个方法 <code>-[_ASDisplayLayer display]</code> 会将异步绘制的工作交给自己的 <code>asyncDelegate</code>，也就是<a href="#uiview-和-calayer-的加载">第一部分</a>中设置的 <code>ASDisplayNode</code>：</p>

<pre><code class="language-objectivec">- (void)display:(BOOL)asynchronously {
  [_asyncDelegate displayAsyncLayer:self asynchronously:asynchronously];
}
</code></pre>

<h4 id="asdisplaynodeasyncdisplay">ASDisplayNode(AsyncDisplay)</h4>

<p>这里省略了一部分 <code>-[ASDisplayNode(AsyncDisplay) displayAsyncLayer:asynchronously:]</code> 方法的实现：</p>

<pre><code class="language-objectivec">- (void)displayAsyncLayer:(_ASDisplayLayer *)asyncLayer asynchronously:(BOOL)asynchronously {
  ASDisplayNodeAssertMainThread();

  ...

  asyncdisplaykit_async_transaction_operation_block_t displayBlock = [self _displayBlockWithAsynchronous:asynchronously isCancelledBlock:isCancelledBlock rasterizing:NO];

  if (!displayBlock) return;

  asyncdisplaykit_async_transaction_operation_completion_block_t completionBlock = ^(id&lt;NSObject&gt; value, BOOL canceled){
	ASDisplayNodeCAssertMainThread();
	if (!canceled &amp;&amp; !isCancelledBlock()) {
	  UIImage *image = (UIImage *)value;
	  _layer.contentsScale = self.contentsScale;
	  _layer.contents = (id)image.CGImage;
	}
  };

  if (asynchronously) {
	CALayer *containerLayer = _layer.asyncdisplaykit_parentTransactionContainer ? : _layer;
	_ASAsyncTransaction *transaction = containerLayer.asyncdisplaykit_asyncTransaction;
	[transaction addOperationWithBlock:displayBlock priority:self.drawingPriority queue:[_ASDisplayLayer displayQueue] completion:completionBlock];
  } else {
	UIImage *contents = (UIImage *)displayBlock();
	completionBlock(contents, NO);
  }
}
</code></pre>

<p>省略后的代码脉络非常清晰，<code>-[ASDisplayNode(AsyncDisplay) _displayBlockWithAsynchronous:isCancelledBlock:rasterizing:]</code> 返回一个用于 <code>displayBlock</code>，然后构造一个 <code>completionBlock</code>，在绘制结束时执行，在主线程中设置当前 <code>layer</code> 的内容。</p>

<p>如果当前的渲染是异步的，就会将 <code>displayBlock</code> 包装成一个事务，添加到队列中执行，否则就会同步执行当前的 block，并执行 <code>completionBlock</code> 回调，通知 <code>layer</code> 更新显示的内容。</p>

<p>同步显示的部分到这里已经很清楚了，我们更关心的其实还是异步绘制的部分，因为这部分才是 ASDK 提升效率的关键；而这就要从获取 <code>displayBlock</code> 的方法开始了解了。</p>

<h4 id="displayblock-的构建">displayBlock 的构建</h4>

<p><code>displayBlock</code> 的创建一般分为三种不同的方式：</p>

<ol>
  <li>将当前视图的子视图压缩成一层绘制在当前页面上</li>
  <li>使用 <code>- displayWithParameters:isCancelled:</code> 返回一个 <code>UIImage</code>，对图像节点 <code>ASImageNode</code> 进行绘制</li>
  <li>使用 <code>- drawRect:withParameters:isCancelled:isRasterizing:</code> 在 CG 上下文中绘制文字节点 <code>ASTextNode</code></li>
</ol>

<p>这三种方式都通过 ASDK 来优化视图的渲染速度，这些操作最后都会扔到后台的并发线程中进行处理。</p>

<blockquote>
  <p>下面三个部分的代码经过了删减，省略了包括取消绘制、通知代理、控制并发数量以及用于调试的代码。</p>
</blockquote>

<h5 id="栅格化子视图">栅格化子视图</h5>

<p>如果当前的视图需要栅格化子视图，就会进入启用下面的构造方式创建一个 block，它会递归地将子视图绘制在父视图上：</p>

<pre><code class="language-objectivec">- (asyncdisplaykit_async_transaction_operation_block_t)_displayBlockWithAsynchronous:(BOOL)asynchronous isCancelledBlock:(asdisplaynode_iscancelled_block_t)isCancelledBlock rasterizing:(BOOL)rasterizing {
  asyncdisplaykit_async_transaction_operation_block_t displayBlock = nil;
  ASDisplayNodeFlags flags = _flags;

  if (!rasterizing &amp;&amp; self.shouldRasterizeDescendants) {
	NSMutableArray *displayBlocks = [NSMutableArray array];
	[self _recursivelyRasterizeSelfAndSublayersWithIsCancelledBlock:isCancelledBlock displayBlocks:displayBlocks];

	CGFloat contentsScaleForDisplay = self.contentsScaleForDisplay;
	BOOL opaque = self.opaque &amp;&amp; CGColorGetAlpha(self.backgroundColor.CGColor) == 1.0f;

	displayBlock = ^id{

	  UIGraphicsBeginImageContextWithOptions(bounds.size, opaque, contentsScaleForDisplay);

	  for (dispatch_block_t block in displayBlocks) {
		block();
	  }

	  UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
	  UIGraphicsEndImageContext();

	  return image;
	};
  } else if (flags.implementsInstanceImageDisplay || flags.implementsImageDisplay) {
	#：绘制 UIImage
  } else if (flags.implementsInstanceDrawRect || flags.implementsDrawRect) {
	#：提供 context，使用 CG 绘图
  }

  return [displayBlock copy];
}
</code></pre>

<p>在压缩视图层级的过程中就会调用 <code>-[ASDisplayNode(AsyncDisplay) _recursivelyRasterizeSelfAndSublayersWithIsCancelledBlock:displayBlocks:]</code> 方法，获取子视图的所有 <code>displayBlock</code>，在得到 <code>UIGraphicsBeginImageContextWithOptions</code> 需要的参数之后，创建一个新的 context，执行了所有的 <code>displayBlock</code> 将子视图的绘制到当前图层之后，使用 <code>UIGraphicsGetImageFromCurrentImageContext</code> 取出图层的内容并返回。</p>

<p><code>-[ASDisplayNode(AsyncDisplay) _recursivelyRasterizeSelfAndSublayersWithIsCancelledBlock:displayBlocks:]</code> 的实现还是有些繁琐的，它主要的功能就是使用 Core Graphics 进行绘图，将背景颜色、仿射变换、位置大小以及圆角等参数绘制到当前的上下文中，而且这个过程是递归的，直到不存在或者不需要绘制子节点为止。</p>

<h5 id="绘制图片">绘制图片</h5>

<p><code>displayBlock</code> 的第二种绘制策略更多地适用于图片节点 <code>ASImageNode</code> 的绘制：</p>

<pre><code class="language-objectivec">- (asyncdisplaykit_async_transaction_operation_block_t)_displayBlockWithAsynchronous:(BOOL)asynchronous isCancelledBlock:(asdisplaynode_iscancelled_block_t)isCancelledBlock rasterizing:(BOOL)rasterizing {
  asyncdisplaykit_async_transaction_operation_block_t displayBlock = nil;
  ASDisplayNodeFlags flags = _flags;

  if (!rasterizing &amp;&amp; self.shouldRasterizeDescendants) {
	#：栅格化
  } else if (flags.implementsInstanceImageDisplay || flags.implementsImageDisplay) {
	id drawParameters = [self drawParameters];

	displayBlock = ^id{
	  UIImage *result = nil;
	  if (flags.implementsInstanceImageDisplay) {
		result = [self displayWithParameters:drawParameters isCancelled:isCancelledBlock];
	  } else {
		result = [[self class] displayWithParameters:drawParameters isCancelled:isCancelledBlock];
	  }
	  return result;
	};
  } else if (flags.implementsInstanceDrawRect || flags.implementsDrawRect) {
	#：提供 context，使用 CG 绘图
  }

  return [displayBlock copy];
}
</code></pre>

<p>通过 <code>- displayWithParameters:isCancelled:</code> 的执行返回一个图片，不过这里的绘制也离不开 Core Graphics 的一些 C 函数，你会在 <code>-[ASImageNode displayWithParameters:isCancelled:]</code> 中看到对于 CG 的运用，它会使用 <code>drawParameters</code> 来修改并绘制自己持有的 <code>image</code> 对象。</p>

<h5 id="使用-cg-绘图">使用 CG 绘图</h5>

<p>文字的绘制一般都会在 <code>- drawRect:withParameters:isCancelled:isRasterizing:</code> 进行，这个方法只是提供了一个合适的用于绘制的上下文，该方法不止可以绘制文字，只是在这里绘制文字比较常见：</p>

<pre><code class="language-objectivec">- (asyncdisplaykit_async_transaction_operation_block_t)_displayBlockWithAsynchronous:(BOOL)asynchronous isCancelledBlock:(asdisplaynode_iscancelled_block_t)isCancelledBlock rasterizing:(BOOL)rasterizing {
  asyncdisplaykit_async_transaction_operation_block_t displayBlock = nil;
  ASDisplayNodeFlags flags = _flags;

  if (!rasterizing &amp;&amp; self.shouldRasterizeDescendants) {
	#：栅格化
  } else if (flags.implementsInstanceImageDisplay || flags.implementsImageDisplay) {
	#：绘制 UIImage
  } else if (flags.implementsInstanceDrawRect || flags.implementsDrawRect) {
	  if (!rasterizing) {
		UIGraphicsBeginImageContextWithOptions(bounds.size, opaque, contentsScaleForDisplay);
	  }

	  if (flags.implementsInstanceDrawRect) {
		[self drawRect:bounds withParameters:drawParameters isCancelled:isCancelledBlock isRasterizing:rasterizing];
	  } else {
		[[self class] drawRect:bounds withParameters:drawParameters isCancelled:isCancelledBlock isRasterizing:rasterizing];
	  }

	  UIImage *image = nil;
	  if (!rasterizing) {
		image = UIGraphicsGetImageFromCurrentImageContext();
		UIGraphicsEndImageContext();
	  }

	  return image;
	};
  }

  return [displayBlock copy];
}
</code></pre>

<p>上述代码跟第一部分比较像，区别是这里不会栅格化子视图；代码根据情况会决定是否重新开一个新的上下文，然后通过 <code>- drawRect:withParameters:isCancelled:isRasterizing:</code> 方法实现绘制。</p>

<h4 id="管理绘制事务">管理绘制事务</h4>

<p>ASDK 提供了一个私有的管理事务的机制，由三部分组成 <code>_ASAsyncTransactionGroup</code>、<code>_ASAsyncTransactionContainer</code> 以及 <code>_ASAsyncTransaction</code>，这三者各自都有不同的功能：</p>

<ul>
  <li><code>_ASAsyncTransactionGroup</code> 会在初始化时，向 Runloop 中注册一个回调，在每次 Runloop 结束时，执行回调来提交 <code>displayBlock</code> 执行的结果</li>
  <li><code>_ASAsyncTransactionContainer</code> 为当前 <code>CALayer</code> 提供了用于保存事务的容器，并提供了获取新的 <code>_ASAsyncTransaction</code> 实例的便利方法</li>
  <li><code>_ASAsyncTransaction</code> 将异步操作封装成了轻量级的事务对象，使用 C++ 代码对 GCD 进行了封装</li>
</ul>

<p>从上面的小节中，我们已经获取到了用于绘制的 <code>displayBlock</code>，然后就需要将 block 添加到绘制事务中：</p>

<pre><code class="language-objectivec">- (void)displayAsyncLayer:(_ASDisplayLayer *)asyncLayer asynchronously:(BOOL)asynchronously {
  ...

  if (asynchronously) {
	CALayer *containerLayer = _layer.asyncdisplaykit_parentTransactionContainer ? : _layer;
	_ASAsyncTransaction *transaction = containerLayer.asyncdisplaykit_asyncTransaction;
	[transaction addOperationWithBlock:displayBlock priority:self.drawingPriority queue:[_ASDisplayLayer displayQueue] completion:completionBlock];
  } else {
	...
  }
}
</code></pre>

<p>前两行代码是获取 <code>_ASAsyncTransaction</code> 实例的过程，这个实例会包含在一个 <code>layer</code> 的哈希表中，最后调用的实例方法 <code>-[_ASAsyncTransaction addOperationWithBlock:priority:queue:completion:]</code> 会把用于绘制的 <code>displayBlock</code> 添加到后台并行队列中：</p>

<pre><code class="language-objectivec">+ (dispatch_queue_t)displayQueue {
  static dispatch_queue_t displayQueue = NULL;
  static dispatch_once_t onceToken;
  dispatch_once(&amp;onceToken, ^{
	displayQueue = dispatch_queue_create("org.AsyncDisplayKit.ASDisplayLayer.displayQueue", DISPATCH_QUEUE_CONCURRENT);
	dispatch_set_target_queue(displayQueue, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0));
  });

  return displayQueue;
}
</code></pre>

<p>这个队列是一个并行队列，并且优先级是 <code>DISPATCH_QUEUE_PRIORITY_HIGH</code>，<strong>确保 UI 的渲染会在其它异步操作执行之前进行</strong>，而 <code>-[_ASAsyncTransaction addOperationWithBlock:priority:queue:completion:]</code> 中会初始化 <code>ASDisplayNodeAsyncTransactionOperation</code> 的实例，然后传入 <code>completionBlock</code>，在绘制结束时回调：</p>

<pre><code class="language-objectivec">- (void)addOperationWithBlock:(asyncdisplaykit_async_transaction_operation_block_t)block priority:(NSInteger)priority queue:(dispatch_queue_t)queue completion:(asyncdisplaykit_async_transaction_operation_completion_block_t)completion {
  ASDisplayNodeAssertMainThread();

  [self _ensureTransactionData];

  ASDisplayNodeAsyncTransactionOperation *operation = [[ASDisplayNodeAsyncTransactionOperation alloc] initWithOperationCompletionBlock:completion];
  [_operations addObject:operation];
  _group-&gt;schedule(priority, queue, ^{
	@autoreleasepool {
	  operation.value = block();
	}
  });
}
</code></pre>

<p><code>schedule</code> 方法是一个 C++ 方法，它会向 <code>ASAsyncTransactionQueue::Group</code> 中派发一个 block，这个 block 中会执行 <code>displayBlock</code>，然后将结果传给 <code>operation.value</code>：</p>

<pre><code class="language-objectivec">void ASAsyncTransactionQueue::GroupImpl::schedule(NSInteger priority, dispatch_queue_t queue, dispatch_block_t block) {
  ASAsyncTransactionQueue &amp;q = _queue;
  ASDN::MutexLocker locker(q._mutex);

  DispatchEntry &amp;entry = q._entries[queue];

  Operation operation;
  operation._block = block;
  operation._group = this;
  operation._priority = priority;
  entry.pushOperation(operation);

  ++_pendingOperations;

  NSUInteger maxThreads = [NSProcessInfo processInfo].activeProcessorCount * 2;

  if ([[NSRunLoop mainRunLoop].currentMode isEqualToString:UITrackingRunLoopMode])
	--maxThreads;

  if (entry._threadCount &lt; maxThreads) {
	bool respectPriority = entry._threadCount &gt; 0;
	++entry._threadCount;

	dispatch_async(queue, ^{
	  while (!entry._operationQueue.empty()) {
		Operation operation = entry.popNextOperation(respectPriority);
		{
		  if (operation._block) {
			operation._block();
		  }
		  operation._group-&gt;leave();
		  operation._block = nil;
		}
	  }
	  --entry._threadCount;

	  if (entry._threadCount == 0) {
		q._entries.erase(queue);
	  }
	});
  }
}
</code></pre>

<p><code>ASAsyncTransactionQueue::GroupImpl</code> 其实现其实就是对 GCD 的封装，同时添加一些最大并发数、线程锁的功能。通过 <code>dispatch_async</code> 将 block 分发到 <code>queue</code> 中，立刻执行 block，将数据传回 <code>ASDisplayNodeAsyncTransactionOperation</code> 实例。</p>

<h3 id="回调">回调</h3>

<p>在 <code>_ASAsyncTransactionGroup</code> 调用 <code>mainTransactionGroup</code> 类方法获取单例时，会通过 <code>+[_ASAsyncTransactionGroup registerTransactionGroupAsMainRunloopObserver]</code> 向 Runloop 中注册回调：</p>

<pre><code class="language-objectivec">+ (void)registerTransactionGroupAsMainRunloopObserver:(_ASAsyncTransactionGroup *)transactionGroup {
  static CFRunLoopObserverRef observer;
  CFRunLoopRef runLoop = CFRunLoopGetCurrent();
  CFOptionFlags activities = (kCFRunLoopBeforeWaiting | kCFRunLoopExit);
  CFRunLoopObserverContext context = {0, (__bridge void *)transactionGroup, &amp;CFRetain, &amp;CFRelease, NULL};

  observer = CFRunLoopObserverCreate(NULL, activities, YES, INT_MAX, &amp;_transactionGroupRunLoopObserverCallback, &amp;context);
  CFRunLoopAddObserver(runLoop, observer, kCFRunLoopCommonModes);
  CFRelease(observer);
}
</code></pre>

<p>上述代码会在即将退出 Runloop 或者 Runloop 开始休眠时执行回调 <code>_transactionGroupRunLoopObserverCallback</code>，而这个回调方法就是这一条主线的入口：</p>

<pre><code class="language-objectivec">static void _transactionGroupRunLoopObserverCallback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) {
  ASDisplayNodeCAssertMainThread();
  _ASAsyncTransactionGroup *group = (__bridge _ASAsyncTransactionGroup *)info;
  [group commit];
}
</code></pre>

<p>上一节中只是会将绘制代码提交到后台的并发进程中，而这里才会将结果提交，也就是在每次 Runloop 循环结束时开始绘制内容，而 <code>-[_operationCompletionBlock commit]</code> 方法的调用栈能够帮助我们理解内容是如何提交的，又是如何传回 <code>node</code> 持有的 <code>layer</code> 的：</p>

<pre><code class="language-objectivec">-[_ASAsyncTransactionGroup commit]
	-[_ASAsyncTransaction commit]
		ASAsyncTransactionQueue::GroupImpl::notify(dispatch_queue_t, dispatch_block_t)
			_notifyList.push_back(GroupNotify)
</code></pre>

<p><code>-[_ASAsyncTransactionGroup commit]</code> 方法的调用完成了对绘制事务的提交，而在 <code>-[_ASAsyncTransaction commit]</code> 中会调用 <code>notify</code> 方法，在上一节中的 <code>displayBlock</code> 执行结束后调用这里传入的 block 执行 <code>-[_ASAsyncTransaction completeTransaction]</code> 方法：</p>

<pre><code class="language-objectivec">- (void)commit {
  ASDisplayNodeAssertMainThread();
  __atomic_store_n(&amp;_state, ASAsyncTransactionStateCommitted, __ATOMIC_SEQ_CST);

  _group-&gt;notify(_callbackQueue, ^{
	ASDisplayNodeAssertMainThread();
	[self completeTransaction];
  });
}
</code></pre>

<p>我们按照时间顺序来分析在上面的 block 执行之前，方法是如何调用的，以及 block 是如何被执行的；这就不得不回到派发绘制事务的部分了，在 <code>ASAsyncTransactionQueue::GroupImpl::schedule</code> 方法中，使用了 <code>dispatch_async</code> 将派发 block：</p>

<pre><code class="language-objectivec">void ASAsyncTransactionQueue::GroupImpl::schedule(NSInteger priority, dispatch_queue_t queue, dispatch_block_t block) {
  ...
  if (entry._threadCount &lt; maxThreads) {
	...    
	dispatch_async(queue, ^{
	  ...
	  while (!entry._operationQueue.empty()) {
		Operation operation = entry.popNextOperation(respectPriority);
		{
		  ASDN::MutexUnlocker unlock(q._mutex);
		  if (operation._block) {
			operation._block();
		  }
		  operation._group-&gt;leave();
		  operation._block = nil;
		}
	  }
	  ...
	});
  }
}
</code></pre>

<p>在 <code>displayBlock</code> 执行之后，会调用的 <code>group</code> 的 <code>leave</code> 方法：</p>

<pre><code class="language-objectivec">void ASAsyncTransactionQueue::GroupImpl::leave() {
  if (_pendingOperations == 0) {
	std::list&lt;GroupNotify&gt; notifyList;
	_notifyList.swap(notifyList);

	for (GroupNotify &amp; notify : notifyList) {
	  dispatch_async(notify._queue, notify._block);
	}
  }
}
</code></pre>

<p>这里终于执行了在 <code>- commit</code> 中加入的 block，也就是 <code>-[_ASAsyncTransaction completeTransaction]</code> 方法：</p>

<pre><code class="language-objectivec">- (void)completeTransaction {
  if (__atomic_load_n(&amp;_state, __ATOMIC_SEQ_CST) != ASAsyncTransactionStateComplete) {
	BOOL isCanceled = (__atomic_load_n(&amp;_state, __ATOMIC_SEQ_CST) == ASAsyncTransactionStateCanceled);
	for (ASDisplayNodeAsyncTransactionOperation *operation in _operations) {
	  [operation callAndReleaseCompletionBlock:isCanceled];
	}

	__atomic_store_n(&amp;_state, ASAsyncTransactionStateComplete, __ATOMIC_SEQ_CST);
  }
}
</code></pre>

<p>最后的最后，<code>-[ASDisplayNodeAsyncTransactionOperation callAndReleaseCompletionBlock:]</code> 方法执行了回调将 <code>displayBlock</code> 执行的结果传回了 CALayer:</p>

<pre><code class="language-objectivec">- (void)callAndReleaseCompletionBlock:(BOOL)canceled; {
  if (_operationCompletionBlock) {
	_operationCompletionBlock(self.value, canceled);
	self.operationCompletionBlock = nil;
  }
}
</code></pre>

<p>也就是在  <code>-[ASDisplayNode(AsyncDisplay) displayAsyncLayer:asynchronously:]</code> 方法中构建的 <code>completionBlock</code>：</p>

<pre><code class="language-objectivec">asyncdisplaykit_async_transaction_operation_completion_block_t completionBlock = ^(id&lt;NSObject&gt; value, BOOL canceled){
  ASDisplayNodeCAssertMainThread();
  if (!canceled &amp;&amp; !isCancelledBlock()) {
	UIImage *image = (UIImage *)value;
	BOOL stretchable = !UIEdgeInsetsEqualToEdgeInsets(image.capInsets, UIEdgeInsetsZero);
	if (stretchable) {
	  ASDisplayNodeSetupLayerContentsWithResizableImage(_layer, image);
	} else {
	  _layer.contentsScale = self.contentsScale;
	  _layer.contents = (id)image.CGImage;
	}
	[self didDisplayAsyncLayer:self.asyncLayer];
  }
};
</code></pre>

<p>这一部分进行的大量的数据传递都是通过 block 进行的，从 Runloop 中对事务的提交，以及通过 <code>notify</code> 方法加入的 block，都是为了最后将绘制的结果传回 <code>CALayer</code> 对象，而到这里可以说整个 ASDK 对于视图内容的绘制过程就结束了。</p>

<h2 id="总结">总结</h2>

<p>ASDK 对于绘制过程的优化有三部分：分别是栅格化子视图、绘制图像以及绘制文字。</p>

<p>它拦截了视图加入层级时发出的通知 <code>- willMoveToWindow:</code> 方法，然后手动调用 <code>- setNeedsDisplay</code>，强制所有的 <code>CALayer</code> 执行 <code>- display</code> 更新内容；</p>

<p>然后将上面的操作全部抛入了后台的并发线程中，并在 Runloop 中注册回调，在每次 Runloop 结束时，对已经完成的事务进行 <code>- commit</code>，以图片的形式直接传回对应的 <code>layer.content</code> 中，完成对内容的更新。</p>

<p>从它的实现来看，确实解决了很多昂贵的 CPU 以及 GPU 操作，有效地加快了视图的绘制和渲染，保证了主线程的流畅执行。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://hardforum.com/threads/how-vsync-works-and-why-people-loathe-it.928593/">How VSync works, and why people loathe it</a></li>
  <li><a href="http://www.jianshu.com/p/71cba1711de0">脑洞大开：为啥帧率达到 60 fps 就流畅？</a></li>
  <li><a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Analog_television#Vertical_synchronization">CADiplayLink Class Reference - Developer- Apple</a></li>
  <li><a href="https://zsisme.gitbooks.io/ios-/content/chapter12/cpu-versus-gpu.html">CPU vs GPU · iOS 核心动画高级技巧</a></li>
  <li><a href="http://vizlabxt.github.io/blog/2012/10/22/UIView-Rendering/">理解 UIView 的绘制</a></li>
  <li><a href="http://vizlabxt.github.io/blog/2015/01/09/Behind-AsyncDisplayKit/">Introduce to AsyncDisplayKit</a></li>
  <li><a href="https://www.raywenderlich.com/86365/asyncdisplaykit-tutorial-achieving-60-fps-scrolling">AsyncDisplayKit Tutorial: Achieving 60 FPS scrolling</a></li>
  <li><a href="http://floriankugler.com/2013/05/24/layer-trees-vs-flat-drawing-graphics-performance-across-ios-device-generations/">Layer Trees vs. Flat Drawing – Graphics Performance Across iOS Device Generations</a></li>
  <li><a href="http://blog.ibireme.com/2015/05/18/runloop/">深入理解 RunLoop</a></li>
</ul>

<h2 id="其它">其它</h2>

<blockquote>
  <p>Github Repo：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://nju520.me/asdk-rendering</p>
</blockquote>

  ]]></description>
</item>


  </channel>
</rss>
