<!DOCTYPE html>
<html>
  <head>
    <!-- [[! Document Settings ]] -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- [[! Page Meta ]] -->
    <title>
      
        雄关漫道真如铁
      
    </title>
    
    <meta name="description" content="雄关漫道真如铁 - nju520's Blog" />
    

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="/assets/images/favicon.ico" >

    <!-- [[! Styles'n'Scripts ]] -->
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css"
      href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />

    <link rel="stylesheet" type="text/css" href="/assets/css/prism.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/toc.css" />

    <!-- [[! Ghost outputs important style and meta data with this tag ]] -->
    <link rel="canonical" href="/" />
<meta name="referrer" content="origin" />
<link rel="next" href="/page2/" />

<meta property="og:site_name" content="雄关漫道真如铁" />
<meta property="og:type" content="website" />
<meta property="og:title" content="" />

<meta property="og:description" content="" />

<meta property="og:url" content="http://localhost:4000" />
<meta property="og:image" content="assets/images/macpro.jpg" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="" />

<meta name="twitter:description" content="" />

<meta name="twitter:url" content="http://localhost:4000" />
<meta name="twitter:image:src" content="assets/images/macpro.jpg" />

<script type="application/ld+json">
  {
  "@context": "http://schema.org",
  "@type": "Website",
  "publisher": "nju520",
  "url": "http://localhost:4000",
  "image": "assets/images/macpro.jpg",
  "description": ""
  }
</script>

<meta name="generator" content="Jekyll 3.0.0" />
<link rel="alternate" type="application/rss+xml" title="雄关漫道真如铁" href="/feed.xml" />

    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
<script>
 (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
 })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

 ga('create', 'UA-114647632-1', 'auto');
 ga('send', 'pageview', location.pathname);

</script>

<!-- Baidu Analytics  Manager -->
<script>
 var _hmt = _hmt || [];
 (function() {
   var hm = document.createElement("script");
   hm.src = "https://hm.baidu.com/hm.js?e9208862845c46a0f79e7828f495e407";
   var s = document.getElementsByTagName("script")[0];
   s.parentNode.insertBefore(hm, s);
 })();
</script>

<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-PWFC85B');</script>
  <!-- End Google Tag Manager -->


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-114647632-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-114647632-1');
</script>

  </head>
  <body class=" home-template nav-closed">
    <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PWFC85B"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->


    <div class="nav">
  <h3 class="nav-title">Home</h3>
  <a href="#" class="nav-close">
    <span class="hidden">Close</span>
  </a>
  <ul>
    <li class="nav-home " role="presentation"><a href="/">Home</a></li>
    <!-- <li class="nav-about " role="presentation"><a href="/about">About</a></li>
    <li class="nav-author " role="presentation"><a href="/author/casper">Author</a></li> -->
    <li class="nav-ios  nav-current" role="presentation"><a href="/tag/iOS">iOS</a></li>
    <li class="nav-mvc " role="presentation"><a href="/tag/MVC">MVC</a></li>
    <li class="nav-server " role="presentation"><a href="/tag/server">Server</a></li>
    <li class="nav-ruby " role="presentation"><a href="/tag/ruby">Ruby</a></li>
  </ul>
  <a class="subscribe-button icon-feed" href="/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

      <!-- [[! Everything else gets inserted here ]] -->
      <!-- < default}} -->
<!-- The tag above means - insert everything in this file into the [body] of the default.hbs template -->

<!-- If we have a tag cover, display that - else blog cover - else nothing -->
<header class="main-header tag-head " style="background-image: url(/assets/images/macpro.jpg) ">
  <nav class="main-nav overlay clearfix">
    <a class="blog-logo" href="/"><img src="/assets/images/ghost.png" alt="Blog Logo" /></a>
    
    <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
    
  </nav>
  <div class="vertical">
    <div class="main-header-content inner">
      <h1 class="page-title">iOS</h1>
      <h2 class="page-description">
        
        A 63-post collection
        
      </h2>
    </div>
  </div>
</header>

<!-- The main content area on the homepage -->
<main id="content" class="content" role="main">

  <!-- The tag below includes the post loop - partials/loop.hbs -->
  <!-- Previous/next page links - only displayed on page 2+ -->
<div class="extra-pagination inner">
  
  <nav class="pagination" role="pagination">
  
  <span class="page-number"> Page 1 of 5 </span>
  
  <a class="older-posts" href="/tag/iOS/page2/" title="Next Page">Older Posts &raquo;</a>
  
</nav>

  
</div>

<!-- This is the post loop - each post will be output using this markup -->

<article class="post">
  <header class="post-header">
    <h2 class="post-title"><a href="/metaprogramming">谈元编程与表达能力</a></h2>
  </header>
  <section class="post-excerpt">
    
    <p>在这篇文章中，作者会介绍不同的编程语言如何增强自身的表达能力，也就是不同的元编程能力，包括宏和运行时两种实现元编程的方法，文章不仅会介绍 C、Elixir 和 Rust 语言中的宏系统的优劣以及特性，还会介绍 Objective-C 和 Ruby 的面向对象模型以及它们在运行期间修改对象行为的原理。 <a class="read-more" href="/metaprogramming">&raquo;</a></p>
    
  </section>
  <footer class="post-meta">
    <img class="author-thumb" src="/assets/images/draven.png" alt="Author image" nopin="nopin" />
    
    <a href='/tag/metaprogramming'>metaprogramming</a>
    
    <a href='/tag/macro'>macro</a>
    
    <a href='/tag/runtime'>runtime</a>
    
    <a href='/tag/c'>c</a>
    
    <a href='/tag/elixir'>elixir</a>
    
    <a href='/tag/rust'>rust</a>
    
    <a href='/tag/ruby'>ruby</a>
    
    <a href='/tag/iOS'>iOS</a>
    
    <a href='/tag/server'>server</a>
    
    <time class="post-date" datetime="2017-12-10">10 Dec 2017</time>
  </footer>
</article>

<article class="post">
  <header class="post-header">
    <h2 class="post-title"><a href="/mvx">浅谈 MVC、MVP 和 MVVM 架构模式</a></h2>
  </header>
  <section class="post-excerpt">
    
    <p>这是 MVX 系列的第四篇文章，在前面的文章中，我们先后介绍了 iOS 中的 Model、View 和 Controller 的现状，对比了其他平台中的设计，最后给出了作者理想中的结构。而这一篇文章，作者会依次介绍 MVC、MVP 以及 MVVM 架构模式以及不同平台对它们的使用，虽然参考了很多资料，不过文中观点难免掺入作者的主观意见，作者也希望文中的错误与不足之处能被各位读者指出。 <a class="read-more" href="/mvx">&raquo;</a></p>
    
  </section>
  <footer class="post-meta">
    <img class="author-thumb" src="/assets/images/draven.png" alt="Author image" nopin="nopin" />
    
    <a href='/tag/MVC'>MVC</a>
    
    <a href='/tag/MVVM'>MVVM</a>
    
    <a href='/tag/iOS'>iOS</a>
    
    <time class="post-date" datetime="2017-07-12">12 Jul 2017</time>
  </footer>
</article>

<article class="post">
  <header class="post-header">
    <h2 class="post-title"><a href="/mvx-controller">谈谈 MVX 中的 Controller</a></h2>
  </header>
  <section class="post-excerpt">
    
    <p>在前两篇文章中，我们已经对 iOS 中的 Model 层以及 View 层进行了分析，划分出了它们的具体职责，其中 Model 层除了负责数据的持久存储、缓存工作，还要负责所有 HTTP 请求的发出等工作；而对于 View 层的职责，我们并没有做出太多的改变，有的只是细分其内部的视图种类，以及分离 UIView 不应该具有的属性和功能。 <a class="read-more" href="/mvx-controller">&raquo;</a></p>
    
  </section>
  <footer class="post-meta">
    <img class="author-thumb" src="/assets/images/draven.png" alt="Author image" nopin="nopin" />
    
    <a href='/tag/MVC'>MVC</a>
    
    <a href='/tag/MVVM'>MVVM</a>
    
    <a href='/tag/iOS'>iOS</a>
    
    <time class="post-date" datetime="2017-06-23">23 Jun 2017</time>
  </footer>
</article>

<article class="post">
  <header class="post-header">
    <h2 class="post-title"><a href="/mvx-view">谈谈 MVX 中的 View</a></h2>
  </header>
  <section class="post-excerpt">
    
    <p>这是谈谈 MVX 系列的第二篇文章，上一篇文章中对 iOS 中 Model 层的设计进行了简要的分析；而在这里，我们会对 MVC 中的视图层进行讨论，谈一谈现有的视图层有着什么样的问题，如何在框架的层面上去改进，同时与服务端的视图层进行对比，分析它们的差异。 <a class="read-more" href="/mvx-view">&raquo;</a></p>
    
  </section>
  <footer class="post-meta">
    <img class="author-thumb" src="/assets/images/draven.png" alt="Author image" nopin="nopin" />
    
    <a href='/tag/MVC'>MVC</a>
    
    <a href='/tag/MVVM'>MVVM</a>
    
    <a href='/tag/iOS'>iOS</a>
    
    <time class="post-date" datetime="2017-06-23">23 Jun 2017</time>
  </footer>
</article>

<article class="post">
  <header class="post-header">
    <h2 class="post-title"><a href="/mvx-model">谈谈 MVX 中的 Model</a></h2>
  </header>
  <section class="post-excerpt">
    
    <p>在大多数 iOS 的项目中，Model 层只是一个单纯的数据结构，你可以看到的绝大部分模型都是这样的；模型起到了定义一堆『坑』的作用，只是一个简单的模板，并没有参与到实际的业务逻辑，只是在模型层进行了一层抽象，将服务端发回的 JSON 或者说 Dictionary 对象中的字段一一取出并装填到预先定义好的模型中。 <a class="read-more" href="/mvx-model">&raquo;</a></p>
    
  </section>
  <footer class="post-meta">
    <img class="author-thumb" src="/assets/images/draven.png" alt="Author image" nopin="nopin" />
    
    <a href='/tag/MVC'>MVC</a>
    
    <a href='/tag/MVVM'>MVVM</a>
    
    <a href='/tag/iOS'>iOS</a>
    
    <time class="post-date" datetime="2017-06-23">23 Jun 2017</time>
  </footer>
</article>

<article class="post">
  <header class="post-header">
    <h2 class="post-title"><a href="/kvocontroller">如何优雅地使用 KVO</a></h2>
  </header>
  <section class="post-excerpt">
    
    <p>KVO 作为 iOS 中一种强大并且有效的机制，为 iOS 开发者们提供了很多的便利；我们可以使用 KVO 来检测对象属性的变化、快速做出响应，这能够为我们在开发强交互、响应式应用以及实现视图和模型的双向绑定时提供大量的帮助。 但是在大多数情况下，除非遇到不用 KVO 无法解决的问题，笔者都会尽量避免它的使用，这并不是因为 KVO 有性能问题或者使用场景不多，总重要的原因是 KVO 的使用是在是太 ** 麻烦了。 使用 KVO 时，既需要进行注册成为某个对象属性的观察者，还要在合适的时间点将自己移除，再加上需要覆写一个又臭又长的方法，并在方法里判断这次是不是自己要观测的属性发生了变化，每次想用... <a class="read-more" href="/kvocontroller">&raquo;</a></p>
    
  </section>
  <footer class="post-meta">
    <img class="author-thumb" src="/assets/images/draven.png" alt="Author image" nopin="nopin" />
    
    <a href='/tag/iOS'>iOS</a>
    
    <a href='/tag/KVO'>KVO</a>
    
    <time class="post-date" datetime="2017-03-06">06 Mar 2017</time>
  </footer>
</article>

<article class="post">
  <header class="post-header">
    <h2 class="post-title"><a href="/racdelegateproxy">从代理到 RACSignal</a></h2>
  </header>
  <section class="post-excerpt">
    
    <p>ReactiveCocoa 将 Cocoa 中的 Target-Action、KVO、通知中心以及代理等设计模式都桥接到了 RAC 的世界中，我们在随后的几篇文章中会介绍 RAC 如何做到了上面的这些事情，而本篇文章会介绍 ReactiveCocoa 是如何把代理转换为信号的。 RACDelegateProxy 从代理转换成信号所需要的核心类就是 RACDelegateProxy，这是一个设计的非常巧妙的类；虽然在类的头文件中，它被标记为私有类，但是我们仍然可以使用 -initWithProtocol: 方法直接初始化该类的实例。 - (instancetype)initWithProtocol:(Protocol *)protocol {... <a class="read-more" href="/racdelegateproxy">&raquo;</a></p>
    
  </section>
  <footer class="post-meta">
    <img class="author-thumb" src="/assets/images/draven.png" alt="Author image" nopin="nopin" />
    
    <a href='/tag/iOS'>iOS</a>
    
    <a href='/tag/RAC'>RAC</a>
    
    <time class="post-date" datetime="2017-02-25">25 Feb 2017</time>
  </footer>
</article>

<article class="post">
  <header class="post-header">
    <h2 class="post-title"><a href="/racscheduler">理解 RACScheduler 的实现</a></h2>
  </header>
  <section class="post-excerpt">
    
    <p>RACScheduler 是一个线性执行队列，ReactiveCocoa 中的信号可以在 RACScheduler 上执行任务、发送结果；它的实现并不复杂，由多个简单的方法和类组成整个 RACScheduler 模块，是整个 ReactiveCocoa 中非常易于理解的部分。 RACScheduler 简介 RACScheduler 作为 ReactiveCocoa 中唯一的用于调度的模块，它包含很多个性化的子类： RACScheduler 类的内部只有一个用于追踪标记和 debug 的属性 name，头文件和实现文件中的其它内容都是各种各样的方法；我们可以把其中的方法分为两类，一类是用于初始化... <a class="read-more" href="/racscheduler">&raquo;</a></p>
    
  </section>
  <footer class="post-meta">
    <img class="author-thumb" src="/assets/images/draven.png" alt="Author image" nopin="nopin" />
    
    <a href='/tag/iOS'>iOS</a>
    
    <a href='/tag/RAC'>RAC</a>
    
    <time class="post-date" datetime="2017-02-17">17 Feb 2017</time>
  </footer>
</article>

<article class="post">
  <header class="post-header">
    <h2 class="post-title"><a href="/racchannel">RAC 中的双向数据绑定 RACChannel</a></h2>
  </header>
  <section class="post-excerpt">
    
    <p>之前讲过了 ReactiveCocoa 中的一对一的单向数据流 RACSignal 和一对多的单向数据流 RACMulticastConnection，这一篇文章分析的是一对一的双向数据流 RACChannel。 RACChannel 其实是一个相对比较复杂的类，但是，对其有一定了解之后合理运用的话，会在合适的业务中提供非常强大的支持能够极大的简化业务代码。 RACChannel 简介 RACChannel 可以被理解为一个双向的连接，这个连接的两端都是 RACSignal 实例，它们可以向彼此发送消息，如果我们在视图和模型之间通过 RACChannel 建立这样的连接： 那么从模型发出的消息，最后会发送到视图上；反之，用户对视图进行的操作最后也会体现在模型上。这种通信方式的实现是基于信号的，RACChannel 内部封装了两个 RACChannelTerminal... <a class="read-more" href="/racchannel">&raquo;</a></p>
    
  </section>
  <footer class="post-meta">
    <img class="author-thumb" src="/assets/images/draven.png" alt="Author image" nopin="nopin" />
    
    <a href='/tag/iOS'>iOS</a>
    
    <a href='/tag/RAC'>RAC</a>
    
    <time class="post-date" datetime="2017-02-16">16 Feb 2017</time>
  </footer>
</article>

<article class="post">
  <header class="post-header">
    <h2 class="post-title"><a href="/racconnection">用于多播的 RACMulticastConnection</a></h2>
  </header>
  <section class="post-excerpt">
    
    <p>ReactiveCocoa 中的信号信号在默认情况下都是冷的，每次有新的订阅者订阅信号时都会执行信号创建时传入的 block；这意味着对于任意一个订阅者，所需要的数据都会重新计算，这在大多数情况下都是开发者想看到的情况，但是这在信号中的 block 有副作用或者较为昂贵时就会有很多问题。 我们希望有一种模型能够将冷信号转变成热信号，并在合适的时间触发，向所有的订阅者发送消息；而今天要介绍的 RACMulticastConnection 就是用于解决上述问题的。 RACMulticastConnection 简介 RACMulticastConnection 封装了将一个信号的订阅分享给多个订阅者的思想，它的每一个对象都持有两个 RACSignal： 一个是私有的源信号 sourceSignal，另一个是用于广播的信号 signal，其实是一个 RACSubject 对象，不过对外只提供 RACSignal 接口，用于使用者通过... <a class="read-more" href="/racconnection">&raquo;</a></p>
    
  </section>
  <footer class="post-meta">
    <img class="author-thumb" src="/assets/images/draven.png" alt="Author image" nopin="nopin" />
    
    <a href='/tag/iOS'>iOS</a>
    
    <a href='/tag/RAC'>RAC</a>
    
    <time class="post-date" datetime="2017-02-15">15 Feb 2017</time>
  </footer>
</article>

<article class="post">
  <header class="post-header">
    <h2 class="post-title"><a href="/raccommand">优雅的 RACCommand</a></h2>
  </header>
  <section class="post-excerpt">
    
    <p>RACCommand 是一个在 ReactiveCocoa 中比较复杂的类，大多数使用 ReactiveCocoa 的人，尤其是初学者并不会经常使用它。 在很多情况下，虽然使用 RACSignal 和 RACSubject 就能解决绝大部分问题，但是 RACCommand 的使用会为我们带来巨大的便利，尤其是在与副作用相关的操作中。 文章中不会讨论 RACCommand 中的并行执行问题，也就是忽略了 allowsConcurrentExecution 以及 allowsConcurrentExecutionSubject 的存在，不过它们确实在... <a class="read-more" href="/raccommand">&raquo;</a></p>
    
  </section>
  <footer class="post-meta">
    <img class="author-thumb" src="/assets/images/draven.png" alt="Author image" nopin="nopin" />
    
    <a href='/tag/iOS'>iOS</a>
    
    <a href='/tag/RAC'>RAC</a>
    
    <time class="post-date" datetime="2017-02-10">10 Feb 2017</time>
  </footer>
</article>

<article class="post">
  <header class="post-header">
    <h2 class="post-title"><a href="/racsubject">『可变』的热信号 RACSubject</a></h2>
  </header>
  <section class="post-excerpt">
    
    <p>在 ReactiveCocoa 中除了不可变的信号 RACSignal，也有用于桥接非 RAC 代码到 ReactiveCocoa 世界的『可变』信号 RACSubject。 RACSubject 到底是什么？根据其字面意思，可以将它理解为一个可以订阅的主题，我们在订阅主题之后，向主题发送新的消息时，所有的订阅者都会接收到最新的消息。 但是这么解释确实有点晦涩，也不易于理解，ReactiveCocoa 团队对 RACSubject 的解释是，RACSubject 其实就是一个可以手动控制的信号（感觉这么解释更难理解了）。 A subject, represented by... <a class="read-more" href="/racsubject">&raquo;</a></p>
    
  </section>
  <footer class="post-meta">
    <img class="author-thumb" src="/assets/images/draven.png" alt="Author image" nopin="nopin" />
    
    <a href='/tag/iOS'>iOS</a>
    
    <a href='/tag/RAC'>RAC</a>
    
    <time class="post-date" datetime="2017-02-07">07 Feb 2017</time>
  </footer>
</article>

<article class="post">
  <header class="post-header">
    <h2 class="post-title"><a href="/racsequence">Pull-Driven 的数据流 RACSequence</a></h2>
  </header>
  <section class="post-excerpt">
    
    <p>ReactiveCocoa 在设计上很大程度借鉴了 Reactive Extension 中的概念，可以说 ReactiveCocoa 是 Rx 在 Objective-C 语言中的实现。 在 Rx 中主要的两个概念信号和序列都在 ReactiveCocoa 中有着相对应的组件 RACSignal 和 RACSequence，上一篇文章已经对前者有一个简单的介绍，而这篇文章主要会介绍后者，也就是 RACSequence。... <a class="read-more" href="/racsequence">&raquo;</a></p>
    
  </section>
  <footer class="post-meta">
    <img class="author-thumb" src="/assets/images/draven.png" alt="Author image" nopin="nopin" />
    
    <a href='/tag/iOS'>iOS</a>
    
    <a href='/tag/RAC'>RAC</a>
    
    <time class="post-date" datetime="2017-02-04">04 Feb 2017</time>
  </footer>
</article>

<article class="post">
  <header class="post-header">
    <h2 class="post-title"><a href="/racsignal">『状态』驱动的世界：ReactiveCocoa</a></h2>
  </header>
  <section class="post-excerpt">
    
    <p>这篇以及之后的文章主要会对 ReactiveObjc v2.1.2 的实现进行分析，从最简单的例子中了解 ReactiveCocoa 的工作原理以及概念，也是笔者个人对于 RAC 学习的总结与理解。本文主要会围绕 RAC 中核心概念 RACSignal 展开，详细了解其底层实现。 状态驱动 2015 年的夏天的时候，做了几个简单的开源框架，想做点其它更有意思的框架却没什么思路，就开始看一些跟编程没有太大关系的书籍。 其中一本叫做《失控》给了我很大的启发，其中有一则故事是这样的： 布鲁克斯开展了一个雄心勃勃的研究生课题项目，研发更接近昆虫而非恐龙的机器人。 布鲁克斯的设想在一个叫「成吉思」的机巧装置上成形。成吉思有橄榄球大小，像只蟑螂似的。布鲁克斯把他的精简理念发挥到了极致。小成吉思有 6 条腿却没有一丁点儿可以称为「脑」的东西。所有... <a class="read-more" href="/racsignal">&raquo;</a></p>
    
  </section>
  <footer class="post-meta">
    <img class="author-thumb" src="/assets/images/draven.png" alt="Author image" nopin="nopin" />
    
    <a href='/tag/iOS'>iOS</a>
    
    <a href='/tag/RAC'>RAC</a>
    
    <time class="post-date" datetime="2017-01-30">30 Jan 2017</time>
  </footer>
</article>

<article class="post">
  <header class="post-header">
    <h2 class="post-title"><a href="/preload">预加载与智能预加载（iOS）</a></h2>
  </header>
  <section class="post-excerpt">
    
    <p>前两次的分享分别介绍了 ASDK 对于渲染的优化以及 ASDK 中使用的另一种布局模型；这两个新机制的引入分别解决了 iOS 在主线程渲染视图以及 Auto Layout 的性能问题，而这一次讨论的主要内容是 ASDK 如何预先请求服务器数据，达到看似无限滚动列表的效果的。 这篇文章是 ASDK 系列中的最后一篇，文章会介绍 iOS 中几种预加载的方案，以及 ASDK 中是如何处理预加载的。 不过，在介绍... <a class="read-more" href="/preload">&raquo;</a></p>
    
  </section>
  <footer class="post-meta">
    <img class="author-thumb" src="/assets/images/draven.png" alt="Author image" nopin="nopin" />
    
    <a href='/tag/iOS'>iOS</a>
    
    <a href='/tag/ASDK'>ASDK</a>
    
    <time class="post-date" datetime="2016-11-04">04 Nov 2016</time>
  </footer>
</article>


<!-- Previous/next page links - displayed on every page -->

<nav class="pagination" role="pagination">
  
  <span class="page-number"> Page 1 of 5 </span>
  
  <a class="older-posts" href="/tag/iOS/page2/" title="Next Page">Older Posts &raquo;</a>
  
</nav>




</main>


      <footer class="site-footer clearfix">
        <section class="copyright"><a href="/">雄关漫道真如铁</a> &copy; 2018</section>
        <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/biomadeira/jasper">Jasper</a></section>
      </footer>
    </div>
    <!-- [[! Ghost outputs important scripts and data with this tag ]] -->
    <script type="text/javascript" src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
    <!-- [[! The main JavaScript file for Casper ]] -->
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="/assets/js/index.js"></script>
    <script type="text/javascript" src="/assets/js/prism.js"></script>
    <script type="text/javascript" src="/assets/js/toc.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  </body>
</html>
