<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    
    <title>nju520.me</title>
    
    <link>http://localhost:4000</link>
    <description>nju520's Blog</description>
    <language>en-uk</language>
    <managingEditor> nju520</managingEditor>
    <atom:link href="rss" rel="self" type="application/rss+xml" />
    
<item>
  <title>谈元编程与表达能力</title>
  <link>//metaprogramming</link>
  <author>nju520</author>
  <pubDate>2017-12-10T00:00:00+08:00</pubDate>
  <guid>//metaprogramming</guid>
  <description><![CDATA[
  <p>在这篇文章中，作者会介绍不同的编程语言如何增强自身的表达能力，在写这篇文章的时候其实就已经想到这可能不是一篇有着较多受众和读者的文章。不过作者仍然想跟各位读者分享一下对不同编程语言的理解，同时也对自己的知识体系进行简单的总结。</p>

<p><img src="https://img.nju520.me/2017-12-10-metaprogramming.png" alt="metaprogramming" /></p>

<p>当我们刚刚开始学习和了解编程这门手艺或者说技巧时，一切的知识与概念看起来都非常有趣，随着学习的深入和对语言的逐渐了解，我们可能会发现原来看起来无所不能的编程语言成为了我们的限制，尤其是在我们想要使用一些<strong>元编程</strong>技巧的时候，你会发现有时候语言限制了我们的能力，我们只能一遍一遍地写重复的代码来解决本可以轻松搞定的问题。</p>

<h2 id="元编程">元编程</h2>

<p>元编程（Metaprogramming）是计算机编程中一个非常重要、有趣的概念，<a href="https://en.wikipedia.org/wiki/Metaprogramming">维基百科</a> 上将元编程描述成一种计算机程序可以<strong>将代码看待成数据</strong>的能力。</p>

<blockquote>
  <p>Metaprogramming is a programming technique in which computer programs have the ability to treat programs as their data.</p>
</blockquote>

<p>如果能够将代码看做数据，那么代码就可以像数据一样在运行时被修改、更新和替换；元编程赋予了编程语言更加强大的表达能力，能够让我们将一些计算过程从运行时挪到编译时、通过编译期间的展开生成代码或者允许程序在运行时改变自身的行为。</p>

<p><img src="https://img.nju520.me/2017-12-10-metaprogramming-usage.png" alt="metaprogramming-usage" /></p>

<p>总而言之，<strong>元编程其实是一种使用代码生成代码的方式</strong>，无论是编译期间生成代码，还是在运行时改变代码的行为都是『生成代码』的一种，下面的代码其实就可以看作一种最简单的元编程技巧：</p>

<pre><code class="language-c">int main() {
    for(int i = 0; i &lt; 10; i++) {
        char *echo = (char*)malloc(6 * sizeof(char));
        sprintf(echo, "echo %d", i);
        system(echo);
    }
    return 0;
}
</code></pre>

<p>这里的代码其实等价于执行了以下的 shell 脚本，也可以说这里使用了 C 语言的代码生成来生成 shell 脚本：</p>

<pre><code class="language-shell">echo 0
echo 1
...
echo 9
</code></pre>

<h2 id="编译时和运行时">编译时和运行时</h2>

<p>现代的编程语言大都会为我们提供不同的元编程能力，从总体来看，根据『生成代码』的时机不同，我们将元编程能力分为两种类型，其中一种是编译期间的元编程，例如：宏和模板；另一种是运行期间的元编程，也就是运行时，它赋予了编程语言在运行期间修改行为的能力，当然也有一些特性既可以在编译期实现，也可以在运行期间实现。</p>

<p><img src="https://img.nju520.me/2017-12-10-compile-and-execute.png" alt="compile-and-execute" /></p>

<p>不同的语言对于泛型就有不一样的实现，Java 的泛型就是在编译期间实现的，它的泛型其实是伪泛型，在编译期间所有的泛型就会被编译器擦除（type erasure），生成的 Java 字节码是不包含任何的泛型信息的，但是 C# 对于泛型就有着不同的实现了，它的泛型类型在运行时进行替换，为实例化的对象保留了泛型的类型信息。</p>

<blockquote>
  <p>C++ 的模板其实与这里讨论的泛型有些类似，它会为每一个具体类型生成一份独立的代码，而 Java 的泛型只会生成一份经过类型擦除后的代码，总而言之 C++ 的模板完全是在编译期间实现的，而 Java 的泛型是编译期间和运行期间协作产生的；模板和泛型虽然非常类似，但是在这里提到的模板大都特指 C++ 的模板，而泛型这一概念其实包含了 C++ 的模板。</p>
</blockquote>

<p>虽然泛型和模板为各种编程语言提供了非常强大的表达能力，但是在这篇文章中，我们会介绍另外两种元编程能力：<em>宏</em>和<em>运行时</em>，前者是在编译期间完成的，而后者是在代码运行期间才发生的。</p>

<h2 id="宏macro">宏（Macro）</h2>

<p>宏是很多编程语言具有的特性之一，它是一个将输入的字符串映射成其他字符串的过程，这个映射的过程也被我们称作宏展开。</p>

<p><img src="https://img.nju520.me/2017-12-10-macro-expansion.png" alt="macro-expansion" /></p>

<p>宏其实就是一个在编译期间中定义的展开过程，通过预先定义好的宏，我们可以使用少量的代码完成更多的逻辑和工作，能够减少应用程序中大量的重复代码。</p>

<p>很多编程语言，尤其是编译型语言都实现了宏这个特性，包括 C、Elixir 和 Rust，然而这些语言却使用了不同的方式来实现宏；我们在这里会介绍两种不同的宏，一种是基于文本替换的宏，另一种是基于语法的宏。</p>

<p><img src="https://img.nju520.me/2017-12-10-different-kinds-of-macros.png" alt="different-kinds-of-macros" /></p>

<p>C、C++ 等语言使用基于文本替换的宏，而类似于 Elixir、Rust 等语言的宏系统其实都是基于语法树和语法元素的，它的实现会比前者复杂很多，应用也更加广泛。</p>

<p>在这一节的剩余部分，我们会分别介绍 C、Elixir 和 Rust 三种不同的编程语言实现的宏系统，它们的使用方法、适用范围和优缺点。</p>

<h3 id="c">C</h3>

<p>作者相信很多工程师入门使用的编程语言其实都是 C 语言，而 C 语言的宏系统看起来还是相对比较简单的，虽然在实际使用时会遇到很多非常诡异的问题。C 语言的宏使用的就是文本替换的方式，所有的宏其实并不是通过编译器展开的，而是由预编译器来处理的。</p>

<p><img src="https://img.nju520.me/2017-12-10-preprocessor.png" alt="preprocesso" /></p>

<p>编译器 GCC 根据『长相』将 C 语言中的宏分为两种，其中的一种宏与编程语言中定义变量非常类似：</p>

<pre><code class="language-c">#define BUFFER_SIZE 1024

char *foo = (char *)malloc(BUFFER_SIZE);
char *foo = (char *)malloc(1024);
</code></pre>

<p>这些宏的定义就是一个简单的标识符，它们会在预编译的阶段被预编译器替换成定义后半部分出现的<strong>字符</strong>，这种宏定义其实比较类似于变量的声明，我们经常会使用这种宏定义替代一些无意义的数字，能够让程序变得更容易理解。</p>

<p>另一种宏定义就比较像对函数的定义了，与其他 C 语言的函数一样，这种宏在定义时也会包含一些宏的参数：</p>

<pre><code class="language-c">#define plus(a, b) a + b
#define multiply(a, b) a * b
</code></pre>

<p>通过在宏的定义中引入参数，宏定义的内部就可以直接使用对应的标识符引入外界传入的参数，在定义之后我们就可以像使用函数一样使用它们：</p>

<pre><code class="language-c">#define plus(a, b) a + b
#define multiply(a, b) a * b

int main(int argc, const char * argv[]) {
    printf("%d", plus(1, 2));       // =&gt; 3
    printf("%d", multiply(3, 2));   // =&gt; 6
    return 0;
}
</code></pre>

<p>上面使用宏的代码与下面的代码是完全等价的，在预编译阶段之后，上面的代码就会被替换成下面的代码，也就是编译器其实是不负责宏展开的过程：</p>

<pre><code class="language-c">int main(int argc, const char * argv[]) {
    printf("%d", 1 + 2);    // =&gt; 3
    printf("%d", 3 * 2);    // =&gt; 6
    return 0;
}
</code></pre>

<p>宏的作用其实非常强大，基于文本替换的宏能做到很多函数无法做到的事情，比如使用宏根据传入的参数创建类并声明新的方法：</p>

<pre><code class="language-c">#define pickerify(KLASS, PROPERTY) interface \
    KLASS (Night_ ## PROPERTY ## _Picker) \
    @property (nonatomic, copy, setter = dk_set ## PROPERTY ## Picker:) DKColorPicker dk_ ## PROPERTY ## Picker; \
    @end \
    @implementation \
    KLASS (Night_ ## PROPERTY ## _Picker) \
    - (DKColorPicker)dk_ ## PROPERTY ## Picker { \
        return objc_getAssociatedObject(self, @selector(dk_ ## PROPERTY ## Picker)); \
    } \
    - (void)dk_set ## PROPERTY ## Picker:(DKColorPicker)picker { \
        objc_setAssociatedObject(self, @selector(dk_ ## PROPERTY ## Picker), picker, OBJC_ASSOCIATION_COPY_NONATOMIC); \
        [self setValue:picker(self.dk_manager.themeVersion) forKeyPath:@keypath(self, PROPERTY)];\
        NSMutableDictionary *pickers = [self valueForKeyPath:@"pickers"];\
        [pickers setValue:[picker copy] forKey:_DKSetterWithPROPERTYerty(@#PROPERTY)]; \
    } \
    @end

@pickerify(Button, backgroundColor);
</code></pre>

<p>上面的代码是我在一个 iOS 的开源库 <a href="https://github.com/nju520/DKNightVersion/blob/master/DKNightVersion/DKNightVersion.h#L57-L72">DKNightVersion</a> 中使用的代码，通过宏的文本替换功能，我们在这里创建了类、属性并且定义了属性的 getter/setter 方法，然而使用者对此其实是一无所知的。</p>

<p>C 语言中的宏只是提供了一些文本替换的功能再加上一些高级的 API，虽然它非常强大，但是强大的事物都是一把双刃剑，再加上 C 语言的宏从实现原理上就有一些无法避免的缺陷，所以在使用时还是要非常小心。</p>

<p>由于预处理器只是对宏进行替换，并没有做任何的语法检查，所以在宏出现问题时，编译器的报错往往会让我们摸不到头脑，不知道哪里出现了问题，还需要脑内对宏进行展开分析出现错误的原因；除此之外，类似于 <code>multiply(1+2, 3)</code> 的展开问题导致人和机器对于同一段代码的理解偏差，作者相信也广为人知了；更高级一些的<strong>分号吞噬</strong>、<strong>参数的重复调用</strong>以及<strong>递归引用时不会递归展开</strong>等问题其实在这里也不想多谈。</p>

<pre><code class="language-c">multiply(1+2, 3) // #=&gt; 1+2 * 3
</code></pre>

<h4 id="卫生宏">卫生宏</h4>

<p>然而 C 语言宏的实现导致的另一个问题却是非常严重的：</p>

<pre><code class="language-c">#define inc(i) do { int a = 0; ++i; } while(0)

int main(int argc, const char * argv[]) {
    int a = 4, b = 8;
    inc(a);
    inc(b);
    printf("%d, %d\n", a, b); // =&gt; 4, 9 !!
    return 0;
}
</code></pre>

<blockquote>
  <p>这一小节与卫生宏有关的 C 语言代码取自 <a href="https://en.wikipedia.org/wiki/Hygienic_macro">Hygienic macro</a> 中的代码示例。</p>
</blockquote>

<p>上述代码中的 <code>printf</code> 函数理应打印出 <code>5, 9</code> 然而却打印出了 <code>4, 9</code>，我们来将上述代码中使用宏的部分展开来看一下：</p>

<pre><code class="language-c">int main(int argc, const char * argv[]) {
    int a = 4, b = 8;
    do { int a = 0; ++a; } while(0);
    do { int a = 0; ++b; } while(0);
    printf("%d, %d\n", a, b); // =&gt; 4, 9 !!
    return 0;
}
</code></pre>

<p>这里的 <code>a = 0</code> 按照逻辑应该不发挥任何的作用，但是在这里却覆盖了上下文中 <code>a</code> 变量的值，导致父作用域中变量 <code>a</code> 的值并没有 <code>+1</code>，这其实就是因为 C 语言中实现的宏不是<em>卫生宏</em>（Hygiene macro）。</p>

<p>作者认为卫生宏（Hygiene macro）是一个非常让人困惑的翻译，它其实指一些<strong>在宏展开之后不会意外捕获上下文中标识符的宏</strong>，从定义中我们就可以看到 C 语言中的宏明显不是卫生宏，而接下来要介绍的两种语言的宏系统就实现了卫生宏。</p>

<h3 id="elixir">Elixir</h3>

<p>Elixir 是一门动态的函数式编程语言，它被设计用来构建可扩展、可维护的应用，所有的 Elixir 代码最终都会被编译成二进制文件运行在 Erlang 的虚拟机 Beam 上，构建在 Erlang 上的 Elixir 也继承了很多 Erlang 的优秀特性。然而在这篇文章中并不会展开介绍 Elixir 语言以及它的某些特点和应用，我们只想了解 Elixir 中的宏系统是如何使用和实现的。</p>

<p><img src="https://img.nju520.me/2017-12-10-elixir-logo.png" alt="elixir-logo" /></p>

<p>宏是 Elixir 具有强大表达能力的一个重要原因，通过内置的宏系统可以减少系统中非常多的重复代码，我们可以使用 <code>defmacro</code> 定义一个宏来实现 <code>unless</code> 关键字：</p>

<pre><code class="language-elixir">defmodule Unless do
  defmacro macro_unless(clause, do: expression) do
    quote do
      if(!unquote(clause), do: unquote(expression))
    end
  end
end
</code></pre>

<p>这里的 <code>quote</code> 和 <code>unquote</code> 是宏系统中最重要的两个函数，你可以从字面上理解 <code>quote</code> 其实就是在一段代码的两侧加上双引号，让这段代码变成字符串，而 <code>unquote</code> 会将传入的多个参数的文本<strong>原封不动</strong>的插入到相应的位置，你可以理解为 <code>unquote</code> 只是将 <code>clause</code> 和 <code>expression</code> 代表的字符串当做了返回值。</p>

<pre><code class="language-elixir">Unless.macro_unless true, do: IO.puts "this should never be printed"
</code></pre>

<p>上面的 Elixir 代码在真正执行之前会被替换成一个使用 <code>if</code> 的表达式，我们可以使用下面的方法获得宏展开之后的代码：</p>

<pre><code class="language-elixir">iex&gt; expr = quote do: Unless.macro_unless true, do: IO.puts "this should never be printed"
iex&gt; expr |&gt; Macro.expand_once(__ENV__) |&gt; Macro.to_string |&gt; IO.puts
if(!true) do
  IO.puts("this should never be printed")
end
:ok
</code></pre>

<p>当我们为 <code>quote</code> 函数传入一个表达式的时候，它会将当前的表达式转换成一个抽象语法树：</p>

<pre><code class="language-elixir">{{:., [], [{:__aliases__, [alias: false], [:Unless]}, :macro_unless]}, [],
 [true,
  [do: {{:., [], [{:__aliases__, [alias: false], [:IO]}, :puts]}, [],
    ["this should never be printed"]}]]}
</code></pre>

<p>在 Elixir 中，抽象语法数是可以直接通过下面的 <code>Code.eval_quoted</code> 方法运行：</p>

<pre><code class="language-elixir">iex&gt; Code.eval_quoted [expr]
** (CompileError) nofile:1: you must require Unless before invoking the macro Unless.macro_unless/2
    (elixir) src/elixir_dispatch.erl:97: :elixir_dispatch.dispatch_require/6
    (elixir) lib/code.ex:213: Code.eval_quoted/3
iex&gt; Code.eval_quoted [quote(do: require Unless), expr]
{[Unless, nil], []}
</code></pre>

<p>我们只运行当前的语法树，我们会发现当前的代码由于 <code>Unless</code> 模块没有加载导致宏找不到报错，所以我们在执行 <code>Unless.macro_unless</code> 之前需要先 <code>require</code> 对应的模块。</p>

<p><img src="https://img.nju520.me/2017-12-10-elixir-macro.png" alt="elixir-macro" /></p>

<p>在最开始对当前的宏进行定义时，我们就会发现宏其实输入的是一些语法元素，实现内部也通过 <code>quote</code> 和 <code>unquote</code> 方法对当前的语法树进行修改，最后返回新的语法树：</p>

<pre><code class="language-elixir">defmacro macro_unless(clause, do: expression) do
  quote do
    if(!unquote(clause), do: unquote(expression))
  end
end

iex&gt; expr = quote do: Unless.macro_unless true, do: IO.puts "this should never be printed"
{{:., [], [{:__aliases__, [alias: false], [:Unless]}, :macro_unless]}, [],
 [true,
  [do: {{:., [], [{:__aliases__, [alias: false], [:IO]}, :puts]}, [],
    ["this should never be printed"]}]]}

iex&gt; Macro.expand_once expr, __ENV__
{:if, [context: Unless, import: Kernel],
 [{:!, [context: Unless, import: Kernel], [true]},
  [do: {{:., [],
     [{:__aliases__, [alias: false, counter: -576460752303422687], [:IO]},
      :puts]}, [], ["this should never be printed"]}]]}
</code></pre>

<p>Elixir 中的宏相比于 C 语言中的宏更强大，这是因为它不是对代码中的文本直接进行替换，它能够为我们直接提供操作 Elixir 抽象语法树的能力，让我们能够参与到 Elixir 的编译过程，影响编译的结果；除此之外，Elixir 中的宏还是卫生宏（Hygiene Macro），宏中定义的参数并不会影响当前代码执行的上下文。</p>

<pre><code class="language-elixir">defmodule Example do
  defmacro hygienic do
    quote do
      val = 1
    end
  end
end

iex&gt; val = 42
42
iex&gt; Example.hygienic
1
iex&gt; val
42
</code></pre>

<p>在上述代码中，虽然宏内部的变量与当前环境上下文中的变量重名了，但是宏内部的变量并没有影响上下文中 <code>val</code> 变量的变化，所以 Elixir 中宏系统是『卫生的』，如果我们真的想要改变上下文中的变量，可以使用 <code>var!</code> 来做这件事情：</p>

<pre><code class="language-elixir">defmodule Example do
  defmacro unhygienic do
    quote do
      var!(val) = 2
    end
  end
end

iex&gt; val = 42
42
iex&gt; Example.unhygienic
2
iex&gt; val
2
</code></pre>

<p>相比于使用文本替换的 C 语言宏，Elixir 的宏系统解决了很多问题，例如：卫生宏，不仅如此，Elixir 的宏还允许我们修改当前的代码中的语法树，提供了更加强大的表达能力。</p>

<h3 id="rust">Rust</h3>

<p>Elixir 的宏系统其实已经足够强大了，不止避免了基于文本替换的宏带来的各种问题，我们还可以直接使用宏操作上下文的语法树，作者在一段时间内都觉得 Elixir 的宏系统是接触到的最强大的宏系统，直到开始学习 <a href="https://www.rust-lang.org/en-US/">Rust</a> 才发现更复杂的宏系统。</p>

<p><img src="https://img.nju520.me/2017-12-10-rust-logo.png" alt="rust-logo" /></p>

<p>Rust 是一门非常有趣的编程语言，它是一门有着极高的性能的系统级的编程语言，能够避免当前应用中发生的段错误并且保证线程安全和内存安全，但是这些都不是我们今天想要关注的事情，与 Elixir 一样，在这篇文章中我们仅仅关心 Rust 的宏系统到底是什么样的：</p>

<pre><code class="language-rust">macro_rules! foo {
    (x =&gt; $e:expr) =&gt; (println!("mode X: {}", $e));
    (y =&gt; $e:expr) =&gt; (println!("mode Y: {}", $e));
}
</code></pre>

<p>上面的 Rust 代码定义了一个名为 <code>foo</code> 的宏，我们在代码中需要使用 <code>foo!</code> 来调用上面定义的宏：</p>

<pre><code class="language-rust">fn main() {
    foo!(y =&gt; 3); // =&gt; mode Y: 3
}
</code></pre>

<p>上述的宏 <code>foo</code> 的主体部分其实会将传入的<strong>语法元素</strong>与宏中的条件进行模式匹配，如果匹配到了，就会返回条件右侧的表达式，到这里其实与 Elixir 的宏系统没有太大的区别，Rust 宏相比 Elixir 更强大主要在于其提供了更加灵活的匹配系统，在宏 <code>foo</code> 的定义中使用的 <code>$e:expr</code> 就会匹配一个表达式并将表达式绑定到 <code>$e</code> 这个上下文的变量中，除此之外，在 Rust 中我们还可以组合使用以下的匹配符：</p>

<p><img src="https://img.nju520.me/2017-12-10-rust-macro-matcher-and-example.png" alt="rust-macro-matcher-and-example" /></p>

<p>为了实现功能更强大的宏系统，Rust 的宏还提供了重复操作符和递归宏的功能，结合这两个宏系统的特性，我们能直接使用宏构建一个生成 HTML 的 DSL：</p>

<pre><code class="language-rust">macro_rules! write_html {
    ($w:expr, ) =&gt; (());

    ($w:expr, $e:tt) =&gt; (write!($w, "{}", $e));

    ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) =&gt; {{
        write!($w, "&lt;{}&gt;", stringify!($tag));
        write_html!($w, $($inner)*);
        write!($w, "&lt;/{}&gt;", stringify!($tag));
        write_html!($w, $($rest)*);
    }};
}
</code></pre>

<p>在上述的 <code>write_html</code> 宏中，我们总共有三个匹配条件，其中前两个是宏的终止条件，第一个条件不会做任何的操作，第二个条件会将匹配到的 Token 树求值并写回到传入的字符串引用 <code>$w</code> 中，最后的条件就是最有意思的部分了，在这里我们使用了形如的 <code>$(...)*</code> 语法来<strong>匹配零个或多个相同的语法元素</strong>，例如 <code>$($inner:tt)*</code> 就是匹配零个以上的 Token 树（tt）；在右侧的代码中递归调用了 <code>write_html</code> 宏并分别传入 <code>$($inner)*</code> 和 <code>$($rest)*</code> 两个参数，这样我们的 <code>write_html</code> 就能够解析 DSL 了。</p>

<p>有了 <code>write_html</code> 宏，我们就可以直接使用形如 <code>html[head[title["Macros guide"]]</code> 的代码返回如下所示的 HTML：</p>

<pre><code class="language-html">&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;&lt;/html&gt;
</code></pre>

<blockquote>
  <p>这一节中提供的与 Rust 宏相关的例子都取自 <a href="https://doc.rust-lang.org/book/first-edition/macros.html">官方文档</a> 中对宏的介绍这一部分内容。</p>
</blockquote>

<p>Rust 的宏系统其实是基于一篇 1986 年的论文 <a href="https://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a> 实现的，如果想要深入了解 Rust 的宏系统可以阅读这篇论文；Rust 的宏系统确实非常完备也足够强大，能够做很多我们使用 C 语言宏时无法做到的事情，极大地提高了语言的表达能力。</p>

<h2 id="运行时runtime">运行时（Runtime）</h2>

<p>宏是一种能在程序执行的预编译或者编译期间改变代码行为的能力，通过编译期的处理过程赋予编程语言元编程能力；而运行时，顾名思义一般是指<strong>面向对象</strong>的编程语言在程序运行的某一个时间的上下文，在这里我们想要介绍的运行时可以理解为<strong>能够在运行期间改变对象行为的机制</strong>。</p>

<p><img src="https://img.nju520.me/2017-12-10-phases.png" alt="phases" /></p>

<p>当相应的行为在当前对象上没有被找到时，运行时会提供一个改变当前对象行为的入口，在篇文章中提到的运行时不是广义上的运行时系统，它特指<strong>面向对象语言在方法决议的过程中为外界提供的入口，让工程师提供的代码也能参与到当前的方法决议和信息发送的过程</strong>。</p>

<p>在这一节中，我们将介绍的两个使用了运行时的面向对象编程语言 Objective-C 和 Ruby，它们有着相似的消息发送的流程，但是由于 OOP 模型实现的不同导致方法调用的过程稍微有一些差别；除此之外，由于 Objective-C 是需要通过编译器编译成二进制文件才能执行的，而 Ruby 可以直接被各种解释器运行，所以两者的元编程能力也会受到这一差别的影响，我们会在下面展开进行介绍。</p>

<h3 id="objective-c">Objective-C</h3>

<p>Objective-C 是一种通用的面向对象编程语言，它将 Smalltalk 消息发送的语法引入了 C 语言；ObjC 语言的面向对象模型其实都是运行在 ObjC Runtime 上的，整个运行时也为 ObjC 提供了方法查找的策略。</p>

<p><img src="https://img.nju520.me/2017-12-10-objc-class-hierachy.png" alt="objc-class-hierachy" /></p>

<p>如上图所示，我们有一个 <code>Dog</code> 类的实例，当我们执行了 <code>dog.wtf</code> 方法时，运行时会先向右再向上的方式在整个继承链中查找相应的方法是否存在，如果当前方法在整个继承链中都完全不存在就会进入<strong>动态方法决议</strong>和<strong>消息转发</strong>的过程。</p>

<p><img src="https://img.nju520.me/2017-12-10-objc-message-resolution-and-forwarding.png" alt="objc-message-resolution-and-forwarding" /></p>

<blockquote>
  <p>上述图片取自 <a href="http://hwbnju.com/racdelegateproxy">从代理到 RACSignal</a>，使用时对图片中的颜色以及字号稍作修改。</p>
</blockquote>

<p>当 ObjC 的运行时在方法查找的过程中已经查找到了上帝类 <code>NSObject</code> 时，仍然没有找到方法的实现就会进入上面的流程，先执行的 <code>+resolveInstanceMethod:</code> 方法就是一个可以为当前的类添加方法的入口：</p>

<pre><code class="language-objc">void dynamicMethodIMP(id self, SEL _cmd) { }

+ (BOOL)resolveInstanceMethod:(SEL)aSEL {
    if (aSEL == @selector(resolveThisMethodDynamically)) {
          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:");
          return YES;
    }
    return [super resolveInstanceMethod:aSel];
}
</code></pre>

<p>在这里可以通过 <code>class_addMethod</code> 动态的为当前的类添加新的方法和对应的实现，如果错过了这个入口，我们就进入了消息转发的流程；在这里，我们有两种选择，一种情况是通过 <code>-forwardTargetForSelector:</code> 将当前方法的调用直接转发到其他方法上，另一种就是组合 <code>-methodSignatureForSelector:</code> 和 <code>-forwardInvocation:</code> 两个方法，直接执行一个 <code>NSInvocation</code> 对象。</p>

<pre><code class="language-objc">- (void)forwardInvocation:(NSInvocation *)anInvocation {
    if ([someOtherObject respondsToSelector:[anInvocation selector]]) {
        [anInvocation invokeWithTarget:someOtherObject];
    } else {
        [super forwardInvocation:anInvocation];
    }
}
</code></pre>

<p><code>-forwardTargetForSelector:</code> 方法只能简单地将方法直接转发给其他的对象，但是在 <code>-forwardInvocation:</code> 中我们可以得到一个 <code>NSInvocation</code> 实例，可以自由地选择需要执行哪些方法，并修改当前方法调用的上下文，包括：方法名、参数和目标对象。</p>

<p>虽然 Objective-C 的运行时系统能够为我们提供动态方法决议的功能，也就是某一个方法在编译期间哪怕不存在，我们也可以在运行时进行调用，这虽然听起来很不错，在很多时候我们都可以通过 <code>-performSelector:</code> 调用<strong>编译器看起来不存的方法</strong>，但是作为一门执行之前需要编译的语言，如果我们在 <code>+resolveInstanceMethod:</code> 中确实动态实现了一些方法，但是编译器在编译期间对这一切都毫不知情。</p>

<pre><code class="language-objectivec">void dynamicMethodIMP(id self, SEL _cmd) { }
+ (BOOL)resolveInstanceMethod:(SEL)aSEL {
    NSString *selector = NSStringFromSelector(aSEL);
    if ([selector hasPrefix:@"find"]) {
          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:");
          return YES;
    }
    return [super resolveInstanceMethod:aSel];
}

- (void)func {
    [self findFoo];
    [self findBar];
    [self find];
}
</code></pre>

<p>从 <code>-func</code> 中调用的三个以 <code>find</code> 开头的方法其实会在运行期间添加到当前类上，但是编译器在编译期间对此一无所知，所以它会提示编译错误，在编译期间将可以运行的代码拦截了下来，这样的代码如果跳过编译器检查，直接运行是不会出问题的，但是代码的执行必须通过编译器编译，这一过程是无法跳过的。</p>

<p><img src="https://img.nju520.me/2017-12-10-objc-compile-and-execute.png" alt="objc-compile-and-execute" /></p>

<p>我们只能通过 <code>-performSelector:</code> 方法绕过编译器的检查，不过使用 <code>-performSelector:</code> 会为代码添加非常多的噪音：</p>

<pre><code class="language-objectivec">- (void)func {
    [self performSelector:@selector(findFoo)];
    [self performSelector:@selector(findBar)];
    [self performSelector:@selector(find)];
}
</code></pre>

<p>所以虽然 Objective-C 通过运行时提供了比较强大的元编程能力，但是由于代码执行时需要经过编译器的检查，所以在很多时候我们都没有办法直接发挥运行时为我们带来的好处，需要通过其他的方式完成方法的调用。</p>

<h3 id="ruby">Ruby</h3>

<p>除了 Objective-C 之外，Ruby 也提供了一些相似的运行时修改行为的特性，它能够在运行时修改自身特性的功能还是建立在它的 OOP 模型之上；Ruby 提供了一些在运行期间能够改变自身行为的入口和 API 可以帮助我们快速为当前的类添加方法或者实例变量。</p>

<p><img src="https://img.nju520.me/2017-12-10-ruby-class-hierachy.png" alt="ruby-class-hierachy" /></p>

<p>当我们调用 <code>Dog</code> 实例的一个方法时，Ruby 会先找到当前对象的类，然后在由 <code>superclass</code> 构成的链上查找并调用相应的方法，这是 OOP 中非常常见的，<strong>向右再向上</strong>的方法查找过程。</p>

<p>与 Objective-C 几乎相同，Ruby 也提供了类似与 <code>+resolveInstanceMethod:</code> 的方法，如果方法在整个继承链上都完全不存在时，就会调用 <code>#method_missing</code> 方法，并传入与这次方法调用有关的参数：</p>

<pre><code class="language-ruby">def method_missing(method, *args, &amp;block)
end
</code></pre>

<p>传入的参数包括方法的符号，调用原方法时传入的参数和 block，在这里我们就可以为当前的类添加方法了：</p>

<pre><code class="language-ruby">class Dog
  def method_missing(m, *args, &amp;block)
    if m.to_s.start_with? 'find'
      define_singleton_method(m) do |*args|
        puts "#{m}, #{args}"
      end
      send(m, *args, &amp;block)
    else
      super
    end
  end
end
</code></pre>

<p>通过 Ruby 提供的一些 API，例如 <code>define_method</code>、<code>define_singleton_method</code> 我们可以直接在运行期间快速改变对象的行为，在使用时也非常简单：</p>

<pre><code class="language-ruby">pry(main)&gt; d = Dog.new
=&gt; #&lt;Dog:0x007fe31e3f87a8&gt;
pry(main)&gt; d.find_by_name "dog"
find_by_name, ["dog"]
=&gt; nil
pry(main)&gt; d.find_by_name "dog", "another_dog"
find_by_name, ["dog", "another_dog"]
=&gt; nil
</code></pre>

<p>当我们调用以 <code>find</code> 开头的实例方法时，由于在当前实例的类以及父类上没有实现，所以就会进入 <code>#method_missing</code> 方法并为<strong>当前实例</strong>定义新的方法 <code>#find_by_name</code>。</p>

<blockquote>
  <p>注意：当前的 <code>#find_by_name</code> 方法只是定义在当前实例上的，存储在当前实例的单类上。</p>
</blockquote>

<p>由于 Ruby 是脚本语言，解释器在脚本执行之前不会对代码进行检查，所以哪怕在未执行期间并不存在的 <code>#find_by_name</code> 方法也不会导致解释器报错，在运行期间通过 <code>#define_singleton_method</code> 动态地
定义了新的 <code>#find_by_name</code> 方法修改了对象的行为，达到了为对象批量添加相似功能的目的。</p>

<h2 id="总结">总结</h2>

<p>在文章中介绍的两种不同的元编程能力，宏系统和运行时，前者通过预先定义好的一些宏规则，在预编译和编译期间对代码进行展开和替换，而后者提供了在运行期间改变代码行为的能力，两种方式的本质都是通过少量的代码生成一些非常相似的代码和逻辑，能够增强编程语言的表达能力并减少开发者的工作量。</p>

<p>无论是宏还是运行时其实都是简化程序中代码的一种手段，归根结底就是一种使用代码生成代码的思想，如果我们能够掌握这种元编程的思想并在编程中熟练的运用就能够很好地解决程序中一些诡异的问题，还能消灭重复的代码，提高我们运用以及掌控编程语言的能力，能够极大地增强编程语言的表达能力，所以元编程确实是一种非常重要并且需要学习的思想。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://en.m.wikipedia.org/wiki/Metaprogramming">Metaprogramming</a></li>
  <li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/differences-between-cpp-templates-and-csharp-generics">C++ 模板和 C# 泛型之间的区别（C# 编程指南）</a></li>
  <li><a href="https://www.zhihu.com/question/33304378">C++ 模板和 Java 泛型有什么异同？</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Macro_(computer_science)">Macro (computer science)</a></li>
  <li><a href="https://elixir-lang.org/getting-started/meta/macros.html">Macros · Elixir Doc</a></li>
  <li><a href="https://gcc.gnu.org/onlinedocs/cpp/Macros.html">Macros · GCC</a></li>
  <li><a href="http://hbprotoss.github.io/posts/cyu-yan-hong-de-te-shu-yong-fa-he-ji-ge-keng.html">C 语言宏的特殊用法和几个坑</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Hygienic_macro">Hygienic macro</a></li>
  <li><a href="https://elixirschool.com/en/lessons/advanced/metaprogramming/">Metaprogramming · ElixirSchool</a></li>
  <li><a href="https://doc.rust-lang.org/book/first-edition/macros.html">Macros · Rust Doc</a></li>
  <li><a href="https://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a></li>
  <li><a href="https://www.rust-lang.org/en-US/">Rust</a></li>
  <li><a href="http://hwbnju.com/message">从源代码看 ObjC 中消息的发送</a></li>
  <li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtDynamicResolution.html">Dynamic Method Resolution</a></li>
  <li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1">Message Forwarding</a></li>
  <li><a href="http://hwbnju.com/racdelegateproxy">从代理到 RACSignal</a></li>
  <li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1418500-resolveinstancemethod">resolveInstanceMethod(_:)</a></li>
  <li><a href="http://rubylearning.com/satishtalim/ruby_method_missing.html">Ruby Method Missing</a></li>
  <li><a href="https://www.leighhalliday.com/ruby-metaprogramming-method-missing">Ruby Metaprogramming - Method Missing</a></li>
</ul>


  ]]></description>
</item>

<item>
  <title>浅谈 MVC、MVP 和 MVVM 架构模式</title>
  <link>//mvx</link>
  <author>nju520</author>
  <pubDate>2017-07-12T09:00:00+08:00</pubDate>
  <guid>//mvx</guid>
  <description><![CDATA[
  <ul>
  <li><a href="http://nju520.me/mvx-model.html">谈谈 MVX 中的 Model</a></li>
  <li><a href="http://nju520.me/mvx-view.html">谈谈 MVX 中的 View</a></li>
  <li><a href="http://nju520.me/mvx-controller.html">谈谈 MVX 中的 Controller</a></li>
  <li><a href="http://nju520.me/mvx.html">浅谈 MVC、MVP 和 MVVM 架构模式</a></li>
</ul>

<p>这是 MVX 系列的第四篇文章，在前面的文章中，我们先后介绍了 MVC 架构模式中的 Model、View 和 Controller 的现状，对比了其他平台中的设计，最后给出了作者理想中的结构。</p>

<p>而在这一篇文章中，作者会依次介绍 MVC、MVP 以及 MVVM 架构模式以及不同平台对它们的使用；虽然参考了诸多资料，不过文中观点难免掺入作者的主观意见，作者也希望文中的错误与不足之处能被各位读者指出。</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/MVC-MVVM-MVP.jpg" alt="MVC-MVVM-MVP" /></p>

<p>前面的几篇文章中重点都是介绍 iOS 平台上的 Model、View 和 Controller 如何设计，而这篇文章会对目前 GUI 应用中的 MVC、MVP 和 MVVM 架构模式进行详细地介绍。</p>

<h2 id="mvc">MVC</h2>

<p>在整个 GUI 编程领域，MVC 已经拥有将近 50 年的历史了。早在几十年前，Smalltalk-76 就对 MVC 架构模式进行了实现，在随后的几十年历史中，MVC 产生了很多的变种，例如：HMVC、MVA、MVP、MVVM 和其它将 MVC 运用于其它不同领域的模式。</p>

<h3 id="早期的-mvc">早期的 MVC</h3>

<p>而本文的内容就是从 MVC 开始的，作为最出名并且应用最广泛的架构模式，MVC 并没有一个<strong>明确的</strong>定义，网上流传的 MVC 架构图也是形态各异，作者查阅了很多资料也没有办法确定到底什么样的架构图才是<strong>标准的</strong> MVC 实现。</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/MVC-1979.jpg" alt="MVC-1979" /></p>

<p>设计 MVC 的重要目的就是在人的心智模型与计算机的模型之间建立一个桥梁，而 MVC 能够解决这一问题并<strong>为用户提供直接看到信息和操作信息的功能</strong>。</p>

<blockquote>
  <p>更早的概念类似 Model-View-Editor（MVE）这里就不再提及了，感兴趣的读者可以阅读这篇论文 <a href="http://heim.ifi.uio.no/~trygver/1979/mvc-1/1979-05-MVC.pdf">Thing-Model-View-Editor</a> 了解更多的信息。</p>
</blockquote>

<h3 id="混乱的-mvc-架构">混乱的 MVC 架构</h3>

<p>作者相信，稍有编程经验的开发者就对 MVC 有所了解，至少也是听过 MVC 的名字。作者也一直都认为绝大多数人对于 MVC 理解的概念都一样，很多人对于 MVVM 的实现有很大争论，说遵循什么什么架构的是 MVVM，MVVM 有什么组件、没有什么组件，而对于 MVC 仿佛没有那么大的疑问，这其实却不然。</p>

<h4 id="aspnet-mvc">ASP.NET MVC</h4>

<p>在最近的几个月，作者发现不同人对于 MVC 的理解有巨大的差异，这是 <a href="https://msdn.microsoft.com/en-us/library/dd381412(v=vs.108).aspx">ASP.NET MVC Overview</a> 一文中对于 MVC 模式描述的示意图。</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/MVC-with-ASP.NET.jpg" alt="MVC-with-ASP.NET" /></p>

<p>图片中并没有对 Model、View 和 Controller 三者之间如何交互进行说明，有的也只是几个箭头。我们应该可以这么简单地理解：</p>

<ol>
  <li>控制器负责管理视图和模型；</li>
  <li>视图负责展示模型中的内容；</li>
</ol>

<blockquote>
  <p>由于文章没有明确对这三个箭头的含义进行解释，所以在这里也仅作推断，无法确认原作者的意思。</p>
</blockquote>

<h4 id="spring-mvc">Spring MVC</h4>

<p>与 ASP.NET 不同，Spring MVC 对于 MVC 架构模式的实现就更加复杂了，增加了一个用于分发请求、管理视图的 DispatchServlet：</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/MVC-with-Spring.jpg" alt="MVC-with-Spring" /></p>

<p>在这里不再介绍 Spring MVC 对于 HTTP 请求的处理流程，我们对其中 Model、View 和 Controller 之间的关系进行简单的分析：</p>

<ol>
  <li>通过 DispatchServlet 将控制器层和视图层完全解耦；</li>
  <li>视图层和模型层之间没有直接关系，只有间接关系，通过控制器对模型进行查询、返回给 DispatchServlet 后再传递至视图层；</li>
</ol>

<p>虽然 Spring MVC 也声称自己遵循 MVC 架构模式，但是这里的 MVC 架构模式和 ASP.NET 中却有很大的不同。</p>

<h4 id="ios-mvc">iOS MVC</h4>

<p>iOS 客户端中的 Cocoa Touch 自古以来就遵循 MVC 架构模式，不过 Cocoa Touch 中的 MVC 与 ASP.NET 和 Spring 中的 MVC 截然不同。</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/MVC-with-iOS.jpg" alt="MVC-with-iOS" /></p>

<p>在 iOS 中，由于 <code>UIViewController</code> 类持有一个根视图 <code>UIView</code>，所以视图层与控制器层是紧密耦合在一起的，这也是 iOS 项目经常遇到视图控制器非常臃肿的重要原因之一。</p>

<h4 id="rails-mvc">Rails MVC</h4>

<p>Rails 作为著名的 MVC 框架，视图层和模型层没有直接的耦合，而是通过控制器作为中间人对信息进行传递：</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/MVC-with-Rails.jpg" alt="MVC-with-Rails" /></p>

<p>这种 MVC 的设计分离了视图层和模型层之间的耦合，作为承担数据存储功能的模型层，可以通过控制器同时为多种不同的视图提供数据：</p>

<p><img src="https://github.com/nju520/analyze/raw/master/contents/architecture/images/mvx/MVC-%05in-Rails-with-different-view.jpg" alt="MVC-in-Rails-with-different-view" /></p>

<p>控制器根据用户发出的 HTTP 请求，从模型中取出相同的数据，然后传给不同的视图以渲染出不同的结果。Rails 中的 MVC 架构模式能够很好地将用于展示的视图和用于存储数据的数据库进行分离，两者之间通过控制器解耦，能够实现同一数据库对应多种视图的架构。</p>

<h4 id="维基百科中的-mvc">维基百科中的 MVC</h4>

<p>除了上述框架中的 MVC 架构模式，还有一些其它的书籍或者资料对于 MVC 也有着不同的解释，比如维基百科的 <a href="https://en.wikipedia.org/wiki/Model–view–controller">Model-view-controller</a> 条目，该条目是我们在 Google 搜索 <a href="https://www.google.com/search?q=MVC">MVC</a> 时能够出现的前几个条目，这也是维基百科中的架构图能够出现在这篇文章中的原因 —— 有着广泛的受众。</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/MVC-in-Wikipedia.jpg" alt="MVC-in-Wikipedia" /></p>

<p>维基百科中对于 MVC 架构模式交互图的描述其实相比上面的图片还都是比较清晰的，这主要是因为它对架构图中的箭头进行了详细的说明，指出了这个关系到底表示什么。</p>

<ol>
  <li>视图被用户看到；</li>
  <li>用户使用控制器；</li>
  <li>控制器操作模型；</li>
  <li>模型更新视图；</li>
</ol>

<p>虽然说整个架构图的逻辑是可以说的通的，不过相比于前面的架构图总是感觉有一些奇怪，而在这幅图片中，视图和控制器之间是毫无关系的，这与前面见到的所有 MVC 架构模式都完全不同，作者也不清楚这幅图来源是什么、为什么这么画，放在这里也仅作参考。</p>

<h3 id="标准的-mvc">『标准』的 MVC</h3>

<p>到底什么才是标准的 MVC 这个问题，到现在作者也没有一个<strong>确切的</strong>答案；不过多个框架以及书籍对 MVC 的理解有一点是完全相同的，也就是它们都将整个应用分成 Model、View 和 Controller 三个部分，而这些组成部分其实也有着几乎相同的职责。</p>

<ul>
  <li>视图：管理作为位图展示到屏幕上的图形和文字输出；</li>
  <li>控制器：翻译用户的输入并依照用户的输入操作模型和视图；</li>
  <li>模型：管理应用的行为和数据，响应数据请求（经常来自视图）和更新状态的指令（经常来自控制器）；</li>
</ul>

<blockquote>
  <p>上述内容出自 <a href="http://www.dgp.toronto.edu/~dwigdor/teaching/csc2524/2012_F/papers/mvc.pdf">Applications Programming in Smalltalk-80: How to use Model-View-Controller (MVC)</a> 一文。</p>
</blockquote>

<p>作者所理解的真正 MVC 架构模式其实与 ASP.NET 中对于 MVC 的设计完全相同：</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/Standard-MVC.jpg" alt="Standard-MV" /></p>

<p>控制器负责对模型中的数据进行更新，而视图向模型中请求数据；当有用户的行为触发操作时，会有控制器更新模型，并通知视图进行更新，在这时视图向模型请求新的数据，而这就是<strong>作者所理解的</strong>标准 MVC 模式下，Model、View 和 Controller 之间的协作方式。</p>

<h4 id="依赖关系">依赖关系</h4>

<p>虽然我们对 MVC 中的各个模块的交互不是特别了解，但是三者之间的依赖关系却是非常明确的；在 MVC 中，模型层可以单独工作，而视图层和控制器层都依赖与模型层中的数据。</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/Essential-Dependencies-in-MVC.jpg" alt="Essential-Dependencies-in-MVC" /></p>

<blockquote>
  <p>虽然如上图所示，视图和控制器之间没有相互依赖，不过因为视图和控制器之间的依赖并不常用，所以图中将视图和控制器之间的依赖省略了。</p>
</blockquote>

<h4 id="分离展示层">分离展示层</h4>

<p>在 Martin Fowler 对于 Model-View-Controller 的描述中，MVC 最重要的概念就是分离展示层 <a href="https://www.martinfowler.com/eaaDev/SeparatedPresentation.html">Separated Presentation</a>，如何在领域对象（Domain Object）和我们在屏幕上看到的 GUI 元素进行划分是 MVC 架构模式中最核心的问题。</p>

<p>GUI 应用程序由于其需要展示内容的特点，分为两个部分：一部分是用于展示内容的展示层（Presentation Layer），另一部分包含领域和数据逻辑的领域层（Domain Layer）。</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/Presentation-Domain.jpg" alt="Presentation-Domain" /></p>

<p>展示层依赖于领域层中存储的数据，而领域层对于展示层一无所知，领域层其实也是 MVC 模式中的模型层，而展示层可以理解为 VC 部分。</p>

<p>MVC 最重要的目的并不是规定各个模块应该如何交互和联系，而是将原有的混乱的应用程序划分出合理的层级，把一团混乱的代码，按照展示层和领域层分成两个部分；在这时，领域层中的领域对象由于其自身特点不需要对展示层有任何了解，可以同时为不同的展示层工作。</p>

<h4 id="观察者同步">观察者同步</h4>

<p>除了分离展示层，MVC 还与观察者同步 <a href="https://www.martinfowler.com/eaaDev/MediatedSynchronization.html">Observer Synchronization</a> 关系紧密。因为在 MVC 模式中，模型可以单独工作，同时它对使用模型中数据的视图和控制器一无所知，为了保持模型的独立性，我们需要一种机制，当模型发生改变时，能够同时更新多个视图和控制器的内容；在这时，就需要以观察者同步的方式解决这个问题。</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/Observer-Synchronization.jpg" alt="Observer-Synchronization" /></p>

<p>我们将所有需要实时更新的组件注册成为模型的观察者，在模型的属性发生变化时，通过观察者模式推送给所有注册的观察者（视图和控制器）。</p>

<p>当多个视图共享相同的数据时，观察者同步是一个非常关键的模式，它能够在对这些视图不知情的前提下，同时通知多个视图；通过观察者模式，我们可以非常容易地创建一个依赖于同一模型的视图。</p>

<p>观察者同步或者说观察者模式的主要缺点就是：由于事件触发的隐式行为可能导致很难查找问题的来源并影响其解决，不过虽然它有着这样的缺点，但是观察者同步这一机制仍然成为 MVC 以及其衍生架构模式中非常重要的一部分。</p>

<h4 id="占主导地位的控制器">占主导地位的控制器</h4>

<p>MVC 架构模式的三个组成部分：Model、View 和 Controller 中最重要的就是控制器，它承担了整个架构中的大部分业务逻辑，同时在用户请求到达或者事件发生时都会首先通知控制器并由它来决定如何响应这次请求或者事件。</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/Main-Controller.jpg" alt="Main-Controlle" /></p>

<p>在 MVC 中，所有的用户请求都会首先交给控制器，再由控制器来决定如何响应用户的输入，无论是更新模型中的信息还是渲染相应的视图，都是通过控制器来决定的；也就是说，在 MVC 中，控制器占据主导地位，它决定用户的输入是如何被处理的。</p>

<h4 id="被动的模型">被动的模型</h4>

<p>在绝大多数的 MVC 架构模式中，模型都不会主动向视图或者控制器推送消息；模型都是被动的，它只存储整个应用中的数据，而信息的获取和更新都是由控制器来驱动的。</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/Passive-Model.jpg" alt="Passive-Mode" /></p>

<p>但是当模型中的数据发生变化时，却需要通过一些方式通知对应的视图进行更新，在这种情况下其实也不需要模型<strong>主动</strong>将数据变化的消息推送给视图；因为所有对于模型层的改变都是<strong>由用户的操作导致的</strong>，而用户的操作都是通过控制器来处理的，所以只需要在控制器改变模型时，将更新的信息发送给视图就可以了；当然，我们也可以通过<strong>观察者模式</strong>向未知的观察者发送通知，以保证状态在不同模块之间能够保持同步。</p>

<p>作为被动的模型层，它对于视图和控制器的存在并不知情，只是向外部提供接口并响应视图和控制器对于数据的请求和更新操作。</p>

<h4 id="mvc--mvc">MVC + MVC</h4>

<p>目前的大多数应用程序都非常复杂并且同时包含客户端和服务端，两者分开部署但同时又都遵循 MVC 或者衍生的架构模式；过去的 Web 应用由于并不复杂，前端和服务端往往都部署在同一台服务器上，比如说使用 erb 模板引擎的 Rails 或者使用 jsp 的 Java 等等；这时的 Web 应用都遵循 MVC 架构模式：</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/MVC-Web-App.jpg" alt="MVC-Web-App" /></p>

<blockquote>
  <p>上图的 MVC 架构模式的通信方式与标准的 MVC 中不同，上图以 Rails 为例展示其中的 MVC 是如何工作的，其中的 HTML、CSS 和 Javascript 代码就是视图层，控制器负责视图的渲染并且操作模型，模型中包含部分业务逻辑并负责管理数据库。</p>
</blockquote>

<p>过去的 Web 应用的非常简单，而现在的应用程序都非常复杂，而整个应用程序无论是 Web 还是客户端其实都包含两个部分，也就是前端/客户端和后端；先抛开后端不谈，无论是 Web 前端、iOS 还是 Android 都遵循 MVC 架构模式或者它的变种。</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/MVC-App-Arch.jpg" alt="MVC-App-Arch" /></p>

<p>在实际情况下，单独的 iOS、Android 和 Web 应用往往不能单独工作，这些客户端应用需要与服务端一起工作；当前端/客户端与后端一同工作时，其实分别『部署』了两个不同的应用，这两个应用都遵循 MVC 架构模式：</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/MVC-MVC.jpg" alt="MVC-MV" /></p>

<p>客户端和服务器通过网络进行连接，并组成了一个更大的 MVC 架构；从这个角度来看，服务端的模型层才存储了真正的数据，而客户端的模型层只不过是一个存储在客户端设备中的本地缓存和临时数据的集合；同理，服务端的视图层也不是整个应用的视图层，用于为用户展示数据的视图层位于客户端，也就是整个架构的最顶部；中间的五个部分，也就是从低端的模型层到最上面的视图共同组成了整个应用的控制器，将模型中的数据以合理的方式传递给最上层的视图层用于展示。</p>

<h2 id="mvp">MVP</h2>

<p>MVP 架构模式是 MVC 的一个变种，很多框架都自称遵循 MVC 架构模式，但是它们实际上却实现了 MVP 模式；MVC 与 MVP 之间的区别其实并不明显，作者认为两者之间最大的区别就是 MVP 中使用 Presenter 对视图和模型进行了解耦，它们彼此都对对方一无所知，沟通都通过 Presenter 进行。</p>

<p>MVP 作为一个比较有争议的架构模式，在维基百科的 <a href="https://en.wikipedia.org/wiki/Model–view–presenter">Model-view-presenter</a> 词条中被描述为 MVC 设计模式的变种（derivation），自上个世纪 90 年代出现在 IBM 之后，随着不断的演化，虽然有着很多分支，不过 Martin Fowler 对 MVP 架构模式的定义最终被广泛接受和讨论。</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/Standard-MVP.jpg" alt="Standard-MVP" /></p>

<p>在 MVP 中，Presenter 可以理解为松散的控制器，其中包含了视图的 UI 业务逻辑，所有从视图发出的事件，都会通过代理给 Presenter 进行处理；同时，Presenter 也通过视图暴露的接口与其进行通信。</p>

<p>目前常见的 MVP 架构模式其实都是它的变种：<a href="https://www.martinfowler.com/eaaDev/PassiveScreen.html">Passive View</a> 和 <a href="https://www.martinfowler.com/eaaDev/SupervisingPresenter.html">Supervising Controller</a>，接下来的内容也是围绕这两种变种进行展开的。</p>

<h3 id="被动视图">被动视图</h3>

<p>MVP 的第一个主要变种就是被动视图（Passive View）；顾名思义，在该变种的架构模式中，视图层是被动的，它本身不会改变自己的任何的状态，所有的状态都是通过 Presenter 来间接改变的。</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/PassIve-View.jpg" alt="PassIve-Vie" /></p>

<p>被动的视图层就像前端中的 HTML 和 CSS 代码，只负责展示视图的结构和内容，本身不具有任何的逻辑：</p>

<pre><code class="language-swift">&lt;article class="post"&gt;
  &lt;header class="post-header"&gt;
    &lt;h2 class="post-title"&gt;&lt;a href="/mvx-controller.html"&gt;谈谈 MVX 中的 Controller&lt;/a&gt;&lt;/h2&gt;
  &lt;/header&gt;
  &lt;section class="post-excerpt"&gt;
    &lt;p&gt;在前两篇文章中，我们已经对 iOS 中的 Model 层以及 View 层进行了分析，划分出了它们的具体职责，其中 Model 层除了负责数据的持久存储、缓存工作，还要负责所有 HTTP... &lt;a class="read-more" href="/mvx-controller.html"&gt;&amp;raquo;&lt;/a&gt;&lt;/p&gt;
  &lt;/section&gt;
  &lt;footer class="post-meta"&gt;
    &lt;img class="author-thumb" src="/assets/images/hacker.png" alt="Author image" nopin="nopin" /&gt;
    &lt;a href='/author/nju520'&gt;nju520&lt;/a&gt;
    &lt;time class="post-date" datetime="2017-06-23"&gt;23 Jun 2017&lt;/time&gt;
  &lt;/footer&gt;
&lt;/article&gt;
</code></pre>

<h4 id="依赖关系-1">依赖关系</h4>

<p>视图成为了完全被动的并且不再根据模型来更新视图本身的内容，也就是说，不同于 MVC 中的依赖关系；在被动视图中，视图层对于模型层没有任何的依赖：</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/Essential-Dependencies-in-Passive-View.jpg" alt="Essential-Dependencies-in-Passive-Vie" /></p>

<p>因为视图层不依赖与其他任何层级也就最大化了视图层的可测试性，同时也将视图层和模型层进行了合理的分离，两者不再相互依赖。</p>

<h4 id="通信方式">通信方式</h4>

<p>被动视图的示意图中一共有四条线，用于表示 Model、View 和 Presenter 之间的通信：</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/Passive-View-with-Tags.jpg" alt="Passive-View-with-Tags" /></p>

<ol>
  <li>当视图接收到来自用户的事件时，会将事件转交给 Presenter 进行处理；</li>
  <li>被动的视图向外界暴露接口，当需要更新视图时 Presenter 通过视图暴露的接口更新视图的内容；</li>
  <li>Presenter 负责对模型进行操作和更新，在需要时取出其中存储的信息；</li>
  <li>当模型层改变时，可以将改变的信息发送给<strong>观察者</strong> Presenter；</li>
</ol>

<p>在 MVP 的变种被动视图中，模型的操作以及视图的更新都仅通过 Presenter 作为中间人进行。</p>

<h3 id="监督控制器">监督控制器</h3>

<p>与被动视图中状态同步都需要<strong>显式</strong>的操作不同，监督控制器（Supervising Controller）就将部分需要显式同步的操作变成了隐式的：</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/Supervising-Controller.jpg" alt="Supervising-Controller" /></p>

<p>在监督控制器中，视图层接管了一部分视图逻辑，主要内容就是同步<strong>简单的</strong>视图和模型的状态；而监督控制器就需要负责响应用户的输入以及一部分更加复杂的视图、模型状态同步工作。</p>

<p>对于用户输入的处理，监督控制器的做法与标准 MVP 中的 Presenter 完全相同；但是对于视图、模型的同步工作，监督控制器会尽可能地将所有简单的属性<strong>以数据绑定的形式声明在视图层中</strong>，类似于 Vue 中双向绑定的简化版本：</p>

<pre><code class="language-html">&lt;a v-bind:href="url"&gt;&lt;/a&gt;
</code></pre>

<p>剩下的无法通过上述方式直接绑定的属性就需要通过监督控制器来操作和更新了。</p>

<h4 id="通信方式-1">通信方式</h4>

<p>监督控制器中的视图和模型层之间增加了两者之间的耦合，也就增加了整个架构的复杂性：</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/Supervising-Controller-With-Tag.jpg" alt="Supervising-Controller-With-Tag" /></p>

<p>视图和监督控制器、模型与监督控制器的关系与被动视图中两者与 Presenter 的关系几乎相同，视图和模型之间新增的依赖就是数据绑定的产物；视图通过声明式的语法与模型中的简单属性进行绑定，当模型发生改变时，会通知其观察者视图作出相应的更新。</p>

<p>通过这种方式能够减轻监督控制器的负担，减少其中简单的代码，将一部分逻辑交由视图进行处理；这样也就导致了视图同时可以被 Presenter 和数据绑定两种方式更新，相比于被动视图，监督控制器的方式也降低了视图的可测试性和封装性。</p>

<h3 id="占主导地位的视图">占主导地位的视图</h3>

<p>无论是在被动视图还是监督控制器版本的 MVP 架构模式中，视图层在整个架构中都是占主导地位的：</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/Main-View-in-MVP.jpg" alt="Main-View-in-MVP" /></p>

<p>在 MVC 中，控制器负责<strong>以不同的视图响应客户端请求的不同动作</strong>；然而，不同于 MVC 模式，MVP 中视图将所有的动作交给 Presenter 进行处理；MVC 中的所有的动作都对应着一个控制器的方法调用，Web 应用中的每一个动作都是对某一个 URL 进行的操作，控制器根据访问的路由和方法（GET 等）对数据进行操作，最终选择正确的视图进行返回。</p>

<p>MVC 中控制器返回的视图没有直接绑定到模型上，它仅仅被控制器渲染并且是完全无状态的，其中不包含任何的逻辑，但是 MVP 中的视图<strong>必须要将对应的事件代理给 Presenter 执行</strong>，否则事件就无法被响应。</p>

<p>另一个 MVP 与 MVC 之间的重大区别就是，MVP（Passive View）中的视图和模型是完全解耦的，它们对于对方的存在完全不知情，这也是区分 MVP 和 MVC 的一个比较容易的方法。</p>

<blockquote>
  <p>上述内容取自 <a href="https://stackoverflow.com/questions/2056/what-are-mvp-and-mvc-and-what-is-the-difference">What are MVP and MVC and what is the difference? · Stack Overflow</a> 中的 Model-View-Controller 部分。</p>
</blockquote>

<h2 id="mvvm">MVVM</h2>

<p>相较于 MVC 和 MVP 模式，MVVM 在定义上就明确得多，同时，维基百科上对于 <a href="https://en.wikipedia.org/wiki/Model–view–viewmodel">Model-View-ViewModel</a> 的词条也没有歧义；不过，在谈 MVVM 架构模式之前，我们需要先了解它是如何发展和演变的。</p>

<h3 id="mvvm-的演变">MVVM 的演变</h3>

<p>早在 2004 年，Martin Fowler 发表了一篇名为 <a href="https://www.martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> （以下简称为 PM 模式）的文章，PM 模式与 MVP 比较相似，它从视图层中分离了行为和状态；PM 模式中创建了一个视图的抽象，叫做 Presentation Model，而视图也成为了这个模型的『渲染』结果。</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/PM-and-MVVM.jpg" alt="PM-and-MVV" /></p>

<p>2005 年，John Gossman 在他的博客上公布了 <a href="https://blogs.msdn.microsoft.com/johngossman/2005/10/08/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps/">Introduction to Model/View/ViewModel pattern for building WPF apps</a> 一文。MVVM 与 Martin Fowler 所说的 PM 模式其实是完全相同的，Fowler 提出的 PM 模式是一种与平台无关的创建视图抽象的方法，而 Gossman 的 MVVM 是专门用于 WPF 框架来简化用户界面的创建的模式；我们可以认为 <strong>MVVM 是在 WPF 平台上对于 PM 模式的实现</strong>。</p>

<blockquote>
  <p>有兴趣的读者可以阅读 <a href="https://blogs.msdn.microsoft.com/johngossman/2005/10/08/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps/ · MSDN">Introduction to Model/View/ViewModel pattern for building WPF apps</a> 获得更多与 MVVM 演化的相关信息。</p>
</blockquote>

<h3 id="展示模型">展示模型</h3>

<blockquote>
  <p>本节大部分内容都节选自 Martin Fowler 的 <a href="https://www.martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> 一文。</p>
</blockquote>

<p>既然 MVVM 是展示模型 <a href="https://www.martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> 的一个实现，那么在介绍 Model-View-ViewModel 之前，我们就需要了解 PM 模式到底是什么。</p>

<p>在 MVC 一节中曾经有过对展示层和领域层进行分离的讨论，而 PM 模式就与分离展示层 <a href="https://www.martinfowler.com/eaaDev/SeparatedPresentation.html">Separated Presentation</a> 有一定的关系。</p>

<p>作为 Martin Fowler 在 2004 年提出的概念，Presentation Model 到今天其实也是非常先进的，PM 模式将视图中的全部状态和行为放到一个单独的展示模型中，协调领域对象（模型）并且为视图层提供一个接口。</p>

<p>在监督控制器中，视图层与模型层中的一些简单属性进行绑定，在模型属性变化时直接更新视图，而 PM 通过引入展示模型将<strong>模型层中的数据与复杂的业务逻辑封装成属性与简单的数据同时暴露给视图，让视图和展示模型中的属性进行同步</strong>。</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/Presentation-Model.jpg" alt="Presentation-Mode" /></p>

<p>展示模型中包含所有的视图渲染需要的动态信息，包括视图的内容（text、color）、组件是否启用（enable），除此之外还会将一些方法暴露给视图用于某些事件的响应。</p>

<h4 id="状态的同步">状态的同步</h4>

<p>展示模型对于模型层的操作以及为视图层暴露接口都是非常容易的，在整个 PM 模式中，最为麻烦的就是视图和展示模型状态的同步。</p>

<p>因为展示模型是视图的抽象，其中包含了视图的状态（属性）和行为（动作），视图的行为可能很少发生改变，但是视图状态的改变就是非常常见的了，那么同步视图和展示模型的代码应该放哪里就是一个需要考虑的问题了。</p>

<p>到目前为止，我们能够防止状态同步代码的地方其实只有两个，也就是视图和展示模型；如果将同步的代码放在视图中，那么可能会影响视图的测试，不过由于现在的大部分客户端程序完全没有测试，这一点其实也影响不大；如果将代码放在展示模型中，实际上就为展示模型增加了视图的依赖，导致不同层级之间的耦合。</p>

<blockquote>
  <p>在作者看来这两种选择其实都影响并不大，反正我们的应用中并没有测试嘛。</p>
</blockquote>

<h4 id="展示模型与其他模块的关系">展示模型与其他模块的关系</h4>

<p>在 PM 模式中，同一个展示模型可以与多个领域对象交互，多个视图可以使用相同的展示模型，但是每一个视图只能持有一个展示模型。</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/PM-View-Domain-Object.jpg" alt="PM-View-Domain-Object" /></p>

<p>PM 模式中不同层级之间的关系还是非常容易理解的，在这里就不做具体解释了。</p>

<h3 id="mvvm-与-wpf">MVVM 与 WPF</h3>

<p>MVVM 架构模式是微软在 2005 年诞生的，从诞生一开始就与 WPF 框架的联系非常紧密，在这一节中，我们将介绍 MVVM 模式是如何遵循 PM 模式实现的，WPF 作为微软用于处理 GUI 软件的框架，提供了一套非常优雅的解决方案。</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/Model-View-ViewModel.jpg" alt="Model-View-ViewModel" /></p>

<p>从 Model-View-ViewModel 这个名字来看，它由三个部分组成，也就是 Model、View 和 ViewModel；其中视图模型（ViewModel）其实就是 PM 模式中的展示模型，在 MVVM 中叫做视图模型。</p>

<p>除了我们非常熟悉的 Model、View 和 ViewModel 这三个部分，在 MVVM 的实现中，还引入了<strong>隐式的</strong>一个 Binder 层，而声明式的数据和命令的绑定在 MVVM 模式中就是通过它完成的。</p>

<p><img src="https://raw.githubusercontent.com/nju520/analyze/master/contents/architecture/images/mvx/Binder-View-ViewModel.jpg" alt="Binder-View-ViewModel" /></p>

<p>在实现 PM 模式时，我们需要处理视图和展示模型之间状态的同步，也就是 MVVM 中的视图和视图模型，我们使用隐式的 Binder 和 XAML 文件来完成视图和视图模型两者之间的双向绑定：</p>

<pre><code class="language-xml">&lt;Window x:Class ="WPFDataBinding.MainWindow" Title="MainWindow" Height="350" Width="604"&gt;
   &lt;Grid&gt;
      &lt;Label Name="nameLabel" Margin="2"&gt;_Name:&lt;/Label&gt;
      &lt;TextBox Name="nameText" Grid.Column="1" Margin="2"
         Text="{Binding Name}"/&gt;
      &lt;Label Name="ageLabel" Margin="2" Grid.Row ="1"&gt;_Age:&lt;/Label&gt;
      &lt;TextBox Name="ageText" Grid.Column="1" Grid.Row ="1" Margin ="2"
         Text="{Binding Age}"/&gt;
   &lt;/Grid&gt;
&lt;/Window&gt;
</code></pre>

<p>在 WPF 中我们可以使用 Binding 关键字在 XAML 中完成双向绑定，当 <code>TextBox</code> 中的文字更新时，Binder 也会更新 ViewModel 中对应属性 <code>Name</code> 或者 <code>Age</code> 的值。</p>

<p>我们可以说 MVVM 将视图和展示模型之间的同步代码放到了视图层（XAML）中，也可以说通过隐式的方法实现了状态的同步。</p>

<p>无论是 MVVM 还是 Presentation Model，其中最重要的不是如何同步视图和展示模型/视图模型之间的状态，是使用观察者模式、双向绑定还是其它的机制都不是整个模式中最重要的部分，最为关键的是<strong>展示模型/视图模型创建了一个视图的抽象，将视图中的状态和行为抽离出一个新的抽象</strong>，这才是 MVVM 和 PM 中需要注意的。</p>

<h2 id="总结">总结</h2>

<p>从 MVC 架构模式到 MVVM，从分离展示层到展示模型层，经过几十年的发展和演变，MVC 架构模式出现了各种各样的变种，并在不同的平台上有着自己的实现。</p>

<p>在架构模式的选用时，我们往往没有太多的发言权，主要因为平台本身往往对应用层有着自己的设计，我们在开发客户端或者前端应用时，只需要遵循平台固有的设计就可以完成应用的开发；不过，在有些时候，由于工程变得庞大、业务逻辑变得异常复杂，我们也可以考虑在原有的架构之上实现一个新的架构以满足工程上的需要。</p>

<p>各种架构模式的作用就是分离关注，将属于不同模块的功能分散到合适的位置中，同时尽量降低各个模块的相互依赖并且减少需要联系的胶水代码。文中对于 MVC、MVP 和 MVVM 架构模式的描述很难不掺杂作者的主观意见，如果对文章中的内容有疑问，欢迎提出不同的意见进行讨论。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html">MVC Index</a></li>
  <li><a href="http://heim.ifi.uio.no/~trygver/2003/javazone-jaoo/MVC_pattern.pdf">The Model-View-Controller (MVC) Its Past and Present</a></li>
  <li><a href="http://www.object-arts.com/downloads/papers/TwistingTheTriad.PDF">The evolution of the Dolphin Smalltalk MVP application framework</a></li>
  <li><a href="http://www.wildcrest.com/Potel/Portfolio/mvp.pdf">MVP: Model-View-Presenter · The Taligent Programming Model for C++ and Java</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/ff798384.aspx">Implementing the Model-View-ViewModel Pattern · MSDN</a></li>
  <li><a href="https://martinfowler.com/eaaDev/uiArchs.html">GUI Architectures · Martin Fowler</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/26799645">GUI 应用程序架构的十年变迁</a></li>
  <li><a href="https://github.com/evancz/elm-architecture-tutorial/">Elm Architecture Tutorial · GitHub</a></li>
  <li><a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model · Martin Fowler</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Model–view–controller">Model-view-controller · Wikipedia</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Model–view–presenter">Model-view-presenter · Wikipedia</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Model–view–viewmodel">Model-view-viewmodel · Wikipedia</a></li>
  <li><a href="http://heim.ifi.uio.no/~trygver/1979/mvc-1/1979-05-MVC.pdf">Thing-Model-View-Editor</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/library/dd381412(v=vs.108).aspx">ASP.NET MVC Overview · MSDN</a></li>
  <li><a href="https://betterexplained.com/articles/intermediate-rails-understanding-models-views-and-controllers/">Intermediate Rails: Understanding Models, Views and Controllers</a></li>
  <li><a href="https://www.martinfowler.com/eaaDev/PassiveScreen.html">Passive View · Martin Fowler</a></li>
  <li><a href="https://www.martinfowler.com/eaaDev/SupervisingPresenter.html">Supervising Controller · Martin Fowler</a></li>
  <li><a href="http://www.dgp.toronto.edu/~dwigdor/teaching/csc2524/2012_F/papers/mvc.pdf">Applications Programming in Smalltalk-80: How to use Model-View-Controller (MVC)</a></li>
  <li><a href="https://stackoverflow.com/questions/2056/what-are-mvp-and-mvc-and-what-is-the-difference">What are MVP and MVC and what is the difference? · Stack Overflow</a></li>
  <li><a href="http://webclientguidance.codeplex.com/wikipage?title=ModelViewPresenterPatternDescription&amp;referringTitle=MVPDocumentation">Model-View-Presenter Pattern</a></li>
  <li><a href="https://msdn.microsoft.com/en-us/magazine/dd419663.aspx">Patterns - WPF Apps With The Model-View-ViewModel Design Pattern · MSDN</a></li>
  <li><a href="https://blogs.msdn.microsoft.com/johngossman/2005/10/08/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps/ · MSDN">Introduction to Model/View/ViewModel pattern for building WPF apps</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Design_Patterns">设计模式</a></li>
</ul>

  ]]></description>
</item>

<item>
  <title>谈谈 MVX 中的 Controller</title>
  <link>//mvx-controller</link>
  <author>nju520</author>
  <pubDate>2017-06-23T02:34:44+08:00</pubDate>
  <guid>//mvx-controller</guid>
  <description><![CDATA[
  <ul>
  <li><a href="http://nju520.me/mvx-model.html">谈谈 MVX 中的 Model</a></li>
  <li><a href="http://nju520.me/mvx-view.html">谈谈 MVX 中的 View</a></li>
  <li><a href="http://nju520.me/mvx-controller.html">谈谈 MVX 中的 Controller</a></li>
  <li><a href="http://nju520.me/mvx.html">浅谈 MVC、MVP 和 MVVM 架构模式</a></li>
</ul>

<blockquote>
  <p>Follow GitHub: <a href="https://github.com/nju520">nju520</a></p>
</blockquote>

<p>在前两篇文章中，我们已经对 iOS 中的 Model 层以及 View 层进行了分析，划分出了它们的具体职责，其中 Model 层除了负责数据的持久存储、缓存工作，还要负责所有 HTTP 请求的发出等工作；而对于 View 层的职责，我们并没有做出太多的改变，有的只是细分其内部的视图种类，以及分离 <code>UIView</code> 不应该具有的属性和功能。</p>

<blockquote>
  <p>如果想要具体了解笔者对 Model 层以及 View 层的理解和设计，这是前面两篇文章的链接：<a href="http://nju520.me/mvx-model.html">谈谈 MVX 中的 Model 层</a>、<a href="http://nju520.me/mvx-view.html">谈谈 MVX 中的 View 层</a></p>
</blockquote>

<p>这是 MVX 系列的第三篇文章，而这篇文章准备介绍整个 MVX 中无法避免的话题，也就是 X 这一部分。</p>

<h2 id="x-是什么">X 是什么</h2>

<p>在进入正题之前，我们首先要知道这里的 X 到底是什么？无论是在 iOS 开发领域还是其它的领域，造出了一堆又一堆的名词，除了我们最常见的 MVC 和 MVVM 以及 Android 中的 MVP 还有一些其他的奇奇怪怪的名词。</p>

<p><img src="https://img.nju520.me/MVC-MVVM-MVP.jpg-1000width" alt="MVC-MVVM-MVP" /></p>

<p>模型层和视图层是整个客户端应用不可分割的一部分，它们的职责非常清楚，一个用于处理本地数据的获取以及存储，另一个用于展示内容、接受用户的操作与事件；在这种情况下，整个应用中的其它功能和逻辑就会被自然而然的扔到 X 层中。</p>

<p>这个 X 在 MVC 中就是 Controller 层、在 MVVM 中就是 ViewModel 层，而在 MVP 中就是 Presenter 层，这篇文章介绍的就是 MVC 中的控制器层 Controller。</p>

<h2 id="臃肿的-controller">臃肿的 Controller</h2>

<p>从 Cocoa Touch 框架使用十年以来，iOS 开发者就一直遵循框架中的设计，使用 Model-View-Controller 的架构模式开发 iOS 应用程序，下面也是对 iOS 中 MVC 的各层交互的最简单的说明。</p>

<p><img src="https://img.nju520.me/Model-View-Controller.jpg-1000width" alt="Model-View-Controlle" /></p>

<p>iOS 中的 Model 层大多为 <code>NSObject</code> 的子类，也就是一个简单的对象；所有的 View 层对象都是 <code>UIView</code> 的子类；而 Controller 层的对象都是 <code>UIViewController</code> 的实例。</p>

<p>我们在这一节中主要是介绍 <code>UIViewController</code> 作为 Controller 层中的最重要的对象，它具有哪些职责，它与 Model 以及 View 层是如何进行交互的。</p>

<p>总体来说，Controller 层要负责以下的问题（包括但不仅限于）：</p>

<ol>
  <li>管理根视图的生命周期和应用生命周期</li>
  <li>负责将视图层的 <code>UIView</code> 对象添加到持有的根视图上；</li>
  <li>负责处理用户行为，比如 <code>UIButton</code> 的点击以及手势的触发；</li>
  <li>储存当前界面的状态；</li>
  <li>处理界面之间的跳转；</li>
  <li>作为 <code>UITableView</code> 以及其它容器视图的代理以及数据源；</li>
  <li>负责 HTTP 请求的发起；</li>
</ol>

<p>除了上述职责外，<code>UIViewController</code> 对象还可能需要处理<strong>业务逻辑</strong>以及各种复杂的动画，这也就是为什么在 iOS 应用中的 Controller 层都非常庞大、臃肿的原因了，而 MVVM、MVP 等架构模式的目的之一就是减少单一 Controller 中的代码。</p>

<h3 id="管理生命周期">管理生命周期</h3>

<p>Controller 层作为整个 MVC 架构模式的中枢，承担着非常重要的职责，不仅要与 Model 以及 View 层进行交互，还有通过 AppDelegate 与诸多的应用生命周期打交道。</p>

<pre><code class="language-objectivec">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(nullable NSDictionary&lt;UIApplicationLaunchOptionsKey, id&gt; *)launchOptions;
- (void)applicationWillResignActive:(UIApplication *)application;
- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler;
</code></pre>

<p>虽然与应用生命周期沟通的工作并不在单独的 Controller 中，但是 <code>self.window.rootController</code> 作为整个应用程序界面的入口，还是需要在 AppDelegate 中进行设置。</p>

<p>除此之外，由于每一个 <code>UIViewController</code> 都持有一个视图对象，所以每一个 <code>UIViewController</code> 都需要负责这个根视图的加载、布局以及生命周期的管理，包括：</p>

<pre><code class="language-objectivec">- (void)loadView;

- (void)viewWillLayoutSubviews;
- (void)viewDidLayoutSubviews;

- (void)viewDidLoad;
- (void)viewWillAppear:(BOOL)animated;
- (void)viewDidAppear:(BOOL)animated;
</code></pre>

<p>除了负责应用生命周期和视图生命周期，控制器还要负责展示内容和布局。</p>

<h3 id="负责展示内容和布局">负责展示内容和布局</h3>

<p>由于每一个 <code>UIViewController</code> 都持有一个 <code>UIView</code> 的对象，所以视图层的对象想要出现在屏幕上，必须成为这个根视图的子视图，也就是说视图层完全没有办法脱离 <code>UIViewController</code> 而单独存在，其一方面是因为 <code>UIViewController</code> 隐式的承担了应用中路由的工作，处理界面之间的跳转，另一方面就是 <code>UIViewController</code> 的设计导致了所有的视图必须加在其根视图上才能工作。</p>

<p><img src="https://img.nju520.me/Controller-RootView.jpg-1000width" alt="Controller-RootVie" /></p>

<p>我们来看一段 <code>UIViewController</code> 中关于视图层的简单代码：</p>

<pre><code class="language-objectivec">- (void)viewDidLoad {
    [super viewDidLoad];
    [self setupUI];
}

- (void)setupUI {
    _backgroundView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"backgroundView"]];

    _registerButton = [[UIButton alloc] init];
    [_registerButton setTitle:@"注册" forState:UIControlStateNormal];
    [_registerButton setTitleColor:UIColorFromRGB(0x00C3F3) forState:UIControlStateNormal];
    [_registerButton addTarget:self action:@selector(registerButtonTapped:) forControlEvents:UIControlEventTouchUpInside];

    [self.view addSubview:_backgroundView];
    [self.view addSubview:_registerButton];

    [_backgroundView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.edges.mas_equalTo(self.view);
    }];
    [_registerButton mas_makeConstraints:^(MASConstraintMaker *make) {
        make.size.mas_equalTo(CGSizeMake(140, 45));
        make.bottom.mas_equalTo(self.view).offset(-25);
        make.left.mas_equalTo(self.view).offset(32);
    }];
}
</code></pre>

<p>在这个欢迎界面以及大多数界面中，由于视图层的代码非常简单，我们很多情况下并不会去写一个单独的 <code>UIView</code> 类，而是将全部的视图层代码丢到了 <code>UIViewController</code> 中，这种情况下甚至也没有 Model 层，Controller 承担了全部的工作。</p>

<p><img src="https://img.nju520.me/Controller-Only.jpg-1000width" alt="Controller-Only" /></p>

<p>上述的代码对视图进行了初始化，将需要展示的视图加到了自己持有的根视图中，然后对这些视图进行简单的布局。</p>

<p>当然我们也可以将视图的初始化单独放到一个类中，不过仍然需要处理 <code>DRKBackgroundView</code> 视图的布局等问题。</p>

<pre><code class="language-objectivec">- (void)setupUI {
    DRKBackgroundView *backgroundView = [[DRKBackgroundView alloc] init];
    [backgroundView.registerButton addTarget:self action:@selector(registerButtonTapped:) forControlEvents:UIControlEventTouchUpInside];

    [self.view addSubview:backgroundView];

    [backgroundView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.edges.mas_equalTo(self.view);
    }];
}
</code></pre>

<p><code>UIViewController</code> 的这种中心化的设计虽然简单，不过也导致了很多代码没有办法真正解耦，视图层必须依赖于 <code>UIViewController</code> 才能展示。</p>

<h4 id="惰性初始化">惰性初始化</h4>

<p>当然，很多人在 Controller 中也会使用惰性初始化的方式生成 Controller 中使用的视图，比如：</p>

<pre><code class="language-objectivec">@interface ViewController ()

@property (nonatomic, strong) UIImageView *backgroundView;

@end

@implementation ViewController

- (UIImageView *)backgroundView {
    if (!_backgroundView) {
        _backgroundView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"backgroundView"]];
    }
    return _backgroundView;
}

@end
</code></pre>

<p>这样在 <code>-viewDidLoad</code> 方法中就可以直接处理视图的视图层级以及布局工作：</p>

<pre><code class="language-objectivec">- (void)viewDidLoad {
    [super viewDidLoad];

    [self.view addSubview:self.backgroundView];

    [self.backgroundView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.edges.mas_equalTo(self.view);
    }];
}
</code></pre>

<p>惰性初始化的方法与其他方法其实并没有什么绝对的优劣，两者的选择只是对于代码规范的一种选择，我们所需要做的，只是在同一个项目中将其中一种做法坚持到底。</p>

<h3 id="处理用户行为">处理用户行为</h3>

<p>在 <code>UIViewController</code> 中处理用户的行为是经常需要做的事情，这部分代码不能放到视图层或者其他地方的原因是，用户的行为经常需要与 Controller 的上下文有联系，比如，界面的跳转需要依赖于 <code>UINavigationController</code> 对象：</p>

<pre><code class="language-objectivec">- (void)registerButtonTapped:(UIButton *)button {
    RegisterViewController *registerViewController = [[RegisterViewController alloc] init];
    [self.navigationController pushViewController:registerViewController animated:YES];
}
</code></pre>

<p>而有的用户行为需要改变模型层的对象、持久存储数据库中的数据或者发出网络请求，主要因为我们要秉承着 MVC 的设计理念，避免 Model 层和 View 层的直接耦合。</p>

<h3 id="存储当前界面的状态">存储当前界面的状态</h3>

<p>在 iOS 中，我们经常需要处理表视图，而在现有的大部分表视图在加载内容时都会进行分页，使用下拉刷新和上拉加载的方式获取新的条目，而这就需要在 Controller 层保存当前显示的页数：</p>

<pre><code class="language-objectivec">@interface TableViewController ()

@property (nonatomic, assign) NSUInteger currentPage;

@end
</code></pre>

<p>只有保存在了当前页数的状态，才能在下次请求网络数据时传入合适的页数，最后获得正确的资源，当然哪怕当前页数是可以计算出来的，比如通过当前的 Model 对象的数和每页个 Model 数，在这种情况下，我们也需要在当前 Controller 中 Model 数组的值。</p>

<pre><code class="language-objectivec">@interface TableViewController ()

@property (nonatomic, strong) NSArray&lt;Model *&gt; *models;

@end
</code></pre>

<p>在 MVC 的设计中，这种保存当前页面状态的需求是存在的，在很多复杂的页面中，我们也需要维护大量的状态，这也是 Controller 需要承担的重要职责之一。</p>

<h3 id="处理界面之间的跳转">处理界面之间的跳转</h3>

<p>由于 Cocoa Touch 提供了 <code>UINavigationController</code> 和 <code>UITabBarController</code> 这两种容器 Controller，所以 iOS 中界面跳转的这一职责大部分都落到了 Controller 上。</p>

<p><img src="https://img.nju520.me/UINavigationController-UITabBarController.jpg-1000width" alt="UINavigationController-UITabBarControlle" /></p>

<p>iOS 中总共有三种界面跳转的方式：</p>

<ul>
  <li><code>UINavigationController</code> 中使用 push 和 pop 改变栈顶的 <code>UIViewController</code> 对象；</li>
  <li><code>UITabBarController</code> 中点击各个 <code>UITabBarItem</code> 实现跳转；</li>
  <li>使用所有的 <code>UIViewController</code> 实例都具有的 <code>-presentViewController:animated:completion</code> 方法；</li>
</ul>

<p>因为所有的 <code>UIViewController</code> 的实例都可以通过 <code>navigationController</code> 这一属性获取到最近的 <code>UINavigationController</code> 对象，所以我们不可避免的要在 Controller 层对界面之间的跳转进行操作。</p>

<blockquote>
  <p>当然，我们也可以引入 Router 路由对 <code>UIViewController</code> 进行注册，在访问合适的 URL 时，通过根 <code>UINavigationController</code> 进行跳转，不过这不是本篇文章想要说明的内容。</p>
</blockquote>

<p><code>UINavigationController</code> 提供的 API 还是非常简单的，我们可以直接使用 <code>-pushViewController:animated:</code> 就可以进行跳转。</p>

<pre><code class="language-objectivec">RegisterViewController *registerViewController = [[RegisterViewController alloc] init];
[self.navigationController pushViewController:registerViewController animated:YES];
</code></pre>

<h3 id="作为数据源以及代理">作为数据源以及代理</h3>

<p>很多 Cocoa Touch 中视图层都是以代理的形式为外界提供接口的，其中最为典型的例子就是 <code>UITableView</code> 和它的数据源协议 <code>UITableViewDataSource</code> 和代理 <code>UITableViewDelegate</code>。</p>

<p>这是因为 <code>UITableView</code> 作为视图层的对象，需要根据 Model 才能知道自己应该展示什么内容，所以在早期的很多视图层组件都是用了代理的形式，从 Controller 或者其他地方获取需要展示的数据。</p>

<pre><code class="language-objectivec">#pragma mark - UITableViewDataSource

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return self.models.count;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    TableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell" forIndexPath:indexPath];
    Model *model = self.models[indexPath.row];
    [cell setupWithModel:model];
    return cell;
}
</code></pre>

<p>上面就是使用 <code>UITableView</code> 时经常需要的方法。</p>

<p>很多文章中都提供了一种用于减少 Controller 层中代理方法数量的技巧，就是使用一个单独的类作为 <code>UITableView</code> 或者其他视图的代理：</p>

<pre><code class="language-objectivec">self.tableView.delegate = anotherObject;
self.tableView.dataSource = anotherObject;
</code></pre>

<p>然而在笔者看来这种办法并没有什么太大的用处，只是将代理方法挪到了一个其他的地方，如果这个代理方法还依赖于当前 <code>UIViewController</code> 实例的上下文，还要向这个对象中传入更多的对象，反而让原有的 MVC 变得更加复杂了。</p>

<h3 id="负责-http-请求的发起">负责 HTTP 请求的发起</h3>

<p>当用户的行为触发一些事件时，比如下拉刷新、更新 Model 的属性等等，Controller 就需要通过 Model 层提供的接口向服务端发出 HTTP 请求，这一过程其实非常简单，但仍然是 Controller 层的职责，也就是响应用户事件，并且更新 Model 层的数据。</p>

<pre><code class="language-objectivec">- (void)registerButtonTapped:(UIButton *)button {
    LoginManager *manager = [LoginManager manager];
    manager.countryCode = _registerPanelView.countryCode;
    ...
    [manager startWithSuccessHandler:^(CCStudent *user) {
        self.currentUser = user;
        ...
    } failureHandler:^(NSError *error) {
        ...
    }];
}
</code></pre>

<p>当按钮被点击时 <code>LoginManager</code> 就会执行 <code>-startWithSuccessHandler:failureHandler:</code> 方法发起请求，并在请求结束后执行回调，更新 Model 的数据。</p>

<h3 id="小结">小结</h3>

<p>iOS 中 Controller 层的职责一直都逃不开与 View 层和 Model 层的交互，因为其作用就是视图层的用户行为进行处理并更新视图的内容，同时也会改变模型层中的数据、使用 HTTP 请求向服务端请求新的数据等作用，其功能就是处理整个应用中的业务逻辑和规则。</p>

<p>但是由于 iOS 中 Controller 的众多职责，单一的 <code>UIViewController</code> 类可能会有上千行的代码，使得非常难以管理和维护，我们也希望在 iOS 中引入新的架构模式来改变 Controller 过于臃肿这一现状。</p>

<h2 id="几点建议">几点建议</h2>

<p>Controller 层作为 iOS 应用中重要的组成部分，在 MVC 以及类似的架构下，笔者对于 Controller 的设计其实没有太多立竿见影的想法。作为应用中处理绝大多数逻辑的 Controller 其实很难简化其中代码的数量；我们能够做的，也是只对其中的代码进行一定的规范以提高它的可维护性，在这里，笔者有几点对于 Controller 层如何设计的建议，供各位读者参考。</p>

<h3 id="不要把-datasource-提取出来">不要把 DataSource 提取出来</h3>

<p>iOS 中的 <code>UITableView</code> 和 <code>UICollectionView</code> 等需要 <code>dataSource</code> 的视图对象十分常见，在一些文章中会提议将数据源的实现单独放到一个对象中。</p>

<pre><code class="language-objectivec">void (^configureCell)(PhotoCell*, Photo*) = ^(PhotoCell* cell, Photo* photo) {
   cell.label.text = photo.name;
};
photosArrayDataSource = [[ArrayDataSource alloc] initWithItems:photos
                                                cellIdentifier:PhotoCellIdentifier
                                            configureCellBlock:configureCell];
self.tableView.dataSource = photosArrayDataSource;
</code></pre>

<p>在 <a href="https://www.objc.io/issues/1-view-controllers/lighter-view-controllers/">Lighter View Controllers</a> 一文中就建议可以将数据源协议的实现方法放到 <code>ArrayDataSource</code> 对象中：</p>

<pre><code class="language-objectivec">@implementation ArrayDataSource

- (id)itemAtIndexPath:(NSIndexPath*)indexPath {
    return items[(NSUInteger)indexPath.row];
}

- (NSInteger)tableView:(UITableView*)tableView
 numberOfRowsInSection:(NSInteger)section {
    return items.count;
}

- (UITableViewCell*)tableView:(UITableView*)tableView
        cellForRowAtIndexPath:(NSIndexPath*)indexPath {
    id cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier
                                              forIndexPath:indexPath];
    id item = [self itemAtIndexPath:indexPath];
    configureCellBlock(cell,item);
    return cell;
}

@end
</code></pre>

<p>做出这种建议的理由是：单独的 <code>ArrayDataSource</code> 类可以更方便的进行测试，同时，展示一个数组的对象是表视图中非常常见的需求，而 <code>ArrayDataSource</code> 能够将这种需求抽象出来并进行重用，也可以达到减轻视图控制器负担的最终目的，但是在笔者看来，上述做法并没有起到<strong>实质性</strong>效果，只是简单的将视图控制器中的一部分代码<em>移到了</em>别的位置而已，还会因为增加了额外的类使 Controller 的维护变得更加的复杂。</p>

<p><img src="https://img.nju520.me/UITableView-DataSource.jpg-1000width" alt="UITableView-DataSource" /></p>

<p>让每一个 Controller 作为 <code>UITableView</code> 对象的代理和数据源其实是没有任何问题的，将这些方法移出 Controller 并不能解决实际的问题。</p>

<h3 id="属性和实例变量的选择">属性和实例变量的选择</h3>

<p>文章的前面曾经提到过在很多的 iOS 应用中，Controller 由于持有一个根视图 <code>UIView</code> 对象，所以需要负责展示内容以及布局，很多 iOS 开发者都把一些模块的视图层代码放到了控制器中，但是无论是将视图层代码放到控制器中，还是新建一个单独的视图类都需要对视图以及子视图进行初始化和布局。</p>

<p>在对视图进行初始化和布局时，我们有两种选择，一种是使用实例变量的方式主动对视图对象进行初始化，另一种是使用属性 <code>@property</code> 对视图对象进行惰性初始化。</p>

<p><img src="https://img.nju520.me/Eager-Lazy-Initialization.jpg-1000width" alt="Eager-Lazy-Initialization" /></p>

<p>虽然上述两种代码在结果上几乎是等价的，但是笔者更加偏好两者之中的后者，它将各个视图属性的初始化放到了各个属性的 getter 方法中，能够将代码在逻辑上分块还是比较清晰的。这两种方法其实只是不同的 taste，有些人会坚持将不需要暴露的变量都写成 <code>_xxx</code> 的形式，有些人更喜欢后者这种分散的写法，这些都不是什么太大的问题，而且很多人担心的性能问题其实也根本不是问题，重要的是我们要在同一个项目中坚持同一种写法，并且保证只有同一个风格的代码合入主分支。</p>

<h3 id="把业务逻辑移到-model-层">把业务逻辑移到 Model 层</h3>

<p>控制器中有很多代码和逻辑其实与控制器本身并没有太多的关系，比如：</p>

<pre><code class="language-objectivec">@implementation ViewController

- (NSString *)formattedPostCreatedAt {
    NSDateFormatter *format = [[NSDateFormatter alloc] init];
    [format setDateFormat:@"MMM dd, yyyy HH:mm"];
    return [format stringFromDate:self.post.createdAt];
}

@end
</code></pre>

<p>在 <a href="http://nju520.me/mvx-model.html">谈谈 MVX 中的 Model 层</a> 一文中，我们曾经分析过，上述逻辑其实应该属于 Model 层，作为 <code>Post</code> 的一个实例方法：</p>

<pre><code class="language-objectivec">@implementation Post

- (NSString *)formattedCreatedAt {
    NSDateFormatter *format = [[NSDateFormatter alloc] init];
    [format setDateFormat:@"MMM dd, yyyy HH:mm"];
    return [format stringFromDate:self.createdAt];
}

@end
</code></pre>

<p>这一条建议是从一些经典的后端 MVC 框架中学习的，Rails 提倡 <em>Fat Model, Skinny Controller</em> 就是希望开发者将 Model 相关的业务逻辑都放到 Model 层中，以减轻 Controller 层的负担。</p>

<h3 id="把视图层代码移到-view-层">把视图层代码移到 View 层</h3>

<p>因为 UIKit 框架设计的原因，Controller 和 View 层是强耦合的，每一个 <code>UIViewController</code> 都会持有一个 <code>UIView</code> 视图对象，这也是导致我们将很多的视图层代码直接放在 Controller 层的原因。</p>

<p><img src="https://img.nju520.me/MVC-in-iOS.jpg-1000width" alt="MVC-in-iOS" /></p>

<p>这种做法在当前模块的视图层比较简单时，笔者觉得没有任何的问题，虽然破坏了经典的 MVC 的架构图，但是也不是什么问题；不过，当视图层的视图对象非常多的时候，大量的配置和布局代码就会在控制器中占据大量的位置，我们可以将整个视图层的代码都移到一个单独的 <code>UIView</code> 子类中。</p>

<pre><code class="language-objectivec">// RegisterView.h
@interface RegisterView : UIView

@property (nonatomic, strong) UITextField *phoneNumberTextField;
@property (nonatomic, strong) UITextField *passwordTextField;

@end

// RegisterView.m
@implementation RegisterView

- (instancetype)initWithFrame:(CGRect)frame {
    if (self = [super initWithFrame:frame]) {
        [self addSubview:self.phoneNumberTextField];
        [self addSubview:self.passwordTextField];

        [self.phoneNumberTextField mas_makeConstraints:^(MASConstraintMaker *make) {
            ...
        }];
        [self.passwordTextField mas_makeConstraints:^(MASConstraintMaker *make) {
            ...
        }];
    }
    return self;
}

- (UITextField *)phoneNumberTextField {
    if (!_phoneNumberTextField) {
        _phoneNumberTextField = [[UITextField alloc] init];
        _phoneNumberTextField.font = [UIFont systemFontOfSize:16];
    }
    return _phoneNumberTextField;
}

- (UITextField *)passwordTextField {
    if (!_passwordTextField) {
        _passwordTextField = [[UITextField alloc] init];
        ...
    }
    return _passwordTextField;
}

@end
</code></pre>

<p>而 Controller 需要持有该视图对象，并将自己持有的根视图替换成该视图对象：</p>

<pre><code class="language-objectivec">@interface ViewController ()

@property (nonatomic, strong) RegisterView *view;

@end

@implementation ViewController

@dynamic view;

- (void)loadView {
    self.view = [[RegisterView alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
}

- (void)viewDidLoad {
    [super viewDidLoad];
}

@end
</code></pre>

<p>在 <code>UIViewController</code> 对象中，我们可以通过覆写 <code>-loadView</code> 方法改变其本身持有的视图对象，并使用新的 <code>@property</code> 声明以及 <code>@dynamic</code> 改变 Controller 持有的根视图，这样我们就把视图层的配置和布局代码从控制器中完全分离了。</p>

<h3 id="使用-pragma-或-extension-分割代码块">使用 pragma 或 extension 分割代码块</h3>

<p>在很多时候，我们对于 Controller 中上千行的代码是非常绝望的，不熟悉这个模块的开发者想要在里面快速找到自己想要的信息真的是非常的麻烦，尤其是如果一个 <code>UIViewController</code> 中的代码没有被组织好的话，那分析起来更是异常头疼。</p>

<p>我们既然没有把上千行的代码瞬间变没的方法，那就只能想想办法在现有的代码上进行美化了，办法其实很简单，就是将具有相同功能的代码分块并使用 <code>pragma</code> 预编译指定或者 <code>MARK</code> 加上 <code>extension</code> 对代码块进行分割。</p>

<p>这里给一个简单的例子，</p>

<pre><code class="language-objectivec">@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    [self setupUI];
}

- (void)layoutSubviews { }

#pragma mark - UI

- (void)setupUI {}

#pragma mark - UITableViewDataSource

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return 1;
}
...

#pragma mark - UITableViewDelegate

- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {
    return 100.0;
}
...

#pragma mark - Callback

- (void)buttonTapped:(UIButton *)button {}
- (void)gestureTriggered:(UIGestureRecognizer *)gesture {}
- (void)keyboardWillShow:(NSNotification *)noti {}

#pragma mark - Getter/Setter

- (NSString *)string { return _string; }
- (void)setString:(NSString*)string { _string = string; }

#pragma mark - Helper

- (void)helperMethod {}

@end
</code></pre>

<p>一个 <code>UIViewController</code> 大体由上面这些部分组成：</p>

<ul>
  <li>生命周期以及一些需要 <code>override</code> 的方法</li>
  <li>视图层代码的初始化</li>
  <li>各种数据源和代理协议的实现</li>
  <li>事件、手势和通知的回调</li>
  <li>实例变量的存取方法</li>
  <li>一些其他的 Helper 方法</li>
</ul>

<p>在 Objective-C 的工程中，我们使用 <code>pragma</code> 预编译指令来对 <code>UIViewController</code> 中的；在 Swift 中，我们可以使用 <code>extension</code> 加上 <code>MARK</code> 来对代码进行分块：</p>

<pre><code class="language-swift">class ViewController: UIViewController {}

// MARK: - UI
extension ViewController {}

// MARK: - UITableViewDataSource
extension ViewController: UITableViewDataSource {}

// MARK: - UITableViewDelegate
extension ViewController: UITableViewDelegate {}

// MARK: - Callback
extension ViewController {}

// MARK: - Getter/Setter
extension ViewController {}

// MARK: - Helper
extension ViewController {}
</code></pre>

<p>上述方法是一种在控制器层分割代码块的方法，它们的顺序并不是特别的重要，最重要的还是要在不同的控制器中保持上述行为的一致性，将合理的方法放到合适的代码块中。</p>

<h3 id="耦合的-view-和-model-层">耦合的 View 和 Model 层</h3>

<p>很多的 iOS 项目中都会为 <code>UIView</code> 添加一个绑定 Model 对象的方法，比如说：</p>

<pre><code class="language-objectivec">@implementation UIView (Model)

- (void)setupWithModel:(id)model {}

@end
</code></pre>

<p>这个方法也可能叫做 <code>-bindWithModel:</code> 或者其他名字，其作用就是根据传入的 Model 对象更新当前是视图中的各种状态，比如 <code>UILabel</code> 中的文本、<code>UIImageView</code> 中的图片等等。</p>

<p>有了上述分类，我们可以再任意的 <code>UIView</code> 的子类中覆写该方法：</p>

<pre><code class="language-objectivec">- (void)setupWithModel:(Model *)model {
    self.imageView.image = model.image;
    self.label.text = model.name;
}
</code></pre>

<p>这种做法其实是将原本 Controller 做的事情放到了 View 中，由视图层来负责如何展示模型对象；虽然它能够减少 Controller 中的代码，但是也导致了 View 和 Model 的耦合。</p>

<p><img src="https://img.nju520.me/Coupling-View-And-Model.jpg-1000width" alt="Coupling-View-And-Mode" /></p>

<p>对于 MVC 架构模式中，Model、View 和 Controller 之间的交互没有明确的规则，但是视图和模型之间的耦合会导致视图层代码很难复用；因为这样设计的视图层都依赖于外部的模型对象，所以<strong>如果同一个视图需要显示多种类型的模型时就会遇到问题</strong>。</p>

<p>视图和模型之间解耦是通过控制器来处理的，控制器获取模型对象并取出其中的属性一一装填到视图中，也就是将 <code>-setupWithModel:</code> 方法中的代码从视图层移到控制器层中，并在视图类中暴露合适的接口。</p>

<h2 id="总结">总结</h2>

<p>本文虽然对 Controller 层的职责进行了分析，但是由于 Controller 在 MVC 中所处的位置，如果不脱离 MVC 架构模式，那么 Controller 的职责很难简化，只能在代码规范和职责划分上进行限制，而在下一篇文章中我们会详细讨论 MVC 以及衍化出来的MVP 以及 MVVM 到底是什么、以及它们有什么样的差异。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://www.objc.io/issues/1-view-controllers/lighter-view-controllers/">Lighter View Controllers</a></li>
</ul>

  ]]></description>
</item>

<item>
  <title>谈谈 MVX 中的 View</title>
  <link>//mvx-view</link>
  <author>nju520</author>
  <pubDate>2017-06-23T01:34:44+08:00</pubDate>
  <guid>//mvx-view</guid>
  <description><![CDATA[
  <ul>
  <li><a href="http://nju520.me/mvx-model.html">谈谈 MVX 中的 Model</a></li>
  <li><a href="http://nju520.me/mvx-view.html">谈谈 MVX 中的 View</a></li>
  <li><a href="http://nju520.me/mvx-controller.html">谈谈 MVX 中的 Controller</a></li>
  <li><a href="http://nju520.me/mvx.html">浅谈 MVC、MVP 和 MVVM 架构模式</a></li>
</ul>

<blockquote>
  <p>Follow GitHub: <a href="https://github.com/nju520">nju520</a></p>
</blockquote>

<p>这是谈谈 MVX 系列的第二篇文章，上一篇文章中对 iOS 中 Model 层的设计进行了简要的分析；而在这里，我们会对 MVC 中的视图层进行讨论，谈一谈现有的视图层有着什么样的问题，如何在框架的层面上去改进，同时与服务端的视图层进行对比，分析它们的差异。</p>

<h2 id="uikit">UIKit</h2>

<p>UIKit 是 Cocoa Touch 中用于构建和管理应用的用户界面的框架，其中几乎包含着与 UI 相关的全部功能，而我们今天想要介绍的其实是 UIKit 中与视图相关的一部分，也就是 <code>UIView</code> 以及相关类。</p>

<p><code>UIView</code> 可以说是 iOS 中用于渲染和展示内容的最小单元，作为开发者能够接触到的大多数属性和方法也都由 <code>UIView</code> 所提供，比如最基本的布局方式 frame 就是通过 <code>UIView</code> 的属性所控制，在 Cocoa Touch 中的所有布局系统最终都会转化为 CFRect 并通过 frame 的方式完成最终的布局。</p>

<p><img src="https://img.nju520.me/Frame-And-Components.jpg-1000width" alt="Frame-And-Components" /></p>

<p><code>UIView</code> 作为 UIKit 中极为重要的类，它的 API 以及设计理念决定了整个 iOS 的视图层该如何工作，这也是理解视图层之前必须要先理解 <code>UIView</code> 的原因。</p>

<h3 id="uiview">UIView</h3>

<p>在 UIKit 中，除了极少数用于展示的类不继承自 <code>UIView</code> 之外，几乎所有类的父类或者或者祖先链中一定会存在 <code>UIView</code>。</p>

<p><img src="https://img.nju520.me/UIView-And-Subclasses.jpg-1000width" alt="UIView-And-Subclasses" /></p>

<p>我们暂且抛开不继承自 <code>UIView</code> 的 <code>UIBarItem</code> 类簇不提，先通过一段代码分析一下 <code>UIView</code> 具有哪些特性。</p>

<pre><code class="language-objectivec">UIImageView *backgroundView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"backgoundImage"]];
UIImageView *logoView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"logo"]];

UIButton *loginButton = [[UIButton alloc] init];
[loginButton setTitle:@"登录" forState:UIControlStateNormal];
[loginButton setTitleColor:UIColorFromRGB(0xFFFFFF) forState:UIControlStateNormal];
[loginButton.titleLabel setFont:[UIFont boldSystemFontOfSize:18]];
[loginButton setBackgroundColor:UIColorFromRGB(0x00C3F3)];

[self.view addSubview:backgroundView];
[backgroundView addSubview:logoView];
[backgroundView addSubview:loginButton];
</code></pre>

<p><code>UIView</code> 作为视图层大部分元素的根类，提供了两个非常重要的特性：</p>

<ul>
  <li>由于 <code>UIView</code> 具有 <code>frame</code> 属性，所以为所有继承自 <code>UIView</code> 的类提供了绝对布局相关的功能，也就是在 Cocoa Touch 中，所有的视图元素都可以通过 <code>frame</code> 设置自己在父视图中的绝对布局；</li>
  <li>
    <p><code>UIView</code> 在接口中提供了操作和管理视图层级的属性和方法，比如 <code>superview</code>、<code>subviews</code> 以及 <code>-addSubview:</code> 等方法；</p>

    <pre><code class="language-objectivec">@interface UIView (UIViewHierarchy)

@property (nullable, nonatomic, readonly) UIView       *superview;
@property (nonatomic, readonly, copy) NSArray&lt;__kindof UIView *&gt; *subviews;

- (void)addSubview:(UIView *)view;

...

@end
</code></pre>

    <p>也就是说 <strong>UIView 和它所有的子类都可以拥有子视图，成为容器并包含其他 UIView 的实例</strong>。</p>

    <pre><code class="language-objectivec">[self.view addSubview:backgroundView];
[backgroundView addSubview:logoView];
[backgroundView addSubview:loginButton];
</code></pre>
  </li>
</ul>

<p>这种使用 <code>UIView</code> 同时为子类提供默认的 <code>frame</code> 布局以及子视图支持的方式在一定程度上能够降低视图模型的复杂度：因为所有的视图都是一个容器，所以在开发时不需要区分视图和容器，但是这种方式虽然带来了一些方便，但是也不可避免地带来了一些问题。</p>

<h3 id="uiview-与布局">UIView 与布局</h3>

<p>在早期的 Cocoa Touch 中，整个视图层的布局都只是通过 <code>frame</code> 属性来完成的（绝对布局），一方面是因为在 iPhone5 之前，iOS 应用需要适配的屏幕尺寸非常单一，完全没有适配的兼容问题，所以使用单一的 <code>frame</code> 布局方式完全是可行的。</p>

<p>但是在目前各种屏幕尺寸的种类暴增的情况下，就很难使用 <code>frame</code> 对所有的屏幕进行适配，在这时苹果就引入了 Auto Layout 采用相对距离为视图层的元素进行布局。</p>

<p><img src="https://img.nju520.me/AutoLayout.jpg-1000width" alt="AutoLayout" /></p>

<p>不过，这算是苹果比较失败的一次性尝试，主要是因为使用 Auto Layout 对视图进行布局实在太过复杂，所以刚出来的时候也不温不火，很少有人使用，直到 Masonry 的出现使得编写 Auto Layout 代码没有那么麻烦和痛苦才普及起来。</p>

<p>但是由于 Auto Layout 的工作原理实际上是解 N 元一次方程组，所以在遇到复杂视图时，会遇到非常严重的性能问题，如果想要了解相关的问题的话，可以阅读 <a href="http://nju520.me/layout-performance.html">从 Auto Layout 的布局算法谈性能</a> 这篇文章，在这里就不再赘述了。</p>

<p>然而 Auto Layout 的相对布局虽然能够在<em>一定程度上</em>解决适配<strong>屏幕大小和尺寸接近的</strong>适配问题，比如 iPhone4s、iPhone5、iPhone6 Plus 等移动设备，或者iPad 等平板设备。但是，Auto Layout 不能通过一套代码打通 iPhone 和 iPad 之间布局方式的差异，只能通过代码中的 if 和 else 进行判断。</p>

<p>在这种背景下，苹果做了很多的尝试，比如说 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Size-ClassSpecificLayout.html">Size-Class-Specific Layout</a>，Size Class 将屏幕的长宽分为三种：</p>

<ul>
  <li>Compact</li>
  <li>Regular</li>
  <li>Any</li>
</ul>

<p>这样就出现了最多 3 x 3 的组合，比如屏幕宽度为 Compact 高度为 Regular 等等，它与 Auto Layout 一起工作省去了一些 if 和 else 的条件判断，但是从实际效果上来说，它的用处并不是特别大，而且使用代码来做 Size Class 的相关工作依然非常困难。</p>

<p>除了 Auto Layout 和 Size Class 之外，苹果在 iOS9 还推出了 <code>UIStackView</code> 来增加 iOS 中的布局方式和手段，这是一种类似 flexbox 的布局方式。</p>

<p>虽然 <code>UIStackView</code> 可以起到一定的作用，但是由于大多数 iOS 应用都要求对设计稿进行严格还原并且其 API 设计相对啰嗦，开发者同时也习惯了使用 Auto Layout 的开发方式，在惯性的驱动下，<code>UIStackView</code> 应用的也不是非常广泛。</p>

<p><img src="https://img.nju520.me/UIStackView.jpg-1000width" alt="UIStackVie" /></p>

<p>不过现在很多跨平台的框架都是用类似 <code>UIStackView</code> 的方式进行布局，比如 React Native、Weex 等，其内部都使用 Facebook 开源的 Yoga。</p>

<blockquote>
  <p>由于 flexbox 以及类似的布局方式在其他平台上都有类似的实现，并且其应用确实非常广泛，笔者认为随着工具的完善，这种布局方式会逐渐进入 iOS 开发者的工具箱中。</p>
</blockquote>

<p>三种布局方式 <code>frame</code>、Auto Layout 以及 <code>UIStackView</code> 其实最终布局都会使用 <code>frame</code>，其他两种方式 Auto Layout 和 <code>UIStackView</code> 都会将代码<em>描述</em>的布局转换成 <code>frame</code> 进行。</p>

<h4 id="布局机制的混用">布局机制的混用</h4>

<p>Auto Layout 和 <code>UIStackView</code> 的出现虽然为布局提供了一些方便，但是也增加了布局系统的复杂性。</p>

<p>因为在 iOS 中几乎所有的视图都继承自 <code>UIView</code>，这样也同时继承了 <code>frame</code> 属性，在使用 Auto Layout 和 <code>UIStackView</code> 时，并没有禁用 <code>frame</code> 布局，所以在混用却没有掌握技巧时可能会有一些比较奇怪的问题。</p>

<p>其实，在混用 Auto Layout 和 <code>frame</code> 时遇到的大部分奇怪的问题都是因为 <a href="https://developer.apple.com/reference/uikit/uiview/1622572-translatesautoresizingmaskintoco">translatesAutoresizingMaskIntoConstraints</a> 属性没有被正确设置的原因。</p>

<blockquote>
  <p>If this property’s value is true, the system creates a set of constraints that duplicate the behavior specified by the view’s autoresizing mask. This also lets you modify the view’s size and location using the view’s frame, bounds, or center properties, allowing you to create a static, frame-based layout within Auto Layout.</p>
</blockquote>

<p>在这里就不详细解释该属性的作用和使用方法了。</p>

<h4 id="对动画的影响">对动画的影响</h4>

<p>在 Auto Layout 出现之前，由于一切布局都是使用 <code>frame</code> 工作的，所以在 iOS 中完成对动画的编写十分容易。</p>

<pre><code class="language-objectivec">UIView.animate(withDuration: 1.0) {
    view.frame = CGRect(x: 10, y: 10, width: 200, height: 200)
}
</code></pre>

<p>而当大部分的 iOS 应用都转而使用 Auto Layout 之后，对于视图大小、位置有关的动画就比较麻烦了：</p>

<pre><code class="language-objectivec">topConstraint.constant = 10
leftConstraint.constant = 10
heightConstraint.constant = 200
widthConstraint.constant = 200
UIView.animate(withDuration: 1.0) {
    view.layoutIfNeeded()
}
</code></pre>

<p>我们需要对视图上的约束对象一一修改并在最后调用 <code>layoutIfNeeded</code> 方法才可以完成相同的动画。由于 Auto Layout 对动画的支持并不是特别的优秀，所以在很多时候笔者在使用 Auto Layout 的视图上，都会使用 <code>transform</code> 属性来改变视图的位置，这样虽然也没有那么的优雅，不过也是一个比较方便的解决方案。</p>

<p><img src="https://img.nju520.me/lottie.jpg-1000width" alt="lottie" /></p>

<h3 id="frame-的问题">frame 的问题</h3>

<p>每一个 <code>UIView</code> 的 <code>frame</code> 属性其实都是一个 <code>CGRect</code> 结构体，这个结构体展开之后有四个组成部分：</p>

<ul>
  <li>origin
    <ul>
      <li>x</li>
      <li>y</li>
    </ul>
  </li>
  <li>size
    <ul>
      <li>width</li>
      <li>height</li>
    </ul>
  </li>
</ul>

<p>当我们设置一个 <code>UIView</code> 对象的 <code>frame</code> 属性时，其实是同时设置了它在父视图中的位置和它的大小，从这里可以获得一条比较重要的信息：</p>

<blockquote>
  <p>iOS 中所有的 <code>UIView</code> 对象都是使用 <code>frame</code> 布局的，否则 <code>frame</code> 中的 <code>origin</code> 部分就失去了意义。</p>
</blockquote>

<p>但是如果为 <code>UIStackView</code> 中的视图设置 <code>frame</code> 的话，这个属性就完全没什么作用了，比如下面的代码：</p>

<pre><code class="language-objectivec">UIStackView *stackView = [[UIStackView alloc] init];
stackView.frame = self.view.frame;
[self.view addSubview:stackView];

UIView *greenView = [[UIView alloc] init];
greenView.backgroundColor = [UIColor greenColor];
greenView.frame = CGRectMake(0, 0, 100, 100);
[stackView addArrangedSubview:greenView];

UIView *redView = [[UIView alloc] init];
redView.backgroundColor = [UIColor redColor];
redView.frame = CGRectMake(0, 0, 100, 100);
[stackView addArrangedSubview:redView];
</code></pre>

<p><code>frame</code> 属性在 <code>UIStackView</code> 上基本上就完全失效了，我们还需要使用约束来控制 <code>UIStackView</code> 中视图的大小，不过如果你要使用 <code>frame</code> 属性来查看视图在父视图的位置和大小，在恰当的时机下是可行的。</p>

<h4 id="谈谈-origin">谈谈 origin</h4>

<p>但是 <code>frame</code> 的不正确使用会导致视图之间的耦合，如果内部视图设置了自己在父视图中的 <code>origin</code>，但是父视图其实并不会使用直接 <code>frame</code> 布局该怎么办？比如，父视图是一个 <code>UIStackView</code>，它就会重写子视图的 <code>origin</code> 甚至是没有正确设置的 <code>size</code> 属性。</p>

<p>最重要的是 <code>UIView</code> 上 <code>frame</code> 的设计导致了视图之间可能会有较强的耦合，因为<strong>子视图不应该知道自己在父视图中的位置</strong>，它应该只关心自己的大小。</p>

<p>也就是作为一个简单的 <code>UIView</code> 它应该只能设置自己的 <code>size</code> 而不是 <code>origin</code>，因为父视图可能是一个 <code>UIStackView</code> 也可能是一个 <code>UITableView</code> 甚至是一个扇形的视图也不是不可能，所以<strong>位置这一信息并不是子视图应该关心的</strong>。</p>

<p>如果视图设置了自己的 <code>origin</code> 其实也就默认了自己的父视图一定是使用 <code>frame</code> 进行布局的，而一旦依赖于外部的信息，它就很难进行复用了。</p>

<h4 id="再谈-size">再谈 size</h4>

<p>关于视图大小的确认，其实也是有一些问题的，因为视图在布局时确实可能依赖于父视图的大小，或者更确切的说是需要父视图提供一个可供布局的大小，然后让子视图通过这个 <code>CGSize</code> 返回一个自己需要的大小给父视图。</p>

<p><img src="https://img.nju520.me/texture.png-1000width" alt="texture" /></p>

<p>这种计算视图大小的方式，其实比较像 <a href="https://github.com/TextureGroup/Texture">Texture</a> 也就是原来的 AsyncDisplayKit 中对于布局系统的实现。</p>

<p>父视图通过调用子视图的 <code>-layoutSpecThatFits:</code> 方法获取子视图布局所需要的大小，而子视图通过父视图传入的 <code>CGSizeRange</code> 来设置自己的大小。</p>

<pre><code class="language-objectivec">- (ASLayoutSpec *)layoutSpecThatFits:(ASSizeRange)constrainedSize
    ...
}
</code></pre>

<p>通过这种方式，子视图对父视图一无所知，它不知道父视图的任何属性，只通过 <code>-layoutSpecThatFits:</code> 方法传入的参数进行布局，实现了解耦以及代码复用。</p>

<h3 id="小结">小结</h3>

<p>由于确实需要对多尺寸的屏幕进行适配，苹果推出 Auto Layout 和 <code>UIStackView</code> 的初衷也没有错，但是在笔者看来，因为绝大部分视图都继承自 <code>UIView</code>，所以在很多情况下并没有对开发者进行强限制，比如在使用 <code>UIStackView</code> 时只能使用 flexbox 式的布局，在使用 Auto Layout 时也只能使用约束对视图进行布局等等，所以在很多时候会带来一些不必要的问题。</p>

<p>同时 <code>UIView</code> 中的 <code>frame</code> 属性虽然在一开始能够很好的解决的布局的问题，但是随着布局系统变得越来越复杂，使得很多 UI 组件在与非 <code>frame</code> 布局的容器同时使用时产生了冲突，最终破坏了良好的封装性。</p>

<p>到目前为止 iOS 中的视图层的问题主要就是 <code>UIView</code> 作为视图层中的上帝类，提供的 <code>frame</code> 布局系统不能良好的和其他布局系统工作，在一些时候 <code>frame</code> 属性完全成为了摆设。</p>

<h2 id="其他平台对视图层的设计">其他平台对视图层的设计</h2>

<p>在接下来的文章中，我们会介绍和分析其他平台 Android、Web 前端以及后端是如何对视图层进行设计的。</p>

<h3 id="android-与-view">Android 与 View</h3>

<p>与 iOS 上使用命令式的风格生成界面不同，Android 使用声明式的 XML 对界面进行描述，在这里举一个最简单的例子：</p>

<pre><code class="language-xml">&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context="com.example.nju520.myapplication.DisplayMessageActivity"&gt;

    &lt;TextView
        android:id="@+id/textView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="16dp"
        android:text="TextView"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" /&gt;

&lt;/android.support.constraint.ConstraintLayout&gt;
</code></pre>

<blockquote>
  <p>整个 XML 文件同时描述了视图的结构和样式，而这也是 Android 对于视图层的设计方式，将结构和样式混合在一个文件中。</p>
</blockquote>

<p>我们首先来分析一下上述代码的结构，整个 XML 文件中只有两个元素，如果我们去掉其中所有的属性，整个界面的元素就是这样的：</p>

<pre><code class="language-xml">&lt;ConstraintLayout&gt;
    &lt;TextView/&gt;
&lt;/ConstraintLayout&gt;
</code></pre>

<p>由一个 <code>ConstraintLayout</code> 节点包含一个 <code>TextView</code> 节点。</p>

<h4 id="view-和-viewgroup">View 和 ViewGroup</h4>

<p>我们再来看一个 Android 中稍微复杂的视图结构：</p>

<pre><code class="language-xml">&lt;LinearLayout&gt;
    &lt;RelativeLayout&gt;
        &lt;ImageView/&gt;
        &lt;LinearLayout&gt;
            &lt;TextView/&gt;
            &lt;TextView/&gt;
        &lt;/LinearLayout&gt;
    &lt;/RelativeLayout&gt;
    &lt;View/&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p>上面的 XML 代码描述了一个更加复杂的视图树，这里通过一张图更清晰地展示该视图表示的结构：</p>

<p><img src="https://img.nju520.me/Android-View-Tree.jpg-1000width" alt="Android-View-Tree" /></p>

<p>我们可以发现，Android 的视图其实分为两类：</p>

<ul>
  <li>一类是不能有子节点的视图，比如 <code>View</code>、<code>ImageView</code> 和 <code>TextView</code> 等；</li>
  <li>另一类是可以有子节点的视图，比如 <code>LinearLayout</code> 和 <code>RelativeLayout</code> 等；</li>
</ul>

<p>在 Android 中，这两类的前者都是 <code>View</code> 的子类，也就是视图；后者是 <code>ViewGroup</code> 的子类，它主要充当视图的容器，与它的子节点以树形的结构形成了一个层次结构。</p>

<p>这种分离视图和容器的方式很好的分离了职责，将管理和控制子视图的功能划分给了 <code>ViewGroup</code>，将显示内容的职责抛给了 <code>View</code> 对各个功能进行了合理的拆分。</p>

<p>子视图的布局属性只有在父视图为特定 <code>ViewGroup</code> 时才会激活，否则就会忽略在 XML 中声明的属性。</p>

<h4 id="混合的结构与样式">混合的结构与样式</h4>

<p>在使用 XML 或者类 XML 的这种文本来描述视图层的内容时，总会遇到一种无法避免的争论：样式到底应该放在哪里？上面的例子显然说明了 Android 对于这一问题的选择，也就是将样式放在 XML 结构中。</p>

<p>这一章节中并不会讨论样式到底应该放在哪里这一问题，我们会在后面的章节中具体讨论，将样式放在 XML 结构中和单独使用各自的优缺点。</p>

<h3 id="web-前端">Web 前端</h3>

<p>随着 Web 前端应用变得越来越复杂，在目前的大多数 Web 前端项目的实践中，我们已经会使用前后端分离方式开发 Web 应用，而 Web 前端也同时包含 Model、View 以及 Controller 三部分，不再通过服务端直接生成前端的 HTML 代码了。</p>

<p><img src="https://img.nju520.me/html-css.jpg-1000width" alt="html-css" /></p>

<p>现在最流行的 Web 前端框架有三个，分别是 React、Vue 和 Angular。不过，这篇文章会以最根本的 HTML 和 CSS 为例，简单介绍 Web 前端中的视图层是如何工作的。</p>

<pre><code class="language-html">&lt;div&gt;
  &lt;h1 class="text-center"&gt;Header&lt;/h1&gt;
&lt;/div&gt;

.text-center {
  text-align: center;
}
</code></pre>

<p>在 HTML 中其实并没有视图和容器这种概念的划分，绝大多数的元素节点都可以包含子节点，只有少数的无内容标签，比如说 <code>br</code>、<code>hr</code>、<code>img</code>、<code>input</code>、<code>link</code> 以及 <code>meta</code> 才不会<strong>解析</strong>自己的子节点。</p>

<h4 id="分离的结构与样式">分离的结构与样式</h4>

<p>与 Android 在定义视图时，使用混合的结构与样式不同，Web 前端在视图层中，采用 HTML 与 CSS 分离，即结构与样式分离的方式进行设计；虽然在 HTML 中，我们也可以使用 <code>style</code> 将 CSS 代码写在视图层的结构中，不过在一般情况下，我们并不会这么做。</p>

<pre><code class="language-html">&lt;body style="background-color:powderblue;"&gt;
&lt;/body&gt;
</code></pre>

<h3 id="结构与样式">结构与样式</h3>

<p>在这一章节中，我们会对结构与样式组织方式之间的优劣进行简单的讨论。</p>

<p>Android 和 Web 前端使用不同的方式对视图层的结构和样式进行组织，前者使用混合的方式，后者使用分离的结构和样式。</p>

<p>相比于分离的组织方式，混合的组织方式有以下的几个优点：</p>

<ul>
  <li>不需要实现元素选择器，降低视图层解析器实现的复杂性；</li>
  <li>元素的样式是内联的，对于元素的样式的定义一目了然，不需要考虑样式的继承等复杂特性；</li>
</ul>

<p>分离的组织方式却正相反：</p>

<ul>
  <li>元素选择器的实现，增加了 CSS 样式代码的复用性，不需要多次定义相同的样式；</li>
  <li>将 CSS 代码从结构中抽离能够增强 HTML 的可读性，可以非常清晰、直观的了解 HTML 的层级结构；</li>
</ul>

<p>对于结构与样式，不同的组织方式能够带来不同的收益，这也是在设计视图层时需要考虑的事情，我们没有办法在使用一种组织方式时获得两种方式的优点，只能尽可能权衡利弊，选择最合适的方法。</p>

<h3 id="后端的视图层">后端的视图层</h3>

<p>这一章节将会研究一下后端视图层的设计，不过在真正开始分析其视图层设计之前，我们需要考虑一个问题，后端的视图层到底是什么？它有客户端或者 Web 前端中的<strong>用于展示内容</strong>视图层么？</p>

<p>这其实是一个比较难以回答的问题，不过严格意义上的后端是没有用于展示内容的视图层的，也就是为客户端提供 API 接口的后端，它们的视图层，其实就是用于返回 JSON 的模板。</p>

<pre><code class="language-ruby">json.extract! user, :id, :mobile, :nickname, :gender, :created_at, :updated_at
json.url user_url user, format: :json
</code></pre>

<p>在 Ruby on Rails 中一般都是类似于上面的 jbuilder 代码。拥有视图层的后端应用大多都是使用了模板引擎技术，直接为 HTTP 请求返回渲染之后的 HTML 和 CSS 等前端代码。</p>

<p>总而言是，使用了模板引擎的后端应用其实是混合了 Web 前端和后端，整个服务的视图层其实就是 Web 前端的代码；而现在的大多数 Web 应用，由于遵循了前后端分离的设计，两者之间的通信都使用约定好的 API 接口，所以后端的视图层其实就是单纯的用于渲染 JSON 的代码，比如 Rails 中的 jbuilder。</p>

<h2 id="理想中的视图层">理想中的视图层</h2>

<p>iOS 中理想的视图层需要解决两个最关键的问题：</p>

<ol>
  <li>细分 <code>UIView</code> 的职责，将其分为视图和容器两类，前者负责展示内容，后者负责对子视图进行布局；</li>
  <li>去除整个视图层对于 <code>frame</code> 属性的依赖，不对外提供 <code>frame</code> 接口，每个视图只能知道自己的大小；</li>
</ol>

<p>解决上述两个问题的办法就是封装原有的 <code>UIView</code> 类，使用组合模式为外界提供合适的接口。</p>

<p><img src="https://img.nju520.me/Node-Delegate-UIView.jpg-1000width" alt="Node-Delegate-UIVie" /></p>

<h3 id="细分-uiview-的职责">细分 UIView 的职责</h3>

<p><code>Node</code> 会作为 <code>UIView</code> 的代理，同时也作为整个视图层新的根类，它将屏蔽掉外界与 <code>UIView</code> 层级操作的有关方法，比如说：<code>-addSubview:</code> 等，同时，它也会屏蔽掉 <code>frame</code> 属性，这样每一个 <code>Node</code> 类的实例就只能设置自己的大小了。</p>

<pre><code class="language-swift">public class Node: Buildable {
    public typealias Element = Node
    public let view: UIView = UIView()

    @discardableResult
    public func size(_ size: CGSize) -&gt; Element {
        view.size = size
        return self
    }    
}
</code></pre>

<p>上面的代码简单说明了这一设计的实现原理，我们可以理解为 <code>Node</code> 作为 <code>UIView</code> 的透明代理，它不提供任何与视图层级相关的方法以及 <code>frame</code> 属性。</p>

<p><img src="https://img.nju520.me/Node-Delegate-Filter.jpg-1000width" alt="Node-Delegate-Filte" /></p>

<h3 id="容器的实现">容器的实现</h3>

<p>除了添加一个用于展示内容的 <code>Node</code> 类，我们还需要一个 <code>Container</code> 的概念，提供为管理子视图的 API 和方法，在这里，我们添加了一个空的 <code>Container</code> 协议：</p>

<pre><code class="language-swift">public protocol Container { }
</code></pre>

<p>利用这个协议，我们构建一个 iOS 中最简单的容器 <code>AbsoluteContainer</code>，内部使用 <code>frame</code> 对子视图进行布局，它应该为外界提供添加子视图的接口，在这里就是 <code>build(closure:)</code> 方法：</p>

<pre><code class="language-swift">public class AbsoluteContainer: Node, Container {
    typealias Element = AbsoluteContainer
    @discardableResult
    public func build(closure: () -&gt; Node) -&gt; Relation&lt;AbsoluteContainer&gt; {
        let node = closure()
        view.addSubview(node.view)
        return Relation&lt;AbsoluteContainer&gt;(container: self, node: node)
    }
}
</code></pre>

<p>该方法会在调用后返回一个 <code>Relation</code> 对象，这主要是因为在这种设计下的 <code>origin</code> 或者 <code>center</code> 等属性不再是 <code>Node</code> 的一个接口，它应该是 <code>Node</code> 节点出现在 <code>AbsoluteContainer</code> 时的产物，也就是说，只有在这两者同时出现时，才可以使用这些属性更新 <code>Node</code> 节点的位置：</p>

<pre><code class="language-swift">public class Relation&lt;Container&gt; {
    public let container: Container
    public let node: Node

    public init(container: Container, node: Node) {
        self.container = container
        self.node = node
    }
}

public extension Relation where Container == AbsoluteContainer {
    @discardableResult
    public func origin(_ origin: CGPoint) -&gt; Relation {
        node.view.origin = origin
        return self
    }
}
</code></pre>

<p>这样就完成了对于 <code>UIView</code> 中视图层级和位置功能的剥离，同时使用透明代理以及 <code>Relation</code> 为 <code>Node</code> 提供其他用于设置视图位置的接口。</p>

<blockquote>
  <p>这一章节中的代码都来自于 <a href="https://github.com/nju520/Mineral">Mineral</a>，如果对代码有兴趣的读者，可以下载自行查看。</p>
</blockquote>

<h2 id="总结">总结</h2>

<p>Cocoa Touch 中的 UIKit 对视图层的设计在一开始确实是没有问题的，主要原因是在 iOS 早期的布局方式并不复杂，只有单一的 <code>frame</code> 布局，而这种方式也恰好能够满足整个平台对于 iOS 应用开发的需要，但是随着屏幕尺寸的增多，苹果逐渐引入的其它布局方式与原有的体系发生了一些冲突，导致在开发时可能遇到奇怪的问题，而这也是本文想要解决的，将原有属于 <code>UIView</code> 的职责抽离出来，提供更合理的抽象。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="http://nju520.me/layout-performance.html">从 Auto Layout 的布局算法谈性能</a></li>
  <li><a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853-CH7-SW1">Understanding Auto Layout</a></li>
  <li><a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Size-ClassSpecificLayout.html">Size-Class-Specific Layout</a></li>
  <li><a href="https://developer.apple.com/reference/uikit/uiview/1622572-translatesautoresizingmaskintoco">translatesAutoresizingMaskIntoConstraints</a></li>
</ul>

  ]]></description>
</item>

<item>
  <title>谈谈 MVX 中的 Model</title>
  <link>//mvx-model</link>
  <author>nju520</author>
  <pubDate>2017-06-23T00:34:44+08:00</pubDate>
  <guid>//mvx-model</guid>
  <description><![CDATA[
  <ul>
  <li><a href="http://nju520.me/mvx-model.html">谈谈 MVX 中的 Model</a></li>
  <li><a href="http://nju520.me/mvx-view.html">谈谈 MVX 中的 View</a></li>
  <li><a href="http://nju520.me/mvx-controller.html">谈谈 MVX 中的 Controller</a></li>
  <li><a href="http://nju520.me/mvx.html">浅谈 MVC、MVP 和 MVVM 架构模式</a></li>
</ul>

<blockquote>
  <p>Follow GitHub: <a href="https://github.com/nju520">nju520</a></p>
</blockquote>

<h2 id="常见的-model-层">常见的 Model 层</h2>

<p>在大多数 iOS 的项目中，Model 层只是一个单纯的数据结构，你可以看到的绝大部分模型都是这样的：</p>

<pre><code class="language-swift">struct User {
    enum Gender: String {
        case male = "male"
        case female = "female"
    }
    let name: String
    let email: String
    let age: Int
    let gender: Gender
}
</code></pre>

<p>模型起到了定义一堆『坑』的作用，只是一个简单的模板，并没有参与到实际的业务逻辑，只是在模型层进行了一层<strong>抽象</strong>，将服务端发回的 JSON 或者说 <code>Dictionary</code> 对象中的字段一一取出并装填到预先定义好的模型中。</p>

<p><img src="https://img.nju520.me/JSON-to-Model.jpg-1000width" alt="JSON-to-Model" /></p>

<p>我们可以将这种模型层中提供的对象理解为『即开即用』的 <code>Dictionary</code> 实例；在使用时，可以直接从模型中取出属性，省去了从 <code>Dictionary</code> 中抽出属性以及验证是否合法的过程。</p>

<pre><code class="language-swift">let user = User...

nameLabel.text = user.name
emailLabel.text = user.email
ageLabel.text = "\(user.age)"
genderLabel.text = user.gender.rawValue
</code></pre>

<h3 id="json---model">JSON -&gt; Model</h3>

<p>使用 Swift 将 <code>Dictionary</code> 转换成模型，在笔者看来其实是一件比较麻烦的事情，主要原因是 Swift 作为一个号称类型安全的语言，有着使用体验非常差的 Optional 特性，从 <code>Dictionary</code> 中取出的值都是不一定存在的，所以如果需要纯手写这个过程其实还是比较麻烦的。</p>

<pre><code class="language-swift">extension User {
    init(json: [String: Any]) {
        let name = json["name"] as! String
        let email = json["email"] as! String
        let age = json["age"] as! Int
        let gender = Gender(rawValue: json["gender"] as! String)!
        self.init(name: name, email: email, age: age, gender: gender)
    }
}
</code></pre>

<p>这里为 <code>User</code> 模型创建了一个 extension 并写了一个简单的模型转换的初始化方法，当我们从 JSON 对象中取值时，得到的都是 Optional 对象；而在大多数情况下，我们都没有办法直接对 Optional 对象进行操作，这就非常麻烦了。</p>

<h4 id="麻烦的-optional">麻烦的 Optional</h4>

<p>在 Swift 中遇到无法立即使用的 Optional 对象时，我们可以会使用 <code>!</code> 默认将字典中取出的值当作非 Optional 处理，但是如果服务端发回的数据为空，这里就会直接崩溃；当然，也可使用更加安全的 <code>if let</code> 对 Optional 对象进行解包（unwrap）。</p>

<pre><code class="language-swift">extension User {
    init?(json: [String: Any]) {
        if let name = json["name"] as? String,
            let email = json["email"] as? String,
            let age = json["age"] as? Int,
            let genderString = json["gender"] as? String,
            let gender = Gender(rawValue: genderString) {
            self.init(name: name, email: email, age: age, gender: gender)
        }
        return nil
    }
}
</code></pre>

<p>上面的代码看起来非常的丑陋，而正是因为上面的情况在 Swift 中非常常见，所以社区在 Swift 2.0 中引入了 <code>guard</code> 关键字来优化代码的结构。</p>

<pre><code class="language-swift">extension User {
    init?(json: [String: Any]) {
        guard let name = json["name"] as? String,
            let email = json["email"] as? String,
            let age = json["age"] as? Int,
            let genderString = json["gender"] as? String,
            let gender = Gender(rawValue: genderString) else {
                return nil
        }
        self.init(name: name, email: email, age: age, gender: gender)
    }
}
</code></pre>

<p>不过，上面的代码在笔者看来，并没有什么本质的区别，不过使用 <code>guard</code> 对错误的情况进行提前返回确实是一个非常好的编程习惯。</p>

<h4 id="不关心空值的-oc">不关心空值的 OC</h4>

<p>为什么 Objective-C 中没有这种问题呢？主要原因是在 OC 中所有的对象其实都是 Optional 的，我们也并不在乎对象是否为空，因为在 OC 中<strong>向 nil 对象发送消息并不会造成崩溃，Objective-C 运行时仍然会返回 nil 对象</strong>。</p>

<blockquote>
  <p>这虽然在一些情况下会造成一些问题，比如，当 <code>nil</code> 导致程序发生崩溃时，比较难找到程序中 <code>nil</code> 出现的原始位置，但是却保证了程序的灵活性，笔者更倾向于 Objective-C 中的做法，不过这也就见仁见智了。</p>
</blockquote>

<p>OC 作为动态语言，这种设计思路其实还是非常优秀的，它避免了大量由于对象不存在导致无法完成方法调用造成的崩溃；同时，作为开发者，我们往往都不需要考虑 <code>nil</code> 的存在，所以使用 OC 时写出的模型转换的代码都相对好看很多。</p>

<pre><code class="language-objectivec">// User.h
typedef NS_ENUM(NSUInteger, Gender) {
    Male = 0,
    Female = 1,
};

@interface User: NSObject

@property (nonatomic, strong) NSString *email;
@property (nonatomic, strong) NSString *name;
@property (nonatomic, assign) NSUInteger age;
@property (nonatomic, assign) Gender gender;

@end

// User.m
@implementation User

- (instancetype)initWithJSON:(NSDictionary *)json {
    if (self = [super init]) {
        self.email = json[@"email"];
        self.name = json[@"name"];
        self.age = [json[@"age"] integerValue];
        self.gender = [json[@"gender"] integerValue];
    }
    return self;
}

@end
</code></pre>

<p>当然，在 OC 中也有很多优秀的 JSON 转模型的框架，如果我们使用 YYModel 这种开源框架，其实只需要写一个 <code>User</code> 类的定义就可以获得 <code>-yy_modelWithJSON:</code> 等方法来初始化 <code>User</code> 对象：</p>

<pre><code class="language-objectivec">User *user = [User yy_modelWithJSON:json];
</code></pre>

<p>而这也是通过 Objective-C 强大的运行时特性做到的。</p>

<blockquote>
  <p>除了 YYModel，我们也可以使用 Mantle 等框架在 OC 中解决 JSON 到模型的转换的问题。</p>
</blockquote>

<h4 id="元编程能力">元编程能力</h4>

<p>从上面的代码，我们可以看出：Objective-C 和 Swift 对于相同功能的处理，却有较大差别的实现。这种情况的出现主要原因是语言的设计思路导致的；Swift 一直<em>鼓吹</em>自己有着较强的安全性，能够写出更加稳定可靠的应用程序，而安全性来自于 Swift 语言的设计哲学；由此看来静态类型、安全和动态类型、元编程能力（？）看起来是比较难以共存的。</p>

<blockquote>
  <p>其实很多静态编程语言，比如 C、C++ 和 Rust 都通过宏实现了比较强大的元编程能力，虽然 Swift 也通过模板在元编程支持上做了一些微小的努力，不过到目前来看（ 3.0 ）还是远远不够的。</p>
</blockquote>

<p><img src="https://img.nju520.me/Dynamic-Static.png-1000width" alt="Dynamic-Stati" /></p>

<p>OC 中对于 <code>nil</code> 的处理能够减少我们在编码时的工作量，不过也对工程师的代码质量提出了考验。我们需要思考 <code>nil</code> 的出现会不会带来崩溃，是否会导致行为的异常、增加应用崩溃的风险以及不确定性，而这也是 Swift 引入 Optional 这一概念来避免上述问题的初衷。</p>

<p>相比而言，笔者还是更喜欢强大的元编程能力，这样可以减少大量的重复工作并且提供更多的可能性，与提升工作效率相比，牺牲一些安全性还是可以接受的。</p>

<h3 id="网络服务-service-层">网络服务 Service 层</h3>

<p>现有的大多数应用都会将网路服务组织成单独的一层，所以有时候你会看到所谓的 MVCS 架构模式，它其实只是在 MVC 的基础上加上了一个服务层（Service），而在 iOS 中常见的 MVC 架构模式也都可以理解为 MVCS 的形式，当引入了 Service 层之后，整个数据的获取以及处理的流程是这样的：</p>

<p><img src="https://img.nju520.me/MVCS-Architecture.png-1000width" alt="MVCS-Architecture" /></p>

<ol>
  <li>大多数情况下服务的发起都是在 Controller 中进行的；</li>
  <li>然后会在 HTTP 请求的回调中交给模型层处理 JSON 数据；</li>
  <li>返回开箱即用的对象交还给 Controller 控制器；</li>
  <li>最后由 View 层展示服务端返回的数据；</li>
</ol>

<p>不过按理来说服务层并不属于模型层，为什么要在这里进行介绍呢？这是因为 <strong>Service 层其实与 Model 层之间的联系非常紧密</strong>；网络请求返回的结果决定了 Model 层该如何设计以及该有哪些功能模块，而 Service 层的设计是与后端的 API 接口的设计强关联的，这也是我们谈模型层的设计无法绕过的坑。</p>

<p>iOS 中的 Service 层大体上有两种常见的组织方式，其中一种是命令式的，另一种是声明式的。</p>

<h4 id="命令式">命令式</h4>

<p>命令式的 Service 层一般都会为每一个或者一组 API 写一个专门用于 HTTP 请求的 Manager 类，在这个类中，我们会在每一个静态方法中使用 AFNetworking 或者 Alamofire 等网络框架发出 HTTP 请求。</p>

<pre><code class="language-objectivec">import Foundation
import Alamofire

final class UserManager {
    static let baseURL = "http://localhost:3000"
    static let usersBaseURL = "\(baseURL)/users"

    static func allUsers(completion: @escaping ([User]) -&gt; ()) {
        let url = "\(usersBaseURL)"
        Alamofire.request(url).responseJSON { response in
            if let jsons = response.result.value as? [[String: Any]] {
                let users = User.users(jsons: jsons)
                completion(users)
            }
        }
    }

    static func user(id: Int, completion: @escaping (User) -&gt; ()) {
        let url = "\(usersBaseURL)/\(id)"
        Alamofire.request(url).responseJSON { response in
            if let json = response.result.value as? [String: Any],
                let user = User(json: json) {
                completion(user)
            }
        }
    }
}
</code></pre>

<p>在这个方法中，我们完成了网络请求、数据转换 JSON、JSON 转换到模型以及最终使用 <code>completion</code> 回调的过程，调用 Service 服务的 Controller 可以直接从回调中使用构建好的 Model 对象。</p>

<pre><code class="language-objectivec">UserManager.user(id: 1) { user in
    self.nameLabel.text = user.name
    self.emailLabel.text = user.email
    self.ageLabel.text = "\(user.age)"
    self.genderLabel.text = user.gender.rawValue
}
</code></pre>

<h4 id="声明式">声明式</h4>

<p>使用声明式的网络服务层与命令式的方法并没有本质的不同，它们最终都调用了底层的一些网络库的 API，这种网络服务层中的请求都是以配置的形式实现的，需要对原有的命令式的请求进行一层封装，也就是说所有的参数 <code>requestURL</code>、<code>method</code> 和 <code>parameters</code> 都应该以配置的形式声明在每一个 <code>Request</code> 类中。</p>

<p><img src="https://img.nju520.me/Abstract-Request.jpg-1000width" alt="Abstract-Request" /></p>

<p>如果是在 Objective-C 中，一般会定义一个抽象的基类，并让所有的 Request 都继承它；但是在 Swift 中，我们可以使用协议以及协议扩展的方式实现这一功能。</p>

<pre><code class="language-swift">protocol AbstractRequest {
    var requestURL: String { get }
    var method: HTTPMethod { get }
    var parameters: Parameters? { get }
}

extension AbstractRequest {
    func start(completion: @escaping (Any) -&gt; Void) {
        Alamofire.request(requestURL, method: self.method).responseJSON { response in
            if let json = response.result.value {
                completion(json)
            }
        }
    }
}
</code></pre>

<p>在 <code>AbstractRequest</code> 协议中，我们定义了发出一个请求所需要的全部参数，并在协议扩展中实现了 <code>start(completion:)</code> 方法，这样实现该协议的类都可以直接调用 <code>start(completion:)</code> 发出网络请求。</p>

<pre><code class="language-swift">final class AllUsersRequest: AbstractRequest {
    let requestURL = "http://localhost:3000/users"
    let method = HTTPMethod.get
    let parameters: Parameters? = nil
}

final class FindUserRequest: AbstractRequest {
    let requestURL: String
    let method = HTTPMethod.get
    let parameters: Parameters? = nil

    init(id: Int) {
        self.requestURL = "http://localhost:3000/users/\(id)"
    }
}
</code></pre>

<p>我们在这里写了两个简单的 <code>Request</code> 类 <code>AllUsersRequest</code> 和 <code>FindUserRequest</code>，它们两个一个负责获取所有的 <code>User</code> 对象，一个负责从服务端获取指定的 <code>User</code>；在使用上面的声明式 Service 层时也与命令式有一些不同：</p>

<pre><code class="language-swift">FindUserRequest(id: 1).start { json in
    if let json = json as? [String: Any],
        let user = User(json: json) {
        print(user)
    }
}
</code></pre>

<p>因为在 Swift 中，我们没法将 JSON 在 Service 层转换成模型对象，所以我们不得不在 <code>FindUserRequest</code> 的回调中进行类型以及 JSON 转模型等过程；又因为 HTTP 请求可能依赖其他的参数，所以在使用这种形式请求资源时，我们需要在初始化方法传入参数。</p>

<h4 id="命令式-vs-声明式">命令式 vs 声明式</h4>

<p>现有的 iOS 开发中的网络服务层一般都是使用这两种组织方式，我们一般会按照<strong>资源</strong>或者<strong>功能</strong>来划分命令式中的 <code>Manager</code> 类，而声明式的 <code>Request</code> 类与实际请求是一对一的关系。</p>

<p><img src="https://img.nju520.me/Manager-And-Request.jpg-1000width" alt="Manager-And-Request" /></p>

<p>这两种网络层的组织方法在笔者看来没有高下之分，无论是 <code>Manager</code> 还是 <code>Request</code> 的方式，尤其是后者由于一个类只对应一个 API 请求，在整个 iOS 项目变得异常复杂时，就会导致<strong>网络层类的数量剧增</strong>。</p>

<p>这个问题并不是不可以接受的，在大多数项目中的网络请求就是这么做的，虽然在查找实际的请求类时有一些麻烦，不过只要遵循一定的<strong>命名规范</strong>还是可以解决的。</p>

<h3 id="小结">小结</h3>

<p>现有的 MVC 下的 Model 层，其实只起到了对数据结构定义的作用，它将服务端返回的 JSON 数据，以更方便使用的方式包装了一下，这样呈现给上层的就是一些即拆即用的『字典』。</p>

<p><img src="https://img.nju520.me/Model-And-Dictioanry.jpg-1000width" alt="Model-And-Dictioanry" /></p>

<p>单独的 Model 层并不能返回什么关键的作用，它只有与网络服务层 Service 结合在一起的时候才能发挥更重要的能力。</p>

<p><img src="https://img.nju520.me/Service-And-API.jpg-1000width" alt="Service-And-API" /></p>

<p>而网络服务 Service 层是对 HTTP 请求的封装，其实现形式有两种，一种是命令式的，另一种是声明式的，这两种实现的方法并没有绝对的优劣，遵循合适的形式设计或者重构现有的架构，随着应用的开发与迭代，为上层提供相同的接口，保持一致性才是设计 Service 层最重要的事情。</p>

<h2 id="服务端的-model-层">服务端的 Model 层</h2>

<p>虽然文章是对客户端中 Model 层进行分析和介绍，但是在客户端大规模使用 MVC 架构模式之前，服务端对于 MVC 的使用早已有多年的历史，而移动端以及 Web 前端对于架构的设计是近年来才逐渐被重视。</p>

<p>因为客户端的应用变得越来越复杂，动辄上百万行代码的巨型应用不断出现，以前流水线式的开发已经没有办法解决现在的开发、维护工作，所以合理的架构设计成为客户端应用必须要重视的事情。</p>

<p>这一节会以 Ruby on Rails 中 Model 层的设计为例，分析在经典的 MVC 框架中的 Model 层是如何与其他模块进行交互的，同时它又担任了什么样的职责。</p>

<h3 id="model-层的职责">Model 层的职责</h3>

<p>Rails 中的 Model 层主要承担着以下两大职责：</p>

<ol>
  <li>使用数据库存储并管理 Web 应用的数据；</li>
  <li>包含 Web 应用<strong>所有</strong>的业务逻辑；</li>
</ol>

<p>除了上述两大职责之外，Model 层还会存储应用的状态，同时，由于它对用户界面一无所知，所以它不依赖于任何视图的状态，这也使得 Model 层的代码可以复用。</p>

<p>Model 层的两大职责决定了它在整个 MVC 框架的位置：</p>

<p><img src="https://img.nju520.me/Server-MVC.jpg-1000width" alt="Server-MV" /></p>

<p>因为 Model 是对数据库中表的映射，所以当 Controller 向 Model 层请求数据时，它会从数据库中获取相应的数据，然后对数据进行加工最后返回给 Controller 层。</p>

<h4 id="数据库">数据库</h4>

<p>Model 层作为数据库中表的映射，它就需要实现两部分功能：</p>

<ol>
  <li>使用合理的方式对数据库进行迁移和更新；</li>
  <li>具有数据库的绝大部分功能，包括最基础的增删改查；</li>
</ol>

<p>在这里我们以 Rails 的 ActiveRecord 为例，简单介绍这两大功能是如何工作的。</p>

<p>ActiveRecord 为数据库的迁移和更新提供了一种名为 Migration 的机制，它可以被理解为一种 DSL，对数据库中的表的字段、类型以及约束进行描述：</p>

<pre><code class="language-ruby">class CreateProducts &lt; ActiveRecord::Migration[5.0]
  def change
    create_table :products do |t|
      t.string :name
      t.text :description
    end
  end
end
</code></pre>

<p>上面的 Ruby 代码创建了一个名为 <code>Products</code> 表，其中包含三个字段 <code>name</code>、<code>description</code> 以及一个默认的主键 <code>id</code>，然而在上述文件生成时，数据库中对应的表还不存在，当我们在命令行中执行 <code>rake db:migrate</code> 时，才会执行下面的 SQL 语句生成一张表：</p>

<pre><code class="language-sql">CREATE TABLE products (
    id int(11)   DEFAULT NULL auto_increment PRIMARY KEY
    name         VARCHAR(255),
    description  text,
);
</code></pre>

<p>同样地，如果我们想要更新数据库中的表的字段，也需要创建一个 Migration 文件，ActiveRecord 会为我们直接生成一个 SQL 语句并在数据库中执行。</p>

<p>ActiveRecord 对数据库的增删改查功能都做了相应的实现，在使用它进行数据库查询时，会生成一条 SQL 语句，在数据库中执行，并将执行的结果初始化成一个 Model 的实例并返回：</p>

<pre><code class="language-ruby">user = User.find(10)
# =&gt; SELECT * FROM users WHERE (users.id = 10) LIMIT 1
</code></pre>

<p>这就是 ActiveRecord 作为 Model 层的 ORM 框架解决两个关键问题的方式，其最终结果都是生成一条 SQL 语句并扔到数据库中执行。</p>

<p><img src="https://img.nju520.me/Relation-Between-Database-And-Model.jpg-1000width" alt="Relation-Between-Database-And-Mode" /></p>

<p>总而言之，Model 层为调用方屏蔽了所有与数据库相关的底层细节，使开发者不需要考虑如何手写 SQL 语句，只需要关心原生的代码，能够极大的降低出错的概率；但是，由于 SQL 语句都由 Model 层负责处理生成，它并不会根据业务帮助我们优化 SQL 查询语句，所以在遇到数据量较大时，其性能难免遇到各种问题，我们仍然需要手动优化查询的 SQL 语句。</p>

<h4 id="controller">Controller</h4>

<p>Model 与数据库之间的关系其实大多数都与数据的存储查询有关，而与 Controller 的关系就不是这样了，在 Rails 这个 MVC 框架中，提倡将业务逻辑放到 Model 层进行处理，也就是所谓的：</p>

<blockquote>
  <p>Fat Models, skinny controllers.</p>
</blockquote>

<p>这种说法形成的原因是，在绝大部分的 MVC 框架中，Controller 的作用都是将请求代理给 Model 去完成，它本身并不包含任何的业务逻辑，任何实际的查询、更新和删除操作都不应该在 Controller 层直接进行，而是要讲这些操作交给 Model 去完成。</p>

<pre><code class="language-ruby">class UsersController
  def show
    @user = User.find params[:id]
  end
end
</code></pre>

<p>这也就是为什么在后端应用中设计合理的 Controller 实际上并没有多少行代码，因为大多数业务逻辑相关的代码都会放到 Model 层。</p>

<p>Controller 的作用更像是胶水，将 Model 层中获取的模型传入 View 层中，渲染 HTML 或者返回 JSON 数据。</p>

<h3 id="小结-1">小结</h3>

<p>虽然服务端对于应用架构的设计已经有了很长时间的沉淀，但是由于客户端和服务端的职责截然不同，我们可以从服务端借鉴一些设计，但是并不应该照搬后端应用架构设计的思路。</p>

<p>服务端重数据，如果把整个 Web 应用看做一个黑箱，那么它的输入就是用户发送的数据，发送的形式无论是遵循 HTTP 协议也好还是其它协议也好，它们都是数据。</p>

<p><img src="https://img.nju520.me/web-black-box.jpg-1000width" alt="web-black-box" /></p>

<p>在服务端拿到数据后对其进行处理、加工以及存储，最后仍然以数据的形式返回给用户。</p>

<p>而客户端重展示，其输入就是用户的行为触发的事件，而输出是用户界面：</p>

<p><img src="https://img.nju520.me/client-black-box.jpg-1000width" alt="client-black-box" /></p>

<p>也就是说，用户的行为在客户端应用中得到响应，并更新了用户界面 GUI。总而言之：</p>

<blockquote>
  <p>客户端重展示，服务端重数据。</p>
</blockquote>

<p>这也是在设计客户端 Model 层时需要考虑的重要因素。</p>

<h2 id="理想中的-model-层">理想中的 Model 层</h2>

<p>在上面的两个小节中，分别介绍了 iOS 中现有的 Model 层以及服务端的 Model 层是如何使用的，并且介绍了它们的职责，在这一章节中，我们准备介绍笔者对于 Model 层的看法以及设计。</p>

<h3 id="明确职责">明确职责</h3>

<p>在具体讨论 Model 层设计之前，肯定要明确它的职责，它应该做什么、不应该做什么以及需要为外界提供什么样的接口和功能。</p>

<p>客户端重展示，无论是 Web、iOS 还是 Android，普通用户应该<strong>无法直接接触到服务端</strong>，如果一个软件系统的使用非常复杂，并且让<strong>普通</strong>用户<strong>直接</strong>接触到服务端的各种报错、提示，比如 404 等等，那么这个软件的设计可能就是不合理的。</p>

<blockquote>
  <p>这里加粗了普通和直接两个词，如果对这句话有疑问，请多读几遍 :)
专业的错误信息在软件工程师介入排错时非常有帮助，这种信息应当放置在不明显的角落。</p>
</blockquote>

<p><img src="https://img.nju520.me/404.gif" alt="404" /></p>

<p>作为软件工程师或者设计师，应该为用户提供更加合理的界面以及展示效果，比如，使用<em>您所浏览的网页不存在</em>来描述或者代替只有从事软件开发行业的人才了解的 404 或者 500 等错误是更为<strong>合适</strong>的方式。</p>

<p>上面的例子主要是为了说明客户端的最重要的职责，将<strong>数据合理地展示给用户</strong>，从这里我们可以领会到，Model 层虽然重要，但是却不是客户端最为复杂的地方，它只是起到了一个将服务端数据『映射』到客户端的作用，这个映射的过程就是获取数据的过程，也决定了 Model 层在 iOS 应用中的位置。</p>

<p><img src="https://img.nju520.me/Model-in-Client.jpg-1000width" alt="Model-in-Client" /></p>

<p>那么这样就产生了几个非常重要的问题和子问题：</p>

<ul>
  <li>数据如何获取？
    <ul>
      <li>在何时获取数据？</li>
      <li>如何存储服务端的数据？</li>
    </ul>
  </li>
  <li>数据如何展示？
    <ul>
      <li>应该为上层提供什么样的接口？</li>
    </ul>
  </li>
</ul>

<h3 id="model-层--service-层">Model 层 += Service 层？</h3>

<p>首先，我们来解决数据获取的问题，在 iOS 客户端常见的 Model 层中，数据的获取都不是由 Model 层负责的，而是由一个单独的 Service 层进行处理，然而经常这么组织网络请求并不是一个非常优雅的办法：</p>

<ol>
  <li>如果按照 API 组织 Service 层，那么网络请求越多，整个项目的 Service 层的类的数量就会越庞大；</li>
  <li>如果按照资源组织 Service 层，那么为什么不把 Service 层中的代码直接扔到 Model 层呢？</li>
</ol>

<p>既然 HTTP 请求都以获取相应的资源为目标，那么以 Model 层为中心来组织 Service 层并没有任何语义和理解上的问题。</p>

<p>如果服务端的 API 严格地按照 RESTful 的形式进行设计，那么就可以在客户端的 Model 层建立起一一对应的关系，拿最基本的几个 API 请求为例：</p>

<pre><code class="language-swift">extension RESTful {
    static func index(completion: @escaping ([Self]) -&gt; ())

    static func show(id: Int, completion: @escaping (Self?) -&gt; ())

    static func create(params: [String: Any], completion: @escaping (Self?) -&gt; ())

    static func update(id: Int, params: [String: Any], completion: @escaping (Self?) -&gt; ())

    static func delete(id: Int, completion: @escaping () -&gt; ())
}
</code></pre>

<p>我们在 Swift 中通过 Protocol Extension 的方式为所有遵循 <code>RESTful</code> 协议的模型添加基本的 CRUD 方法，那么 <code>RESTful</code> 协议本身又应该包含什么呢？</p>

<pre><code class="language-swift">protocol RESTful {
    init?(json: [String: Any])
    static var url: String { get }
}
</code></pre>

<p>RESTful 协议本身也十分简单，一是 JSON 转换方法，也就是如何将服务器返回的 JSON 数据转换成对应的模型，另一个是资源的 <code>url</code></p>

<blockquote>
  <p>对于这里的 <code>url</code>，我们可以遵循约定优于配置的原则，通过反射获取一个<strong>默认</strong>的资源链接，从而简化原有的 <code>RESTful</code> 协议，但是这里为了简化代码并没有使用这种方法。</p>
</blockquote>

<pre><code class="language-swift">extension User: RESTful {
    static var url: String {
        return "http://localhost:3000/users"
    }

    init?(json: [String: Any]) {
        guard let id = json["id"] as? Int,
            let name = json["name"] as? String,
            let email = json["email"] as? String,
            let age = json["age"] as? Int,
            let genderValue = json["gender"] as? Int,
            let gender = Gender(rawInt: genderValue) else {
                return nil
        }
        self.init(id: id, name: name, email: email, age: age, gender: gender)
    }
}
</code></pre>

<p>在 <code>User</code> 模型遵循上述协议之后，我们就可以简单的通过它的静态方法来对服务器上的资源进行一系列的操作。</p>

<pre><code class="language-swift">User.index { users in
    // users
}

User.create(params: ["name": "Stark", "email": "example@email.com", "gender": 0, "age": 100]) { user in
    // user
}
</code></pre>

<p>当然 RESTful 的 API 接口仍然需要服务端提供支持，不过以 Model 取代 Service 作为 HTTP 请求的发出者确实是可行的。</p>

<h4 id="问题">问题</h4>

<p>虽然上述的方法简化了 Service 层，但是在真正使用时确实会遇到较多的限制，比如，用户需要对另一用户进行关注或者取消关注操作，这样的 API 如果要遵循 RESTful 就需要使用以下的方式进行设计：</p>

<pre><code class="language-swift">POST   /api/users/1/follows
DELETE /api/users/1/follows
</code></pre>

<p>这种情况就会导致在当前的客户端的 Model 层没法建立合适的抽象，因为 <code>follows</code> 并不是一个真实存在的模型，它只代表两个用户之间的关系，所以在当前所设计的模型层中没有办法实现上述的功能，还需要引入 Service 层，来对服务端中的每一个 Controller 的 action 进行抽象，在这里就不展开讨论了。</p>

<p>对 Model 层网络服务的设计，与服务端的设计有着非常大的关联，如果能够对客户端和服务端之间的 API 进行严格规范，那么对于设计出简洁、优雅的网络层还是有巨大帮助的。</p>

<h3 id="缓存与持久存储">缓存与持久存储</h3>

<p>客户端的持久存储其实与服务端的存储天差地别，客户端中保存的各种数据更准确的说其实是<strong>缓存</strong>，既然是缓存，那么它在客户端应用中的地位并不是极其重要、非他不可的；正相反，很多客户端应用没有缓存也运行的非常好，它并不是一个必要的功能，只是能够提升用户体验而已。</p>

<p>虽然客户端的存储只是缓存，但是在目前的大型应用中，也确实需要这种缓存，有以下几个原因：</p>

<ul>
  <li>能够快速为用户提供可供浏览的内容；</li>
  <li>在网络情况较差或者无网络时，也能够为用户提供兜底数据；</li>
</ul>

<p>以上的好处其实都是从用户体验的角度说的，不过缓存确实能够提高应用的质量。</p>

<p>在 iOS 中，持久存储虽然不是一个必要的功能，但是苹果依然为我们提供了不是那么好用的 Core Data 框架，但这并不是这篇文章需要介绍和讨论的内容。</p>

<p>目前的绝大多数 Model 框架，其实提供的都只是<strong>硬编码</strong>的数据库操作能力，或者提供的 API 不够优雅，原因是虽然 Swift 语法比 Objective-C 更加简洁，但是缺少元编程能力是它的硬伤。</p>

<p>熟悉 ActiveRecord 的开发者应该都熟悉下面的使用方式：</p>

<pre><code class="language-ruby">User.find_by_name "hacker"
</code></pre>

<p>在 Swift 中通过现有的特性很难提供这种 API，所以很多情况下只能退而求其次，继承 <code>NSObject</code> 并且使用 <code>dynamic</code> 关键字记住 Objective-C 的特性实现一些功能：</p>

<pre><code class="language-objectivec">class User: Object {
    dynamic var name = ""
    dynamic var age = 0
}
</code></pre>

<p>这确实是一种解决办法，但是并不是特别的优雅，如果我们在编译器间获得模型信息，然后使用这些信息生成代码就可以解决这些问题了，这种方法同时也能够在 Xcode 编译器中添加代码提示。</p>

<h3 id="上层接口">上层接口</h3>

<p>Model 层为上层提供提供的接口其实就是自身的一系列属性，只是将服务器返回的 JSON 经过处理和类型转换，变成了即拆即用的数据。</p>

<p><img src="https://img.nju520.me/JSON-Model.jpg-1000width" alt="JSON-Mode" /></p>

<p>上层与 Model 层交互有两种方式，一是通过 Model 层调用 HTTP 请求，异步获取模型数据，另一种就是通过 Model 暴露出来的属性进行存取，而底层数据库会在 Model 属性更改时发出网络请求并且修改对应的字段。</p>

<h2 id="总结">总结</h2>

<p>虽然客户端的 Model 层与服务端的 Model 层有着相同的名字，但是客户端的 Model 层由于处理的是缓存，对本地的数据库中的表进行迁移、更改并不是一个必要的功能，在本地表字段进行大规模修改时，只需要删除全部表中的内容，并重新创建即可，只要不影响服务端的数据就不是太大的问题。</p>

<p>iOS 中的 Model 层不应该是一个单纯的数据结构，它应该起到发出 HTTP 请求、进行字段验证以及持久存储的职责，同时为上层提供网络请求的方法以及字段作为接口，为视图的展示提供数据源的作用。我们应该将更多的与 Model 层有关的业务逻辑移到 Model 中以控制 Controller 的复杂性。</p>


  ]]></description>
</item>

<item>
  <title>如何优雅地使用 KVO</title>
  <link>//kvocontroller</link>
  <author>nju520</author>
  <pubDate>2017-03-06T00:34:44+08:00</pubDate>
  <guid>//kvocontroller</guid>
  <description><![CDATA[
  <p>KVO 作为 iOS 中一种强大并且有效的机制，为 iOS 开发者们提供了很多的便利；我们可以使用 KVO 来检测对象属性的变化、快速做出响应，这能够为我们在开发强交互、响应式应用以及实现视图和模型的双向绑定时提供大量的帮助。</p>

<p>但是在大多数情况下，除非遇到不用 KVO 无法解决的问题，笔者都会尽量避免它的使用，这并不是因为 KVO 有性能问题或者使用场景不多，总重要的原因是 KVO 的使用是在是太 ** <strong>麻烦</strong>了。</p>

<p><img src="https://img.nju520.me/2017-03-06-trouble.jpg-1000width" alt="trouble" /></p>

<p>使用 KVO 时，既需要进行<strong>注册成为某个对象属性的观察者</strong>，还要在合适的时间点将自己<strong>移除</strong>，再加上需要<strong>覆写一个又臭又长的方法</strong>，并在方法里<strong>判断这次是不是自己要观测的属性发生了变化</strong>，每次想用 KVO 解决一些问题的时候，作者的第一反应就是头疼，这篇文章会为各位为 KVO 所苦的开发者提供一种更优雅的解决方案。</p>

<h2 id="使用-kvo">使用 KVO</h2>

<p>不过在介绍如何优雅地使用 KVO 之前，我们先来回忆一下，在通常情况下，我们是如何使用 KVO 进行键值观测的。</p>

<p>首先，我们有一个 <code>Fizz</code> 类，其中包含一个 <code>number</code> 属性，它在初始化时会自动被赋值为 <code>@0</code>：</p>

<pre><code class="language-objectivec">// Fizz.h
@interface Fizz : NSObject

@property (nonatomic, strong) NSNumber *number;

@end

// Fizz.m
@implementation Fizz

- (instancetype)init {
    if (self = [super init]) {
        _number = @0;
    }
    return self;
}

@end
</code></pre>

<p>我们想在 <code>Fizz</code> 对象中的 <code>number</code> 对象发生改变时获得通知得到<strong>新</strong>的和<strong>旧</strong>的值，这时我们就要祭出 <code>-addObserver:forKeyPath:options:context</code> 方法来监控 <code>number</code> 属性的变化：</p>

<pre><code class="language-objectivec">Fizz *fizz = [[Fizz alloc] init];
[fizz addObserver:self
       forKeyPath:@"number"
          options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld
          context:nil];
fizz.number = @2;
</code></pre>

<p>在将当前对象 <code>self </code>注册成为 <code>fizz</code> 的观察者之后，我们需要在当前对象中覆写 <code>-observeValueForKeyPath:ofObject:change:context:</code> 方法：</p>

<pre><code class="language-objectivec">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context {
    if ([keyPath isEqualToString:@"number"]) {
        NSLog(@"%@", change);
    }
}
</code></pre>

<p>在大多数情况下我们只需要对比 <code>keyPath</code> 的值，就可以知道我们到底监控的是哪个对象，但是在更复杂的业务场景下，使用 <code>context</code> 上下文以及其它辅助手段才能够帮助我们更加精准地确定被观测的对象。</p>

<p>但是当上述代码运行时，虽然可以成功打印出 <code>change</code> 字典，但是却会发生崩溃，你会在控制台中看到下面的内容：</p>

<pre><code class="language-objectivec">2017-02-26 23:44:19.666 KVOTest[15888:513229] {
    kind = 1;
    new = 2;
    old = 0;
}
2017-02-26 23:44:19.720 KVOTest[15888:513229] *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'An instance 0x60800001dd20 of class Fizz was deallocated while key value observers were still registered with it. Current observation info: &lt;NSKeyValueObservationInfo 0x60800003d320&gt; (
&lt;NSKeyValueObservance 0x608000057310: Observer: 0x7fa098f07590, Key path: number, Options: &lt;New: YES, Old: YES, Prior: NO&gt; Context: 0x0, Property: 0x608000057400&gt;
)'
</code></pre>

<p>这是因为 <code>fizz</code> 对象没有被其它对象引用，在脱离 <code>viewDidLoad</code> 作用于之后就被回收了，然而在 <code>-dealloc</code> 时，并没有移除观察者，所以会造成崩溃。</p>

<p>我们可以使用下面的代码来验证上面的结论是否正确：</p>

<pre><code class="language-objectivec">// Fizz.h
@interface Fizz : NSObject

@property (nonatomic, strong) NSNumber *number;
@property (nonatomic, weak) NSObject *observer;

@end

// Fizz.m
@implementation Fizz

- (instancetype)init {
    if (self = [super init]) {
        _number = @0;
    }
    return self;
}

- (void)dealloc {
    [self removeObserver:self.observer forKeyPath:@"number"];
}

@end
</code></pre>

<p>在 <code>Fizz</code> 类的接口中添加一个 <code>observer</code> 弱引用来持有对象的观察者，并在对象 <code>-dealloc</code> 时将它移除，重新运行这段代码，就不会发生崩溃了。</p>

<p><img src="https://img.nju520.me/2017-03-06-not-crash-with-remove-observer-when-dealloc.png-1000width" alt="not-crash-with-remove-observer-when-deallo" /></p>

<p>由于没有移除观察者导致崩溃使用 KVO 时经常会遇到的问题之一，解决办法其实有很多，我们在这里简单介绍一个，使用当前对象持有被观测的对象，并在当前对象 <code>-dealloc</code> 时，移除观察者：</p>

<pre><code class="language-objectivec">- (void)viewDidLoad {
    [super viewDidLoad];
    self.fizz = [[Fizz alloc] init];
    [self.fizz addObserver:self
                forKeyPath:@"number"
                   options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld
                   context:nil];
    self.fizz.number = @2;
}

- (void)dealloc {
    [self.fizz removeObserver:self forKeyPath:@"number"];
}
</code></pre>

<p>这也是我们经常使用来避免崩溃的办法，但是在笔者看来也是非常的不优雅，除了上述的崩溃问题，使用 KVO 的过程也非常的别扭和痛苦：</p>

<ol>
  <li>需要手动<strong>移除观察者</strong>，且移除观察者的<strong>时机必须合适</strong>；</li>
  <li>注册观察者的代码和事件发生处的代码上下文不同，<strong>传递上下文</strong>是通过 <code>void *</code> 指针；</li>
  <li>需要覆写 <code>-observeValueForKeyPath:ofObject:change:context:</code> 方法，比较麻烦；</li>
  <li>在复杂的业务逻辑中，准确判断被观察者相对比较麻烦，有多个被观测的对象和属性时，需要在方法中写大量的 <code>if</code> 进行判断；</li>
</ol>

<p>虽然上述几个问题并不影响 KVO 的使用，不过这也足够成为笔者尽量不使用 KVO 的理由了。</p>

<h2 id="优雅地使用-kvo">优雅地使用 KVO</h2>

<p>如何优雅地解决上一节提出的几个问题呢？我们在这里只需要使用 Facebook 开源的 <a href="https://github.com/facebook/KVOController">KVOController</a> 框架就可以优雅地解决这些问题了。</p>

<p>如果想要实现同样的业务需求，当使用 KVOController 解决上述问题时，只需要以下代码就可以达到与上一节中<strong>完全相同</strong>的效果：</p>

<pre><code class="language-objectivec">[self.KVOController observe:self.fizz
                    keyPath:@"number"
                    options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld
                      block:^(id  _Nullable observer, id  _Nonnull object, NSDictionary&lt;NSString    *,id&gt; * _Nonnull change) {
                          NSLog(@"%@", change);
                      }];
</code></pre>

<p>我们可以在任意对象上<strong>获得</strong> <code>KVOController</code> 对象，然后调用它的实例方法 <code>-observer:keyPath:options:block:</code> 就可以检测某个对象对应的属性了，该方法传入的参数还是非常容易理解的，在 block 中也可以获得所有与 KVO 有关的参数。</p>

<p>使用 KVOController 进行键值观测可以说完美地解决了在使用原生 KVO 时遇到的各种问题。</p>

<ol>
  <li>不需要手动移除观察者；</li>
  <li>实现 KVO 与事件发生处的代码上下文相同，不需要跨方法传参数；</li>
  <li>使用 block 来替代方法能够减少使用的复杂度，提升使用 KVO 的体验；</li>
  <li>每一个 <code>keyPath</code> 会对应一个属性，不需要在 block 中使用 <code>if</code> 判断 <code>keyPath</code>；</li>
</ol>

<h2 id="kvocontroller-的实现">KVOController 的实现</h2>

<p>KVOController 其实是对 Cocoa 中 KVO 的封装，它的实现其实也很简单，整个框架中只有两个实现文件，先来简要看一下 KVOController 如何为所有的 <code>NSObject</code> 对象都提供 <code>-KVOController</code> 属性的吧。</p>

<h3 id="分类和-kvocontroller-的初始化">分类和 KVOController 的初始化</h3>

<p>KVOController 不止为 Cocoa Touch 中所有的对象提供了 <code>-KVOController</code> 属性还提供了另一个 <code>KVOControllerNonRetaining</code> 属性，实现方法就是分类和 ObjC Runtime。</p>

<pre><code class="language-objectivec">@interface NSObject (FBKVOController)

@property (nonatomic, strong) FBKVOController *KVOController;
@property (nonatomic, strong) FBKVOController *KVOControllerNonRetaining;

@end
</code></pre>

<p>从名字可以看出 <code>KVOControllerNonRetaining</code> 在使用时并不会<strong>持有</strong>被观察的对象，与它相比 <code>KVOController</code> 就会持有该对象了。</p>

<p>对于 <code>KVOController</code> 和 <code>KVOControllerNonRetaining</code> 属性来说，其实现都非常简单，对运行时非常熟悉的读者都应该知道使用关联对象就可以轻松实现这一需求。</p>

<pre><code class="language-objectivec">- (FBKVOController *)KVOController {
  id controller = objc_getAssociatedObject(self, NSObjectKVOControllerKey);
  if (nil == controller) {
    controller = [FBKVOController controllerWithObserver:self];
    self.KVOController = controller;
  }
  return controller;
}

- (void)setKVOController:(FBKVOController *)KVOController {
  objc_setAssociatedObject(self, NSObjectKVOControllerKey, KVOController, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (FBKVOController *)KVOControllerNonRetaining {
  id controller = objc_getAssociatedObject(self, NSObjectKVOControllerNonRetainingKey);
  if (nil == controller) {
    controller = [[FBKVOController alloc] initWithObserver:self retainObserved:NO];
    self.KVOControllerNonRetaining = controller;
  }
  return controller;
}

- (void)setKVOControllerNonRetaining:(FBKVOController *)KVOControllerNonRetaining {
  objc_setAssociatedObject(self, NSObjectKVOControllerNonRetainingKey, KVOControllerNonRetaining, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
</code></pre>

<p>两者的 <code>setter</code> 方法都只是使用 <code>objc_setAssociatedObject</code> 按照键值简单地存一下，而 <code>getter</code> 中不同的其实也就是对于 <code>FBKVOController</code> 的初始化了。</p>

<p><img src="https://img.nju520.me/2017-03-06-easy.jpg-1000width" alt="easy" /></p>

<p>到这里这个整个 FBKVOController 框架中的两个实现文件中的一个就介绍完了，接下来要看一下其中的另一个文件中的类 <code>KVOController</code>。</p>

<h4 id="kvocontroller-的初始化">KVOController 的初始化</h4>

<p><code>KVOController</code> 是整个框架中提供 KVO 接口的类，作为 KVO 的管理者，其必须持有当前对象所有与 KVO 有关的信息，而在 <code>KVOController</code> 中，用于存储这个信息的数据结构就是 <code>NSMapTable</code>。</p>

<p><img src="https://img.nju520.me/2017-03-06-KVOController.png-1000width" alt="KVOControlle" /></p>

<p>为了使 <code>KVOController</code> 达到线程安全，它还必须持有一把 <code>pthread_mutex_t</code> 锁，用于在操作 <code>_objectInfosMap</code> 时使用。</p>

<p>再回到上一节提到的初始化问题，<code>NSObject</code> 的属性 <code>FBKVOController</code> 和 <code>KVOControllerNonRetaining</code> 的区别在于前者会持有观察者，使其引用计数加一。</p>

<pre><code class="language-objectivec">- (instancetype)initWithObserver:(nullable id)observer retainObserved:(BOOL)retainObserved {
  self = [super init];
  if (nil != self) {
    _observer = observer;
    NSPointerFunctionsOptions keyOptions = retainObserved ? NSPointerFunctionsStrongMemory|NSPointerFunctionsObjectPointerPersonality : NSPointerFunctionsWeakMemory|NSPointerFunctionsObjectPointerPersonality;
    _objectInfosMap = [[NSMapTable alloc] initWithKeyOptions:keyOptions valueOptions:NSPointerFunctionsStrongMemory|NSPointerFunctionsObjectPersonality capacity:0];
    pthread_mutex_init(&amp;_lock, NULL);
  }
  return self;
}
</code></pre>

<p>在初始化方法中使用各自的方法对 <code>KVOController</code> 对象持有的所有实例变量进行初始化，<code>KVOController</code> 和 <code>KVOControllerNonRetaining</code> 的区别就体现在生成的 <code>NSMapTable</code> 实例时传入的是 <code>NSPointerFunctionsStrongMemory</code> 还是 <code>NSPointerFunctionsWeakMemory</code> 选项。</p>

<h3 id="kvo-的过程">KVO 的过程</h3>

<p>使用 <code>KVOController</code> 实现键值观测时，大都会调用实例方法 <code>-observe:keyPath:options:block</code> 来注册成为某个对象的观察者，监控属性的变化：</p>

<pre><code class="language-objectivec">- (void)observe:(nullable id)object keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options block:(FBKVONotificationBlock)block {
  _FBKVOInfo *info = [[_FBKVOInfo alloc] initWithController:self keyPath:keyPath options:options block:block];

  [self _observe:object info:info];
}
</code></pre>

<h4 id="数据结构-_fbkvoinfo">数据结构 _FBKVOInfo</h4>

<p>这个方法中就涉及到另外一个私有的数据结构 <code>_FBKVOInfo</code>，这个类中包含着所有与 KVO 有关的信息：</p>

<p><img src="https://img.nju520.me/2017-03-06-_FBKVOInfo.png-1000width" alt="_FBKVOInfo" /></p>

<p><code>_FBKVOInfo</code> 在 <code>KVOController</code> 中充当的作用仅仅是一个数据结构，我们主要用它来存储整个 KVO 过程中所需要的全部信息，其内部没有任何值得一看的代码，需要注意的是，<code>_FBKVOInfo</code> 覆写了 <code>-isEqual:</code> 方法用于对象之间的判等以及方便 <code>NSMapTable</code> 的存储。</p>

<p>如果再有点别的什么特别作用的就是，其中的 <code>state</code> 表示当前的 KVO 状态，不过在本文中不会具体介绍。</p>

<pre><code class="language-objectivec">typedef NS_ENUM(uint8_t, _FBKVOInfoState) {
  _FBKVOInfoStateInitial = 0,
  _FBKVOInfoStateObserving,
  _FBKVOInfoStateNotObserving,
};
</code></pre>

<h4 id="observe-的过程">observe 的过程</h4>

<p>在使用 <code>-observer:keyPath:options:block:</code> 监听某一个对象属性的变化时，该过程的核心调用栈其实还是比较简单：</p>

<p><img src="https://img.nju520.me/2017-03-06-KVOController-Observe-Stack.png-1000width" alt="KVOController-Observe-Stack" /></p>

<p>我们从栈底开始简单分析一下整个封装 KVO 的过程，其中栈底的方法，也就是我们上面提到的 <code>-observer:keyPath:options:block:</code> 初始化了一个名为 <code>_FBKVOInfo</code> 的对象：</p>

<pre><code class="language-objectivec">- (void)observe:(nullable id)object keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options block:(FBKVONotificationBlock)block {
  _FBKVOInfo *info = [[_FBKVOInfo alloc] initWithController:self keyPath:keyPath options:options block:block];
  [self _observe:object info:info];
}
</code></pre>

<p>在创建了 <code>_FBKVOInfo</code> 之后执行了另一个私有方法 <code>-_observe:info:</code>：</p>

<pre><code class="language-objectivec">- (void)_observe:(id)object info:(_FBKVOInfo *)info {
  pthread_mutex_lock(&amp;_lock);
  NSMutableSet *infos = [_objectInfosMap objectForKey:object];

  _FBKVOInfo *existingInfo = [infos member:info];
  if (nil != existingInfo) {
    pthread_mutex_unlock(&amp;_lock);
    return;
  }

  if (nil == infos) {
    infos = [NSMutableSet set];
    [_objectInfosMap setObject:infos forKey:object];
  }
  [infos addObject:info];
  pthread_mutex_unlock(&amp;_lock);

  [[_FBKVOSharedController sharedController] observe:object info:info];
}
</code></pre>

<p>这个私有方法通过自身持有的 <code>_objectInfosMap</code> 来判断当前对象、属性以及各种上下文是否已经注册在表中存在了，在这个 <code>_objectInfosMap</code> 中保存着对象以及与对象有关的 <code>_FBKVOInfo</code> 集合：</p>

<p><img src="https://img.nju520.me/2017-03-06-objectInfosMap.png-1000width" alt="objectInfosMap" /></p>

<p>在操作了当前 <code>KVOController</code> 持有的 <code>_objectInfosMap</code> 之后，才会执行私有的 <code>_FBKVOSharedController</code> 类的实例方法 <code>-observe:info:</code>：</p>

<pre><code class="language-objectivec">- (void)observe:(id)object info:(nullable _FBKVOInfo *)info {
  pthread_mutex_lock(&amp;_mutex);
  [_infos addObject:info];
  pthread_mutex_unlock(&amp;_mutex);

  [object addObserver:self forKeyPath:info-&gt;_keyPath options:info-&gt;_options context:(void *)info];

  if (info-&gt;_state == _FBKVOInfoStateInitial) {
    info-&gt;_state = _FBKVOInfoStateObserving;
  } else if (info-&gt;_state == _FBKVOInfoStateNotObserving) {
    [object removeObserver:self forKeyPath:info-&gt;_keyPath context:(void *)info];
  }
}
</code></pre>

<p><code>_FBKVOSharedController</code> 才是最终调用 Cocoa 中的 <code>-observe:forKeyPath:options:context:</code> 方法开始对属性的监听的地方；同时，在整个应用运行时，只会存在一个 <code>_FBKVOSharedController</code> 实例：</p>

<pre><code class="language-objectivec">+ (instancetype)sharedController {
  static _FBKVOSharedController *_controller = nil;
  static dispatch_once_t onceToken;
  dispatch_once(&amp;onceToken, ^{
    _controller = [[_FBKVOSharedController alloc] init];
  });
  return _controller;
}
</code></pre>

<p>这个唯一的 <code>_FBKVOSharedController</code> 实例会在 KVO 的回调方法中将事件分发给 KVO 的观察者。</p>

<pre><code class="language-objectivec">- (void)observeValueForKeyPath:(nullable NSString *)keyPath
                      ofObject:(nullable id)object
                        change:(nullable NSDictionary&lt;NSString *, id&gt; *)change
                       context:(nullable void *)context {
    _FBKVOInfo *info;
    pthread_mutex_lock(&amp;_mutex);
    info = [_infos member:(__bridge id)context];
    pthread_mutex_unlock(&amp;_mutex);

    FBKVOController *controller = info-&gt;_controller;
    id observer = controller.observer;

    if (info-&gt;_block) {
        NSDictionary&lt;NSString *, id&gt; *changeWithKeyPath = change;
        if (keyPath) {
            NSMutableDictionary&lt;NSString *, id&gt; *mChange = [NSMutableDictionary dictionaryWithObject:keyPath forKey:FBKVONotificationKeyPathKey];
            [mChange addEntriesFromDictionary:change];
            changeWithKeyPath = [mChange copy];
        }
        info-&gt;_block(observer, object, changeWithKeyPath);
    } else if (info-&gt;_action) {
        [observer performSelector:info-&gt;_action withObject:change withObject:object];
    } else {
        [observer observeValueForKeyPath:keyPath ofObject:object change:change context:info-&gt;_context];
    }
}
</code></pre>

<p>在这个 <code>-observeValueForKeyPath:ofObject:change:context:</code> 回调方法中，<code>_FBKVOSharedController</code> 会根据 KVO 的信息 <code>_KVOInfo</code> 选择不同的方式分发事件，如果观察者没有传入 block 或者选择子，就会调用观察者 KVO 回调方法。</p>

<p><img src="https://img.nju520.me/2017-03-06-KVOSharedController.png-1000width" alt="KVOSharedControlle" /></p>

<p>上图就是在使用 KVOController 时，如果一个 KVO 事件触发之后，整个框架是如何对这个事件进行处理以及回调的。</p>

<h3 id="如何-removeobserver">如何 removeObserver</h3>

<p>在使用 KVOController 时，我们并不需要手动去处理 KVO 观察者的移除，因为所有的 KVO 事件都由私有的 <code>_KVOSharedController</code> 来处理；</p>

<p><img src="https://img.nju520.me/2017-03-06-KVOController-Unobserve-Stack.png-1000width" alt="KVOController-Unobserve-Stack" /></p>

<p>当每一个 <code>KVOController</code> 对象被释放时，都会将它自己持有的所有 KVO 的观察者交由 <code>_KVOSharedController</code> 的 <code>-unobserve:infos:</code> 方法处理：</p>

<pre><code class="language-objectivec">- (void)unobserve:(id)object infos:(nullable NSSet&lt;_FBKVOInfo *&gt; *)infos {
  pthread_mutex_lock(&amp;_mutex);
  for (_FBKVOInfo *info in infos) {
    [_infos removeObject:info];
  }
  pthread_mutex_unlock(&amp;_mutex);

  for (_FBKVOInfo *info in infos) {
    if (info-&gt;_state == _FBKVOInfoStateObserving) {
      [object removeObserver:self forKeyPath:info-&gt;_keyPath context:(void *)info];
    }
    info-&gt;_state = _FBKVOInfoStateNotObserving;
  }
}
</code></pre>

<p>该方法会遍历所有传入的 <code>_FBKVOInfo</code>，从其中取出 <code>keyPath</code> 并将 <code>_KVOSharedController</code> 移除观察者。</p>

<p>除了在 <code>KVOController</code> 析构时会自动移除观察者，我们也可以通过它的实例方法 <code>-unobserve:keyPath:</code> 操作达到相同的效果；不过在调用这个方法时，我们能够得到一个不同的调用栈：</p>

<p><img src="https://img.nju520.me/2017-03-06-KVOController-Unobserve-Object-Stack.png-1000width" alt="KVOController-Unobserve-Object-Stack" /></p>

<p>功能的实现过程其实都是类似的，都是通过 <code>-removeObserver:forKeyPath:context:</code> 方法移除观察者：</p>

<pre><code class="language-objectivec">- (void)unobserve:(id)object info:(nullable _FBKVOInfo *)info {
  pthread_mutex_lock(&amp;_mutex);
  [_infos removeObject:info];
  pthread_mutex_unlock(&amp;_mutex);

  if (info-&gt;_state == _FBKVOInfoStateObserving) {
    [object removeObserver:self forKeyPath:info-&gt;_keyPath context:(void *)info];
  }
  info-&gt;_state = _FBKVOInfoStateNotObserving;
}
</code></pre>

<p>不过由于这个方法的参数并不是一个数组，所以并不需要使用 <code>for</code> 循环，而是只需要将该 <code>_FBKVOInfo</code> 对应的 KVO 事件移除就可以了。</p>

<h2 id="总结">总结</h2>

<p>KVOController 对于 Cocoa 中 KVO 的封装非常的简洁和优秀，我们只需要调用一个方法就可以完成一个对象的键值观测，同时不需要处理移除观察者等问题，能够降低我们出错的可能性。</p>

<p>在笔者看来 KVOController 中唯一不是很优雅的地方就是，需要写出 <code>object.KVOController</code> 才可以执行 KVO，如果能将 <code>KVOController</code> 换成更短的形式可能看起来更舒服一些：</p>

<pre><code class="language-objectivec">[self.kvo observer:keyPath:options:block:];
</code></pre>

<p>不过这并不是一个比较大的问题，同时也只是笔者自己的看法，况且不影响 KVOController 的使用，所以各位读者也无须太过介意。</p>

  ]]></description>
</item>

<item>
  <title>从代理到 RACSignal</title>
  <link>//racdelegateproxy</link>
  <author>nju520</author>
  <pubDate>2017-02-25T22:55:52+08:00</pubDate>
  <guid>//racdelegateproxy</guid>
  <description><![CDATA[
  <p>ReactiveCocoa 将 Cocoa 中的 Target-Action、KVO、通知中心以及代理等设计模式都桥接到了 RAC 的世界中，我们在随后的几篇文章中会介绍 RAC 如何做到了上面的这些事情，而本篇文章会介绍 ReactiveCocoa 是如何把<strong>代理</strong>转换为信号的。</p>

<p><img src="https://img.nju520.me/2017-02-25-Delegate-To-RACSignal.png-1000width" alt="Delegate-To-RACSigna" /></p>

<h2 id="racdelegateproxy">RACDelegateProxy</h2>

<p>从代理转换成信号所需要的核心类就是 <code>RACDelegateProxy</code>，这是一个设计的非常巧妙的类；虽然在类的头文件中，它被标记为私有类，但是我们仍然可以使用 <code>-initWithProtocol:</code> 方法直接初始化该类的实例。</p>

<pre><code class="language-objectivec">- (instancetype)initWithProtocol:(Protocol *)protocol {
	self = [super init];
	class_addProtocol(self.class, protocol);
	_protocol = protocol;
	return self;
}
</code></pre>

<p>从初始化方法中，我们可以看出 <code>RACDelegateProxy</code> 是一个包含实例变量 <code>_protocol</code> 的类：</p>

<p><img src="https://img.nju520.me/2017-02-25-RACDelegateProxy.png-1000width" alt="RACDelegateProxy" /></p>

<p>在整个 <code>RACDelegateProxy</code> 类的实现中，你都不太能看出与这个实例变量 <code>_protocol</code> 的关系；稍微对 iOS 有了解的人可能都知道，在 Cocoa 中有一个非常特别的根类 <code>NSProxy</code>，而从它的名字我们也可以推断出来，<code>NSProxy</code> 一般用于实现代理（主要是对消息进行转发），但是 ReactiveCocoa 中这个 <code>delegate</code> 的代理 <code>RACDelegateProxy</code> 并没有继承这个 <code>NSProxy</code> 根类：</p>

<pre><code class="language-objectivec">@interface RACDelegateProxy : NSObject

@end
</code></pre>

<p>那么 <code>RACDelegateProxy</code> 是如何作为 Cocoa 中组件的代理，并为原生组件添加 <code>RACSignal</code> 的支持呢？我们以 <code>UITableView</code> 为例来展示 <code>RACDelegateProxy</code> 是如何与 UIKit 组件互动的，我们需要实现的是以下功能：</p>

<p><img src="https://img.nju520.me/2017-02-25-RACDelegateProxy-UITableView.gif" alt="RACDelegateProxy-UITableVie" /></p>

<p>在点击所有的 <code>UITableViewCell</code> 时都会自动取消点击状态，通常情况下，我们可以直接在代理方法 <code>-tableView:didSelectRowAtIndexPath:</code> 中执行 <code>-deselectRowAtIndexPath:animated:</code> 方法：</p>

<pre><code class="language-objectivec">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {
    [tableView deselectRowAtIndexPath:indexPath animated:YES];
}
</code></pre>

<p>使用信号的话相比而言就比较麻烦了：</p>

<pre><code class="language-objectivec">RACDelegateProxy *proxy = [[RACDelegateProxy alloc] initWithProtocol:@protocol(UITableViewDelegate)];
objc_setAssociatedObject(self, _cmd, proxy, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
proxy.rac_proxiedDelegate = self;
[[proxy rac_signalForSelector:@selector(tableView:didSelectRowAtIndexPath:)]
 subscribeNext:^(RACTuple *value) {
     [value.first deselectRowAtIndexPath:value.second animated:YES];
 }];
self.tableView.delegate = (id&lt;UITableViewDelegate&gt;)proxy;
</code></pre>

<ol>
  <li>初始化 <code>RACDelegateProxy</code> 实例，传入 <code>UITableViewDelegate</code> 协议，并将实例存入视图控制器以<strong>确保实例不会被意外释放</strong>造成崩溃；</li>
  <li>设置代理的 <code>rac_proxiedDelegate</code> 属性为视图控制器；</li>
  <li>使用 <code>-rac_signalForSelector:</code> 方法生成一个 <code>RACSignal</code>，在 <code>-tableView:didSelectRowAtIndexPath:</code> 方法调用时将方法的参数打包成 <code>RACTuple</code> 向信号中发送新的 <code>next</code> 消息；</li>
  <li>重新设置 <code>UITableView</code> 的代理；</li>
</ol>

<p>在 <code>UITableViewDelgate</code> 中的代理方法执行时，实际上会被 <code>RACDelegateProxy</code> 拦截，并根据情况决定是处理还是转发：</p>

<p><img src="https://img.nju520.me/2017-02-25-UITableViewDelegate-With-RACDelegateProxy.png-1000width" alt="UITableViewDelegate-With-RACDelegateProxy" /></p>

<p>如果 <code>RACDelegateProxy</code> 实现了该代理方法就会交给它处理，如：<code>-tableView:didSelectRowAtIndexPath:</code>；否则，当前方法就会被转发到原 <code>delegate</code> 上，在这里就是 <code>UIViewController</code> 对象。</p>

<p><code>RACDelegateProxy</code> 中有两个值得特别注意的问题，一是 <code>RACDelegateProxy</code> 是如何进行消息转发的，有事如何将自己无法实现的消息交由原代理处理，第二是 <code>RACDelegateProxy</code> 如何通过方法 <code>-rac_signalForSelector:</code> 在原方法调用时以 <code>RACTuple</code> 的方式发送到 <code>RACSignal</code> 上。</p>

<h2 id="消息转发的实现">消息转发的实现</h2>

<p>首先，我们来看 <code>RACDelegateProxy</code> 是如何在无法响应方法时，将方法转发给原有的代理的；<code>RACDelegateProxy</code> 通过覆写几个方法来实现，最关键的就是 <code>-forwardInvocation:</code> 方法：</p>

<pre><code class="language-objectivec">- (void)forwardInvocation:(NSInvocation *)invocation {
	[invocation invokeWithTarget:self.rac_proxiedDelegate];
}
</code></pre>

<p>当然，作为消息转发流程的一部分 <code>-methodSignatureForSelector:</code> 方法也需要在 <code>RACDelegateProxy</code> 对象中实现：</p>

<pre><code class="language-objectivec">- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector {
	struct objc_method_description methodDescription = protocol_getMethodDescription(_protocol, selector, NO, YES);
	if (methodDescription.name == NULL) {
		methodDescription = protocol_getMethodDescription(_protocol, selector, YES, YES);
		if (methodDescription.name == NULL) return [super methodSignatureForSelector:selector];
	}
	return [NSMethodSignature signatureWithObjCTypes:methodDescription.types];
}
</code></pre>

<p>我们会从协议的方法中尝试获取其中的可选方法和必须实现的方法，最终获取方法的签名 <code>NSMethodSignature</code> 对象。</p>

<p>整个方法决议和消息转发的过程如下图所示，在整个方法决议和消息转发的过程中 Objective-C 运行时会再次提供执行该方法的机会。</p>

<p><img src="https://img.nju520.me/2017-02-25-Message-Forwarding.png-1000width" alt="Message-Forwarding" /></p>

<p>例子中的代理方法最后也被 <code>-forwardInvocation:</code> 方法成功的转发到了 <code>UITableView</code> 的原代理上。</p>

<h2 id="从代理到信号">从代理到信号</h2>

<p>在 <code>RACDelegateProxy</code> 中的另一个非常神奇的方法就是将某一个代理方法转换成信号的 <code>-signalForSelector:</code>：</p>

<pre><code class="language-objectivec">- (RACSignal *)signalForSelector:(SEL)selector {
	return [self rac_signalForSelector:selector fromProtocol:_protocol];
}

- (RACSignal *)rac_signalForSelector:(SEL)selector fromProtocol:(Protocol *)protocol {
	return NSObjectRACSignalForSelector(self, selector, protocol);
}
</code></pre>

<p>该方法会在传入的协议方法被调用时，将协议方法中的所有参数以 <code>RACTuple</code> 的形式发送到返回的信号上，使用者可以通过订阅这个信号来获取所有的参数；而方法 <code>NSObjectRACSignalForSelector</code> 的实现还是比较复杂的。</p>

<pre><code class="language-objectivec">static RACSignal *NSObjectRACSignalForSelector(NSObject *self, SEL selector, Protocol *protocol) {
	SEL aliasSelector = RACAliasForSelector(selector);

    RACSubject *subject = objc_getAssociatedObject(self, aliasSelector);
    if (subject != nil) return subject;

    Class class = RACSwizzleClass(self);
    subject = [RACSubject subject];
    objc_setAssociatedObject(self, aliasSelector, subject, OBJC_ASSOCIATION_RETAIN);

    Method targetMethod = class_getInstanceMethod(class, selector);
    if (targetMethod == NULL) {
        const char *typeEncoding;
        if (protocol == NULL) {
            typeEncoding = RACSignatureForUndefinedSelector(selector);
        } else {
            struct objc_method_description methodDescription = protocol_getMethodDescription(protocol, selector, NO, YES);
            if (methodDescription.name == NULL) {
                methodDescription = protocol_getMethodDescription(protocol, selector, YES, YES);
            }
            typeEncoding = methodDescription.types;
        }
        class_addMethod(class, selector, _objc_msgForward, typeEncoding);
    } else if (method_getImplementation(targetMethod) != _objc_msgForward) {
        const char *typeEncoding = method_getTypeEncoding(targetMethod);

        class_addMethod(class, aliasSelector, method_getImplementation(targetMethod), typeEncoding);
        class_replaceMethod(class, selector, _objc_msgForward, method_getTypeEncoding(targetMethod));
    }
    return subject;
}
</code></pre>

<p>这个 C 函数总共做了两件非常重要的事情，第一个是将传入的选择子对应的实现变为 <code>_objc_msgForward</code>，也就是在调用该方法时，会直接进入消息转发流程，第二是用 <code>RACSwizzleClass</code> 调剂当前类的一些方法。</p>

<p><img src="https://img.nju520.me/2017-02-25-NSObjectRACSignalForSelector.png-1000width" alt="NSObjectRACSignalForSelecto" /></p>

<h3 id="从-selector-到-_objc_msgforward">从 selector 到 _objc_msgForward</h3>

<p>我们具体看一下这部分代码是如何实现的，在修改选择子对应的实现之前，我们会先做一些准备工作：</p>

<pre><code class="language-objectivec">SEL aliasSelector = RACAliasForSelector(selector);

RACSubject *subject = objc_getAssociatedObject(self, aliasSelector);
if (subject != nil) return subject;

Class class = RACSwizzleClass(self);

subject = [RACSubject subject];
objc_setAssociatedObject(self, aliasSelector, subject, OBJC_ASSOCIATION_RETAIN);

Method targetMethod = class_getInstanceMethod(class, selector);
</code></pre>

<ol>
  <li>获取选择子的别名，在这里我们通过为选择子加前缀 <code>rac_alias_</code> 来实现；</li>
  <li>尝试以 <code>rac_alias_selector</code> 为键获取一个热信号 <code>RACSubject</code>；</li>
  <li>使用 <code>RACSwizzleClass</code> 调剂当前类的一些方法（我们会在下一节中介绍）；</li>
  <li>从当前类中获取目标方法的结构体 <code>targetMethod</code>；</li>
</ol>

<p>在进行了以上的准备工作之后，我们就开始修改选择子对应的实现了，整个的修改过程会分为三种情况：</p>

<p><img src="https://img.nju520.me/2017-02-25-Swizzle-objc_msgForward.png-1000width" alt="Swizzle-objc_msgForward" /></p>

<p>下面会按照这三种情况依次介绍在不同情况下，如何将对应选择子的实现改为 <code>_objc_msgForward</code> 完成消息转发的。</p>

<h4 id="targetmethod--null--protocol--null">targetMethod == NULL &amp;&amp; protocol == NULL</h4>

<p>在找不到选择子对应的方法并且没有传入协议时，这时执行的代码最为简单：</p>

<pre><code class="language-objectivec">typeEncoding = RACSignatureForUndefinedSelector(selector);
class_addMethod(class, selector, _objc_msgForward, typeEncoding);
</code></pre>

<p>我们会通过 <code>RACSignatureForUndefinedSelector</code> 生成一个当前方法默认的类型编码。</p>

<blockquote>
  <p>对类型编码不了解的可以阅读苹果的官方文档 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encodings · Apple Developer</a>，其中详细解释了类型编码是什么，它在整个 Objective-C 运行时有什么作用。</p>
</blockquote>

<pre><code class="language-objectivec">static const char *RACSignatureForUndefinedSelector(SEL selector) {
	const char *name = sel_getName(selector);
	NSMutableString *signature = [NSMutableString stringWithString:@"v@:"];

	while ((name = strchr(name, ':')) != NULL) {
		[signature appendString:@"@"];
		name++;
	}

	return signature.UTF8String;
}
</code></pre>

<p>该方法在生成类型编码时，会按照 <code>:</code> 的个数来为 <code>v@:</code> 这个类型编码添加 <code>@</code> 字符；简单说明一下它的意思，ReactiveCocoa 默认所有的方法的返回值类型都为空 <code>void</code>，都会传入 <code>self</code> 以及当前方法的选择子 <code>SEL</code>，它们的类型编码可以在下图中找到，分别是 <code>v@:</code>；而 <code>@</code> 代表 <code>id</code> 类型，也就是我们默认代理方法中的所有参数都是 <code>NSObject</code> 类型的。</p>

<p><img src="https://img.nju520.me/2017-02-25-TypeEncoding.png-1000width" alt="TypeEncoding" /></p>

<p>生成了类型编码之后，由于我们并没有在当前类中找到该选择子对应的方法，所以会使用 <code>class_addMethod</code> 为当前类提供一个方法的实现，直接将当前选择子的实现改为 <code>_objc_msgForward</code>。</p>

<p><img src="https://img.nju520.me/2017-02-25-Selector-To-ObjC-Message-Forward.png-1000width" alt="Selector-To-ObjC-Message-Forward" /></p>

<h4 id="targetmethod--null--protocol--null-1">targetMethod == NULL &amp;&amp; protocol != NULL</h4>

<p>当类中不存在当前选择子对应的方法 <code>targetMethod</code>，但是向当前函数中传入了协议时，我们会尝试从协议中获取方法描述：</p>

<pre><code class="language-objectivec">struct objc_method_description methodDescription = protocol_getMethodDescription(protocol, selector, NO, YES);

if (methodDescription.name == NULL) {
    methodDescription = protocol_getMethodDescription(protocol, selector, YES, YES);
}
typeEncoding = methodDescription.types;
class_addMethod(class, selector, _objc_msgForward, typeEncoding);
</code></pre>

<p>这里会使用 <code>protocol_getMethodDescription</code> 两次从协议中获取可选和必须实现的方法的描述，并从结构体中拿出类型编码，最后为类添加这个之前不存在的方法：</p>

<p><img src="https://img.nju520.me/2017-02-25-Selector-To-ObjC-Message-Forward.png-1000width" alt="Selector-To-ObjC-Message-Forward" /></p>

<p>在这种情况下，其最后的结果与上一种的完全相同，因为它们都是对不存在该方法，只需要获得方法的类型编码并将实现添加为 <code>_objc_msgForward</code>，交给消息转发流程进行处理即可。</p>

<h4 id="targetmethod--null">targetMethod != NULL</h4>

<p>在目标方法的实现不为空并且它的实现并不是 <code>_objc_msgForward</code> 时，我们就会进入以下流程修改原有方法的实现：</p>

<pre><code class="language-objectivec">const char *typeEncoding = method_getTypeEncoding(targetMethod);

class_addMethod(class, aliasSelector, method_getImplementation(targetMethod), typeEncoding);
class_replaceMethod(class, selector, _objc_msgForward, method_getTypeEncoding(targetMethod));
</code></pre>

<p>同样，我们需要获得目标方法的方法签名、添加 <code>aliasSelector</code> 这个新方法，最后在修改原方法的实现到 <code>_objc_msgForward</code>。</p>

<p><img src="https://img.nju520.me/2017-02-25-Selector-To-ObjC-Message-Forward-With-RACSelector.png-1000width" alt="Selector-To-ObjC-Message-Forward-With-RACSelecto" /></p>

<p>上图展示了在目标方法不为空并且其实现不为 <code>_objc_msgForward</code> 时，<code>NSObjectRACSignalForSelector</code> 是如何修改原方法实现的。</p>

<h3 id="调剂类的方法">调剂类的方法</h3>

<p><code>NSObjectRACSignalForSelector</code> 在修改原选择子方法实现的之前就已经修改了当前类很多方法的实现：</p>

<ul>
  <li><code>-methodSignatureForSelector:</code></li>
  <li><code>-class</code></li>
  <li><code>-respondsToSelector</code></li>
  <li><code>-forwardInvocation:</code></li>
</ul>

<p>整个调剂方法的过程 <code>RACSwizzleClass</code> 还是比较复杂的，我们可以分三部分看下面的代码：</p>

<pre><code class="language-objectivec">static Class RACSwizzleClass(NSObject *self) {
	Class statedClass = self.class;
	Class baseClass = object_getClass(self);

	NSString *className = NSStringFromClass(baseClass);
	const char *subclassName = [className stringByAppendingString:RACSubclassSuffix].UTF8String;
	Class subclass = objc_getClass(subclassName);

	if (subclass == nil) {
		subclass = objc_allocateClassPair(baseClass, subclassName, 0);
		if (subclass == nil) return nil;

		RACSwizzleForwardInvocation(subclass);
		RACSwizzleRespondsToSelector(subclass);
		RACSwizzleGetClass(subclass, statedClass);
		RACSwizzleGetClass(object_getClass(subclass), statedClass);
		RACSwizzleMethodSignatureForSelector(subclass);

		objc_registerClassPair(subclass);
	}
	object_setClass(self, subclass);
	return subclass;
}
</code></pre>

<ol>
  <li>从当前类 <code>RACDelegateProxy</code> 衍生出一个子类 <code>RACDelegateProxy_RACSelectorSignal</code>；</li>
  <li>调用各种 <code>RACSwizzleXXX</code> 方法修改当前子类的一些表现；</li>
  <li>将 <code>RACDelegateProxy</code> 对象的类设置成自己，这样就会在查找方法时，找到 <code>RACDelegateProxy_RACSelectorSignal</code> 中的实现；</li>
</ol>

<p>在修改的几个方法中最重要的就是 <code>-forwardInvocation:</code>：</p>

<pre><code class="language-objectivec">static void RACSwizzleForwardInvocation(Class class) {
	SEL forwardInvocationSEL = @selector(forwardInvocation:);
	Method forwardInvocationMethod = class_getInstanceMethod(class, forwardInvocationSEL);

	void (*originalForwardInvocation)(id, SEL, NSInvocation *) = NULL;
	if (forwardInvocationMethod != NULL) {
		originalForwardInvocation = (__typeof__(originalForwardInvocation))method_getImplementation(forwardInvocationMethod);
	}

	id newForwardInvocation = ^(id self, NSInvocation *invocation) {
		BOOL matched = RACForwardInvocation(self, invocation);
		if (matched) return;

		if (originalForwardInvocation == NULL) {
			[self doesNotRecognizeSelector:invocation.selector];
		} else {
			originalForwardInvocation(self, forwardInvocationSEL, invocation);
		}
	};

	class_replaceMethod(class, forwardInvocationSEL, imp_implementationWithBlock(newForwardInvocation), "v@:@");
}
</code></pre>

<p>这个方法中大部分的内容都是平淡无奇的，在新的 <code>-forwardInvocation:</code> 方法中，执行的 <code>RACForwardInvocation</code> 是实现整个消息转发的关键内容：</p>

<pre><code class="language-objectivec">static BOOL RACForwardInvocation(id self, NSInvocation *invocation) {
	SEL aliasSelector = RACAliasForSelector(invocation.selector);
	RACSubject *subject = objc_getAssociatedObject(self, aliasSelector);

	Class class = object_getClass(invocation.target);
	BOOL respondsToAlias = [class instancesRespondToSelector:aliasSelector];
	if (respondsToAlias) {
		invocation.selector = aliasSelector;
		[invocation invoke];
	}

	if (subject == nil) return respondsToAlias;

	[subject sendNext:invocation.rac_argumentsTuple];
	return YES;
}
</code></pre>

<p>在 <code>-rac_signalForSelector:</code> 方法返回的 <code>RACSignal</code> 上接收到的参数信号，就是从这个方法发送过去的，新的实现 <code>RACForwardInvocation</code> 改变了原有的 <code>selector</code> 到 <code>aliasSelector</code>，然后使用 <code>-invoke</code> 完成该调用，而所有的参数会以 <code>RACTuple</code> 的方式发送到信号上。</p>

<p>像其他的方法 <code>-respondToSelector:</code> 等等，它们的实现就没有这么复杂并且重要了：</p>

<pre><code class="language-objectivec">id newRespondsToSelector = ^ BOOL (id self, SEL selector) {
    Method method = rac_getImmediateInstanceMethod(class, selector);

    if (method != NULL &amp;&amp; method_getImplementation(method) == _objc_msgForward) {
        SEL aliasSelector = RACAliasForSelector(selector);
        if (objc_getAssociatedObject(self, aliasSelector) != nil) return YES;
    }

    return originalRespondsToSelector(self, respondsToSelectorSEL, selector);
};
</code></pre>

<p><code>rac_getImmediateInstanceMethod</code> 从当前类获得方法的列表，并从中找到与当前 <code>selector</code> 同名的方法 <code>aliasSelector</code>，然后根据不同情况判断方法是否存在。</p>

<p>对 <code>class</code> 的修改，是为了让对象对自己的身份『说谎』，因为我们子类化了 <code>RACDelegateProxy</code>，并且重新设置了对象的类，将所有的方法都转发到了这个子类上，如果不修改 <code>class</code> 方法，那么当开发者使用它自省时就会得到错误的类，而这是我们不希望看到的。</p>

<pre><code class="language-objectivec">static void RACSwizzleGetClass(Class class, Class statedClass) {
	SEL selector = @selector(class);
	Method method = class_getInstanceMethod(class, selector);
	IMP newIMP = imp_implementationWithBlock(^(id self) {
		return statedClass;
	});
	class_replaceMethod(class, selector, newIMP, method_getTypeEncoding(method));
}
</code></pre>

<p>在最后我们会对获得方法签名的 <code>-methodSignatureForSelector:</code> 方法进行修改：</p>

<pre><code class="language-objectivec">IMP newIMP = imp_implementationWithBlock(^(id self, SEL selector) {
    Class actualClass = object_getClass(self);
    Method method = class_getInstanceMethod(actualClass, selector);
    if (method == NULL) {
        struct objc_super target = {
            .super_class = class_getSuperclass(class),
            .receiver = self,
        };
        NSMethodSignature * (*messageSend)(struct objc_super *, SEL, SEL) = (__typeof__(messageSend))objc_msgSendSuper;
        return messageSend(&amp;target, @selector(methodSignatureForSelector:), selector);
    }

    char const *encoding = method_getTypeEncoding(method);
    return [NSMethodSignature signatureWithObjCTypes:encoding];
});
</code></pre>

<p>在方法不存在时，通过 <code>objc_msgSendSuper</code> 调用父类的 <code>-methodSignatureForSelector:</code> 方法获取方法签名。</p>

<h2 id="方法调用的过程">方法调用的过程</h2>

<p>在一般情况下，Objective-C 中某一消息被发送到一个对象时，它会先获取当前对象对应的类，然后从类的选择子表查找该方法对应的实现并执行。</p>

<p><img src="https://img.nju520.me/2017-02-25-Selector-To-IMP.png-1000width" alt="Selector-To-IMP" /></p>

<p>与正常的方法实现查找以及执行过程的简单不同，如果我们对某一个方法调用了 <code>-rac_signalForSelector:</code> 方法，那么对于同一个对象对应的类的所有方法，它们的执行过程会变得非常复杂：</p>

<p><img src="https://img.nju520.me/2017-02-25-After-Call-RACSignalForSelector.png-1000width" alt="After-Call-RACSignalForSelecto" /></p>

<ol>
  <li>由于当前对象对应的类已经被改成了 <code>Subclass</code>，即 <code>Class_RACSelectorSignal</code>，所以会在子类中查找方法的实现；</li>
  <li>方法对应的实现已经被改成了 <code>-forwardInvocation:</code>，会直接进入消息转发流程中处理；</li>
  <li>根据传入的选择子获取同名选择子 <code>rac_alias_selector</code>；</li>
  <li>拿到当前 <code>NSInvocation</code> 对象中 <code>target</code> 的类，判断是否可以响应该选择子；</li>
  <li>将 <code>NSInvocation</code> 对象中的选择子改为 <code>rac_alias_selector</code> 并执行其实现；</li>
  <li>从 <code>NSInvocation</code> 对象中获取参数并打包成 <code>RACTuple</code>，以 <code>next</code> 消息的形式发送到持有的 <code>RACSubject</code> 热信号上；</li>
</ol>

<p>这时所有的订阅者才会在该方法被调用时收到消息，完成相应的任务。</p>

<h2 id="总结">总结</h2>

<p>ReactiveCocoa 使用了一种非常神奇的办法把原有的代理模式成功的桥接到 <code>RACSignal</code> 的世界中，并为我们提供了 <code>RACDelegateProxy</code> 这一接口，能够帮助我们以信号的形式监听所有的代理方法，可以用 block 的形式去代替原有的方法，为我们减少一些工作量。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encodings · Apple Developer</a></li>
</ul>

<blockquote>
  <p>Github Repo：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://nju520.me/racdelegateproxy</p>
</blockquote>

  ]]></description>
</item>

<item>
  <title>理解 RACScheduler 的实现</title>
  <link>//racscheduler</link>
  <author>nju520</author>
  <pubDate>2017-02-17T20:10:43+08:00</pubDate>
  <guid>//racscheduler</guid>
  <description><![CDATA[
  <p><code>RACScheduler</code> 是一个线性执行队列，ReactiveCocoa 中的信号可以在 <code>RACScheduler</code> 上执行任务、发送结果；它的实现并不复杂，由多个简单的方法和类组成整个 <code>RACScheduler</code> 模块，是整个 ReactiveCocoa 中非常易于理解的部分。</p>

<h2 id="racscheduler-简介">RACScheduler 简介</h2>

<p><code>RACScheduler</code> 作为 ReactiveCocoa 中唯一的用于调度的模块，它包含很多个性化的子类：</p>

<p><img src="https://img.nju520.me/2017-02-17-RACScheduler-Subclasses.png-1000width" alt="RACScheduler-Subclasses" /></p>

<p><code>RACScheduler</code> 类的内部只有一个用于追踪标记和 debug 的属性 <code>name</code>，头文件和实现文件中的其它内容都是各种各样的方法；我们可以把其中的方法分为两类，一类是用于初始化 <code>RACScheduler</code> 实例的初始化方法：</p>

<p><img src="https://img.nju520.me/2017-02-17-RACScheduler-Initializers.png-1000width" alt="RACScheduler-Initializers" /></p>

<p>另一类就是用于调度、执行任务的 <code>+schedule:</code> 等方法：</p>

<p><img src="https://img.nju520.me/2017-02-17-RACScheduler-Schedule.png-1000width" alt="RACScheduler-Schedule" /></p>

<p>在图中都省略了一些参数缺省的方法，以及一些调用其他方法的调度方法或者初始化方法，用以减少我们分析和理解整个 <code>RACScheduler</code> 类的难度。</p>

<p>在 <code>RACScheduler</code> 中，大部分的调度方法都是需要子类覆写，它本身只提供少数的功能，比如递归 block 的执行：</p>

<pre><code class="language-objectivec">- (RACDisposable *)scheduleRecursiveBlock:(RACSchedulerRecursiveBlock)recursiveBlock {
	RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];
	[self scheduleRecursiveBlock:[recursiveBlock copy] addingToDisposable:disposable];
	return disposable;
}
</code></pre>

<p>该方法会递归的执行传入的 <code>recursiveBlock</code>，使用的方式非常简单：</p>

<pre><code class="language-objectivec">[scheduler scheduleRecursiveBlock:^(void (^reschedule)(void)) {
    if (needTerminated) return;

    // do something

    reschedule();
}];
</code></pre>

<p>如果需要递归就执行方法中的 <code>reschedule()</code>，就会再次执行当前的 block；<code>-scheduleRecursiveBlock:</code> 中调用的 <code>-scheduleRecursiveBlock:addingToDisposable:</code> 实现比较复杂：</p>

<pre><code class="language-objectivec">- (void)scheduleRecursiveBlock:(RACSchedulerRecursiveBlock)recursiveBlock addingToDisposable:(RACCompoundDisposable *)disposable {
    ...
    RACDisposable *schedulingDisposable = [self schedule:^{
        void (^reallyReschedule)(void) = ^{
            [self scheduleRecursiveBlock:recursiveBlock addingToDisposable:disposable];
        };

        recursiveBlock(^{
            reallyReschedule();
        });
    }];
    ...
}
</code></pre>

<blockquote>
  <p>方法使用了 <code>NSLock</code> 保证在并发情况下并不会出现任何问题，不过在这里展示的代码中，我们将它省略了，一并省略的还有 <code>RACDisposable</code> 相关的代码，以保证整个方法逻辑的清晰，方法的原实现可以查看这里 <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/9164a24abfbb7d6b2280d78f9c9308a9842bfcfe/ReactiveObjC/RACScheduler.m#L130-L187">RACScheduler.m#L130-L187</a>。</p>
</blockquote>

<p>在每次执行 <code>recursiveBlock</code> 时，都会传入一个 <code>reallyReschedule</code> 用于递归执行传入的 block。</p>

<p>其他的方法包括 <code>+schedule:</code>、<code>+after:schedule:</code> 以及 <code>after:repeatingEvery:withLeeway:schedule:</code> 方法都需要子类覆写：</p>

<pre><code class="language-objectivec">- (RACDisposable *)schedule:(void (^)(void))block;
- (RACDisposable *)after:(NSDate *)date schedule:(void (^)(void))block;
- (RACDisposable *)after:(NSDate *)date repeatingEvery:(NSTimeInterval)interval withLeeway:(NSTimeInterval)leeway schedule:(void (^)(void))block {
	NSCAssert(NO, @"%@ must be implemented by subclasses.", NSStringFromSelector(_cmd));
	return nil;
}
</code></pre>

<p>而接下来我们就按照初始化方法的顺序依次介绍 <code>RACScheduler</code> 的子类了。</p>

<h3 id="racimmediatescheduler">RACImmediateScheduler</h3>

<p><code>RACImmediateScheduler</code> 是一个会立即执行传入的代码块的调度器，我们可以使用 <code>RACScheduler</code> 的类方法 <code>+immediateScheduler</code> 返回一个它的实例：</p>

<pre><code class="language-objectivec">+ (RACScheduler *)immediateScheduler {
	static dispatch_once_t onceToken;
	static RACScheduler *immediateScheduler;
	dispatch_once(&amp;onceToken, ^{
		immediateScheduler = [[RACImmediateScheduler alloc] init];
	});
	return immediateScheduler;
}
</code></pre>

<p>由于 <code>RACImmediateScheduler</code> 是一个私有类，全局只能通过该方法返回它的实例，所以整个程序的运行周期内，我们通过『合法』手段只能获得唯一一个单例。</p>

<p>作为 <code>RACScheduler</code> 的子类，它必须对父类的调度方法进行覆写，不过因为本身的职能原因，<code>RACImmediateScheduler</code> 对于父类的覆写还是非常简单的：</p>

<pre><code class="language-objectivec">- (RACDisposable *)schedule:(void (^)(void))block {
	block();
	return nil;
}

- (RACDisposable *)after:(NSDate *)date schedule:(void (^)(void))block {
	[NSThread sleepUntilDate:date];
	block();
	return nil;
}

- (RACDisposable *)after:(NSDate *)date repeatingEvery:(NSTimeInterval)interval withLeeway:(NSTimeInterval)leeway schedule:(void (^)(void))block {
	NSCAssert(NO, @"+[RACScheduler immediateScheduler] does not support %@.", NSStringFromSelector(_cmd));
	return nil;
}
</code></pre>

<ul>
  <li><code>+schedule</code> 方法会立刻执行传入的 block；</li>
  <li><code>+after:schedule:</code> 方法会将当前线程休眠到指定时间后执行 block；</li>
  <li>而对于 <code>+after:repeatingEvery:withLeeway:schedule:</code> 方法就干脆不支持。</li>
</ul>

<p>这确实非常符合 <code>RACImmediateScheduler</code> 类的名字以及功能，虽然没有要求对递归执行 block 的方法进行覆写，不过它依然做了这件事情：</p>

<pre><code class="language-objectivec">- (RACDisposable *)scheduleRecursiveBlock:(RACSchedulerRecursiveBlock)recursiveBlock {
	for (__block NSUInteger remaining = 1; remaining &gt; 0; remaining--) {
		recursiveBlock(^{
			remaining++;
		});
	}
	return nil;
}
</code></pre>

<p>实现的过程非常简洁，甚至没有什么值得解释的地方了。</p>

<h3 id="ractargetqueuescheduler">RACTargetQueueScheduler</h3>

<p><code>RACTargetQueueScheduler</code> 继承自 <code>RACQueueScheduler</code>，但是由于后者是抽象类，我们并不会直接使用它，它只是为前者提供必要的方法支持，将一部分逻辑抽离出来：</p>

<p><img src="https://img.nju520.me/2017-02-17-RACTargetQueueScheduler.png-1000width" alt="RACTargetQueueSchedule" /></p>

<p>这里我们先简单看一下 <code>RACTargetQueueScheduler</code> 的实现，整个 <code>RACTargetQueueScheduler</code> 类中只有一个初始化方法：</p>

<pre><code class="language-objectivec">- (instancetype)initWithName:(NSString *)name targetQueue:(dispatch_queue_t)targetQueue {
	dispatch_queue_t queue = dispatch_queue_create(name.UTF8String, DISPATCH_QUEUE_SERIAL);
	dispatch_set_target_queue(queue, targetQueue);
	return [super initWithName:name queue:queue];
}
</code></pre>

<p>初始化方法 <code>-initWithName:targetQueue:</code> 使用 <code>dispatch_queue_create</code> 创建了一个串行队列，然后通过 <code>dispatch_set_target_queue</code>  根据传入的 <code>targetQueue</code> 设置队列的优先级，最后调用父类的指定构造器完成整个初始化过程。</p>

<p><code>RACTargetQueueScheduler</code> 在使用时，将待执行的任务加入一个私有的串行队列中，其优先级与传入的 targetQueue 完全相同；不过提到 <code>RACTargetQueueScheduler</code> 中队列的优先级，对 GCD 稍有了解的人应该都知道在 GCD 中有着四种不同优先级的全局并行队列，而在 <code>RACScheduler</code> 中也有一一对应的枚举类型：</p>

<p><img src="https://img.nju520.me/2017-02-17-RACScheduler-Priority.png-1000width" alt="RACScheduler-Priority" /></p>

<p>在使用 <code>+schedulerWithPriority:</code> 方法创建 <code>RACTargetQueueScheduler</code> 时，就需要传入上面的优先级，方法会通过 GCD 的内置方法 <code>dispatch_get_global_queue</code> 获取全局的并行队列，最终返回一个新的实例。</p>

<pre><code class="language-objectivec">+ (RACScheduler *)schedulerWithPriority:(RACSchedulerPriority)priority name:(NSString *)name {
	return [[RACTargetQueueScheduler alloc] initWithName:name targetQueue:dispatch_get_global_queue(priority, 0)];
}
</code></pre>

<p>在 <code>RACScheduler</code> 接口中另一个获得主线程调度器的方法 <code>+mainThreadScheduler</code>，其实现也是返回一个 <code>RACTargetQueueScheduler</code> 对象：</p>

<pre><code class="language-objectivec">+ (RACScheduler *)mainThreadScheduler {
	static dispatch_once_t onceToken;
	static RACScheduler *mainThreadScheduler;
	dispatch_once(&amp;onceToken, ^{
		mainThreadScheduler = [[RACTargetQueueScheduler alloc] initWithName:@"org.reactivecocoa.ReactiveObjC.RACScheduler.mainThreadScheduler" targetQueue:dispatch_get_main_queue()];
	});

	return mainThreadScheduler;
}
</code></pre>

<p>与前者不同的是，后者通过单例模式每次调用时返回一个相同的主线程队列。</p>

<h4 id="抽象类-racqueuescheduler">抽象类 RACQueueScheduler</h4>

<p>在我们对 <code>RACTargetQueueScheduler</code> 有一定了解之后，再看它的抽象类就非常简单了；<code>RACImmediateScheduler</code> 会立即执行传入的任务，而 <code>RACQueueScheduler</code> 其实就是对 GCD 的封装，相信各位读者从它的子类的实现就可以看出来。</p>

<p><code>RACQueueScheduler</code> 对三个需要覆写的方法都进行了重写，其实现完全基于 GCD，以 <code>-schedule:</code> 方法为例：</p>

<pre><code class="language-objectivec">- (RACDisposable *)schedule:(void (^)(void))block {
	RACDisposable *disposable = [[RACDisposable alloc] init];

	dispatch_async(self.queue, ^{
		if (disposable.disposed) return;
		[self performAsCurrentScheduler:block];
	});

	return disposable;
}
</code></pre>

<p>使用 <code>dispatch_async</code> 方法直接将需要执行的任务<strong>异步派发</strong>到它所持有的队列上；而 <code>-after:schedule:</code> 方法的实现相信各位读者也能猜到：</p>

<pre><code class="language-objectivec">- (RACDisposable *)after:(NSDate *)date schedule:(void (^)(void))block {
	RACDisposable *disposable = [[RACDisposable alloc] init];

	dispatch_after([self.class wallTimeWithDate:date], self.queue, ^{
		if (disposable.disposed) return;
		[self performAsCurrentScheduler:block];
	});

	return disposable;
}
</code></pre>

<p>哪怕不使用 <code>RACScheduler</code>，我们也能够想到利用 <code>dispatch_after</code> 完成一些需要延迟执行的任务，最后的 <code>+after:repeatingEvery:withLeeway:schedule:</code> 方法的实现就稍微复杂一些了：</p>

<pre><code class="language-objectivec">- (RACDisposable *)after:(NSDate *)date repeatingEvery:(NSTimeInterval)interval withLeeway:(NSTimeInterval)leeway schedule:(void (^)(void))block {
	uint64_t intervalInNanoSecs = (uint64_t)(interval * NSEC_PER_SEC);
	uint64_t leewayInNanoSecs = (uint64_t)(leeway * NSEC_PER_SEC);

	dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, self.queue);
	dispatch_source_set_timer(timer, [self.class wallTimeWithDate:date], intervalInNanoSecs, leewayInNanoSecs);
	dispatch_source_set_event_handler(timer, block);
	dispatch_resume(timer);

	return [RACDisposable disposableWithBlock:^{
		dispatch_source_cancel(timer);
	}];
}
</code></pre>

<p>方法使用 <code>dispatch_source_t</code> 以及定时器，完成了每隔一段时间需要执行任务的需求。</p>

<h3 id="racsubscriptionscheduler">RACSubscriptionScheduler</h3>

<p>最后的 <code>RACSubscriptionScheduler</code> 是 ReactiveCocoa 中一个比较特殊的调度器，所有 ReactiveCocoa 中的订阅事件都会在 <code>RACSubscriptionScheduler</code> 调度器上进行；而它是通过封装两个调度器实现的：</p>

<p><img src="https://img.nju520.me/2017-02-17-RACSubscriptionScheduler.png-1000width" alt="RACSubscriptionSchedule" /></p>

<blockquote>
  <p><code>backgroundScheduler</code> 是一个优先级为 <code>RACSchedulerPriorityDefault</code> 的串行队列。</p>
</blockquote>

<p><code>RACSubscriptionScheduler</code> 本身不提供任何的调度功能，它会根据当前状态选择持有的两个调度器中的一个执行任务；首先判断当前线程是否存在 <code>currentScheduler</code>，如果不存在的话才会在 <code>backgroundScheduler</code> 执行任务。</p>

<pre><code class="language-objectivec">- (RACDisposable *)schedule:(void (^)(void))block {
	if (RACScheduler.currentScheduler == nil) return [self.backgroundScheduler schedule:block];
	block();
	return nil;
}

- (RACDisposable *)after:(NSDate *)date schedule:(void (^)(void))block {
	RACScheduler *scheduler = RACScheduler.currentScheduler ?: self.backgroundScheduler;
	return [scheduler after:date schedule:block];
}

- (RACDisposable *)after:(NSDate *)date repeatingEvery:(NSTimeInterval)interval withLeeway:(NSTimeInterval)leeway schedule:(void (^)(void))block {
	RACScheduler *scheduler = RACScheduler.currentScheduler ?: self.backgroundScheduler;
	return [scheduler after:date repeatingEvery:interval withLeeway:leeway schedule:block];
}
</code></pre>

<p><code>RACSubscriptionScheduler</code> 作为一个私有类，我们并不能直接在 ReactiveCocoa 外部使用它，需要通过私有方法 <code>+subscriptionScheduler</code> 获取这个调度器：</p>

<pre><code class="language-objectivec">+ (RACScheduler *)subscriptionScheduler {
	static dispatch_once_t onceToken;
	static RACScheduler *subscriptionScheduler;
	dispatch_once(&amp;onceToken, ^{
		subscriptionScheduler = [[RACSubscriptionScheduler alloc] init];
	});

	return subscriptionScheduler;
}
</code></pre>

<h2 id="总结">总结</h2>

<p><code>RACScheduler</code> 在某些方面与 GCD 中的队列十分相似，与 GCD 中的队列不同的有两点，第一，它可以通过 <code>RACDisposable</code> 对执行中的任务进行取消，第二是 <code>RACScheduler</code> 中任务的执行都是线性的；与此同时 <code>RACScheduler</code> 也与 <code>NSOperationQueue</code> 非常类似，但是它并不支持对调度的任务进行<strong>重排序</strong>以及实现任务与任务之间的<strong>依赖</strong>关系。</p>

<h2 id="references">References</h2>

<blockquote>
  <p>Github Repo：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://nju520.me/racscheduler</p>
</blockquote>

  ]]></description>
</item>

<item>
  <title>RAC 中的双向数据绑定 RACChannel</title>
  <link>//racchannel</link>
  <author>nju520</author>
  <pubDate>2017-02-16T19:59:14+08:00</pubDate>
  <guid>//racchannel</guid>
  <description><![CDATA[
  <p>之前讲过了 ReactiveCocoa 中的一对一的单向数据流 <code>RACSignal</code> 和一对多的单向数据流 <code>RACMulticastConnection</code>，这一篇文章分析的是一对一的双向数据流 <code>RACChannel</code>。</p>

<p><img src="https://img.nju520.me/2017-02-16-What-is-RACChannel.png-1000width" alt="What-is-RACChanne" /></p>

<p><code>RACChannel</code> 其实是一个相对比较复杂的类，但是，对其有一定了解之后合理运用的话，会在合适的业务中提供非常强大的支持能够极大的简化业务代码。</p>

<h2 id="racchannel-简介">RACChannel 简介</h2>

<p><code>RACChannel</code> 可以被理解为一个双向的连接，这个连接的两端都是 <code>RACSignal</code> 实例，它们可以向彼此发送消息，如果我们在视图和模型之间通过 <code>RACChannel</code> 建立这样的连接：</p>

<p><img src="https://img.nju520.me/2017-02-16-Connection-Between-View-Model.png-1000width" alt="Connection-Between-View-Mode" /></p>

<p>那么从模型发出的消息，最后会发送到视图上；反之，用户对视图进行的操作最后也会体现在模型上。这种通信方式的实现是基于信号的，<code>RACChannel</code> 内部封装了两个 <code>RACChannelTerminal</code> 对象，它们都是 <code>RACSignal</code> 的子类：</p>

<p><img src="https://img.nju520.me/2017-02-16-RACChannel-Interface.png-1000width" alt="RACChannel-Interface" /></p>

<p>对模型进行的操作最后都会发送给 <code>leadingTerminal</code> 再通过内部的实现发送给 <code>followingTerminal</code>，由于视图是 <code>followingTerminal</code> 的订阅者，所以消息最终会发送到视图上。</p>

<p><img src="https://img.nju520.me/2017-02-16-Messages-Send-From-Model.png-1000width" alt="Messages-Send-From-Mode" /></p>

<p>在上述情况下，<code>leadingTerminal</code> 的订阅者（模型）并不会收到消息，它的订阅者（视图）只会在 <code>followingTerminal</code> 收到消息时才会接受到新的值。</p>

<p>同时，<code>RACChannel</code> 的绑定都是双向的，视图收到用户的动作，例如点击等事件时，会将消息发送给 <code>followingTerminal</code>，而 <code>followingTerminal</code> 并<strong>不会</strong>将消息发送给自己的订阅者（视图），而是会发送给 <code>leadingTerminal</code>，并通过 <code>leadingTerminal</code> 发送给其订阅者，即模型。</p>

<p><img src="https://img.nju520.me/2017-02-16-Terminals-Between-View-Model.png-1000width" alt="Terminals-Between-View-Mode" /></p>

<p>上图描述了信息在 <code>RACChannel</code> 之间的传递过程，无论是模型属性的改变还是用户对视图进行的操作都会通过这两个 <code>RACChannelTerminal</code> 传递到另一端；同时，由于消息不会发送给自己的订阅者，所以不会造成信息的循环发送。</p>

<h2 id="racchannel-和-racchannelterminal">RACChannel 和 RACChannelTerminal</h2>

<p><code>RACChannel</code> 和 <code>RACChannelTerminal</code> 的关系非常密切，前者可以理解为一个网络连接，后者可以理解为 <code>socket</code>，表示网络连接的一端，下图描述了 <code>RACChannel</code> 与网络连接中概念的一一对应关系。</p>

<p><img src="https://img.nju520.me/2017-02-16-Channel-And-Network-Connection.png-1000width" alt="Channel-And-Network-Connection" /></p>

<ul>
  <li>在客户端使用 <code>write</code> 向 <code>socket</code> 中发送消息时，<code>socket</code> 的持有者客户端不会收到消息，只有在 <code>socket</code> 上调用 <code>read</code> 的服务端才会收到消息；反之亦然。</li>
  <li>在模型使用 <code>sendNext</code> 向<code>leadingTerminal</code> 中发送消息时，<code>leadingTerminal</code> 的订阅者模型不会收到消息，只有在 <code>followingTerminal</code> 上调用 <code>subscribe</code> 的视图才会收到消息；反之亦然。</li>
</ul>

<h3 id="racchannelterminal-的实现">RACChannelTerminal 的实现</h3>

<p>为什么向 <code>RACChannelTerminal</code> 发送消息，它的订阅者获取不到？先来看一下它在头文件中的定义：</p>

<pre><code class="language-objectivec">@interface RACChannelTerminal : RACSignal &lt;RACSubscriber&gt;
@end
</code></pre>

<p><code>RACChannelTerminal</code> 是一个信号的子类，同时它还遵循了 <code>RACSubscriber</code> 协议，也就是可以向它调用 <code>-sendNext:</code> 等方法；<code>RAChannelTerminal</code> 中持有了两个对象：</p>

<p><img src="https://img.nju520.me/2017-02-16-RACChannelTerminal-Interface.png-1000width" alt="RACChannelTerminal-Interface" /></p>

<p>在初始化时，需要传入 <code>values</code> 和 <code>otherTerminal</code> 这两个属性，其中 <code>values</code> 表示当前断点，<code>otherTerminal</code> 表示远程端点：</p>

<pre><code class="language-objectivec">- (instancetype)initWithValues:(RACSignal *)values otherTerminal:(id&lt;RACSubscriber&gt;)otherTerminal {
	self = [super init];
	_values = values;
	_otherTerminal = otherTerminal;
	return self;
}
</code></pre>

<p>当然，作为 <code>RACSignal</code> 的子类，<code>RACChannelTerminal</code> 必须覆写 <code>-subscribe:</code> 方法：</p>

<pre><code class="language-objectivec">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber {
	return [self.values subscribe:subscriber];
}
</code></pre>

<p>在订阅者调用 <code>-subscribeNext:</code> 等方法发起订阅时，实际上订阅的是当前端点；如果向当前端点发送消息，会被转发到远程端点上，而这也就是当前端点的订阅者不会接收到向当前端点发送消息的原因：</p>

<pre><code class="language-objectivec">- (void)sendNext:(id)value {
	[self.otherTerminal sendNext:value];
}
- (void)sendError:(NSError *)error {
	[self.otherTerminal sendError:error];
}
- (void)sendCompleted {
	[self.otherTerminal sendCompleted];
}
</code></pre>

<h3 id="racchannel-的初始化">RACChannel 的初始化</h3>

<p>我们在任何情况下都不应该直接使用 <code>-init</code> 方法初始化 <code>RACChannelTerminal</code> 的实例，而是应该以创建 <code>RACChannel</code> 的方式生成它：</p>

<pre><code class="language-objectivec">- (instancetype)init {
	self = [super init];

	RACReplaySubject *leadingSubject = [RACReplaySubject replaySubjectWithCapacity:0];
	RACReplaySubject *followingSubject = [RACReplaySubject replaySubjectWithCapacity:1];

	[[leadingSubject ignoreValues] subscribe:followingSubject];
	[[followingSubject ignoreValues] subscribe:leadingSubject];

	_leadingTerminal = [[RACChannelTerminal alloc] initWithValues:leadingSubject otherTerminal:followingSubject];
	_followingTerminal = [[RACChannelTerminal alloc] initWithValues:followingSubject otherTerminal:leadingSubject];

	return self;
}
</code></pre>

<p>两个 <code>RACChannelTerminal</code> 中包装的其实是两个 <code>RACSubject</code> 热信号，它们既可以作为订阅者，也可以接收其他对象发送的消息；我们并不希望 <code>leadingSubject</code> 有任何的初始值，但是我们需要 <code>error</code> 和 <code>completed</code> 信息可以被重播。</p>

<p><img src="https://img.nju520.me/2017-02-16-Sending-Errors-And-Completed-Messages.png-1000width" alt="Sending-Errors-And-Completed-Messages" /></p>

<p>通过 <code>-ignoreValues</code> 和 <code>-subscribe:</code> 方法，<code>leadingSubject</code> 和 <code>followingSubject</code> 两个热信号中产生的错误会互相发送，这是为了防止连接的两端一边发生了错误，另一边还继续工作的情况的出现。</p>

<p>在初始化方法的最后，生成两个 <code>RACChannelTerminal</code> 实例的过程就不多说了。</p>

<h2 id="racchannel-与-uikit-组件">RACChannel 与 UIKit 组件</h2>

<p>如果在整个 ReactiveCocoa 工程中搜索 <code>RACChannel</code>，你会发现以下的 UIKit 组件都与 <code>RACChannel</code> 有着非常密切的关系：</p>

<p><img src="https://img.nju520.me/2017-02-16-RACChannel-Hierachy.png-1000width" alt="RACChannel-Hierachy" /></p>

<p>UIKit 中的这些组件都提供了使用 <code>RACChannel</code> 的接口，用以降低数据双向绑定的复杂度，我们以 <code>UITextField</code> 为例，它在分类的接口中提供了 <code>rac_newTextChannel</code> 方法：</p>

<pre><code class="language-objectivec">- (RACChannelTerminal *)rac_newTextChannel {
	return [self rac_channelForControlEvents:UIControlEventAllEditingEvents key:@keypath(self.text) nilValue:@""];
}
</code></pre>

<p>上述方法用于返回一个一端绑定 <code>UIControlEventAllEditingEvents</code> 事件的 <code>RACChannelTerminal</code> 对象。</p>

<p><img src="https://img.nju520.me/2017-02-16-UITextField-RACChannel-Interface.png-1000width" alt="UITextField-RACChannel-Interface" /></p>

<p><code>UIControlEventAllEditingEvents</code> 事件发生时，它会将自己的 <code>text</code> 属性作为信号发送到 <code>followingTerminal -&gt; leadingTerminal</code> 管道中，最后发送给 <code>leadingTerminal</code> 的订阅者。</p>

<p>在 <code>rac_newTextChannel</code> 中调用的方法 <code>-rac_channelForControlEvents:key:nilValue:</code> 是一个 <code>UIControl</code> 的私有方法：</p>

<pre><code class="language-objectivec">- (RACChannelTerminal *)rac_channelForControlEvents:(UIControlEvents)controlEvents key:(NSString *)key nilValue:(id)nilValue {
	key = [key copy];
	RACChannel *channel = [[RACChannel alloc] init];

	RACSignal *eventSignal = [[[self
		rac_signalForControlEvents:controlEvents]
		mapReplace:key]
		takeUntil:[[channel.followingTerminal
			ignoreValues]
			catchTo:RACSignal.empty]];
	[[self
		rac_liftSelector:@selector(valueForKey:) withSignals:eventSignal, nil]
		subscribe:channel.followingTerminal];

	RACSignal *valuesSignal = [channel.followingTerminal
		map:^(id value) {
			return value ?: nilValue;
		}];
	[self rac_liftSelector:@selector(setValue:forKey:) withSignals:valuesSignal, [RACSignal return:key], nil];

	return channel.leadingTerminal;
}
</code></pre>

<p>这个方法为所有的 <code>UIControl</code> 子类，包括 <code>UITextField</code>、<code>UISegmentedControl</code> 等等，它的主要作用就是当传入的 <code>controlEvents</code> 事件发生时，将 UIKit 组件的属性 <code>key</code> 发送到返回的 <code>RACChannelTerminal</code> 实例中；同时，在向返回的 <code>RACChannelTerminal</code> 实例中发送消息时，也会自动更新 UIKit 组件的属性。</p>

<p>上面的代码在初始化 <code>RACChannel</code> 之后做了两件事情，首先是在 <code>UIControlEventAllEditingEvents</code> 事件发生时，将 <code>text</code> 属性发送到 <code>followingTerminal</code> 中：</p>

<pre><code class="language-objectivec">RACSignal *eventSignal = [[[self
    rac_signalForControlEvents:controlEvents]
    mapReplace:key]
    takeUntil:[[channel.followingTerminal
        ignoreValues]
        catchTo:RACSignal.empty]];
[[self
    rac_liftSelector:@selector(valueForKey:) withSignals:eventSignal, nil]
    subscribe:channel.followingTerminal];
</code></pre>

<p>第二个是在 <code>followingTerminal</code> 接收到来自 <code>leadingTerminal</code> 的消息时，更新 <code>UITextField</code> 的 <code>text</code> 属性。</p>

<pre><code class="language-objectivec">RACSignal *valuesSignal = [channel.followingTerminal
    map:^(id value) {
        return value ?: nilValue;
    }];
[self rac_liftSelector:@selector(setValue:forKey:) withSignals:valuesSignal, [RACSignal return:key], nil];
</code></pre>

<p>这两件事情都是通过 <code>-rac_liftSelector:withSignals:</code> 方法来完成的，不过，我们不会在这篇文章中介绍这个方法。</p>

<h2 id="racchannel-与-kvo">RACChannel 与 KVO</h2>

<p><code>RACChannel</code> 不仅为 UIKit 组件提供了接口，还为键值观测提供了 <code>RACKVOChannel</code> 来高效地完成双向绑定；<code>RACKVOChannel</code> 是 <code>RACChannel</code> 的子类：</p>

<p><img src="https://img.nju520.me/2017-02-16-RACKVOChannel.png-1000width" alt="RACKVOChanne" /></p>

<p>在 <code>RACKVOChannel</code> 提供的接口中，我们一般都会使用 <code>RACChannelTo</code> 来观测某一个对象的对应属性，三个参数依次为对象、属性和默认值：</p>

<pre><code class="language-objectivec">RACChannelTerminal *integerChannel = RACChannelTo(self, integerProperty, @42);
</code></pre>

<p>而 <code>RACChannelTo</code> 是 <code>RACKVOChannel</code> 头文件中的一个宏，上面的表达式可以展开成为：</p>

<pre><code class="language-objectivec">RACChannelTerminal *integerChannel = [[RACKVOChannel alloc] initWithTarget:self keyPath:@"integerProperty" nilValue:@42][@"followingTerminal"];
</code></pre>

<p>该宏初始化了一个 <code>RACKVOChannel</code> 对象，并通过方括号的方式获取其中的 <code>followingTerminal</code>，这种获取类属性的方式是通过覆写以下的两个方法实现的：</p>

<pre><code class="language-objectivec">- (RACChannelTerminal *)objectForKeyedSubscript:(NSString *)key {
	RACChannelTerminal *terminal = [self valueForKey:key];
	return terminal;
}

- (void)setObject:(RACChannelTerminal *)otherTerminal forKeyedSubscript:(NSString *)key {
	RACChannelTerminal *selfTerminal = [self objectForKeyedSubscript:key];
	[otherTerminal subscribe:selfTerminal];
	[[selfTerminal skip:1] subscribe:otherTerminal];
}
</code></pre>

<p>又由于覆写了这两个方法，在 <code>-setObject:forKeyedSubscript:</code> 时会自动调用 <code>-subscribe:</code> 方法完成双向绑定，所以我们可以使用 <code>=</code> 来对两个 <code>RACKVOChannel</code> 进行双向绑定：</p>

<pre><code class="language-objectivec">RACChannelTo(view, property) = RACChannelTo(model, property);

[[RACKVOChannel alloc] initWithTarget:view keyPath:@"property" nilValue:nil][@"followingTerminal"] = [[RACKVOChannel alloc] initWithTarget:model keyPath:@"property" nilValue:nil][@"followingTerminal"];
</code></pre>

<p>以上的两种方式是完全等价的，它们都会在对方的属性更新时更新自己的属性。</p>

<p><img src="https://img.nju520.me/2017-02-16-RACChannelTo-Model-View.png-1000width" alt="RACChannelTo-Model-Vie" /></p>

<p>实现的方式其实与 <code>RACChannel</code> 差不多，这里不会深入到代码中进行介绍，与 <code>RACChannel</code> 的区别是，<code>RACKVOChannel</code> 并没有暴露出 <code>leadingTerminal</code> 而是 <code>followingTerminal</code>：</p>

<p><img src="https://img.nju520.me/2017-02-16-RACChannelTo-And-Property.png-1000width" alt="RACChannelTo-And-Property" /></p>

<h2 id="racchannel-实战">RACChannel 实战</h2>

<p>这一小节通过一个简单的例子来解释如何使用 <code>RACChannel</code> 进行双向数据绑定。</p>

<p><img src="https://img.nju520.me/2017-02-16-TextField-With-Channel.gif" alt="TextField-With-Channe" /></p>

<p>在整个视图上有两个 <code>UITextField</code>，我们想让这两个 <code>UITextField</code> <code>text</code> 的值相互绑定，在一个 <code>UITextField</code> 编辑时也改变另一个 <code>UITextField</code> 中的内容：</p>

<pre><code class="language-objectivec">@property (weak, nonatomic) IBOutlet UITextField *textField;
@property (weak, nonatomic) IBOutlet UITextField *anotherTextField;
</code></pre>

<p>实现的过程非常简单，分别获取两个 <code>UITextField</code> 的 <code>rac_newTextChannel</code> 属性，并让它们订阅彼此的内容：</p>

<pre><code class="language-objectivec">[self.textField.rac_newTextChannel subscribe:self.anotherTextField.rac_newTextChannel];
[self.anotherTextField.rac_newTextChannel subscribe:self.textField.rac_newTextChannel];
</code></pre>

<p>这样在使用两个文本输入框时就能达到预期的效果了，这是一个非常简单的例子，可以得到如下的结构图。</p>

<p><img src="https://img.nju520.me/2017-02-16-Two-UITextField-With-RACChannel.png-1000width" alt="Two-UITextField-With-RACChanne" /></p>

<p>两个 <code>UITextField</code> 通过 <code>RACChannel</code> 互相影响，在对方属性更新时同时更新自己的属性。</p>

<h2 id="总结">总结</h2>

<p><code>RACChannel</code> 非常适合于视图和模型之间的双向绑定，在对方的属性或者状态更新时及时通知自己，达到预期的效果；我们可以使用 ReactiveCocoa 中内置的很多与 <code>RACChannel</code> 有关的方法，来获取开箱即用的 <code>RACChannelTerminal</code>，当然也可以使用 <code>RACChannelTo</code> 通过 <code>RACKVOChannel</code> 来快速绑定类与类的属性。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://spin.atomicobject.com/2015/05/04/bi-directional-data-bindings-reactivecocoa/">Bi-directional Data Bindings in ReactiveCocoa with RACChannel</a></li>
  <li><a href="http://tech.meituan.com/ReactiveCocoaSignalFlow.html">ReactiveCocoa 核心元素与信号流</a></li>
</ul>

<blockquote>
  <p>Github Repo：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://nju520.me/racchannel</p>
</blockquote>

  ]]></description>
</item>

<item>
  <title>用于多播的 RACMulticastConnection</title>
  <link>//racconnection</link>
  <author>nju520</author>
  <pubDate>2017-02-15T15:21:01+08:00</pubDate>
  <guid>//racconnection</guid>
  <description><![CDATA[
  <p>ReactiveCocoa 中的信号信号在默认情况下都是冷的，每次有新的订阅者订阅信号时都会执行信号创建时传入的 block；这意味着对于任意一个订阅者，所需要的数据都会<strong>重新计算</strong>，这在大多数情况下都是开发者想看到的情况，但是这在信号中的 block 有副作用或者较为昂贵时就会有很多问题。</p>

<p><img src="https://img.nju520.me/2017-02-15-RACMulticastConnection.png-1000width" alt="RACMulticastConnection" /></p>

<p>我们希望有一种模型能够将冷信号转变成热信号，并在合适的时间触发，向所有的订阅者发送消息；而今天要介绍的 <code>RACMulticastConnection</code> 就是用于解决上述问题的。</p>

<h2 id="racmulticastconnection-简介">RACMulticastConnection 简介</h2>

<p><code>RACMulticastConnection</code> 封装了将一个信号的订阅分享给多个订阅者的思想，它的每一个对象都持有两个 <code>RACSignal</code>：</p>

<p><img src="https://img.nju520.me/2017-02-15-RACMulticastConnection-Interface.png-1000width" alt="RACMulticastConnection-Interface" /></p>

<p>一个是私有的源信号 <code>sourceSignal</code>，另一个是用于广播的信号 <code>signal</code>，其实是一个 <code>RACSubject</code> 对象，不过对外只提供 <code>RACSignal</code> 接口，用于使用者通过 <code>-subscribeNext:</code> 等方法进行订阅。</p>

<h2 id="racmulticastconnection-的初始化">RACMulticastConnection 的初始化</h2>

<p><code>RACMulticastConnection</code> 有一个非常简单的初始化方法 <code>-initWithSourceSignal:subject:</code>，不过这个初始化方法是私有的：</p>

<pre><code class="language-objectivec">- (instancetype)initWithSourceSignal:(RACSignal *)source subject:(RACSubject *)subject {
	self = [super init];

	_sourceSignal = source;
	_serialDisposable = [[RACSerialDisposable alloc] init];
	_signal = subject;

	return self;
}
</code></pre>

<p>在 <code>RACMulticastConnection</code> 的头文件的注释中，对它的初始化有这样的说明：</p>

<blockquote>
  <p>Note that you shouldn’t create RACMulticastConnection manually. Instead use -publish or -multicast:.</p>
</blockquote>

<p>我们不应该直接使用 <code>-initWithSourceSignal:subject:</code> 来初始化一个对象，我们应该通过 <code>RACSignal</code> 的实例方法初始化 <code>RACMulticastConnection</code> 实例。</p>

<pre><code class="language-objectivec">- (RACMulticastConnection *)publish {
	RACSubject *subject = [RACSubject subject];
	RACMulticastConnection *connection = [self multicast:subject];
	return connection;
}

- (RACMulticastConnection *)multicast:(RACSubject *)subject {
	RACMulticastConnection *connection = [[RACMulticastConnection alloc] initWithSourceSignal:self subject:subject];
	return connection;
}
</code></pre>

<p>这两个方法 <code>-publish</code> 和 <code>-multicast:</code> 都是对初始化方法的封装，并且都会返回一个 <code>RACMulticastConnection</code> 对象，传入的 <code>sourceSignal</code> 就是当前信号，<code>subject</code> 就是用于对外广播的 <code>RACSubject</code> 对象。</p>

<h2 id="racsignal-和-racmulticastconnection">RACSignal 和 RACMulticastConnection</h2>

<p>网络请求在客户端其实是一个非常昂贵的操作，也算是多级缓存中最慢的一级，在使用 ReactiveCocoa 处理业务需求中经常会遇到下面的情况：</p>

<pre><code class="language-objectivec">RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
    NSLog(@"Send Request");
    NSURL *url = [NSURL URLWithString:@"http://localhost:3000"];
    AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:url];
    NSString *URLString = [NSString stringWithFormat:@"/api/products/1"];
    NSURLSessionDataTask *task = [manager GET:URLString parameters:nil progress:nil
                                      success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) {
                                          [subscriber sendNext:responseObject];
                                          [subscriber sendCompleted];
                                      } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
                                          [subscriber sendError:error];
                                      }];
    return [RACDisposable disposableWithBlock:^{
        [task cancel];
    }];
}];

[requestSignal subscribeNext:^(id  _Nullable x) {
    NSLog(@"product: %@", x);
}];

[requestSignal subscribeNext:^(id  _Nullable x) {
    NSNumber *productId = [x objectForKey:@"id"];
    NSLog(@"productId: %@", productId);
}];
</code></pre>

<p>通过订阅发出网络请求的信号经常会被多次订阅，以满足不同 UI 组件更新的需求，但是以上代码却有非常严重的问题。</p>

<p><img src="https://img.nju520.me/2017-02-15-RACSignal-And-Subscribe.png-1000width" alt="RACSignal-And-Subscribe" /></p>

<p>每一次在 <code>RACSignal</code> 上执行 <code>-subscribeNext:</code> 以及类似方法时，都会发起一次新的网络请求，我们希望避免这种情况的发生。</p>

<p>为了解决上述问题，我们使用了 <code>-publish</code> 方法获得一个多播对象 <code>RACMulticastConnection</code>，更改后的代码如下：</p>

<pre><code class="language-objectivec">RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) {
    NSLog(@"Send Request");
    ...
}] publish];

[connection.signal subscribeNext:^(id  _Nullable x) {
    NSLog(@"product: %@", x);
}];
[connection.signal subscribeNext:^(id  _Nullable x) {
    NSNumber *productId = [x objectForKey:@"id"];
    NSLog(@"productId: %@", productId);
}];

[connection connect];
</code></pre>

<p>在这个例子中，我们使用 <code>-publish</code> 方法生成实例，订阅者不再订阅源信号，而是订阅 <code>RACMulticastConnection</code> 中的 <code>RACSubject</code> 热信号，最后通过 <code>-connect</code> 方法触发源信号中的任务。</p>

<p><img src="https://img.nju520.me/2017-02-15-RACSignal-RACMulticastConnection-Connect.png-1000width" alt="RACSignal-RACMulticastConnection-Connect" /></p>

<blockquote>
  <p>对于热信号不了解的读者，可以阅读这篇文章 <a href="https://github.com/nju520/iOS-Source-Code-Analyze/blob/master/contents/ReactiveObjC/RACSubject.md">『可变』的热信号 RACSubject</a>。</p>
</blockquote>

<h3 id="publish-和-multicast-方法">publish 和 multicast 方法</h3>

<p>我们再来看一下 <code>-publish</code> 和 <code>-multicast:</code> 这两个方法的实现：</p>

<pre><code class="language-objectivec">- (RACMulticastConnection *)publish {
	RACSubject *subject = [RACSubject subject];
	RACMulticastConnection *connection = [self multicast:subject];
	return connection;
}

- (RACMulticastConnection *)multicast:(RACSubject *)subject {
	RACMulticastConnection *connection = [[RACMulticastConnection alloc] initWithSourceSignal:self subject:subject];
	return connection;
}
</code></pre>

<p>当 <code>-publish</code> 方法调用时相当于向 <code>-multicast:</code> 传入了 <code>RACSubject</code>。</p>

<p><img src="https://img.nju520.me/2017-02-15-publish-and-multicast.png-1000width" alt="publish-and-multicast" /></p>

<p><code>-publish</code> 只是对 <code>-multicast:</code> 方法的简单封装，它们都是通过 <code>RACMulticastConnection</code> 私有的初始化方法 <code>-initWithSourceSignal:subject:</code> 创建一个新的实例。</p>

<p>在使用 <code>-multicast:</code> 方法时，传入的信号其实就是用于广播的信号；这个信号必须是一个 <code>RACSubject</code> 本身或者它的子类：</p>

<p><img src="https://img.nju520.me/2017-02-15-RACSubject - Subclasses.png-1000width" alt="RACSubject - Subclasses" /></p>

<p>传入 <code>-multicast:</code> 方法的一般都是 <code>RACSubject</code> 或者 <code>RACReplaySubject</code> 对象。</p>

<h3 id="订阅源信号的时间点">订阅源信号的时间点</h3>

<p>订阅 <code>connection.signal</code> 中的数据流时，其实只是向多播对象中的热信号 <code>RACSubject</code> 持有的数组中加入订阅者，而这时刚刚创建的 <code>RACSubject</code> 中并没有任何的消息。</p>

<p><img src="https://img.nju520.me/2017-02-15-SubscribeNext-To-RACSubject-Before-Connect.png-1000width" alt="SubscribeNext-To-RACSubject-Before-Connect" /></p>

<p>只有在调用 <code>-connect</code> 方法之后，<code>RACSubject</code> 才会<strong>订阅</strong>源信号 <code>sourceSignal</code>。</p>

<pre><code class="language-objectivec">- (RACDisposable *)connect {
	self.serialDisposable.disposable = [self.sourceSignal subscribe:_signal];
	return self.serialDisposable;
}
</code></pre>

<p>这时源信号的 <code>didSubscribe</code> 代码块才会执行，向 <code>RACSubject</code> 推送消息，消息向下继续传递到 <code>RACSubject</code> 所有的订阅者中。</p>

<p><img src="https://img.nju520.me/2017-02-15-Values-From-RACSignal-To-Subscribers.png-1000width" alt="Values-From-RACSignal-To-Subscribers" /></p>

<p><code>-connect</code> 方法通过 <code>-subscribe:</code> 实际上建立了 <code>RACSignal</code> 和 <code>RACSubject</code> 之间的连接，这种方式保证了 <code>RACSignal</code> 中的 <code>didSubscribe</code> 代码块只执行了一次。</p>

<p>所有的订阅者不再订阅原信号，而是订阅 <code>RACMulticastConnection</code> 持有的热信号 <code>RACSubject</code>，实现对冷信号的一对多传播。</p>

<p>在 <code>RACMulticastConnection</code> 中还有另一个用于连接 <code>RACSignal</code> 和 <code>RACSubject</code> 信号的 <code>-autoconnect</code> 方法：</p>

<pre><code class="language-objectivec">- (RACSignal *)autoconnect {
	__block volatile int32_t subscriberCount = 0;
	return [RACSignal
		createSignal:^(id&lt;RACSubscriber&gt; subscriber) {
			OSAtomicIncrement32Barrier(&amp;subscriberCount);
			RACDisposable *subscriptionDisposable = [self.signal subscribe:subscriber];
			RACDisposable *connectionDisposable = [self connect];

			return [RACDisposable disposableWithBlock:^{
				[subscriptionDisposable dispose];
				if (OSAtomicDecrement32Barrier(&amp;subscriberCount) == 0) {
					[connectionDisposable dispose];
				}
			}];
		}];
}
</code></pre>

<p>它保证了在 <code>-autoconnect</code> 方法返回的对象被第一次订阅时，就会建立源信号与热信号之间的连接。</p>

<h3 id="使用-racreplaysubject-订阅源信号">使用 RACReplaySubject 订阅源信号</h3>

<p>虽然使用 <code>-publish</code> 方法已经能够解决大部分问题了，但是在 <code>-connect</code> 方法调用之后才订阅的订阅者并不能收到消息。</p>

<p>如何才能保存 <code>didSubscribe</code> 执行过程中发送的消息，并在 <code>-connect</code> 调用之后也可以收到消息？这时，我们就要使用 <code>-multicast:</code> 方法和 <code>RACReplaySubject</code> 来完成这个需求了。</p>

<pre><code class="language-objectivec">RACSignal *sourceSignal = [RACSignal createSignal:...];
RACMulticastConnection *connection = [sourceSignal multicast:[RACReplaySubject subject]];
[connection.signal subscribeNext:^(id  _Nullable x) {
    NSLog(@"product: %@", x);
}];
[connection connect];
[connection.signal subscribeNext:^(id  _Nullable x) {
    NSNumber *productId = [x objectForKey:@"id"];
    NSLog(@"productId: %@", productId);
}];
</code></pre>

<p>除了使用上述的代码，也有一个更简单的方式创建包含 <code>RACReplaySubject</code> 对象的 <code>RACMulticastConnection</code>：</p>

<pre><code class="language-objectivec">RACSignal *signal = [[RACSignal createSignal:...] replay];
[signal subscribeNext:^(id  _Nullable x) {
    NSLog(@"product: %@", x);
}];
[signal subscribeNext:^(id  _Nullable x) {
    NSNumber *productId = [x objectForKey:@"id"];
    NSLog(@"productId: %@", productId);
}];
</code></pre>

<p><code>-replay</code> 方法和 <code>-publish</code> 差不多，只是内部封装的热信号不同，并在方法调用时就连接原信号：</p>

<pre><code class="language-objectivec">- (RACSignal *)replay {
	RACReplaySubject *subject = [RACReplaySubject subject];
	RACMulticastConnection *connection = [self multicast:subject];
	[connection connect];
	return connection.signal;
}
</code></pre>

<p>除了 <code>-replay</code> 方法，<code>RACSignal</code> 中还定义了与 <code>RACMulticastConnection</code> 中相关的其它 <code>-replay</code> 方法：</p>

<pre><code class="language-objectivec">- (RACSignal&lt;ValueType&gt; *)replay;
- (RACSignal&lt;ValueType&gt; *)replayLast;
- (RACSignal&lt;ValueType&gt; *)replayLazily;
</code></pre>

<p>三个方法都会在 <code>RACMulticastConnection</code> 初始化时传入一个 <code>RACReplaySubject</code> 对象，不过却有一点细微的差别：</p>

<p><img src="https://img.nju520.me/2017-02-15-Difference-Between-Replay-Methods.png-1000width" alt="Difference-Between-Replay-Methods" /></p>

<p>相比于 <code>-replay</code> 方法，<code>-replayLast</code> 方法生成的 <code>RACMulticastConnection</code> 中热信号的容量为 <code>1</code>：</p>

<pre><code class="language-objectivec">- (RACSignal *)replayLast {
	RACReplaySubject *subject = [RACReplaySubject replaySubjectWithCapacity:1];
	RACMulticastConnection *connection = [self multicast:subject];
	[connection connect];
	return connection.signal;
}
</code></pre>

<p>而 <code>replayLazily</code> 会在返回的信号被<strong>第一次订阅</strong>时，才会执行 <code>-connect</code> 方法：</p>

<pre><code class="language-objectivec">- (RACSignal *)replayLazily {
	RACMulticastConnection *connection = [self multicast:[RACReplaySubject subject]];
	return [RACSignal
		defer:^{
			[connection connect];
			return connection.signal;
		}];
}
</code></pre>

<h2 id="总结">总结</h2>

<p><code>RACMulticastConnection</code> 在处理冷热信号相互转换时非常好用，在 <code>RACSignal</code> 中也提供了很多将原有的冷信号通过 <code>RACMulticastConnection</code> 转换成热信号的方法。</p>

<p><img src="https://img.nju520.me/2017-02-15-RACMulticastConnection.png-1000width" alt="RACMulticastConnection" /></p>

<p>在遇到冷信号中的行为有副作用后者非常昂贵时，我们就可以使用这些方法将单播变成多播，提高执行效率，减少副作用。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://github.com/nju520/iOS-Source-Code-Analyze/blob/master/contents/ReactiveObjC/RACSubject.md">『可变』的热信号 RACSubject</a></li>
  <li><a href="http://williamzang.com/blog/2015/08/18/talk-about-reactivecocoas-cold-signal-and-hot-signal/">细说 ReactiveCocoa 的冷信号与热信号</a></li>
</ul>

<blockquote>
  <p>Github Repo：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://nju520.me/racconnection</p>
</blockquote>

  ]]></description>
</item>


  </channel>
</rss>
