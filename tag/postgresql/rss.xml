<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    
    <title>nju520.me</title>
    
    <link>http://localhost:4000</link>
    <description>nju520's Blog</description>
    <language>en-uk</language>
    <managingEditor> nju520</managingEditor>
    <atom:link href="rss" rel="self" type="application/rss+xml" />
    
<item>
  <title>浅谈数据库并发控制 - 锁和 MVCC</title>
  <link>//database-concurrency-control</link>
  <author>nju520</author>
  <pubDate>2017-10-01T00:00:00+08:00</pubDate>
  <guid>//database-concurrency-control</guid>
  <description><![CDATA[
  <p>在学习几年编程之后，你会发现所有的问题都没有简单、快捷的解决方案，很多问题都需要权衡和妥协，而本文介绍的就是数据库在并发性能和可串行化之间做的权衡和妥协 - 并发控制机制。</p>

<p><img src="https://img.nju520.me/2017-10-02-tradeoff-between-performance-and-serializability.png" alt="tradeoff-between-performance-and-serializability" /></p>

<p>如果数据库中的所有事务都是串行执行的，那么它非常容易成为整个应用的性能瓶颈，虽然说没法水平扩展的节点在最后都会成为瓶颈，但是串行执行事务的数据库会加速这一过程；而并发（Concurrency）使一切事情的发生都有了可能，它能够解决一定的性能问题，但是它会带来更多诡异的错误。</p>

<p>引入了并发事务之后，如果不对事务的执行进行控制就会出现各种各样的问题，你可能没有享受到并发带来的性能提升就已经被各种奇怪的问题折磨的欲仙欲死了。</p>

<h2 id="概述">概述</h2>

<p>如何控制并发是数据库领域中非常重要的问题之一，不过到今天为止事务并发的控制已经有了很多成熟的解决方案，而这些方案的原理就是这篇文章想要介绍的内容，文章中会介绍最为常见的三种并发控制机制：</p>

<p><img src="https://img.nju520.me/2017-10-02-pessimistic-optimistic-multiversion-conccurency-control.png" alt="pessimistic-optimistic-multiversion-conccurency-control" /></p>

<p>分别是悲观并发控制、乐观并发控制和多版本并发控制，其中悲观并发控制其实是最常见的并发控制机制，也就是锁；而乐观并发控制其实也有另一个名字：乐观锁，乐观锁其实并不是一种真实存在的锁，我们会在文章后面的部分中具体介绍；最后就是多版本并发控制（MVCC）了，与前两者对立的命名不同，MVCC 可以与前两者中的任意一种机制结合使用，以提高数据库的读性能。</p>

<p>既然这篇文章介绍了不同的并发控制机制，那么一定会涉及到不同事务的并发，我们会通过示意图的方式分析各种机制是如何工作的。</p>

<h2 id="悲观并发控制">悲观并发控制</h2>

<p>控制不同的事务对同一份数据的获取是保证数据库的一致性的最根本方法，如果我们能够让事务在同一时间对同一资源有着独占的能力，那么就可以保证操作同一资源的不同事务不会相互影响。</p>

<p><img src="https://img.nju520.me/2017-10-02-pessimistic-conccurency-control.png" alt="pessimistic-conccurency-control" /></p>

<p>最简单的、应用最广的方法就是使用锁来解决，当事务需要对资源进行操作时需要先获得资源对应的锁，保证其他事务不会访问该资源后，在对资源进行各种操作；在悲观并发控制中，数据库程序对于数据被修改持悲观的态度，在数据处理的过程中都会被锁定，以此来解决竞争的问题。</p>

<h3 id="读写锁">读写锁</h3>

<p>为了最大化数据库事务的并发能力，数据库中的锁被设计为两种模式，分别是共享锁和互斥锁。当一个事务获得共享锁之后，它只可以进行读操作，所以共享锁也叫读锁；而当一个事务获得一行数据的互斥锁时，就可以对该行数据进行读和写操作，所以互斥锁也叫写锁。</p>

<p><img src="https://img.nju520.me/2017-10-02-Shared-Exclusive-Lock.png" alt="Shared-Exclusive-Lock" /></p>

<p>共享锁和互斥锁除了限制事务能够执行的读写操作之外，它们之间还有『共享』和『互斥』的关系，也就是多个事务可以同时获得某一行数据的共享锁，但是互斥锁与共享锁和其他的互斥锁并不兼容，我们可以很自然地理解这么设计的原因：多个事务同时写入同一数据难免会发生各种诡异的问题。</p>

<p><img src="https://img.nju520.me/2017-10-02-lock-and-wait.png" alt="lock-and-wait" /></p>

<p>如果当前事务没有办法获取该行数据对应的锁时就会陷入等待的状态，直到其他事务将当前数据对应的锁释放才可以获得锁并执行相应的操作。</p>

<h3 id="两阶段锁协议">两阶段锁协议</h3>

<p>两阶段锁协议（2PL）是一种能够保证事务可串行化的协议，它将事务的获取锁和释放锁划分成了增长（Growing）和缩减（Shrinking）两个不同的阶段。</p>

<p><img src="https://img.nju520.me/2017-10-02-growing-to-shrinking.png" alt="growing-to-shrinking" /></p>

<p>在增长阶段，一个事务可以获得锁但是不能释放锁；而在缩减阶段事务只可以释放锁，并不能获得新的锁，如果只看 2PL 的定义，那么到这里就已经介绍完了，但是它还有两个变种：</p>

<ol>
  <li><strong>Strict 2PL</strong>：事务持有的<strong>互斥</strong>锁必须在提交后再释放；</li>
  <li><strong>Rigorous 2PL</strong>：事务持有的<strong>所有</strong>锁必须在提交后释放；</li>
</ol>

<p><img src="https://img.nju520.me/2017-10-02-two-phase-locking.png" alt="two-phase-locking" /></p>

<p>虽然锁的使用能够为我们解决不同事务之间由于并发执行造成的问题，但是两阶段锁的使用却引入了另一个严重的问题，死锁；不同的事务等待对方已经锁定的资源就会造成死锁，我们在这里举一个简单的例子：</p>

<p><img src="https://img.nju520.me/2017-10-02-deadlock.png" alt="deadlock" /></p>

<p>两个事务在刚开始时分别获取了 draven 和 beacon 资源上面的锁，然后再请求对方已经获得的锁时就会发生死锁，双方都没有办法等到锁的释放，如果没有死锁的处理机制就会无限等待下去，两个事务都没有办法完成。</p>

<h3 id="死锁的处理">死锁的处理</h3>

<p>死锁在多线程编程中是经常遇到的事情，一旦涉及多个线程对资源进行争夺就需要考虑当前的几个线程或者事务是否会造成死锁；解决死锁大体来看有两种办法，一种是从源头杜绝死锁的产生和出现，另一种是允许系统进入死锁的状态，但是在系统出现死锁时能够及时发现并且进行恢复。</p>

<p><img src="https://img.nju520.me/2017-10-02-deadlock-handling.png" alt="deadlock-handling" /></p>

<h4 id="预防死锁">预防死锁</h4>

<p>有两种方式可以帮助我们预防死锁的出现，一种是保证事务之间的等待不会出现环，也就是事务之间的等待图应该是一张<strong>有向无环图</strong>，没有循环等待的情况或者保证一个事务中想要获得的所有资源都在事务开始时以原子的方式被锁定，所有的资源要么被锁定要么都不被锁定。</p>

<p>但是这种方式有两个问题，在事务一开始时很难判断哪些资源是需要锁定的，同时因为一些很晚才会用到的数据被提前锁定，数据的利用率与事务的并发率也非常的低。一种解决的办法就是按照一定的顺序为所有的数据行加锁，同时与 2PL 协议结合，在加锁阶段保证所有的数据行都是从小到大依次进行加锁的，不过这种方式依然需要事务提前知道将要加锁的数据集。</p>

<p>另一种预防死锁的方法就是使用抢占加事务回滚的方式预防死锁，当事务开始执行时会先获得一个时间戳，数据库程序会根据事务的时间戳决定事务应该等待还是回滚，在这时也有两种机制供我们选择，一种是 wait-die 机制：</p>

<p><img src="https://img.nju520.me/2017-10-02-deadlock-prevention-wait-die.png" alt="deadlock-prevention-wait-die" /></p>

<p>当执行事务的时间戳小于另一事务时，即事务 A 先于 B 开始，那么它就会等待另一个事务释放对应资源的锁，否则就会保持当前的时间戳并回滚。</p>

<p>另一种机制叫做 wound-wait，这是一种抢占的解决方案，它和 wait-die 机制的结果完全相反，当前事务如果先于另一事务执行并请求了另一事务的资源，那么另一事务会立刻回滚，将资源让给先执行的事务，否则就会等待其他事务释放资源：</p>

<p><img src="https://img.nju520.me/2017-10-02-deadlock-prevention-wound-wait.png" alt="deadlock-prevention-wound-wait" /></p>

<p>两种方法都会造成不必要的事务回滚，由此会带来一定的性能损失，更简单的解决死锁的方式就是使用超时时间，但是超时时间的设定是需要仔细考虑的，否则会造成耗时较长的事务无法正常执行，或者无法及时发现需要解决的死锁，所以它的使用还是有一定的局限性。</p>

<h3 id="死锁检测和恢复">死锁检测和恢复</h3>

<p>如果数据库程序无法通过协议从原理上保证死锁不会发生，那么就需要在死锁发生时及时检测到并从死锁状态恢复到正常状态保证数据库程序可以正常工作。在使用检测和恢复的方式解决死锁时，数据库程序需要维护数据和事务之间的引用信息，同时也需要提供一个用于判断当前数据库是否进入死锁状态的算法，最后需要在死锁发生时提供合适的策略及时恢复。</p>

<p>在上一节中我们其实提到死锁的检测可以通过一个有向的等待图来进行判断，如果一个事务依赖于另一个事务正在处理的数据，那么当前事务就会等待另一个事务的结束，这也就是整个等待图中的一条边：</p>

<p><img src="https://img.nju520.me/2017-10-02-deadlock-wait-for-graph.png" alt="deadlock-wait-for-graph" /></p>

<p>如上图所示，如果在这个有向图中出现了环，就说明当前数据库进入了死锁的状态 <code>TransB -&gt; TransE -&gt; TransF -&gt; TransD -&gt; TransB</code>，在这时就需要死锁恢复机制接入了。</p>

<p>如何从死锁中恢复其实非常简单，最常见的解决办法就是选择整个环中一个事务进行回滚，以打破整个等待图中的环，在整个恢复的过程中有三个事情需要考虑：</p>

<p><img src="https://img.nju520.me/2017-10-02-deadlock-recovery.png" alt="deadlock-recovery" /></p>

<p>每次出现死锁时其实都会有多个事务被波及，而选择其中哪一个任务进行回滚是必须要做的事情，在选择牺牲品（Victim）时的黄金原则就是<strong>最小化代价</strong>，所以我们需要综合考虑事务已经计算的时间、使用的数据行以及涉及的事务等因素；当我们选择了牺牲品之后就可以开始回滚了，回滚其实有两种选择一种是全部回滚，另一种是部分回滚，部分回滚会回滚到事务之前的一个检查点上，如果没有检查点那自然没有办法进行部分回滚。</p>

<blockquote>
  <p>在死锁恢复的过程中，其实还可能出现某些任务在多次死锁时都被选择成为牺牲品，一直都不会成功执行，造成饥饿（Starvation），我们需要保证事务会在有穷的时间内执行，所以要在选择牺牲品时将时间戳加入考虑的范围。</p>
</blockquote>

<h3 id="锁的粒度">锁的粒度</h3>

<p>到目前为止我们都没有对不同粒度的锁进行讨论，一直以来我们都讨论的都是数据行锁，但是在有些时候我们希望将多个节点看做一个数据单元，使用锁直接将这个数据单元、表甚至数据库锁定起来。这个目标的实现需要我们在数据库中定义不同粒度的锁：</p>

<p><img src="https://img.nju520.me/2017-10-02-granularity-hierarchy.png" alt="granularity-hierarchy" /></p>

<p>当我们拥有了不同粒度的锁之后，如果某个事务想要锁定整个数据库或者整张表时只需要简单的锁住对应的节点就会在当前节点加上显示（explicit）锁，在所有的子节点上加隐式（implicit）锁；虽然这种不同粒度的锁能够解决父节点被加锁时，子节点不能被加锁的问题，但是我们没有办法在子节点被加锁时，立刻确定父节点不能被加锁。</p>

<p>在这时我们就需要引入<em>意向锁</em>来解决这个问题了，当需要给子节点加锁时，先给所有的父节点加对应的意向锁，意向锁之间是完全不会互斥的，只是用来帮助父节点快速判断是否可以对该节点进行加锁：</p>

<p><img src="https://img.nju520.me/2017-10-02-lock-type-compatibility-matrix.png" alt="lock-type-compatibility-matrix" /></p>

<p>这里是一张引入了两种意向锁，<em>意向共享锁</em>和<em>意向互斥锁</em>之后所有的锁之间的兼容关系；到这里，我们通过不同粒度的锁和意向锁加快了数据库的吞吐量。</p>

<h2 id="乐观并发控制">乐观并发控制</h2>

<p>除了悲观并发控制机制 - 锁之外，我们其实还有其他的并发控制机制，<em>乐观并发控制</em>（Optimistic Concurrency Control）。乐观并发控制也叫乐观锁，但是它并不是真正的锁，很多人都会误以为乐观锁是一种真正的锁，然而它只是一种并发控制的思想。</p>

<p><img src="https://img.nju520.me/2017-10-02-pessimistic-and-optimistic.png" alt="pessimistic-and-optimisti" /></p>

<p>在这一节中，我们将会先介绍<em>基于时间戳的并发控制机制</em>，然后在这个协议的基础上进行扩展，实现乐观的并发控制机制。</p>

<h3 id="基于时间戳的协议">基于时间戳的协议</h3>

<p>锁协议按照不同事务对同一数据项请求的时间依次执行，因为后面执行的事务想要获取的数据已将被前面的事务加锁，只能等待锁的释放，所以基于锁的协议执行事务的顺序与获得锁的顺序有关。在这里想要介绍的基于时间戳的协议能够在事务执行之前先决定事务的执行顺序。</p>

<p>每一个事务都会具有一个全局唯一的时间戳，它即可以使用系统的时钟时间，也可以使用计数器，只要能够保证所有的时间戳都是唯一并且是随时间递增的就可以。</p>

<p><img src="https://img.nju520.me/2017-10-02-timestamp-ordering-protocol.png" alt="timestamp-ordering-protocol" /></p>

<p>基于时间戳的协议能够保证事务并行执行的顺序与事务按照时间戳串行执行的效果完全相同；每一个数据项都有两个时间戳，读时间戳和写时间戳，分别代表了当前成功执行对应操作的事务的时间戳。</p>

<p>该协议能够保证所有冲突的读写操作都能按照时间戳的大小串行执行，在执行对应的操作时不需要关注其他的事务只需要关心数据项对应时间戳的值就可以了：</p>

<p><img src="https://img.nju520.me/2017-10-02-timestamp-ordering-protocol-process.png" alt="timestamp-ordering-protocol-process" /></p>

<p>无论是读操作还是写操作都会从左到右依次比较读写时间戳的值，如果小于当前值就会直接被拒绝然后回滚，数据库系统会给回滚的事务添加一个新的时间戳并重新执行这个事务。</p>

<h3 id="基于验证的协议">基于验证的协议</h3>

<p><em>乐观并发控制</em>其实本质上就是基于验证的协议，因为在多数的应用中只读的事务占了绝大多数，事务之间因为写操作造成冲突的可能非常小，也就是说大多数的事务在不需要并发控制机制也能运行的非常好，也可以保证数据库的一致性；而并发控制机制其实向整个数据库系统添加了很多的开销，我们其实可以通过别的策略降低这部分开销。</p>

<p>而验证协议就是我们找到的解决办法，它根据事务的只读或者更新将所有事务的执行分为两到三个阶段：</p>

<p><img src="https://img.nju520.me/2017-10-02-validation-based-protocol.png" alt="validation-based-protoco" /></p>

<p>在读阶段，数据库会执行事务中的<strong>全部读操作和写操作</strong>，并将所有写后的值存入临时变量中，并不会真正更新数据库中的内容；在这时候会进入下一个阶段，数据库程序会检查当前的改动是否合法，也就是是否有其他事务在 RAED PHASE 期间更新了数据，如果通过测试那么直接就进入 WRITE PHASE 将所有存在临时变量中的改动全部写入数据库，没有通过测试的事务会直接被终止。</p>

<p>为了保证乐观并发控制能够正常运行，我们需要知道一个事务不同阶段的发生时间，包括事务开始时间、验证阶段的开始时间以及写阶段的结束时间；通过这三个时间戳，我们可以保证任意冲突的事务不会同时写入数据库，一旦由一个事务完成了验证阶段就会立即写入，其他读取了相同数据的事务就会回滚重新执行。</p>

<p>作为乐观的并发控制机制，它会假定所有的事务在最终都会通过验证阶段并且执行成功，而锁机制和基于时间戳排序的协议是悲观的，因为它们会在发生冲突时强制事务进行等待或者回滚，哪怕有不需要锁也能够保证事务之间不会冲突的可能。</p>

<h2 id="多版本并发控制">多版本并发控制</h2>

<p>到目前为止我们介绍的并发控制机制其实都是通过延迟或者终止相应的事务来解决事务之间的竞争条件（Race condition）来保证事务的可串行化；虽然前面的两种并发控制机制确实能够从根本上解决并发事务的可串行化的问题，但是在实际环境中数据库的事务大都是只读的，读请求是写请求的很多倍，如果写请求和读请求之前没有并发控制机制，那么最坏的情况也是读请求读到了已经写入的数据，这对很多应用完全是可以接受的。</p>

<p><img src="https://img.nju520.me/2017-10-02-multiversion-scheme.png" alt="multiversion-scheme" /></p>

<p>在这种大前提下，数据库系统引入了另一种并发控制机制 - <em>多版本并发控制</em>（Multiversion Concurrency Control），每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回；在这时，读写操作之间的冲突就不再需要被关注，而管理和快速挑选数据的版本就成了 MVCC 需要解决的主要问题。</p>

<p>MVCC 并不是一个与乐观和悲观并发控制对立的东西，它能够与两者很好的结合以增加事务的并发量，在目前最流行的 SQL 数据库 MySQL 和 PostgreSQL 中都对 MVCC 进行了实现；但是由于它们分别实现了悲观锁和乐观锁，所以 MVCC 实现的方式也不同。</p>

<h3 id="mysql-与-mvcc">MySQL 与 MVCC</h3>

<p>MySQL 中实现的多版本两阶段锁协议（Multiversion 2PL）将 MVCC 和 2PL 的优点结合了起来，每一个版本的数据行都具有一个唯一的时间戳，当有读事务请求时，数据库程序会直接从多个版本的数据项中具有最大时间戳的返回。</p>

<p><img src="https://img.nju520.me/2017-10-02-multiversion-2pl-read.png" alt="multiversion-2pl-read" /></p>

<p>更新操作就稍微有些复杂了，事务会先读取最新版本的数据计算出数据更新后的结果，然后创建一个新版本的数据，新数据的时间戳是目前数据行的最大版本 <code>＋1</code>：</p>

<p><img src="https://img.nju520.me/2017-10-02-multiversion-2pl-write.png" alt="multiversion-2pl-write" /></p>

<p>数据版本的删除也是根据时间戳来选择的，MySQL 会将版本最低的数据定时从数据库中清除以保证不会出现大量的遗留内容。</p>

<h3 id="postgresql-与-mvcc">PostgreSQL 与 MVCC</h3>

<p>与 MySQL 中使用悲观并发控制不同，PostgreSQL 中都是使用乐观并发控制的，这也就导致了 MVCC 在于乐观锁结合时的实现上有一些不同，最终实现的叫做多版本时间戳排序协议（Multiversion Timestamp Ordering），在这个协议中，所有的的事务在执行之前都会被分配一个唯一的时间戳，每一个数据项都有读写两个时间戳：</p>

<p><img src="https://img.nju520.me/2017-10-02-dataitem-with-timestamps.png" alt="dataitem-with-timestamps" /></p>

<p>当 PostgreSQL 的事务发出了一个读请求，数据库直接将最新版本的数据返回，不会被任何操作阻塞，而写操作在执行时，事务的时间戳一定要大或者等于数据行的读时间戳，否则就会被回滚。</p>

<p>这种 MVCC 的实现保证了读事务永远都不会失败并且不需要等待锁的释放，对于读请求远远多于写请求的应用程序，乐观锁加 MVCC 对数据库的性能有着非常大的提升；虽然这种协议能够针对一些实际情况做出一些明显的性能提升，但是也会导致两个问题，一个是每一次读操作都会更新读时间戳造成两次的磁盘写入，第二是事务之间的冲突是通过回滚解决的，所以如果冲突的可能性非常高或者回滚代价巨大，数据库的读写性能还不如使用传统的锁等待方式。</p>

<h2 id="总结">总结</h2>

<p>数据库的并发控制机制到今天已经有了非常成熟、完善的解决方案，我们并不需要自己去设计一套新的协议来处理不同事务之间的冲突问题，从数据库的并发控制机制中学习到的相关知识，无论是锁还是乐观并发控制在其他的领域或者应用中都被广泛使用，所以了解、熟悉不同的并发控制机制的原理是很有必要的。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://nju520.me/database-concurrency-control.html">浅谈数据库并发控制 - 锁和 MVCC · 雄关漫道真如铁</a></li>
  <li><a href="https://www.ibm.com/support/knowledgecenter/en/SSPK3V_7.0.0/com.ibm.swg.im.soliddb.sql.doc/doc/pessimistic.vs.optimistic.concurrency.control.html">PESSIMISTIC vs. OPTIMISTIC concurrency control</a></li>
  <li><a href="https://devcenter.heroku.com/articles/postgresql-concurrency">PostgreSQL Concurrency with MVCC</a></li>
  <li><a href="https://www.enterprisedb.com/well-known-databases-use-different-approaches-mvcc">Well-known Databases Use Different Approaches for MVCC</a></li>
  <li><a href="https://www.cs.unc.edu/~dewan/242/s01/notes/trans/node3.html">Serializability</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Race_condition">Race condition</a></li>
</ul>


  ]]></description>
</item>

<item>
  <title>『浅入深出』MySQL 中事务的实现</title>
  <link>//mysql-transaction</link>
  <author>nju520</author>
  <pubDate>2017-08-20T00:00:00+08:00</pubDate>
  <guid>//mysql-transaction</guid>
  <description><![CDATA[
  <p>在关系型数据库中，事务的重要性不言而喻，只要对数据库稍有了解的人都知道事务具有 ACID 四个基本属性，而我们不知道的可能就是数据库是如何实现这四个属性的；在这篇文章中，我们将对事务的实现进行分析，尝试理解数据库是如何实现事务的，当然我们也会在文章中简单对 MySQL 中对 ACID 的实现进行简单的介绍。</p>

<p><img src="https://img.nju520.me/2017-08-20-Transaction-Basics.jpg-1000width" alt="Transaction-Basics" /></p>

<p>事务其实就是<strong>并发控制的基本单位</strong>；相信我们都知道，事务是一个序列操作，其中的操作要么都执行，要么都不执行，它是一个不可分割的工作单位；数据库事务的 ACID 四大特性是事务的基础，了解了 ACID 是如何实现的，我们也就清除了事务的实现，接下来我们将依次介绍数据库是如何实现这四个特性的。</p>

<h2 id="原子性">原子性</h2>

<p>在学习事务时，经常有人会告诉你，事务就是一系列的操作，要么全部都执行，要都不执行，这其实就是对事务原子性的刻画；虽然事务具有原子性，但是原子性并不是只与事务有关系，它的身影在很多地方都会出现。</p>

<p><img src="https://img.nju520.me/2017-08-20-Atomic-Operation.jpg-1000width" alt="Atomic-Operation" /></p>

<p>由于操作并不具有原子性，并且可以再分为多个操作，当这些操作出现错误或抛出异常时，整个操作就可能不会继续执行下去，而已经进行的操作造成的副作用就可能造成数据更新的丢失或者错误。</p>

<p>事务其实和一个操作没有什么太大的区别，它是一系列的数据库操作（可以理解为 SQL）的集合，如果事务不具备原子性，那么就没办法保证同一个事务中的所有操作都被执行或者未被执行了，整个数据库系统就既不可用也不可信。</p>

<h3 id="回滚日志">回滚日志</h3>

<p>想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，而在 MySQL 中，恢复机制是通过<em>回滚日志</em>（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。</p>

<p><img src="https://img.nju520.me/2017-08-20-Transaction-Undo-Log.jpg-1000width" alt="Transaction-Undo-Log" /></p>

<p>这个过程其实非常好理解，为了能够在发生错误时撤销之前的全部操作，肯定是需要将之前的操作都记录下来的，这样在发生错误时才可以回滚。</p>

<p>回滚日志除了能够在发生错误或者用户执行 <code>ROLLBACK</code> 时提供回滚相关的信息，它还能够在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要先写日志后写数据库的主要原因。</p>

<p>回滚日志并不能将数据库物理地恢复到执行语句或者事务之前的样子；它是逻辑日志，当回滚日志被使用时，它只会按照日志<strong>逻辑地</strong>将数据库中的修改撤销掉看，可以<strong>理解</strong>为，我们在事务中使用的每一条 <code>INSERT</code> 都对应了一条 <code>DELETE</code>，每一条 <code>UPDATE</code> 也都对应一条相反的 <code>UPDATE</code> 语句。</p>

<p><img src="https://img.nju520.me/2017-08-20-Logical-Undo-Log.jpg-1000width" alt="Logical-Undo-Log" /></p>

<p>在这里，我们并不会介绍回滚日志的格式以及它是如何被管理的，本文重点关注在它到底是一个什么样的东西，究竟解决了、如何解决了什么样的问题，如果想要了解具体实现细节的读者，相信网络上关于回滚日志的文章一定不少。</p>

<h3 id="事务的状态">事务的状态</h3>

<p>因为事务具有原子性，所以从远处看的话，事务就是密不可分的一个整体，事务的状态也只有三种：Active、Commited 和 Failed，事务要不就在执行中，要不然就是成功或者失败的状态：</p>

<p><img src="https://img.nju520.me/2017-08-20-Atomitc-Transaction-State.jpg-1000width" alt="Atomitc-Transaction-State" /></p>

<p>但是如果放大来看，我们会发现事务不再是原子的，其中包括了很多中间状态，比如部分提交，事务的状态图也变得越来越复杂。</p>

<p><img src="https://img.nju520.me/2017-08-20-Nonatomitc-Transaction-State.jpg-1000width" alt="Nonatomitc-Transaction-State" /></p>

<blockquote>
  <p>事务的状态图以及状态的描述取自 <a href="https://www.amazon.com/Database-System-Concepts-Computer-Science/dp/0073523321">Database System Concepts</a> 一书中第 14 章的内容。</p>
</blockquote>

<ul>
  <li>Active：事务的初始状态，表示事务正在执行；</li>
  <li>Partially Commited：在最后一条语句执行之后；</li>
  <li>Failed：发现事务无法正常执行之后；</li>
  <li>Aborted：事务被回滚并且数据库恢复到了事务进行之前的状态之后；</li>
  <li>Commited：成功执行整个事务；</li>
</ul>

<p>虽然在发生错误时，整个数据库的状态可以恢复，但是如果我们在事务中执行了诸如：向标准输出打印日志、向外界发出邮件、没有通过数据库修改了磁盘上的内容甚至在事务执行期间发生了转账汇款，那么这些操作作为可见的外部输出都是没有办法回滚的；这些问题都是由应用开发者解决和负责的，在绝大多数情况下，我们都需要在整个事务提交后，再触发类似的无法回滚的操作。</p>

<p><img src="https://img.nju520.me/2017-08-20-Shutdown-After-Commited.jpg-1000width" alt="Shutdown-After-Commited" /></p>

<p>以订票为例，哪怕我们在整个事务结束之后，才向第三方发起请求，由于向第三方请求并获取结果是一个需要较长事件的操作，如果在事务刚刚提交时，数据库或者服务器发生了崩溃，那么我们就非常有可能丢失发起请求这一过程，这就造成了非常严重的问题；而这一点就不是数据库所能保证的，开发者需要在适当的时候查看请求是否被发起、结果是成功还是失败。</p>

<h3 id="并行事务的原子性">并行事务的原子性</h3>

<p>到目前为止，所有的事务都只是串行执行的，一直都没有考虑过并行执行的问题；然而在实际工作中，并行执行的事务才是常态，然而并行任务下，却可能出现非常复杂的问题：</p>

<p><img src="https://img.nju520.me/2017-08-20-Nonrecoverable-Schedule.jpg-1000width" alt="Nonrecoverable-Schedule" /></p>

<p>当 Transaction1 在执行的过程中对 <code>id = 1</code> 的用户进行了读写，但是没有将修改的内容进行提交或者回滚，在这时 Transaction2 对同样的数据进行了读操作并提交了事务；也就是说 Transaction2 是依赖于 Transaction1 的，当 Transaction1 由于一些错误需要回滚时，因为要保证事务的原子性，需要对 Transaction2 进行回滚，但是由于我们已经提交了 Transaction2，所以我们已经没有办法进行回滚操作，在这种问题下我们就发生了问题，<a href="https://www.amazon.com/Database-System-Concepts-Computer-Science/dp/0073523321">Database System Concepts</a> 一书中将这种现象称为<em>不可恢复安排</em>（Nonrecoverable Schedule），那什么情况下是可以恢复的呢？</p>

<blockquote>
  <p>A recoverable schedule is one where, for each pair of transactions Ti and Tj such that Tj reads a data item previously written by Ti , the commit operation of Ti appears before the commit operation of Tj .</p>
</blockquote>

<p>简单理解一下，如果 Transaction2 依赖于事务 Transaction1，那么事务 Transaction1 必须在 Transaction2 提交之前完成提交的操作：</p>

<p><img src="https://img.nju520.me/2017-08-20-Recoverable-Schedule.jpg-1000width" alt="Recoverable-Schedule" /></p>

<p>然而这样还不算完，当事务的数量逐渐增多时，整个恢复流程也会变得越来越复杂，如果我们想要从事务发生的错误中恢复，也不是一件那么容易的事情。</p>

<p><img src="https://img.nju520.me/2017-08-20-Cascading-Rollback.jpg-1000width" alt="Cascading-Rollback" /></p>

<p>在上图所示的一次事件中，Transaction2 依赖于 Transaction1，而 Transaction3 又依赖于 Transaction1，当 Transaction1 由于执行出现问题发生回滚时，为了保证事务的原子性，就会将 Transaction2 和 Transaction3 中的工作全部回滚，这种情况也叫做<em>级联回滚</em>（Cascading Rollback），级联回滚的发生会导致大量的工作需要撤回，是我们难以接受的，不过如果想要达到<strong>绝对的</strong>原子性，这件事情又是不得不去处理的，我们会在文章的后面具体介绍如何处理并行事务的原子性。</p>

<h2 id="持久性">持久性</h2>

<p>既然是数据库，那么一定对数据的持久存储有着非常强烈的需求，如果数据被写入到数据库中，那么数据一定能够被安全存储在磁盘上；而事务的持久性就体现在，一旦事务被提交，那么数据一定会被写入到数据库中并持久存储起来。</p>

<p><img src="https://img.nju520.me/2017-08-20-Compensating-Transaction.jpg-1000width" alt="Compensating-Transaction" /></p>

<p>当事务已经被提交之后，就无法再次回滚了，唯一能够撤回已经提交的事务的方式就是创建一个相反的事务对原操作进行『补偿』，这也是事务持久性的体现之一。</p>

<h3 id="重做日志">重做日志</h3>

<p>与原子性一样，事务的持久性也是通过日志来实现的，MySQL 使用重做日志（redo log）实现事务的持久性，重做日志由两部分组成，一是内存中的重做日志缓冲区，因为重做日志缓冲区在内存中，所以它是易失的，另一个就是在磁盘上的重做日志文件，它是持久的。</p>

<p><img src="https://img.nju520.me/2017-08-20-Redo-Logging.jpg-1000width" alt="Redo-Logging" /></p>

<p>当我们在一个事务中尝试对数据进行修改时，它会先将数据从磁盘读入内存，并更新内存中缓存的数据，然后生成一条重做日志并写入重做日志缓存，当事务真正提交时，MySQL 会将重做日志缓存中的内容刷新到重做日志文件，再将内存中的数据更新到磁盘上，图中的第 4、5 步就是在事务提交时执行的。</p>

<p>在 InnoDB 中，重做日志都是以 512 字节的块的形式进行存储的，同时因为块的大小与磁盘扇区大小相同，所以重做日志的写入可以保证原子性，不会由于机器断电导致重做日志仅写入一半并留下脏数据。</p>

<p>除了所有对数据库的修改会产生重做日志，因为回滚日志也是需要持久存储的，它们也会创建对应的重做日志，在发生错误后，数据库重启时会从重做日志中找出未被更新到数据库磁盘中的日志重新执行以满足事务的持久性。</p>

<h3 id="回滚日志和重做日志">回滚日志和重做日志</h3>

<p>到现在为止我们了解了 MySQL 中的两种日志，回滚日志（undo log）和重做日志（redo log）；在数据库系统中，事务的原子性和持久性是由事务日志（transaction log）保证的，在实现时也就是上面提到的两种日志，前者用于对事务的影响进行撤销，后者在错误处理时对已经提交的事务进行重做，它们能保证两点：</p>

<ol>
  <li>发生错误或者需要回滚的事务能够成功回滚（原子性）；</li>
  <li>在事务提交后，数据没来得及写会磁盘就宕机时，在下次重新启动后能够成功恢复数据（持久性）；</li>
</ol>

<p>在数据库中，这两种日志经常都是一起工作的，我们<strong>可以</strong>将它们整体看做一条事务日志，其中包含了事务的 ID、修改的行元素以及修改前后的值。</p>

<p><img src="https://img.nju520.me/2017-08-20-Transaction-Log.jpg-1000width" alt="Transaction-Log" /></p>

<p>一条事务日志同时包含了修改前后的值，能够非常简单的进行回滚和重做两种操作，在这里我们也不会对重做和回滚日志展开进行介绍，可能会在之后的文章谈一谈数据库系统的恢复机制时提到两种日志的使用。</p>

<h2 id="隔离性">隔离性</h2>

<p>其实作者在之前的文章 <a href="http://nju520.me/mysql-innodb.html">『浅入浅出』MySQL 和 InnoDB</a> 就已经介绍过数据库事务的隔离性，不过为了保证文章的独立性和完整性，我们还会对事务的隔离性进行介绍，介绍的内容可能稍微有所不同。</p>

<p>事务的隔离性是数据库处理数据的几大基础之一，如果没有数据库的事务之间没有隔离性，就会发生在 <a href="#并行事务的原子性">并行事务的原子性</a> 一节中提到的级联回滚等问题，造成性能上的巨大损失。如果所有的事务的执行顺序都是线性的，那么对于事务的管理容易得多，但是允许事务的并行执行却能能够提升吞吐量和资源利用率，并且可以减少每个事务的等待时间。</p>

<p><img src="https://img.nju520.me/2017-08-20-Reasons-for-Allowing-Concurrency.jpg-1000width" alt="Reasons-for-Allowing-Concurrency" /></p>

<p>当多个事务同时并发执行时，事务的隔离性可能就会被违反，虽然单个事务的执行可能没有任何错误，但是从总体来看就会造成数据库的一致性出现问题，而串行虽然能够允许开发者忽略并行造成的影响，能够很好地维护数据库的一致性，但是却会影响事务执行的性能。</p>

<h3 id="事务的隔离级别">事务的隔离级别</h3>

<p>所以说数据库的隔离性和一致性其实是一个需要开发者去权衡的问题，为数据库提供什么样的隔离性层级也就决定了数据库的性能以及可以达到什么样的一致性；在 SQL 标准中定义了四种数据库的事务的隔离级别：<code>READ UNCOMMITED</code>、<code>READ COMMITED</code>、<code>REPEATABLE READ</code> 和 <code>SERIALIZABLE</code>；每个事务的隔离级别其实都比上一级多解决了一个问题：</p>

<ul>
  <li><code>RAED UNCOMMITED</code>：使用查询语句不会加锁，可能会读到未提交的行（Dirty Read）；</li>
  <li><code>READ COMMITED</code>：只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable Read）；</li>
  <li><code>REPEATABLE READ</code>：多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读（Phantom Read）；</li>
  <li><code>SERIALIZABLE</code>：InnoDB 隐式地将全部的查询语句加上共享锁，解决了幻读的问题；</li>
</ul>

<p>以上的所有的事务隔离级别都不允许脏写入（Dirty Write），也就是当前事务更新了另一个事务已经更新但是还未提交的数据，大部分的数据库中都使用了 READ COMMITED 作为默认的事务隔离级别，但是 MySQL 使用了 REPEATABLE READ 作为默认配置；从 RAED UNCOMMITED 到 SERIALIZABLE，随着事务隔离级别变得越来越严格，数据库对于并发执行事务的性能也逐渐下降。</p>

<p><img src="https://img.nju520.me/2017-08-20-Isolation-Performance.jpg-1000width" alt="Isolation-Performance" /></p>

<p>对于数据库的使用者，从理论上说，并不需要知道事务的隔离级别是如何实现的，我们只需要知道这个隔离级别解决了什么样的问题，但是不同数据库对于不同隔离级别的是实现细节在很多时候都会让我们遇到意料之外的坑。</p>

<p>如果读者不了解脏读、不可重复读和幻读究竟是什么，可以阅读之前的文章 <a href="http://nju520.me/mysql-innodb.html">『浅入浅出』MySQL 和 InnoDB</a>，在这里我们仅放一张图来展示各个隔离层级对这几个问题的解决情况。</p>

<p><img src="https://img.nju520.me/2017-08-20-Transaction-Isolation-Matrix.jpg-1000width" alt="Transaction-Isolation-Matrix" /></p>

<h3 id="隔离级别的实现">隔离级别的实现</h3>

<p>数据库对于隔离级别的实现就是使用<strong>并发控制机制</strong>对在同一时间执行的事务进行控制，限制不同的事务对于同一资源的访问和更新，而最重要也最常见的并发控制机制，在这里我们将简单介绍三种最重要的并发控制器机制的工作原理。</p>

<h4 id="锁">锁</h4>

<p>锁是一种最为常见的并发控制机制，在一个事务中，我们并不会将整个数据库都加锁，而是只会锁住那些需要访问的数据项， MySQL 和常见数据库中的锁都分为两种，共享锁（Shared）和互斥锁（Exclusive），前者也叫读锁，后者叫写锁。</p>

<p><img src="https://img.nju520.me/2017-08-20-Shared-Exclusive-Lock.jpg-1000width" alt="Shared-Exclusive-Lock" /></p>

<p>读锁保证了读操作可以并发执行，相互不会影响，而写锁保证了在更新数据库数据时不会有其他的事务访问或者更改同一条记录造成不可预知的问题。</p>

<h4 id="时间戳">时间戳</h4>

<p>除了锁，另一种实现事务的隔离性的方式就是通过时间戳，使用这种方式实现事务的数据库，例如 PostgreSQL 会为每一条记录保留两个字段；<em>读时间戳</em>中报错了所有访问该记录的事务中的最大时间戳，而记录行的<em>写时间戳</em>中保存了将记录改到当前值的事务的时间戳。</p>

<p><img src="https://img.nju520.me/2017-08-20-Timestamps-Record.jpg-1000width" alt="Timestamps-Record" /></p>

<p>使用时间戳实现事务的隔离性时，往往都会使用乐观锁，先对数据进行修改，在写回时再去判断当前值，也就是时间戳是否改变过，如果没有改变过，就写入，否则，生成一个新的时间戳并再次更新数据，乐观锁其实并不是真正的锁机制，它只是一种思想，在这里并不会对它进行展开介绍。</p>

<h4 id="多版本和快照隔离">多版本和快照隔离</h4>

<p>通过维护多个版本的数据，数据库可以允许事务在数据被其他事务更新时对旧版本的数据进行读取，很多数据库都对这一机制进行了实现；因为所有的读操作不再需要等待写锁的释放，所以能够显著地提升读的性能，MySQL 和 PostgreSQL 都对这一机制进行自己的实现，也就是 MVCC，虽然各自实现的方式有所不同，MySQL 就通过文章中提到的回滚日志实现了 MVCC，保证事务并行执行时能够不等待互斥锁的释放直接获取数据。</p>

<h3 id="隔离性与原子性">隔离性与原子性</h3>

<p>在这里就需要简单提一下在在原子性一节中遇到的级联回滚等问题了，如果一个事务对数据进行了写入，这时就会获取一个互斥锁，其他的事务就想要获得改行数据的读锁就必须等待写锁的释放，自然就不会发生级联回滚等问题了。</p>

<p><img src="https://img.nju520.me/2017-08-20-Shared-Lock-and-Atomicity.jpg-1000width" alt="Shared-Lock-and-Atomicity" /></p>

<p>不过在大多数的数据库，比如 MySQL 中都使用了 MVCC 等特性，也就是正常的读方法是不需要获取锁的，在想要对读取的数据进行更新时需要使用 <code>SELECT ... FOR UPDATE</code> 尝试获取对应行的互斥锁，以保证不同事务可以正常工作。</p>

<h2 id="一致性">一致性</h2>

<p>作者认为数据库的一致性是一个非常让人迷惑的概念，原因是数据库领域其实包含两个一致性，一个是 ACID 中的一致性、另一个是 CAP 定义中的一致性。</p>

<p><img src="https://img.nju520.me/2017-08-20-ACID-And-CAP.jpg-1000width" alt="ACID-And-CAP" /></p>

<p>这两个数据库的一致性说的<strong>完全不是</strong>一个事情，很多很多人都对这两者的概念有非常深的误解，当我们在讨论数据库的一致性时，一定要清楚上下文的语义是什么，尽量明确的问出我们要讨论的到底是 ACID 中的一致性还是 CAP 中的一致性。</p>

<h3 id="acid">ACID</h3>

<p>数据库对于 ACID 中的一致性的定义是这样的：如果一个事务原子地在一个一致地数据库中独立运行，那么在它执行之后，数据库的状态一定是一致的。对于这个概念，它的第一层意思就是对于数据完整性的约束，包括主键约束、引用约束以及一些约束检查等等，在事务的执行的前后以及过程中不会违背对数据完整性的约束，所有对数据库写入的操作都应该是合法的，并不能产生不合法的数据状态。</p>

<blockquote>
  <p>A transaction must preserve database consistency - if a transaction is run atomically in isolation starting from a consistent database, the database must again be consistent at the end of the transaction.</p>
</blockquote>

<p>我们可以将事务理解成一个函数，它接受一个外界的 SQL 输入和一个一致的数据库，它一定会返回一个一致的数据库。</p>

<p><img src="https://img.nju520.me/2017-08-20-Transaction-Consistency.jpg-1000width" alt="Transaction-Consistency" /></p>

<p>而第二层意思其实是指逻辑上的对于开发者的要求，我们要在代码中写出正确的事务逻辑，比如银行转账，事务中的逻辑不可能只扣钱或者只加钱，这是应用层面上对于数据库一致性的要求。</p>

<blockquote>
  <p>Ensuring consistency for an individual transaction is the responsibility of the application programmer who codes the transaction. - <a href="https://www.amazon.com/Database-System-Concepts-Computer-Science/dp/0073523321">Database System Concepts</a></p>
</blockquote>

<p>数据库 ACID 中的一致性对事务的要求不止包含对数据完整性以及合法性的检查，还包含应用层面逻辑的正确。</p>

<p>CAP 定理中的数据一致性，其实是说分布式系统中的各个节点中对于同一数据的拷贝有着相同的值；而 ACID 中的一致性是指数据库的规则，如果 schema 中规定了一个值必须是唯一的，那么一致的系统必须确保在所有的操作中，该值都是唯一的，由此来看 CAP 和 ACID 对于一致性的定义有着根本性的区别。</p>

<h2 id="总结">总结</h2>

<p>事务的 ACID 四大基本特性是保证数据库能够运行的基石，但是完全保证数据库的 ACID，尤其是隔离性会对性能有比较大影响，在实际的使用中我们也会根据业务的需求对隔离性进行调整，除了隔离性，数据库的原子性和持久性相信都是比较好理解的特性，前者保证数据库的事务要么全部执行、要么全部不执行，后者保证了对数据库的写入都是持久存储的、非易失的，而一致性不仅是数据库对本身数据的完整性的要求，同时也对开发者提出了要求 - 写出逻辑正确并且合理的事务。</p>

<p>最后，也是最重要的，当别人在将一致性的时候，一定要搞清楚他的上下文，如果对文章的内容有疑问，可以在评论中留言。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://www.amazon.com/Database-System-Concepts-Computer-Science/dp/0073523321">Database System Concepts</a></li>
  <li><a href="https://zh.wikipedia.org/wiki/数据库事务">数据库事务</a></li>
  <li><a href="https://vladmihalcea.com/2017/03/01/how-does-mvcc-multi-version-concurrency-control-work/">How does MVCC (Multi-Version Concurrency Control) work</a></li>
  <li><a href="https://vladmihalcea.com/2017/02/14/how-does-a-relational-database-work/">How does a relational database work</a></li>
  <li><a href="http://www.mathcs.emory.edu/~cheung/Courses/377/Syllabus/10-Transactions/redo-log.html">Implementing Transaction Processing using Redo Logs</a></li>
  <li><a href="http://www.mathcs.emory.edu/~cheung/Courses/377/Syllabus/10-Transactions/undo-log.html">Implementing Transaction Processing using Undo Logs</a></li>
  <li><a href="http://cs.ulb.ac.be/public/_media/teaching/infoh417/05_-_logging-sol-slides.pdf">Undo/Redo Logging Rules</a></li>
  <li><a href="https://www.qiancheng.me/post/coding/mysql-001">MySQL 解密：InnoDB 存储引擎重做日志漫游</a></li>
  <li><a href="http://www.jdon.com/46956">ACID 中 C 与 CAP 定理中 C 的区别</a></li>
  <li><a href="https://www.voltdb.com/blog/2015/10/22/disambiguating-acid-cap/">Disambiguating ACID and CAP</a></li>
</ul>

  ]]></description>
</item>


  </channel>
</rss>
