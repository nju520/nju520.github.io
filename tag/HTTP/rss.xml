<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    
    <title>nju520.me</title>
    
    <link>http://localhost:4000</link>
    <description>nju520's Blog</description>
    <language>en-uk</language>
    <managingEditor> nju520</managingEditor>
    <atom:link href="rss" rel="self" type="application/rss+xml" />
    
<item>
  <title>如何进行 HTTP Mock（iOS）</title>
  <link>//http-mock</link>
  <author>nju520</author>
  <pubDate>2016-08-16T21:58:39+08:00</pubDate>
  <guid>//http-mock</guid>
  <description><![CDATA[
  <p>这篇文章会对 <a href="[https://github.com/AliSoftware/OHHTTPStubs]">OHHTTPStubs</a> 源代码的分析，其实现原理是建立在 <code>NSURLProtocol</code> 的基础上的，对这部分内容不了解的读者，可以阅读这篇文章 <a href="https://github.com/nju520/iOS-Source-Code-Analyze/blob/master/contents/OHHTTPStubs/iOS%20开发中使用%20NSURLProtocol%20拦截%20HTTP%20请求.md">iOS 开发中使用 NSURLProtocol 拦截 HTTP 请求</a>了解相关知识，本文中不会介绍拦截 HTTP 请求的原理。</p>

<h3 id="如何使用-ohhttpstubs-mock-网络请求">如何使用 OHHTTPStubs Mock 网络请求</h3>

<p>HTTP Mock 在测试中非常好用，我们可以在不需要后端 API 的情况下，在本地对 HTTP 请求进行拦截，返回想要的 <code>json</code> 数据，而 OHHTTPStubs 就为我们提供了这样一种解决方案。</p>

<p>在了解其实现之前，先对 OHHTTPStubs 进行简单的介绍，引入头文件这种事情在这里会直接省略，先来看一下程序的源代码：</p>

<pre><code class="language-objectivec">[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest * _Nonnull request) {
    return [request.URL.absoluteString isEqualToString:@"https://idont.know"];
} withStubResponse:^OHHTTPStubsResponse * _Nonnull(NSURLRequest * _Nonnull request) {
    NSString *fixture = OHPathForFile(@"example.json", self.class);
    return [OHHTTPStubsResponse responseWithFileAtPath:fixture statusCode:200 headers:@{@"Content-Type":@"application/json"}];
}];

AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
[manager GET:@"https://idont.know"
  parameters:nil
    progress:nil
     success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
         NSLog(@"%@", responseObject);
     } failure:nil];
</code></pre>

<p>我们向 <code>https://idont.know</code> 这个 URL 发送一个 GET 请求，虽然这个 URL 并不存在，但是这里的代码通过 HTTP stub 成功地模拟了 HTTP 响应：</p>

<p><img src="https://img.nju520.me/2016-08-16-OHHTTPStubs-test.png-1000width" alt="OHHTTPStubs-test" /></p>

<h2 id="ohhttpstubs-的实现">OHHTTPStubs 的实现</h2>

<p>在了解了 OHHTTPStubs 的使用之后，我们会对其实现进行分析，它分成四部分进行：</p>

<ul>
  <li><code>OHHTTPStubsProtocol</code> 拦截 HTTP 请求</li>
  <li><code>OHHTTPStubs</code> 单例管理 <code>OHHTTPStubsDescriptor</code> 实例</li>
  <li><code>OHHTTPStubsResponse</code> 伪造 HTTP 响应</li>
  <li>一些辅助功能</li>
</ul>

<h3 id="ohhttpstubsprotocol-拦截-http-请求">OHHTTPStubsProtocol 拦截 HTTP 请求</h3>

<p>在 OHHTTPStubs 中继承 <code>NSURLProtocol</code> 的类就是 <code>OHHTTPStubsProtocol</code>，它在 HTTP 请求发出之前对 request 对象进行过滤以及处理：</p>

<pre><code class="language-objectivec">+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
	return ([OHHTTPStubs.sharedInstance firstStubPassingTestForRequest:request] != nil);
}

- (id)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)response client:(id&lt;NSURLProtocolClient&gt;)client {
	OHHTTPStubsProtocol* proto = [super initWithRequest:request cachedResponse:nil client:client];
	proto.stub = [OHHTTPStubs.sharedInstance firstStubPassingTestForRequest:request];
	return proto;
}

+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
	return request;
}
</code></pre>

<p>判断请求是否会被当前协议对象进行处理是需要 <code>OHHTTPStubs</code> 的实例方法 <code>- firstStubPassingTestForRequest:</code> 的执行的，在这里暂时先不对这个方法进行讨论。</p>

<p>接下来就是请求发送的过程 <code>- startLoading</code> 方法了，该方法的实现实在是太过于复杂，所以这里分块来分析代码：</p>

<pre><code class="language-objectivec">- (void)startLoading {
	NSURLRequest* request = self.request;
	id&lt;NSURLProtocolClient&gt; client = self.client;

	OHHTTPStubsResponse* responseStub = self.stub.responseBlock(request);

	if (OHHTTPStubs.sharedInstance.onStubActivationBlock) {
		OHHTTPStubs.sharedInstance.onStubActivationBlock(request, self.stub, responseStub);
	}

	...
}
</code></pre>

<p>从当前对象中取出 <code>request</code> 以及 <code>client</code> 对象，如果 <code>OHHTTPStubs</code> 的单例中包含 <code>onStubActivationBlock</code>，就会执行这里的 block，然后调用 <code>responseBlock</code> 获取一个 <code>OHHTTPStubsResponse</code> HTTP 响应对象。</p>

<p><code>OHHTTPStubs</code> 不只提供了 <code>onStubActivationBlock</code> 这一个钩子，还有以下 block：</p>

<ul>
  <li><code>+ onStubActivationBlock</code>：stub 被激活时调用</li>
  <li><code>+ onStubRedirectBlock</code>：发生重定向时</li>
  <li><code>+ afterStubFinishBlock</code>：在 stub 结束时调用</li>
</ul>

<p>如果响应对象的生成没有遇到任何问题，就会进入处理 Cookie、重定向、发送响应和模拟数据流的过程了。</p>

<ol>
  <li>首先是对 Cookie 的处理</li>
</ol>

<pre><code class="language-objectivec">NSHTTPURLResponse* urlResponse = [[NSHTTPURLResponse alloc] initWithURL:request.URL
															 statusCode:responseStub.statusCode
															HTTPVersion:@"HTTP/1.1"
														   headerFields:responseStub.httpHeaders];

if (request.HTTPShouldHandleCookies &amp;&amp; request.URL) {
	NSArray* cookies = [NSHTTPCookie cookiesWithResponseHeaderFields:responseStub.httpHeaders forURL:request.URL];
	if (cookies) {
		[NSHTTPCookieStorage.sharedHTTPCookieStorage setCookies:cookies forURL:request.URL mainDocumentURL:request.mainDocumentURL];
	}
}
</code></pre>

<ol>
  <li>如果 HTTP 状态码在 300-400 之间，就会处理重定向的问题，调用 <code>onStubRedirectBlock</code> 进行需要的回调</li>
</ol>

<pre><code class="language-objectivec">NSString* redirectLocation = (responseStub.httpHeaders)[@"Location"];
NSURL* redirectLocationURL = redirectLocation ? [NSURL URLWithString:redirectLocation] : nil;

if (((responseStub.statusCode &gt; 300) &amp;&amp; (responseStub.statusCode &lt; 400)) &amp;&amp; redirectLocationURL) {
	NSURLRequest* redirectRequest = [NSURLRequest requestWithURL:redirectLocationURL];
	[self executeOnClientRunLoopAfterDelay:responseStub.requestTime block:^{
		if (!self.stopped) {
			[client URLProtocol:self wasRedirectedToRequest:redirectRequest redirectResponse:urlResponse];
			if (OHHTTPStubs.sharedInstance.onStubRedirectBlock) {
				OHHTTPStubs.sharedInstance.onStubRedirectBlock(request, redirectRequest, self.stub, responseStub);
			}
		}
	}];
}
</code></pre>

<ol>
  <li>最后这里有一些复杂，我们根据 <code>stub</code> 中存储的 <code>responseTime</code> 来模拟响应的一个延迟时间，然后使用 <code>- streamDataForClient:withStubResponse:completion:</code> 来模拟数据以 <code>NSData</code> 的形式分块发送回 <code>client</code> 的过程，最后调用 <code>afterStubFinishBlock</code>。</li>
</ol>

<pre><code class="language-objectivec">[self executeOnClientRunLoopAfterDelay:responseStub.requestTime block:^{
	if (!self.stopped) {
		[client URLProtocol:self didReceiveResponse:urlResponse cacheStoragePolicy:NSURLCacheStorageNotAllowed];
		if(responseStub.inputStream.streamStatus == NSStreamStatusNotOpen) {
			[responseStub.inputStream open];
		}
		[self streamDataForClient:client
				 withStubResponse:responseStub
					   completion:^(NSError * error) {
			 [responseStub.inputStream close];
			 NSError *blockError = nil;
			 if (error==nil) {
				 [client URLProtocolDidFinishLoading:self];
			 } else {
				 [client URLProtocol:self didFailWithError:responseStub.error];
				 blockError = responseStub.error;
			 }
			 if (OHHTTPStubs.sharedInstance.afterStubFinishBlock) {
				 OHHTTPStubs.sharedInstance.afterStubFinishBlock(request, self.stub, responseStub, blockError);
			 }
		 }];
	}
}];
</code></pre>

<p>当然如果在生成 <code>responseStub</code> 的时候发生了错误，也会进行类似的操作，在延迟一定时间（模拟网络延迟）后执行 block 并传入各种参数：</p>

<pre><code class="language-objectivec">[self executeOnClientRunLoopAfterDelay:responseStub.responseTime block:^{
	if (!self.stopped) {
		[client URLProtocol:self didFailWithError:responseStub.error];
		if (OHHTTPStubs.sharedInstance.afterStubFinishBlock) {
			OHHTTPStubs.sharedInstance.afterStubFinishBlock(request, self.stub, responseStub, responseStub.error);
		}
	}
}];
</code></pre>

<h4 id="模拟数据流">模拟数据流</h4>

<p>因为在客户端接收数据时，所有的 <code>NSData</code> 并不是一次就涌入客户端的，而是分块加载打包解码的，尤其是在我们执行下载操作时，有时几 MB 的文件不可能同时到达服务端，而 <code>- startLoading</code> 中调用的 <code>- streamDataForClient:withStubResponse:completion:</code> 方法就是为了模拟数据流，分块向服务端发送数据，不过这部分的处理涉及到一个私有的结构体 <code>OHHTTPStubsStreamTimingInfo</code>：</p>

<pre><code class="language-objectivec">typedef struct {
	NSTimeInterval slotTime;
	double chunkSizePerSlot;
	double cumulativeChunkSize;
} OHHTTPStubsStreamTimingInfo;
</code></pre>

<p>这个结构体包含了关于发送数据流的信息：</p>

<ul>
  <li><code>slotTime</code>：两次发送 <code>NSData</code> 的间隔时间</li>
  <li><code>chunkSizePerSlot</code>：每块数据流大小</li>
  <li><code>cumulativeChunkSize</code>：已发送的数据流大小</li>
</ul>

<p>模拟数据流的过程需要两个方法的支持，其中一个方法做一些预加载工作：</p>

<pre><code class="language-objectivec">- (void)streamDataForClient:(id&lt;NSURLProtocolClient&gt;)client
		   withStubResponse:(OHHTTPStubsResponse*)stubResponse
				 completion:(void(^)(NSError * error))completion {
	if ((stubResponse.dataSize&gt;0) &amp;&amp; stubResponse.inputStream.hasBytesAvailable &amp;&amp; (!self.stopped)) {
		OHHTTPStubsStreamTimingInfo timingInfo = {
			.slotTime = kSlotTime,
			.cumulativeChunkSize = 0
		};

		if(stubResponse.responseTime &lt; 0) {
			timingInfo.chunkSizePerSlot = (fabs(stubResponse.responseTime) * 1000) * timingInfo.slotTime;
		} else if (stubResponse.responseTime &lt; kSlotTime) {
			timingInfo.chunkSizePerSlot = stubResponse.dataSize;
			timingInfo.slotTime = stubResponse.responseTime;
		} else {
			timingInfo.chunkSizePerSlot = ((stubResponse.dataSize/stubResponse.responseTime) * timingInfo.slotTime);
		}

		[self streamDataForClient:client
					   fromStream:stubResponse.inputStream
					   timingInfo:timingInfo
					   completion:completion];
	} else {
		if (completion) completion(nil);
	}
}
</code></pre>

<p>该方法将生成的 <code>OHHTTPStubsStreamTimingInfo</code> 信息传入下一个实例方法 <code>- streamDataForClient:fromStream:timingInfo:completion:</code>：</p>

<pre><code class="language-objectivec">- (void)streamDataForClient:(id&lt;NSURLProtocolClient&gt;)client fromStream:(NSInputStream*)inputStream timingInfo:(OHHTTPStubsStreamTimingInfo)timingInfo completion:(void(^)(NSError * error))completion {
	if (inputStream.hasBytesAvailable &amp;&amp; (!self.stopped)) {
		double cumulativeChunkSizeAfterRead = timingInfo.cumulativeChunkSize + timingInfo.chunkSizePerSlot;
		NSUInteger chunkSizeToRead = floor(cumulativeChunkSizeAfterRead) - floor(timingInfo.cumulativeChunkSize);
		timingInfo.cumulativeChunkSize = cumulativeChunkSizeAfterRead;

		if (chunkSizeToRead == 0) {
			[self executeOnClientRunLoopAfterDelay:timingInfo.slotTime block:^{
				[self streamDataForClient:client fromStream:inputStream
							   timingInfo:timingInfo completion:completion];
			}];
		} else {
			uint8_t* buffer = (uint8_t*)malloc(sizeof(uint8_t)*chunkSizeToRead);
			NSInteger bytesRead = [inputStream read:buffer maxLength:chunkSizeToRead];
			if (bytesRead &gt; 0) {
				NSData * data = [NSData dataWithBytes:buffer length:bytesRead];
				[self executeOnClientRunLoopAfterDelay:((double)bytesRead / (double)chunkSizeToRead) * timingInfo.slotTime block:^{
					[client URLProtocol:self didLoadData:data];
					[self streamDataForClient:client fromStream:inputStream
								   timingInfo:timingInfo completion:completion];
				}];
			} else {
				if (completion) completion(inputStream.streamError);
			}
			free(buffer);
		}
	} else {
		if (completion) completion(nil);
	}
}
</code></pre>

<ul>
  <li>上述方法会先计算 <code>chunkSizeToRead</code>，也就是接下来要传递给 <code>client</code> 的数据长度</li>
  <li>从 <code>NSInputStream</code> 中读取对应长度的数据</li>
  <li>通过 <code>- executeOnClientRunLoopAfterDelay:block:</code> 模拟数据传输的延时</li>
  <li>使用 <code>- URLProtocol:didLoadData:</code> 代理方法将数据传回 <code>client</code></li>
</ul>

<p>OHHTTPStubs 通过上面的两个方法很好的模拟了 HTTP 响应由于网络造成的延迟以及数据分块到达客户端的特点。</p>

<h3 id="ohhttpstubs-以及-ohhttpstubsdescriptor-对-stub-的管理">OHHTTPStubs 以及 OHHTTPStubsDescriptor 对 stub 的管理</h3>

<p><code>OHHTTPStubs</code> 遵循单例模式，其主要作用就是提供便利的 API 并持有一个 <code>OHHTTPStubsDescriptor</code> 数组，对 stub 进行管理。</p>

<p><code>OHHTTPStubs</code> 提供的类方法 <code>+ stubRequestsPassingTest:withStubResponse:</code> 会添加一个 <code>OHHTTPStubsDescriptor </code> 的实例到 <code>OHHTTPStubsDescriptor</code> 数组中：</p>

<pre><code class="language-objectivec">+ (id&lt;OHHTTPStubsDescriptor&gt;)stubRequestsPassingTest:(OHHTTPStubsTestBlock)testBlock
									withStubResponse:(OHHTTPStubsResponseBlock)responseBlock {
	OHHTTPStubsDescriptor* stub = [OHHTTPStubsDescriptor stubDescriptorWithTestBlock:testBlock
																	   responseBlock:responseBlock];
	[OHHTTPStubs.sharedInstance addStub:stub];
	return stub;
}
</code></pre>

<p>该类主要有两种方法，一种方法用于管理持有的 HTTP stub，比如说：</p>

<ul>
  <li><code>+ (BOOL)removeStub:(id&lt;OHHTTPStubsDescriptor&gt;)stubDesc</code></li>
  <li><code>+ (void)removeAllStubs</code></li>
  <li><code>- (void)addStub:(OHHTTPStubsDescriptor*)stubDesc</code></li>
  <li><code>- (BOOL)removeStub:(id&lt;OHHTTPStubsDescriptor&gt;)stubDesc</code></li>
  <li><code>- (void)removeAllStubs</code></li>
</ul>

<p>这些方法都是用来操作单例持有的数组的，而另一种方法用来设置相应事件发生时的回调：</p>

<ul>
  <li><code>+ (void)onStubActivation:( nullable void(^)(NSURLRequest* request, id&lt;OHHTTPStubsDescriptor&gt; stub, OHHTTPStubsResponse* responseStub) )block</code></li>
  <li><code>+ (void)onStubRedirectResponse:( nullable void(^)(NSURLRequest* request, NSURLRequest* redirectRequest, id&lt;OHHTTPStubsDescriptor&gt; stub, OHHTTPStubsResponse* responseStub) )block</code></li>
  <li><code>+ (void)afterStubFinish:( nullable void(^)(NSURLRequest* request, id&lt;OHHTTPStubsDescriptor&gt; stub, OHHTTPStubsResponse* responseStub, NSError* error) )block</code></li>
</ul>

<p>类中最重要的实例方法就是 <code>- firstStubPassingTestForRequest:</code>，它遍历自己持有的全部 stub，通过 <code>testBlock</code> 的调用返回第一个符合条件的 stub：</p>

<pre><code class="language-objectivec">- (OHHTTPStubsDescriptor*)firstStubPassingTestForRequest:(NSURLRequest*)request {
	OHHTTPStubsDescriptor* foundStub = nil;
	@synchronized(_stubDescriptors) {
		for(OHHTTPStubsDescriptor* stub in _stubDescriptors.reverseObjectEnumerator) {
			if (stub.testBlock(request)) {
				foundStub = stub;
				break;
			}
		}
	}
	return foundStub;
}
</code></pre>

<p>相比之下 <code>OHHTTPStubsDescriptor</code> 仅仅作为一个保存信息的类，其职能相对单一、实现相对简单：</p>

<pre><code class="language-objectivec">@interface OHHTTPStubsDescriptor : NSObject &lt;OHHTTPStubsDescriptor&gt;
@property(atomic, copy) OHHTTPStubsTestBlock testBlock;
@property(atomic, copy) OHHTTPStubsResponseBlock responseBlock;
@end

@implementation OHHTTPStubsDescriptor

+ (instancetype)stubDescriptorWithTestBlock:(OHHTTPStubsTestBlock)testBlock
							  responseBlock:(OHHTTPStubsResponseBlock)responseBlock {
	OHHTTPStubsDescriptor* stub = [OHHTTPStubsDescriptor new];
	stub.testBlock = testBlock;
	stub.responseBlock = responseBlock;
	return stub;
}

@end
</code></pre>

<p>两个属性以及一个方法构成了 <code>OHHTTPStubsDescriptor</code> 类的全部实现。</p>

<h3 id="ohhttpstubsresponse-伪造-http-响应">OHHTTPStubsResponse 伪造 HTTP 响应</h3>

<p><code>OHHTTPStubsResponse</code> 类为请求提供了相应所需要的各种参数，HTTP 状态码、请求时间以及数据的输入流也就是用于模拟网络请求的 <code>inputStream</code>。</p>

<p>指定构造器 <code>- initWithFileURL:statusCode:headers:</code> 完成了对这些参数的配置：</p>

<pre><code class="language-objectivec">- (instancetype)initWithInputStream:(NSInputStream*)inputStream dataSize:(unsigned long long)dataSize statusCode:(int)statusCode headers:(nullable NSDictionary*)httpHeaders {
	if (self = [super init]) {
		_inputStream = inputStream;
		_dataSize = dataSize;
		_statusCode = statusCode;
		NSMutableDictionary * headers = [NSMutableDictionary dictionaryWithDictionary:httpHeaders];
		static NSString *const ContentLengthHeader = @"Content-Length";
		if (!headers[ContentLengthHeader]) {
			headers[ContentLengthHeader] = [NSString stringWithFormat:@"%llu",_dataSize];
		}
		_httpHeaders = [NSDictionary dictionaryWithDictionary:headers];
	}
	return self;
}
</code></pre>

<p>同时，该类也提供了非常多的便利构造器以及类方法帮助我们实例化 <code>OHHTTPStubsResponse</code>，整个类中的所有构造方法大都会调用上述构造器；只是会传入不同的参数：</p>

<pre><code class="language-objectivec">- (instancetype)initWithFileURL:(NSURL *)fileURL statusCode:(int)statusCode headers:(nullable NSDictionary *)httpHeaders {
	NSNumber *fileSize;
	NSError *error;
	const BOOL success __unused = [fileURL getResourceValue:&amp;fileSize forKey:NSURLFileSizeKey error:&amp;error];

	return [self initWithInputStream:[NSInputStream inputStreamWithURL:fileURL] dataSize:[fileSize unsignedLongLongValue] statusCode:statusCode headers:httpHeaders];
}
</code></pre>

<p>比如 <code>- initWithFileURL:statusCode:headers:</code> 方法就会从文件中读取数据，然后构造一个数据输入流。</p>

<h3 id="其他内容">其他内容</h3>

<p>使用 <code>NSURLProtocol</code> 拦截 HTTP 请求时会有一个非常严重的问题，如果发出的是 POST 请求，请求的 body 会在到达 OHHTTPStubs 时被重置为空，也就是我们无法直接在 <code>testBlock</code> 中获取其 <code>HTTPBody</code>；所以，我们只能通过通过方法调剂在设置 <code>HTTPBody</code> 时，进行备份：</p>

<pre><code class="language-objectivec">typedef void(*OHHHTTPStubsSetterIMP)(id, SEL, id);
static OHHHTTPStubsSetterIMP orig_setHTTPBody;

static void OHHTTPStubs_setHTTPBody(id self, SEL _cmd, NSData* HTTPBody) {
	if (HTTPBody) {
		[NSURLProtocol setProperty:HTTPBody forKey:OHHTTPStubs_HTTPBodyKey inRequest:self];
	}
	orig_setHTTPBody(self, _cmd, HTTPBody);
}
@interface NSMutableURLRequest (HTTPBodyTesting) @end

@implementation NSMutableURLRequest (HTTPBodyTesting)

+ (void)load {
	orig_setHTTPBody = (OHHHTTPStubsSetterIMP)OHHTTPStubsReplaceMethod(@selector(setHTTPBody:), (IMP)OHHTTPStubs_setHTTPBody, [NSMutableURLRequest class], NO);
}

@end
</code></pre>

<p>除了对于 <code>HTTPBody</code> 的备份之外，OHHTTPStubs 还提供了一些用于从文件中获取数据的 C 函数：</p>

<pre><code class="language-objectivec">NSString* __nullable OHPathForFile(NSString* fileName, Class inBundleForClass);
NSString* __nullable OHPathForFileInBundle(NSString* fileName, NSBundle* bundle);
NSString* __nullable OHPathForFileInDocumentsDir(NSString* fileName);
NSBundle* __nullable OHResourceBundle(NSString* bundleBasename, Class inBundleForClass);
</code></pre>

<p>这些 C 语言函数能够帮助我们构造 HTTP 响应。</p>

<h2 id="总结">总结</h2>

<p>如果阅读过上一篇文章中的内容，理解这里的实现原理也不是什么太大的问题。在需要使用到 HTTP mock 进行测试时，使用 OHHTTPStubs 还是很方便的，当然现在也有很多其他的 HTTP stub 框架，不过实现基本上都是基于 <code>NSURLProtocol</code> 的。</p>

<blockquote>
  <p>Github Repo：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://nju520.me/http-mock</p>
</blockquote>

  ]]></description>
</item>

<item>
  <title>iOS 开发中使用 NSURLProtocol 拦截 HTTP 请求</title>
  <link>//intercept</link>
  <author>nju520</author>
  <pubDate>2016-08-16T21:46:58+08:00</pubDate>
  <guid>//intercept</guid>
  <description><![CDATA[
  <p>这篇文章会提供一种在 Cocoa 层拦截所有 HTTP 请求的方法，其实标题已经说明了拦截 HTTP 请求需要的了解的就是 <code>NSURLProtocol</code>。</p>

<p>由于文章的内容较长，会分成两部分，这篇文章介绍 <code>NSURLProtocol</code> 拦截 HTTP 请求的原理，另一篇文章<a href="https://github.com/nju520/iOS-Source-Code-Analyze/blob/master/contents/OHHTTPStubs/如何进行%20HTTP%20Mock（iOS）.md">如何进行 HTTP Mock</a> 介绍这个原理在 <code>OHHTTPStubs</code> 中的应用，它是如何 Mock（伪造）某个 HTTP 请求对应的响应的。</p>

<h2 id="nsurlprotocol">NSURLProtocol</h2>

<p><code>NSURLProtocol</code> 是苹果为我们提供的 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html">URL Loading System</a> 的一部分，这是一张从官方文档贴过来的图片：</p>

<p><img src="https://img.nju520.me/2016-08-16-URL-loading-system.png-1000width" alt="URL-loading-syste" /></p>

<p>官方文档对 <code>NSURLProtocol</code> 的描述是这样的：</p>

<blockquote>
  <p>An NSURLProtocol object handles the loading of protocol-specific URL data. The NSURLProtocol class itself is an abstract class that provides the infrastructure for processing URLs with a specific URL scheme. You create subclasses for any custom protocols or URL schemes that your app supports.</p>
</blockquote>

<p>在每一个 HTTP 请求开始时，URL 加载系统创建一个合适的 <code>NSURLProtocol</code> 对象处理对应的 URL 请求，而我们需要做的就是写一个继承自 <code>NSURLProtocol</code> 的类，并通过 <code>- registerClass:</code> 方法注册我们的协议类，然后 URL 加载系统就会在请求发出时使用我们创建的协议对象对该请求进行处理。</p>

<p>这样，我们需要解决的核心问题就变成了如何使用 <code>NSURLProtocol</code> 来处理所有的网络请求，这里使用苹果官方文档中的 <a href="https://developer.apple.com/library/ios/samplecode/CustomHTTPProtocol/CustomHTTPProtocol.zip">CustomHTTPProtocol</a> 进行介绍，你可以点击<a href="https://developer.apple.com/library/ios/samplecode/CustomHTTPProtocol/CustomHTTPProtocol.zip">这里</a>下载源代码。</p>

<p>在这个工程中 <code>CustomHTTPProtocol.m</code> 是需要重点关注的文件，<code>CustomHTTPProtocol</code> 就是 <code>NSURLProtocol</code> 的子类：</p>

<pre><code class="language-objectivec">@interface CustomHTTPProtocol : NSURLProtocol

...

@end
</code></pre>

<p>现在重新回到需要解决的问题，也就是 <strong>如何使用 NSURLProtocol 拦截 HTTP 请求？</strong>，有这个么几个问题需要去解决：</p>

<ul>
  <li>如何决定哪些请求需要当前协议对象处理？</li>
  <li>对当前的请求对象需要进行哪些处理？</li>
  <li><code>NSURLProtocol</code> 如何实例化？</li>
  <li>如何发出 HTTP 请求并且将响应传递给调用者？</li>
</ul>

<p>上面的这几个问题其实都可以通过 <code>NSURLProtocol</code> 为我们提供的 API 来解决，决定请求是否需要当前协议对象处理的方法是：<code>+ canInitWithRequest</code>：</p>

<pre><code class="language-objectivec">+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
	BOOL shouldAccept;
	NSURL *url;
	NSString *scheme;

	shouldAccept = (request != nil);
	if (shouldAccept) {
		url = [request URL];
		shouldAccept = (url != nil);
	}
	return shouldAccept;
}
</code></pre>

<p>因为项目中的这个方法是大约有 60 多行，在这里只粘贴了其中的一部分，只为了说明该方法的作用：每一次请求都会有一个 <code>NSURLRequest</code> 实例，上述方法会拿到所有的请求对象，我们就可以根据对应的请求选择是否处理该对象；而上面的代码只会处理所有 <code>URL</code> 不为空的请求。</p>

<p>请求经过 <code>+ canInitWithRequest:</code> 方法过滤之后，我们得到了所有要处理的请求，接下来需要对请求进行一定的操作，而这都会在 <code>+ canonicalRequestForRequest:</code> 中进行，虽然它与 <code>+ canInitWithRequest:</code> 方法传入的 request 对象都是一个，但是最好不要在 <code>+ canInitWithRequest:</code> 中操作对象，可能会有语义上的问题；所以，我们需要覆写 <code>+ canonicalRequestForRequest:</code> 方法提供一个标准的请求对象：</p>

<pre><code class="language-objectivec">+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
	return request;
}
</code></pre>

<p>这里对请求不做任何修改，直接返回，当然你也可以给这个请求加个 header，只要最后返回一个 <code>NSURLRequest</code> 对象就可以。</p>

<p>在得到了需要的请求对象之后，就可以初始化一个 <code>NSURLProtocol</code> 对象了：</p>

<pre><code class="language-objectivec">- (id)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id &lt;NSURLProtocolClient&gt;)client {
	return [super initWithRequest:request cachedResponse:cachedResponse client:client];
}
</code></pre>

<p>在这里直接调用 <code>super</code> 的指定构造器方法，实例化一个对象，然后就进入了发送网络请求，获取数据并返回的阶段了：</p>

<pre><code class="language-objectivec">- (void)startLoading {
	NSURLSession *session = [NSURLSession sessionWithConfiguration:[[NSURLSessionConfiguration alloc] init] delegate:self delegateQueue:nil];
	NSURLSessionDataTask *task = [session dataTaskWithRequest:self.request];
	[task resume];
}
</code></pre>

<blockquote>
  <p>这里使用简化了 CustomHTTPClient 中的项目代码，可以达到几乎相同的效果。</p>
</blockquote>

<p>你可以在 <code>- startLoading</code> 中使用任何方法来对协议对象持有的 <code>request</code> 进行转发，包括 <code>NSURLSession</code>、 <code>NSURLConnection</code> 甚至使用 AFNetworking 等网络库，只要你能在回调方法中把数据传回 <code>client</code>，帮助其正确渲染就可以，比如这样：</p>

<pre><code class="language-objectivec">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler {
	[[self client] URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageAllowed];

	completionHandler(NSURLSessionResponseAllow);
}

- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data {
	[[self client] URLProtocol:self didLoadData:data];
}
</code></pre>

<blockquote>
  <p>当然这里省略后的代码只会保证大多数情况下的正确执行，只是给你一个对获取响应数据粗略的认知，如果你需要更加详细的代码，我觉得最好还是查看一下 <code>CustomHTTPProtocol</code> 中对 HTTP 响应处理的代码，也就是 <code>NSURLSessionDelegate</code> 协议实现的部分。</p>
</blockquote>

<p><code>client</code> 你可以理解为当前网络请求的发起者，所有的 <code>client</code> 都实现了 <code>NSURLProtocolClient</code> 协议，协议的作用就是在 HTTP 请求发出以及接受响应时向其它对象传输数据：</p>

<pre><code class="language-objectivec">@protocol NSURLProtocolClient &lt;NSObject&gt;
...
- (void)URLProtocol:(NSURLProtocol *)protocol didReceiveResponse:(NSURLResponse *)response cacheStoragePolicy:(NSURLCacheStoragePolicy)policy;

- (void)URLProtocol:(NSURLProtocol *)protocol didLoadData:(NSData *)data;

- (void)URLProtocolDidFinishLoading:(NSURLProtocol *)protocol;
...
@end
</code></pre>

<p>当然这个协议中还有很多其他的方法，比如 HTTPS 验证、重定向以及响应缓存相关的方法，你需要在合适的时候调用这些代理方法，对信息进行传递。</p>

<p>如果你只是继承了 <code>NSURLProtocol</code> 并且实现了上述方法，依然不能达到预期的效果，完成对 HTTP 请求的拦截，你还需要在 URL 加载系统中注册当前类：</p>

<pre><code class="language-objectivec">[NSURLProtocol registerClass:self];
</code></pre>

<blockquote>
  <p>需要注意的是 <code>NSURLProtocol</code> 只能拦截 <code>UIURLConnection</code>、<code>NSURLSession</code> 和 <code>UIWebView</code> 中的请求，对于 <code>WKWebView</code> 中发出的网络请求也无能为力，如果真的要拦截来自 <code>WKWebView</code> 中的请求，还是需要实现 <code>WKWebView</code> 对应的 <code>WKNavigationDelegate</code>，并在代理方法中获取请求。
无论是 <code>NSURLProtocol</code>、<code>NSURLConnection</code> 还是 <code>NSURLSession</code> 都会走底层的 socket，但是 <code>WKWebView</code> 可能由于基于 WebKit，并不会执行 C socket 相关的函数对 HTTP 请求进行处理，具体会执行什么代码暂时不是很清楚，如果对此有兴趣的读者，可以联系笔者一起讨论。</p>
</blockquote>

<h2 id="总结">总结</h2>

<p>如果你只想了解如何对 HTTP 请求进行拦截，其实看到这里就可以了，不过如果你想应用文章中的内容或者希望了解如何伪造 HTTP 响应，可以看下一篇文章<a href="https://github.com/nju520/iOS-Source-Code-Analyze/blob/master/contents/OHHTTPStubs/如何进行%20HTTP%20Mock（iOS）.md">如何进行 HTTP Mock</a>。</p>

<h2 id="references">References</h2>
<p> + <a href="[http://nshipster.com/nsurlprotocol/]">NSURLProtocol</a></p>

<blockquote>
  <p>Github Repo：<a href="https://github.com/nju520/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p>

</blockquote>

<blockquote>

  <p>Source: http://nju520.me/intercept</p>
</blockquote>

  ]]></description>
</item>


  </channel>
</rss>
