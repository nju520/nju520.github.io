<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    
    <title>nju520.me</title>
    
    <link>http://localhost:4000</link>
    <description>nju520's Blog</description>
    <language>en-uk</language>
    <managingEditor> nju520</managingEditor>
    <atom:link href="rss" rel="self" type="application/rss+xml" />
    
<item>
  <title>iOS 源代码分析 ---- Alamofire</title>
  <link>//ios-yuan-dai-ma-fen-xi-alamofire</link>
  <author>nju520</author>
  <pubDate>2016-03-10T17:41:36+08:00</pubDate>
  <guid>//ios-yuan-dai-ma-fen-xi-alamofire</guid>
  <description><![CDATA[
  <p>已经有几个月没有阅读著名开源项目的源代码了, 最近才有时间来做这件事情.</p>

<p>下面是 Github 主页上对 <a href="https://github.com/Alamofire/Alamofire">Alamofire</a> 的描述</p>

<blockquote>
  <p>Elegant HTTP Networking in Swift</p>
</blockquote>

<p>为什么这次我选择阅读 Alamofire 的源代码而不是 AFNetworking 呢, 其实有两点原因.</p>

<ol>
  <li>AFNetworking 作为一个有着很多年的历史的框架, 它虽然有着强大的社区, 不过因为时间太久了, 可能有一些历史上的包袱. 而 Alamofire 是在 Swift 诞生之后才开始出现的, 到现在为止也并没有多长时间, 它的源代码都是<strong>新鲜</strong>的.</li>
  <li>由于最近在写 Swift 的项目, 所以没有选择 AFNetworking.</li>
</ol>

<p>在阅读 Alamofire 的源代码之前, 我先粗略的查看了一下 Alamofire 实现的代码行数:</p>

<pre><code class="language-shell">$ find Source -name "*.swift" | xargs cat |wc -l
&gt; 3363
</code></pre>

<p>也就是说 Alamofire 在包含注释以及空行的情况下, 只使用了 3000 多行代码就实现了一个用于处理 HTTP 请求的框架.</p>

<p>所以它描述中的 <code>Elegant</code> 也可以说是名副其实.</p>

<h2 id="目录结构">目录结构</h2>

<p>首先, 我们来看一下 Alamofire 中的目录结构, 来了解一下它是如何组织各个文件的.</p>

<pre><code>- Source
	- Alamore.swift
	- Core
		- Manager.swift
		- ParameterEncoding.swift
		- Request.swift
	- Features
		- Download.swift
		- MultipartFromData.swift
		- ResponseSeriallization.swift
		- Upload.swift
		- Validation.swift
</code></pre>

<p>框架中最核心并且我们最值得关注的就是 <code>Alamore.swift</code> <code>Manager.swift</code> 和 <code>Request.swift</code> 这三个文件. 也是在这篇 post 中主要介绍的三个文件.</p>

<h3 id="alamofire">Alamofire</h3>

<p>在 Alamofire 中并没有找到 <code>Alamofire</code> 这个类, 相反这仅仅是一个命名空间, 在 <code>Alamofire.swift</code> 这个文件中不存在 <code>class Alamofire</code> 这种关键字, 这只是为了使得方法名更简洁的一种手段.</p>

<p>我们在使用 Alamofire 时, 往往都会采用这种方式:</p>

<pre><code class="language-swift">Alamofire.request(.GET, "http://httpbin.org/get")
</code></pre>

<p>有了 Alamofire 作为命名空间, 就不用担心 <code>request</code> 方法与其他同名方法的冲突了.</p>

<p>在 <code>Alamofire.swift</code>  文件中为我们提供了三类方法:</p>

<ul>
  <li>request</li>
  <li>upload</li>
  <li>download</li>
</ul>

<p>这三种方法都是通过调用 <code>Manager</code> 对应的操作来完成请求, 上传和下载的操作, 并返回一个 <code>Request</code> 的实例.</p>

<p>下面是 <code>request</code> 方法的一个实现:</p>

<pre><code class="language-swift">public func request(method: Method, URLString: URLStringConvertible, parameters: [String: AnyObject]? = nil, encoding: ParameterEncoding = .URL, headers: [String: String]? = nil) -&gt; Request {
    return Manager.sharedInstance.request(method, URLString, parameters: parameters, encoding: encoding, headers: headers)
}
</code></pre>

<p>这也就是 <code>Alamofire.request(.GET, "http://httpbin.org/get")</code> 所调用的方法. 而这个方法实际上就是通过这些参数调用 <code>Manager</code> 的具体方法, 我们所使用的 <code>request</code> 也好 <code>download</code> 也好, 都是对 <code>Manager</code> 方法的一个包装罢了.</p>

<h3 id="manager">Manager</h3>

<p>Alamofire 中的几乎所有操作都是通过 <code>Manager</code> 来控制, 而 <code>Manager</code> 也可以说是 Alamofire 的核心部分, 它负责与 <code>Request</code> 交互完成网络操作:</p>

<blockquote>
  <p>Responsible for creating and managing <code>Request</code> objects, as well as their underlying <code>NSURLSession</code>.</p>
</blockquote>

<h4 id="managersharedinstance">Manager.sharedInstance</h4>

<p><code>Manager</code> 在 Alamofire 中有着极其重要的地位, 而在 <code>Manager</code> 方法的设计中, 一般也使用 <code>sharedInstance</code> 来获取 <code>Manager</code> 的单例:</p>

<pre><code class="language-swift">public static let sharedInstance: Manager = {
    let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
    configuration.HTTPAdditionalHeaders = Manager.defaultHTTPHeaders

    return Manager(configuration: configuration)
}()
</code></pre>

<p>对于其中 <code>defaultHTTPHeaders</code> 和 <code>Manager</code> 的初始化方法, 在这里就不多提了, 但是在这里有必要说明一下 <code>SessionDelegate</code> 这个类, 在 <code>Manager</code> 的初始化方法中, 调用了 <code>SessionDelegate</code> 的初始化方法, 返回了一个它的实例.</p>

<h4 id="sessiondelegate">SessionDelegate</h4>

<blockquote>
  <p>Responsible for handling all delegate callbacks for the underlying session.</p>
</blockquote>

<p>这个类的主要作用就是处理对应 session 的所有代理回调, 它持有两个属性:</p>

<pre><code class="language-swift">private var subdelegates: [Int: Request.TaskDelegate] = [:]
private let subdelegateQueue = dispatch_queue_create(nil, DISPATCH_QUEUE_CONCURRENT)
</code></pre>

<p><code>subdelegates</code> 以 task 标识符为键, 存储了所有的回调. <code>subdelegateQueue</code> 是一个异步的队列, 用于处理任务的回调.</p>

<h4 id="managersharedinstacerequest">Manager.sharedInstace.request</h4>

<p><code>Manager</code> 有两个返回 <code>Request</code> 实例的 <code>request</code> 方法:</p>

<ul>
  <li><code>public func request(method: Method, _ URLString: URLStringConvertible, parameters: [String: AnyObject]? = nil, encoding: ParameterEncoding = .URL, headers: [String: String]? = nil) -&gt; Request</code></li>
  <li><code>public func request(URLRequest: URLRequestConvertible) -&gt; Request</code></li>
</ul>

<p>第一个方法的实现非常的简单:</p>

<pre><code class="language-swift">public func request(method: Method, _ URLString: URLStringConvertible, parameters: [String: AnyObject]? = nil, encoding: ParameterEncoding = .URL, headers: [String: String]? = nil) -&gt; Request {
    let mutableURLRequest = URLRequest(method, URLString, headers: headers)
    let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
    return request(encodedURLRequest)
}
</code></pre>

<p>方法中首先调用了 <code>URLRequest</code> 方法:</p>

<pre><code class="language-swift">func URLRequest(method: Method, URLString: URLStringConvertible, headers: [String: String]? = nil) -&gt; NSMutableURLRequest {
    let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!)
    mutableURLRequest.HTTPMethod = method.rawValue

    if let headers = headers {
        for (headerField, headerValue) in headers {
        mutableURLRequest.setValue(headerValue, forHTTPHeaderField: headerField)
        }
    }

    return mutableURLRequest
}
</code></pre>

<p>首先创建一个 <code>NSMutableURLRequest</code> 设置它的 HTTP 请求方法和 HTTP header, 然后返回这个请求.</p>

<p>在请求被返回之后, 就进入了下一个环节 <code>encode</code>.</p>

<pre><code class="language-swift">let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
</code></pre>

<h4 id="parameterencodingencoding">ParameterEncoding.encoding</h4>

<p><code>ParameterEncoding</code> 是一个用来处理一系列的参数是如何被”添加”到 URL 请求上的.</p>

<blockquote>
  <p>Used to specify the way in which a set of parameters are applied to a URL request.</p>
</blockquote>

<p><code>ParameterEncoding</code> 类型中有四种不同的编码方法:</p>

<ul>
  <li>URL</li>
  <li>JSON</li>
  <li>PropertyList</li>
  <li>Custom</li>
</ul>

<p>其中 <code>encode</code> 方法就根据 <code>ParameterEncoding</code> 类型的不同返回不同的 <code>NSMutableURLRequest</code></p>

<p>如果 <code>PatameterEncoding</code> 的类型为 <code>URL</code>, 那么就会把这次请求的参数以下面这种形式添加到请求的 <code>URL</code> 上</p>

<pre><code>foo[]=1&amp;foo[]=2
</code></pre>

<p>在完成对参数的编码之后, 就会调用另一个同名的 <code>request</code> 方法</p>

<pre><code class="language-swift">request(encodedURLRequest)
</code></pre>

<h4 id="managersharedinstacerequesturlrequestconvertible">Manager.sharedInstace.request(URLRequestConvertible)</h4>

<p><code>request</code> 方法根据指定的 URL 请求返回一个 <code>Request</code></p>

<blockquote>
  <p>Creates a request for the specified URL request.</p>
</blockquote>

<p>它使用 <code>dispatch_sync</code> 把一个 <code>NSURLRequest</code> 请求同步加到一个串行队列中, 返回一个 <code>NSURLSessionDataTask</code>. 并通过 <code>session</code> 和 <code>dataTask</code> 生成一个 <code>Request</code> 的实例.</p>

<pre><code class="language-swift">public func request(URLRequest: URLRequestConvertible) -&gt; Request {
    var dataTask: NSURLSessionDataTask!

    dispatch_sync(queue) {
        dataTask = self.session.dataTaskWithRequest(URLRequest.URLRequest)
    }

    let request = Request(session: session, task: dataTask)
    delegate[request.delegate.task] = request.delegate

    if startRequestsImmediately {
        request.resume()
    }

    return request
}
</code></pre>

<p>这段代码还是很直观的, 它的主要作用就是创建 <code>Request</code> 实例, 并发送请求.</p>

<h4 id="requestinit">Request.init</h4>

<p><code>Request</code> 这个类的 <code>init</code> 方法根据传入的 <code>task</code> 类型的不同, 生成了不用类型的 <code>TaskDelegate</code>, 可以说是 Swift 中对于反射的运用:</p>

<pre><code class="language-swift">init(session: NSURLSession, task: NSURLSessionTask) {
    self.session = session

    switch task {
    case is NSURLSessionUploadTask:
        self.delegate = UploadTaskDelegate(task: task)
    case is NSURLSessionDataTask:
        self.delegate = DataTaskDelegate(task: task)
    case is NSURLSessionDownloadTask:
        self.delegate = DownloadTaskDelegate(task: task)
    default:
        self.delegate = TaskDelegate(task: task)
    }
}
</code></pre>

<p>在 <code>UploadTaskDelegate</code> <code>DataTaskDelegate</code> <code>DownloadTaskDelegate</code> 和 <code>TaskDelegate</code> 几个类的作用是处理对应任务的回调, 在 <code>Request</code> 实例初始化之后, 会把对应的 <code>delegate</code> 添加到 <code>manager</code> 持有的 <code>delegate</code> 数组中, 方便之后在对应的时间节点通知代理事件的发生.</p>

<p>在最后返回 <code>request</code>, 到这里一次网络请求就基本完成了.</p>

<h3 id="responseserialization">ResponseSerialization</h3>

<p><code>ResponseSerialization</code> 是用来对 <code>Reponse</code> 返回的值进行序列化显示的一个 extension.</p>

<p>它的设计非常的巧妙, 同时可以处理 <code>Data</code> <code>String</code> 和 <code>JSON</code> 格式的数据,</p>

<h4 id="responseserializer-协议">ResponseSerializer 协议</h4>

<p>Alamofire 在这个文件的开头定义了一个所有 responseSerializer 都必须遵循的 <code>protocol</code>, 这个 protocol 的内容十分简单, 其中最重要的就是:</p>

<pre><code class="language-swift">var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?) -&gt; Result&lt;SerializedObject&gt; { get }
</code></pre>

<p>所有的 responseSerializer 都必须包含 <code>serializeResponse</code> 这个闭包, 它的作用就是处理 response.</p>

<h4 id="genericresponseserializer">GenericResponseSerializer</h4>

<p>为了同时处理不同类型的数据, Alamofire 使用泛型创建了 <code>GenericResponseSerializer&lt;T&gt;</code>, 这个结构体为处理 <code>JSON</code> <code>XML</code> 和 <code>NSData</code> 等数据的 responseSerializer 提供了一个骨架.</p>

<p>它在结构体中遵循了 <code>ResponseSerializer</code> 协议, 然后提供了一个 <code>init</code> 方法</p>

<pre><code class="language-swift">public init(serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?) -&gt; Result&lt;SerializedObject&gt;) {
    self.serializeResponse = serializeResponse
}
</code></pre>

<h4 id="response-方法">response 方法</h4>

<p>在 Alamofire 中, 如果我们调用了 reponse 方法, 就会在 request 结束时, 添加一个处理器来处理服务器的 reponse.</p>

<p>这个方法有两个版本, 第一个版本是不对返回的数据进行处理:</p>

<pre><code class="language-swift">public func response(
    queue queue: dispatch_queue_t? = nil,
    completionHandler: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -&gt; Void)
    -&gt; Self
{
    delegate.queue.addOperationWithBlock {
        dispatch_async(queue ?? dispatch_get_main_queue()) {
            completionHandler(self.request, self.response, self.delegate.data, self.delegate.error)
        }
    }

    return self
}
</code></pre>

<p>该方法的实现将一个 block 追加到 request 所在的队列中, 其它的部分过于简单, 在这里就不多说了.</p>

<p>另一个版本的 response 的作用就是处理多种类型的数据.</p>

<pre><code class="language-swift">public func response&lt;T: ResponseSerializer, V where T.SerializedObject == V&gt;(
    queue queue: dispatch_queue_t? = nil,
    responseSerializer: T,
    completionHandler: (NSURLRequest?, NSHTTPURLResponse?, Result&lt;V&gt;) -&gt; Void)
    -&gt; Self
{
    delegate.queue.addOperationWithBlock {
        var result = responseSerializer.serializeResponse(self.request, self.response, self.delegate.data)

        if let error = self.delegate.error {
            result = .Failure(self.delegate.data, error)
        }

        dispatch_async(queue ?? dispatch_get_main_queue()) {
            completionHandler(self.request, self.response, result)
        }
    }

    return self
}
</code></pre>

<p>它会直接调用参数中 <code>responseSerializer</code> 所持有的闭包 <code>serializeResponse</code>, 然后返回对应的数据.</p>

<h4 id="多种类型的-response-数据">多种类型的 response 数据</h4>

<p>有了高级的抽象方法 <code>response</code>, 我们现在就可以直接向这个方法中传入不同的 <code>responseSerializer</code> 来产生不同数据类型的 <code>handler</code></p>

<p>比如说 <code>NSData</code></p>

<pre><code class="language-swift">public static func dataResponseSerializer() -&gt; GenericResponseSerializer&lt;NSData&gt; {
    return GenericResponseSerializer { _, _, data in
        guard let validData = data else {
            let failureReason = "Data could not be serialized. Input data was nil."
            let error = Error.errorWithCode(.DataSerializationFailed, failureReason: failureReason)
            return .Failure(data, error)
        }

        return .Success(validData)
    }
}

public func responseData(completionHandler: (NSURLRequest?, NSHTTPURLResponse?, Result&lt;NSData&gt;) -&gt; Void) -&gt; Self {
    return response(responseSerializer: Request.dataResponseSerializer(), completionHandler: completionHandler)
}
</code></pre>

<p>在 <code>ResponseSerialization.swift</code> 这个文件中, 你还可以看到其中对于 <code>String</code> <code>JSON</code> <code>propertyList</code> 数据处理的 <code>responseSerializer</code>.</p>

<h3 id="urlstringconvertible">URLStringConvertible</h3>

<p>在 ALamofire 的实现中还有一些我们可以学习的地方. 因为 Alamofire 是一个 Swift 的框架, 而且 Swift 是静态语言, 所以有一些坑是必须要解决的, 比如说 <code>NSURL</code> 和 <code>String</code> 之间的相互转换. 在 Alamofire 中用了一种非常优雅的解决方案, 我相信能够给很多人带来一定的启发.</p>

<p>首先我们先定义了一个 <code>protocol</code> <code>URLStringConvertible</code> (注释部分已经省略) :</p>

<pre><code class="language-swift">public protocol URLStringConvertible {
    var URLString: String { get }
}
</code></pre>

<p>这个 <code>protocol</code> 只定义了一个 <code>var</code>, 遵循这个协议的类必须实现 <code>URLString</code> 返回 <code>String</code> 的这个<strong>功能</strong>.</p>

<p>接下来让所有可以转化为 <code>String</code> 的类全部遵循这个协议, 这个方法虽然我以前知道, 不过我还是第一次见到在实际中的使用, 真的非常的优雅:</p>

<pre><code class="language-swift">extension String: URLStringConvertible {
    public var URLString: String {
        return self
    }
}

extension NSURL: URLStringConvertible {
    public var URLString: String {
        return absoluteString!
    }
}

extension NSURLComponents: URLStringConvertible {
    public var URLString: String {
        return URL!.URLString
    }
}

extension NSURLRequest: URLStringConvertible {
    public var URLString: String {
        return URL!.URLString
    }
}
</code></pre>

<p>这样 <code>String</code> <code>NSURL</code> <code>NSURLComponents</code> 和 <code>NSURLRequest</code> 都可以调用 <code>URLString</code> 方法了. 我们也就可以<strong>直接在方法的签名中使用 <code>URLStringConvertible</code> 类型</strong>.</p>

<h2 id="end">End</h2>

<p>到目前为止关于 Alamofire 这个框架就大致介绍完了, 框架的实现还是非常简洁和优雅的, 这篇 post 从开始写到现在也过去了好久, 写的也不是十分的详细具体. 如果你对这个框架的实现有兴趣, 那么看一看这个框架的源代码也未尝不可.</p>

<iframe src="http://ghbtns.com/github-btn.html?user=nju520&amp;type=follow&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowtransparency="true"></iframe>

<p>Blog: <a href="http://nju520.me">nju520.me</a></p>

  ]]></description>
</item>


  </channel>
</rss>
