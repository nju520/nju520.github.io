<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    
    <title>hwbnju.com</title>
    
    <link>http://hwbnju.com</link>
    <description>nju520's Blog</description>
    <language>en-uk</language>
    <managingEditor> nju520</managingEditor>
    <atom:link href="rss" rel="self" type="application/rss+xml" />
    
<item>
  <title>Ruby Rack 协议及其应用(三)</title>
  <link>//rack-rails</link>
  <author>nju520</author>
  <pubDate>2017-11-05T00:00:00+08:00</pubDate>
  <guid>//rack-rails</guid>
  <description><![CDATA[
  <h2 id="ruby-on-rails-启动流程">Ruby on Rails 启动流程</h2>

<p>我们从 <code>rails server</code> 这个指令开始来解读<code>Ruby on Rails</code>的启动流程.</p>

<h3 id="源码阅读前的准备">源码阅读前的准备</h3>

<h4 id="pry-use">Pry Use</h4>

<h4 id="ruby-file-operation">Ruby File Operation</h4>

<p>阅读源码时需要用到文件路径的几个方法, 先在这里总结一下.</p>

<ol>
  <li>
    <p><code>__FILE__</code> 是一个常量, 返回一个带文件后缀的文件名.</p>
  </li>
  <li>
    <p><code>File.dirname</code> 返回当前文件的相对路径</p>
    <blockquote>
      <p>Returns all components of the filename given in file_name except the last one. The filename can be formed using both File::SEPARATOR and File::ALT_SEPARATOR as the separator when File::ALT_SEPARATOR is not nil.</p>
    </blockquote>
  </li>
</ol>

<pre><code class="language-ruby">File.dirname("/home/gumby/work/ruby.rb")
# =&gt; "/home/gumby/work"
</code></pre>

<ol>
  <li><code>File.expand_path</code>, 将路径名转换为绝对路径返回.
    <blockquote>
      <p>Converts a pathname to an absolute pathname. Relative paths are referenced from the current working directory of the process unless dir_string is given, in which case it will be used as the starting point. The given pathname may start with a “~”, which expands to the process owner’s home directory (the environment variable HOME must be set correctly). “~user” expands to the named user’s home directory.</p>
    </blockquote>
  </li>
</ol>

<pre><code class="language-ruby">File.expand_path('.')
# =&gt; return current absolute path
</code></pre>

<pre><code class="language-test.rb">puts "__FILE__ is #{__FILE__}"
puts "File.dirname(__FILE__) is #{File.dirname(__FILE__)}"
puts "File.expand_path(File.dirname(__FILE__)) is #{File.expand_path(File.dirname(__FILE__))}"
</code></pre>

<p>输出结果如下:</p>

<pre><code class="language-shell">__FILE__ is hehe.rb
File.dirname(__FILE__) is .
File.expand_path(File.dirname(__FILE__)) is /Users/bobo/Tool/hehe

</code></pre>

<h3 id="railtie类---ruby-on-rails-内部引擎">Railtie类 -&gt; Ruby On Rails 内部引擎</h3>

<h3 id="rails-applciation-api-guide">Rails Applciation API Guide</h3>

<p>熟悉<code>Ruby on Rails</code>的同学可以知道, 我们可以通过<code>rails console</code> 或者 <code>rails server</code> 命令启动<code>Rails</code>应用.</p>

<p>在<code>Rails API</code>文档中(5.2.0), 关于<code>Application</code>这个类的介绍写到了一个<code>Rails Application</code>的启动流程:</p>

<pre><code class="language-ruby">1)  require "config/boot.rb" to setup load paths
2)  require railties and engines
3)  Define Rails.application as "class MyApp::Application &lt; Rails::Application"
4)  Run config.before_configuration callbacks
5)  Load config/environments/ENV.rb
6)  Run config.before_initialize callbacks
7)  Run Railtie#initializer defined by railties, engines and application.
    One by one, each engine sets up its load paths, routes and runs its config/initializers/* files.
8)  Custom Railtie#initializers added by railties, engines and applications are executed
9)  Build the middleware stack and run to_prepare callbacks
10) Run config.before_eager_load and eager_load! if eager_load is true
11) Run config.after_initialize callbacks
</code></pre>

<p>我们就参照上面的启动流程开启<code>Ruby on Rails</code>的启动流程解读.</p>

<h3 id="server-的启动">Server 的启动</h3>

<p>我们直接从<code>rails server</code>这条命令开始定位<code>Server.start</code></p>

<h5 id="railtiesexerails">railties/exe/rails</h5>

<p>在某个Rails项目的命令行中运行如下指令可以定位我们使用的<code>rails</code></p>

<pre><code class="language-shell">where rails
# =&gt; /Users/bobo/.rvm/gems/ruby-2.4.2/bin/rails
</code></pre>

<p><code>rails server</code> 命令中的 <code>rails</code> 就位于上述的一个<code>Ruby</code>可执行文件. 文件内容如下:</p>

<pre><code class="language-ruby">λ cat /Users/bobo/.rvm/gems/ruby-2.4.2/bin/rails
#!/usr/bin/env ruby
#
# This file was generated by RubyGems.
#
# The application 'railties' is installed as part of a gem, and
# this file is here to facilitate running it.
#

require 'rubygems'

version = "&gt;= 0.a"

if ARGV.first
  str = ARGV.first
  str = str.dup.force_encoding("BINARY") if str.respond_to? :force_encoding
  if str =~ /\A_(.*)_\z/ and Gem::Version.correct?($1) then
    version = $1
    ARGV.shift
  end
end

if Gem.respond_to?(:activate_bin_path)
  load Gem.activate_bin_path('railties', 'rails', version)
else
  gem "railties", version
  load Gem.bin_path("railties", "rails", version)
end

</code></pre>

<p>在 <code>Rails Console</code>中运行上述代码, 我们可以看到加载的文件如下:</p>

<pre><code class="language-shell">"/Users/bobo/.rvm/gems/ruby-2.4.2/gems/railties-5.1.6/exe/rails"
</code></pre>

<p>让我们来看一下这个文件的内容:</p>
<pre><code class="language-ruby">#!/usr/bin/env ruby

git_path = File.expand_path("../../../.git", __FILE__)
# =&gt; /Users/bobo/.rvm/gems/ruby-2.4.2/gems/.git

if File.exist?(git_path)
  railties_path = File.expand_path("../../lib", __FILE__)
  $:.unshift(railties_path)
end

# 关键代码
require "rails/cli"
</code></pre>

<p>关键代码就是最后一行, 加载 <code>rails/cli</code> 文件.</p>

<pre><code class="language-ruby"># frozen_string_literal: true

require "rails/app_loader"

# If we are inside a Rails application this method performs an exec and thus
# the rest of this script is not run.
Rails::AppLoader.exec_app

require "rails/ruby_version_check"
Signal.trap("INT") { puts; exit(1) }

require "rails/command"

if ARGV.first == "plugin"
  ARGV.shift
  Rails::Command.invoke :plugin, ARGV
else
  Rails::Command.invoke :application, ARGV
end
</code></pre>

<h5 id="railtieslibrailsapp_loaderrb">railties/lib/rails/app_loader.rb</h5>

<p>查看文件 <code>railties/lib/rails/app_loader.rb</code>:</p>

<pre><code class="language-ruby">
RUBY = Gem.ruby
# "/Users/bobo/.rvm/rubies/ruby-2.4.2/bin/ruby"
EXECUTABLES = ["bin/rails", "script/rails"]

def exec_app
  original_cwd = Dir.pwd

  loop do
    if exe = find_executable
      contents = File.read(exe)

      if contents =~ /(APP|ENGINE)_PATH/
        exec RUBY, exe, *ARGV
        break # non reachable, hack to be able to stub exec in the test suite
      elsif exe.end_with?("bin/rails") &amp;&amp; contents.include?("This file was generated by Bundler")
        # 以下情况只有在 bin/rails 中没有 APP_PATH 或者 ENGINE_PATH时才会设置
        $stderr.puts(BUNDLER_WARNING)
        # 设置 APP_PATH 常量
        Object.const_set(:APP_PATH, File.expand_path("config/application", Dir.pwd))
        # 加载 config/root.rb
        require File.expand_path("../boot", APP_PATH)
        # 加载 rails/commands
        require "rails/commands"
        break
      end
    end

    # If we exhaust the search there is no executable, this could be a
    # call to generate a new application, so restore the original cwd.
    Dir.chdir(original_cwd) &amp;&amp; return if Pathname.new(Dir.pwd).root?

    # Otherwise keep moving upwards in search of an executable.
    Dir.chdir("..")
  end
end

def find_executable
  EXECUTABLES.find { |exe| File.file?(exe) }
end
</code></pre>

<p><code>exec_app</code>方法的主要作用是执行应用中的<code>bin/rails</code>文件.
如果在当前文件夹未找到<code>bin/rails</code>文件, 就会继续在上层文件夹中查找, 直到找到为止. 因此, 我们可以在一个<code>Rails</code>应用中的任何位置执行<code>rails 命令</code>.</p>

<p>执行 <code>rails server</code> 实际上就相当于执行 <strong><code>exec ruby bin/rails server</code></strong></p>

<h5 id="binrails-文件">bin/rails 文件</h5>

<pre><code class="language-ruby">#!/usr/bin/env ruby
begin
  load File.expand_path('../spring', __FILE__)
rescue LoadError =&gt; e
  raise unless e.message.include?('spring')
end

APP_PATH = File.expand_path('../config/application', __dir__)
# =&gt; "/Users/bobo/bobo/risewinter/Project/AW/config/application"

require_relative '../config/boot'
# boot 用于加载并设置 Bundler

require 'rails/commands'
# 加载 commands 文件
# 用来响应 rails server 这条指令

</code></pre>

<p>PS: 程序执行到<code>app_loader.rb</code>还未加载 <code>config/application.rb</code>.</p>

<h5 id="railscommandsrb">rails/commands.rb</h5>

<p><code>bin/rails</code>文件中执行 <code>config/boot.rb</code>文件的代码之后, 下一步就是要加载<code>rails/commands</code>,作用就是扩展命令别名.
我们在命令行中输入<code>rails server</code>, ARGV 数组只包含将要传递的<code>server</code>命令:</p>

<pre><code class="language-ruby"># frozen_string_literal: true

require "rails/command"

aliases = {
  "g"  =&gt; "generate",
  "d"  =&gt; "destroy",
  "c"  =&gt; "console",
  "s"  =&gt; "server",
  "db" =&gt; "dbconsole",
  "r"  =&gt; "runner",
  "t"  =&gt; "test"
}

command = ARGV.shift
command = aliases[command] || command

# rails server 命令执行时, 会调用下面一行代码
# command =&gt; server
# ARGV =&gt; 命令行参数
Rails::Command.invoke command, ARGV

</code></pre>

<h5 id="railscommandrb">rails/command.rb</h5>

<pre><code class="language-ruby"># namespace = server

# Receives a namespace, arguments and the behavior to invoke the command.
def invoke(full_namespace, args = [], **config)
  namespace = full_namespace = full_namespace.to_s

  if char = namespace =~ /:(\w+)$/
    command_name, namespace = $1, namespace.slice(0, char)
  else
    command_name = namespace
  end

  command_name, namespace = "help", "help" if command_name.blank? || HELP_MAPPINGS.include?(command_name)
  command_name, namespace = "version", "version" if %w( -v --version ).include?(command_name)

  command = find_by_namespace(namespace, command_name)
  if command &amp;&amp; command.all_commands[command_name]
    command.perform(command_name, args, config)
  else
    find_by_namespace("rake").perform(full_namespace, args, config)
  end
end
</code></pre>

<p>当我们输入<code>Rails</code>命令时, <code>invoke</code>尝试查找指定命名空间的命令, 如果找到就执行那个命令.
如果找不到, <code>Rails</code>委托<code>rake</code>执行同名任务.</p>

<p>我们输入的<code>rails server</code>命令, 因此<code>Rails</code>会进一步运行下面的代码:</p>

<pre><code class="language-ruby">module Rails
  module Command
    class ServerCommand &lt; Base
      def perform
        set_application_directory!
        prepare_restart

        # 关键点(一)
        Rails::Server.new(server_options).tap do |server|
          # Require application after server sets environment to propagate
          # the --environment option.
          # config/application.rb
          # 关键点(二)
          require APP_PATH
          Dir.chdir(Rails.application.root)

          if server.serveable?
            print_boot_information(server.server, server.served_url)
            after_stop_callback = -&gt; { say "Exiting" unless options[:daemon] }
            # 关键点(三)
            server.start(after_stop_callback) # 启动服务器
          else
            say rack_server_suggestion(using)
          end
        end
      end

    end
  end
end
</code></pre>

<p>上述三个关键点分别对应三个重要环节:</p>

<ul>
  <li>初始化 <code>server</code></li>
  <li>加载 <code>APP_PATH</code></li>
  <li>启动 <code>server</code></li>
</ul>

<h4 id="初始化-server">初始化 server</h4>

<h5 id="railscommandsserverserver_commandrb">rails/commands/server/server_command.rb</h5>

<p>此文件中定义了<code>Rails::Server</code>类, 它继承自<code>Rack::Server</code>类.
当调用<code>Rails::Server.new</code>方法时, 会调用此文件中定义的<code>initialize</code>方法.</p>

<pre><code class="language-ruby">def initialize
  super
  set_enviroment
end
</code></pre>

<p><code>super</code>关键字会调用<code>Rack::Server</code>类的<code>initialize</code>方法.</p>

<h5 id="rack-librackserverrb">Rack: lib/rack/server.rb</h5>

<p>又回到了我们之前讲述过的<code>Rack</code>了.<code>Rack::Server</code>类负责所有基于<code>Rack</code>的应用(包括Rails)提供通用服务器接口.
<code>Rack::Server</code>类的<code>initialize</code>方法作用主要是设置几个变量.</p>

<p>当<code>super</code>方法完成<code>Rack::Server</code>类的<code>initialize</code>方法的调用时, 程序执行流程会重新回到<code>rails/commands/server/server_command.rb</code>文件中,
继续调用<code>set_enviroment</code>方法. 此方法主要用来配置一些基本的参数, 暂且不表.</p>

<p><code>initialize</code>方法运行完成之后, 程序执行流程就会跳回<code>server</code>命令, 加载之前设置的 <code>APP_PATH</code>.</p>

<h4 id="加载-app_path">加载 <code>APP_PATH</code></h4>

<h4 id="configapplicationrb">config/application.rb</h4>

<p>执行<code>require APP_PATH</code>时, 会加载<code>config/application.rb</code>文件.</p>

<p>在<code>require APP_PATH</code>时, 实际上对应API文档中的流程 1–4.</p>

<pre><code class="language-ruby">1) require "config/boot.rb" to setup load paths
2) require railties and engines
3) Define Rails.application as "class MyApp::Application &lt; Rails::Application"
4) Run config.before_configuration callbacks
</code></pre>

<pre><code class="language-ruby"># config/application.rb
require_relative 'boot'

require 'rails/all'

# Require the gems listed in Gemfile, including any gems
# you've limited to :test, :development, or :production.
Bundler.require(*Rails.groups)

ENV.update YAML.load_file('config/application.yml')[Rails.env] rescue {}

module MyApp
  class Application &lt; Rails::Application
    config.load_defaults 5.1
	config.time_zone = 'Beijing'
  end
  
end
</code></pre>

<h6 id="加载-boot">加载 boot</h6>

<pre><code class="language-ruby"># config/boot.rb
ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../Gemfile', __dir__)
# 设置 环境变量: BUNDLE_GEMFILE

require 'bundler/setup' # Set up gems listed in the Gemfile.
</code></pre>

<p>标准的Rails应用中包含<code>Gemfile</code>文件, 用于声明应用的所有依赖关系. <code>config/boot.rb</code>文件会把<code>ENV['BUNDLE_GEMFILE']</code>设置为<code>Gemfile</code>文件的路径.</p>

<h5 id="加载-railties-and-engines">加载 railties and engines</h5>

<p>这个其实是在<code>boot.rb</code>中进行的 <code>bunlder/setup</code>.<code>Bundler</code>通过它设置<code>Gemfile</code>中依赖关系的加载路径.</p>

<p>就相当于把<code>Gemfile</code>中使用的一些<code>gem</code>(这些Gem包含各种Engine或者Railtie)都加载到<code>load_path</code>中</p>

<h5 id="define-railsapplication-as-class-myappapplication--railsapplication">Define Rails.application as <code>class MyApp::Application &lt; Rails::Application</code></h5>

<p>在<code>config/application.rb</code>文件中, 我们在<code>MyApp</code>中定义了一个类继承<code>Rails::Application</code></p>

<pre><code class="language-ruby">module MyApp
  class Application &lt; Rails::Application
    config.load_defaults 5.1
	config.time_zone = 'Beijing'
  end
  
end
</code></pre>

<p>当<code>Rails::Application</code>被继承时, 会执行下面的一个<code>callback</code>:</p>

<pre><code class="language-ruby">module Rails
  class Application &lt; Engine
    class &lt;&lt; self
      #当 Rails::Application被继承时, 会调用这个 callback
      def inherited(base)
        super # Engine
        Rails.app_class = base
        add_lib_to_load_path!(find_root(base.called_from))
        ActiveSupport.run_load_hooks(:before_configuration, base)
      end
        
    end
  end
end
</code></pre>

<ul>
  <li>设置 Rails.application -&gt; MyApp::Application</li>
  <li>加载 lib 目录到 load_path</li>
  <li>执行 <code>config.before_configuration callbacks</code></li>
</ul>

<h4 id="server-启动">server 启动</h4>

<p><code>server</code>的启动其实是根据参数来选择一个符合<code>rack</code>规范的具体的<code>server</code>, 比如<code>thin</code> <code>webrick</code>.</p>

<p><code>config/application.rb</code>文件加载完毕之后, 就会调用<code>server.start</code>方法.</p>

<pre><code class="language-ruby">
def start
  print_boot_information # 打印启动信息
  trap(:INT) { exit }
  create_tmp_directories # 创建 tmp 目录
  setup_dev_caching
  log_to_stdout if options[:log_stdout] #是否打印 log 到标准输出

  super # Rack::Server.start
  ...
end

private
  def print_boot_information
    ...
    puts "=&gt; Run `rails server -h` for more startup options"
  end

  def create_tmp_directories
    %w(cache pids sockets).each do |dir_to_make|
      FileUtils.mkdir_p(File.join(Rails.root, 'tmp', dir_to_make))
    end
  end

  def setup_dev_caching
    if options[:environment] == "development"
      Rails::DevCaching.enable_by_argument(options[:caching])
    end
  end

  def log_to_stdout
    wrapped_app # 对应用执行 touch 操作，以便设置记录器

    console = ActiveSupport::Logger.new(STDOUT)
    console.formatter = Rails.logger.formatter
    console.level = Rails.logger.level

    unless ActiveSupport::Logger.logger_outputs_to?(Rails.logger, STDOUT)
    Rails.logger.extend(ActiveSupport::Logger.broadcast(console))
  end
</code></pre>

<p>这是<code>Rails</code>初始化过程中第一次输出信息. <code>start</code>方法为<code>INT</code>信号创建了一个陷阱, 只要在服务器运行时按下<code>CTRL+C</code>, 服务器进程就会退出.
上述代码还会创建<code>tmp/cache</code> <code>tmp/pids</code> <code>tmp/sockets</code>文件夹, 用于存放 <code>socket</code>.</p>

<p>最后调用<code>wrapped_app</code>方法, 作用就是先创建一个<code>Rack应用</code>, 然后创建<code>ActiveSupport::Logger</code>实例.</p>

<p>在<code>Rack应用(二)</code> 中我们曾研究过<code>wrapped_app</code>以及<code>server.start</code>方法:</p>

<pre><code class="language-ruby"># rack/lib/rack/server.rb
def start &amp;blk
  
  # 关键点(一)
  wrapped_app
    
  # 关键点(二)
  server.run wrapped_app, options, &amp;blk
end

def wrapped_app
  @wrapped_app ||= build_app app
end
</code></pre>

<ul>
  <li>wrapped_app: 构建一个完成的 app.
    <ul>
      <li>其中 <code>app</code>就是执行 <code>config.ru</code>文件, 最终得到一个应用APP</li>
      <li>build_ap 作用就是在得到的app的上层包装上<code>server</code>的<code>middleware</code></li>
    </ul>
  </li>
  <li>server.run: 最终启动 server</li>
</ul>

<p>在执行<code>config.ru</code>文件的过程中, 又涉及到了<code>rails</code>启动过程中的步骤 5 - 11.</p>

<pre><code class="language-ruby"># config.ru
# This file is used by Rack-based servers to start the application.

require_relative 'config/environment'

run Rails.application

</code></pre>

<p><code>Rails</code>初始化过程中的大部分工作都是在这一步中完成.
** <code>rails server</code> 指令可以使用 <code>rackup config.ru</code> 代替 **</p>

<p>在 <code>config.ru</code>文件中, 加载 <code>config/environment.rb</code>文件中的第一行代码先被执行:</p>

<pre><code class="language-ruby">require_relative 'config/environment'
</code></pre>

<h5 id="configenvironmentrb">config/environment.rb</h5>

<p><code>config.ru</code>文件和 <code>passenger</code>都需要加载此文件.这两种运行服务器的方式到此才有了交集, 此前的一切工作都是围绕<code>Rack</code>以及<code>Rails</code>配置进行的.
此文件首先加载<code>config/application.rb</code>文件:</p>
<pre><code class="language-ruby"># Load the Rails application.
require_relative 'application'

# Initialize the Rails application.
Rails.application.initialize!

</code></pre>

<h4 id="configapplicationrb-1">config/application.rb</h4>

<p>此文件会加载<code>config/boot.rb</code>文件:</p>

<pre><code class="language-ruby">ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../Gemfile', __dir__)

require 'bundler/setup' # Set up gems listed in the Gemfile.
</code></pre>

<p>对于<code>rails server</code>这种启动方式, 之前并为加载<code>config/boot.rb</code>文件, 因此这里会加载该文件; 像<code>passenger</code>之前已经加载过该文件, 这里就不会重复加载了.</p>

<h3 id="加载-rails">加载 Rails</h3>

<p><code>config/application.rb</code>文件的下一行就是:</p>
<pre><code class="language-ruby">require 'rails/all'
</code></pre>

<p>我们可以查看<code>rails/all</code>的源码:</p>

<pre><code class="language-ruby">
require "rails"

%w(
  active_record/railtie
  action_controller/railtie
  action_view/railtie
  action_mailer/railtie
  active_job/railtie
  action_cable/engine
  rails/test_unit/railtie
  sprockets/railtie
).each do |railtie|
  begin
    require railtie
  rescue LoadError
  end
end
</code></pre>

<p>此文件负责加载<code>Rails</code>中所有独立的框架.
这些框架加载完成之后, 就可以在<code>Rails</code>应用中使用了.</p>

<h5 id="回到-configenvironmentrb-文件">回到 config/environment.rb 文件</h5>

<p>config/application.rb 文件的其余部分定义了 Rails::Application 的配置，当应用的初始化全部完成后就会使用这些配置。当 config/application.rb 文件完成了 Rails 的加载和应用命名空间的定义后，程序执行流程再次回到 config/environment.rb 文件。在这里会通过 rails/application.rb 文件中定义的 Rails.application.initialize! 方法完成应用的初始化。</p>

<h5 id="railtieslibrailsapplicationrb">railties/lib/rails/application.rb</h5>

<pre><code class="language-ruby"># rails/railties/lib/rails/application.rb
def initialize!(group=:default) #:nodoc:
  raise "Application has been already initialized." if @initialized
  run_initializers(group, self) # 执行所有的注册的 initializers
  @initialized = true
  self
end
</code></pre>
<p>我们可以看到一个应用只能被初始化一次. <code>railties/lib/rails/initializable.rb</code>文件中定义的<code>run_initializers</code>方法负责运行初始化程序:</p>

<pre><code class="language-ruby"># rails/railties/lib/rails/initializable.rb
def run_initializers(group=:default, *args)
  return if instance_variable_defined?(:@ran)
  # initializers 在 rails/application.rb文件中被覆写
  initializers.tsort_each do |initializer|
    initializer.run(*args) if initializer.belongs_to?(group)
  end
  @ran = true
end

# rails/railties/lib/rails/application.rb
def initializers #:nodoc:
  Bootstrap.initializers_for(self) +
  railties_initializers(super) +
  Finisher.initializers_for(self)
end

</code></pre>

<p>run_initializers 方法的代码比较复杂，Rails 会遍历所有类的祖先，以查找能够响应 initializers 方法的类。对于找到的类，首先按名称排序，然后依次调用 initializers 方法。例如，Engine 类通过为所有的引擎提供 initializers 方法而使它们可用。</p>

<p>在Rails中的<code>initializer</code>分为以下三类:</p>

<ul>
  <li>Bootstrap 的 initializer</li>
  <li>Application, Engine, Railtie 注册的 initializer</li>
  <li>Finisher的 initializer</li>
</ul>

<p>railties/lib/rails/application.rb 文件中定义的 Rails::Application 类，定义了 bootstrap、railtie 和 finisher 初始化程序。bootstrap 初始化程序负责完成应用初始化的准备工作（例如初始化记录器），而 finisher 初始化程序（例如创建中间件栈）总是最后运行。railtie 初始化程序在 Rails::Application 类自身中定义，在 bootstrap 之后、finishers 之前运行。</p>

<p>启动流程中的步骤 5 – 11 都是一些特定的initializer来执行.</p>

<h5 id="步骤5-load-configenviromentsenvrb">步骤5: Load config/enviroments/ENV.rb</h5>

<pre><code class="language-ruby"># rails/railties/lib/rails/engine.rb
# 这个就是启动流程中的 5) Load config/environments/ENV.rb, 特别注意这里用了before
initializer :load_environment_config, before: :load_environment_hook, group: :all do
  paths["config/environments"].existent.each do |environment|
    require environment
  end
end
</code></pre>

<h5 id="步骤6-run-configbefore_initialize-callbacks">步骤6: Run config.before_initialize callbacks</h5>

<pre><code class="language-ruby"># rails/railties/lib/rails/application/bootstrap.rb
initializer :bootstrap_hook, group: :all do |app|
  ActiveSupport.run_load_hooks(:before_initialize, app)
end
</code></pre>

<h5 id="rails应用config目录下的initializers执行的源码位置">Rails应用config目录下的initializers执行的源码位置:</h5>

<pre><code class="language-ruby"># rails/railties/lib/rails/engine.rb
# 这里就是config目录下的initializers执行的位置
initializer :load_config_initializers do
  config.paths["config/initializers"].existent.sort.each do |initializer|
    load_config_initializer(initializer)
  end
end
</code></pre>

<h5 id="步骤9-build-the-middleware-stack-and-run-to_prepare-callbacks">步骤9: Build the middleware stack and run to_prepare callbacks</h5>
<p>build_middleware_stack，该方法alias到app方法，这个方法是个重要的方法，这里就是把所有middleware都一层一层嵌套然后得到最终的app。</p>

<pre><code class="language-ruby"># rails/railties/lib/rails/application/finisher.rb
initializer :build_middleware_stack do
  build_middleware_stack
end
</code></pre>

<p>This needs to happen before eager load so it happens</p>

<p>in exactly the same point regardless of config.cache_classes</p>

<h5 id="9-run-to_prepare-callbacks">9) run to_prepare callbacks</h5>

<p>initializer :run_prepare_callbacks do
  ActionDispatch::Reloader.prepare!
end</p>

<h5 id="步骤10-run-configbefore_eager_load-and-eager_load-if-eager_load-is-true">步骤10: Run config.before_eager_load and eager_load! if eager_load is true</h5>

<pre><code class="language-ruby"># rails/railties/lib/rails/application/finisher.rb
initializer :eager_load! do
  if config.eager_load
    ActiveSupport.run_load_hooks(:before_eager_load, self)
    config.eager_load_namespaces.each(&amp;:eager_load!)
  end
end
</code></pre>

<h5 id="步骤11-run-configafter_initialize-callbacks">步骤11: Run config.after_initialize callbacks</h5>

<pre><code class="language-ruby"># rails/railties/lib/rails/application/finisher.rb
# All initialization is done, including eager loading in production
initializer :finisher_hook do
  ActiveSupport.run_load_hooks(:after_initialize, self)
end

</code></pre>
<p>应用初始化完成后，程序执行流程再次回到 Rack::Server 类。</p>

<h4 id="rack-librackserverrb-1">Rack: lib/rack/server.rb</h4>

<p>程序执行流程上一次离开此文件是定义<code>app</code>方法时:</p>
<pre><code class="language-ruby">def app
  @app ||= options[:builder] ? build_app_from_string : build_app_and_options_from_config
end
...
private
def build_app_and_options_from_config
  if !::File.exist? options[:config]
    abort "configuration #{options[:config]} not found"
  end

  app, options = Rack::Builder.parse_file(self.options[:config], opt_parser)
  self.options.merge! options
  app
end

def build_app_from_string
  Rack::Builder.new_from_string(self.options[:builder])
end
</code></pre>

<p>此时，app 就是 Rails 应用本身（一个中间件），接下来 Rack 会调用所有已提供的中间件：</p>
<pre><code class="language-ruby">
def build_app(app)
  middleware[options[:environment]].reverse_each do |middleware|
    middleware = middleware.call(self) if middleware.respond_to?(:call)
    next unless middleware
    klass = middleware.shift
    app = klass.new(app, *middleware)
  end
  app
end
</code></pre>

<p>在 Server#start 方法定义的最后一行代码中，通过 wrapped_app 方法调用了 build_app 方法。让我们回顾一下这行代码：</p>
<pre><code class="language-ruby">
server.run wrapped_app, options, &amp;blk

</code></pre>

<p>server.run 方法的实现方式取决于我们所使用的服务器。例如，如果使用的是 Puma，run 方法的实现方式如下：</p>
<pre><code class="language-ruby">...
DEFAULT_OPTIONS = {
  :Host =&gt; '0.0.0.0',
  :Port =&gt; 8080,
  :Threads =&gt; '0:16',
  :Verbose =&gt; false
}

def self.run(app, options = {})
  options = DEFAULT_OPTIONS.merge(options)

  if options[:Verbose]
    app = Rack::CommonLogger.new(app, STDOUT)
  end

  if options[:environment]
    ENV['RACK_ENV'] = options[:environment].to_s
  end

  server   = ::Puma::Server.new(app)
  min, max = options[:Threads].split(':', 2)

  puts "Puma #{::Puma::Const::PUMA_VERSION} starting..."
  puts "* Min threads: #{min}, max threads: #{max}"
  puts "* Environment: #{ENV['RACK_ENV']}"
  puts "* Listening on tcp://#{options[:Host]}:#{options[:Port]}"

  server.add_tcp_listener options[:Host], options[:Port]
  server.min_threads = min
  server.max_threads = max
  yield server if block_given?

  begin
    server.run.join
  rescue Interrupt
    puts "* Gracefully stopping, waiting for requests to finish"
    server.stop(true)
    puts "* Goodbye!"
  end

end
</code></pre>

<p>上面就是 Rails 初始化过程的最后一步了。</p>

  ]]></description>
</item>

<item>
  <title>Ruby Rack 协议及其应用(二)</title>
  <link>//rack-working</link>
  <author>nju520</author>
  <pubDate>2017-10-24T00:00:00+08:00</pubDate>
  <guid>//rack-working</guid>
  <description><![CDATA[
  <h2 id="rack实现分析">Rack实现分析</h2>

<h3 id="创建应用程序">创建应用程序</h3>

<p>要分析<code>Rack</code>的源码, 我们首先创建一个简单的<code>Rack应用程序</code></p>

<pre><code class="language-ruby">#config.ru
# 将 body 标签的内容转换为全大写.
class ToUpper
  def initialize(app)
    @app = app
  end
  def call(env)
    status, head, body = @app.call(env)
    upcased_body = body.map{|chunk| chunk.upcase }
    [status, head, upcased_body]
  end
end
# 将 body 内容置于标签, 设置字体颜色为红色, 并指明返回的内容为 text/html.
class WrapWithRedP
  def initialize(app)
    @app = app
  end
  def call(env)
    status, head, body = @app.call(env)
    red_body = body.map{|chunk| "&lt;p style='color:red;'&gt;#{chunk}&lt;/p&gt;" }
    head['Content-type'] = 'text/html'
    [status, head, red_body]
  end
end

# 将 body 内容放置到 HTML 文档中.
class WrapWithHtml
  def initialize(app)
    @app = app
  end

  def call(env)
    status, head, body = @app.call(env)
    wrap_html = &lt;&lt;-EOF
       &lt;!DOCTYPE html&gt;
       &lt;html&gt;
         &lt;head&gt;
         &lt;title&gt;hello&lt;/title&gt;
         &lt;body&gt;
         #{body[0]}
         &lt;/body&gt;
       &lt;/html&gt;
    EOF
    [status, head, [wrap_html]]
  end
end

# 起始点, 只返回一行字符的 rack app.
class Hello
  def initialize
    super
  end
  def call(env)
    [200, {'Content-Type' =&gt; 'text/plain'}, ["hello, this is a test."]]
  end
end
use WrapWithHtml
use WrapWithRedP
use ToUpper
run Hello.new
</code></pre>

<h3 id="rackup-命令">rackup 命令</h3>

<p>在 <code>terminal</code>下输入命令 <code>rackup</code>, 就会启动一个<code>Web服务</code></p>

<pre><code class="language-shell">$ rackup

Puma starting in single mode...
* Version 3.11.2 (ruby 2.4.2-p198), codename: Love Song
* Min threads: 0, max threads: 16
* Environment: development
* Listening on tcp://localhost:9292
Use Ctrl-C to stop
</code></pre>

<p><code>rackup</code> 来自于哪里? 如何加载<code>config.ru</code>文件并生成项目?</p>

<p>首先我们可以通过 <code>where</code>命令来查找当前<code>rackup</code>指令的执行路径并打印文件代码:</p>

<pre><code class="language-ruby">$ where rackup
/Users/bobo/.rvm/gems/ruby-2.4.2/bin/rackup

$ cat /Users/bobo/.rvm/gems/ruby-2.4.2/bin/rackup
#!/usr/bin/env ruby
#
# This file was generated by RubyGems.
#
# The application 'rack' is installed as part of a gem, and
# this file is here to facilitate running it.
#

require 'rubygems'

version = "&gt;= 0.a"

if ARGV.first
  str = ARGV.first
  str = str.dup.force_encoding("BINARY") if str.respond_to? :force_encoding
  if str =~ /\A_(.*)_\z/ and Gem::Version.correct?($1) then
    version = $1
    ARGV.shift
  end
end

if Gem.respond_to?(:activate_bin_path)
  load Gem.activate_bin_path('rack', 'rackup', version)
else
  gem "rack", version
  load Gem.bin_path("rack", "rackup", version)
end
</code></pre>

<p>从 <code>rackup</code>文件中我们可以看出当前文件是由<code>RubyGems</code>自动生成, 在文件最后通过<code>load</code>方法加载对应文件中的代码, 从而启动服务. 我们可以在 <code>pry</code>中找到要加载的文件及其代码.</p>

<pre><code class="language-shell">λ gem list "^rack$"

*** LOCAL GEMS ***

rack (2.0.3, 2.0.1, 1.6.8)

λ pry
[1] pry(main)&gt; Gem.activate_bin_path('rack', 'rackup', '2.0.3')
=&gt; "/Users/bobo/.rvm/gems/ruby-2.4.2/gems/rack-2.0.3/bin/rackup"
[2] pry(main)&gt; exit

λ cat /Users/bobo/.rvm/gems/ruby-2.4.2/gems/rack-2.0.3/bin/rackup
#!/usr/bin/env ruby

require "rack"
Rack::Server.start

</code></pre>

<blockquote>
  <p><code>rackup</code>命令定义在 <code>rack</code>工程的 <code>bin/rackup</code>文件中. 通过 <code>rubygems</code>安装后会生成另外一个加载该文件的可执行文件.</p>
</blockquote>

<p>最后我们找到了加载的文件. <code>.activate_bin_path</code>方法会查找对应的<code>gem</code>当前生效的版本, 并返回文件的路径. 在这个可执行文件中, 只是简单的两行代码</p>

<pre><code class="language-ruby">#!/usr/bin/env ruby

require 'rack'

# 启动一个Web Server
Rack::Server.start
</code></pre>

<h3 id="启动-web-server">启动 Web Server</h3>

<p>从这里开始, 我们就已经从<code>	rakcup</code>命令的执行进入了<code>rack</code> 的源码.  当前<code>Rack::Server</code>类初始化一个新的实例后, 在新对象上执行了<code>#start</code>方法.</p>

<pre><code class="language-ruby">[1] pry(main)&gt; require 'rack'
=&gt; true
[2] pry(main)&gt; $ Rack::Server.start

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 147:
Owner: #&lt;Class:Rack::Server&gt;
Visibility: public
Number of lines: 3

def self.start(options = nil)
  new(options).start
end
</code></pre>

<h4 id="初始化和配置">初始化和配置</h4>

<p>在<code>Rack::Server</code>启动过程中初始化一个新的对象, 初始化的过程就包含了整个服务器的配置过程:</p>

<pre><code class="language-ruby">[3] pry(main)&gt; $ Rack::Server#initialize

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 185:
Owner: Rack::Server
Visibility: private
Number of lines: 13

def initialize(options = nil)
  @ignore_options = []

  # 直接运行`rackup`时没有传入任何参数, 因此代码跳转到 `else`部分
  if options
    @use_default_options = false
    @options = options
    @app = options[:app] if options[:app]
  else
    argv = defined?(SPEC_ARGV) ? SPEC_ARGV : ARGV
    @use_default_options = true
    @options = parse_options(argv)
  end
end
</code></pre>

<p>解析参数部分:</p>

<pre><code class="language-ruby">[4] pry(main)&gt; $ Rack::Server#parse_options

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 328:
Owner: Rack::Server
Visibility: private
Number of lines: 10

#传入的参数 args == [], 因此`opt_parser.parse!(args)`直接返回 {}
def parse_options(args)
  # Don't evaluate CGI ISINDEX parameters.
  # http://www.meb.uni-bonn.de/docs/cgi/cl.html
  args.clear if ENV.include?(REQUEST_METHOD)

  # @options = {}
  @options = opt_parser.parse!(args)

  # `options`为 `Rack::Server`类中定义的一个实例方法
  # `@options[:config] = 'config.ru'
  @options[:config] = ::File.expand_path(options[:config])
  ENV["RACK_ENV"] = options[:environment]
  @options
end

-------------------------------------------------------------------------
[5] pry(main)&gt; $ Rack::Server#opt_parser

From: /Users/bobo/.rvm/gems/ruby-2.4.2/gems/rack-2.0.3/lib/rack/server.rb @ line 339:
Owner: Rack::Server
Visibility: private
Number of lines: 3

def opt_parser
  Options.new
end

-------------------------------------------------------------------------
[6] pry(main)&gt; $ Rack::Server::Options#parse!

From: /Users/bobo/.rvm/gems/ruby-2.4.2/gems/rack-2.0.3/lib/rack/server.rb @ line 10:
Owner: Rack::Server::Options
Visibility: public
Number of lines: 96

def parse!(args)
  options = {}
  opt_parser = OptionParser.new("", 24, '  ') do |opts|
  opts.banner = "Usage: rackup [ruby options] [rack options] [rackup config]"

  opts.separator ""
  opts.separator "Ruby options:"
  # ...
  options[:config] = args.last if args.last &amp;&amp; !args.last.empty?
  options
end

-------------------------------------------------------------------------
[7] pry(main)&gt; $ Rack::Server#options

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 199:
Owner: Rack::Server
Visibility: public
Number of lines: 4

# 由于我们运行`rackup`指令时没有传入任何参数, 因此 `@use_default_options = true`.
#`options`中方法中继续调用`default_options`
def options
  merged_options = @use_default_options ? default_options.merge(@options) : @options
  merged_options.reject { |k, v| @ignore_options.include?(k) }
end

-------------------------------------------------------------------------    
[8] pry(main)&gt; $ Rack::Server#default_options

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 204:
Owner: Rack::Server
Visibility: public
Number of lines: 13

# `default_options`会处理对象本身定义的一些参数, 比如默认的端口号、默认的`config`文件
# `config`文件就是`rackup`接收的一个文件参数, 文件中的内容就是用来配置`Rack`服务器的代码.
# 默认情况下名为`config.ru`, 也就是我们在前面写好的那个配置文件
def default_options
  environment  = ENV['RACK_ENV'] || 'development'
  default_host = environment == 'development' ? 'localhost' : '0.0.0.0'

  {
    :environment =&gt; environment,
    :pid         =&gt; nil,
    :Port        =&gt; 9292,
    :Host        =&gt; default_host,
    :AccessLog   =&gt; [],
    :config      =&gt; "config.ru"
  }
end

</code></pre>

<h4 id="包装应用">包装应用</h4>

<p>当我们执行了 <code>initialize</code>方法初始化了一个新的实例后, 接下来就会进入<code>#start</code>实例方法启动一个 	<code>WebServer</code>来处理<code>config.ru</code>中定义的应用了:</p>

<pre><code class="language-ruby">[9] pry(main)&gt; $ Rack::Server#start

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 258:
Owner: Rack::Server
Visibility: public
Number of lines: 41

def start &amp;blk
  # 删除了多余不重要的代码

  # Touch the wrapped app, so that the config.ru is loaded before
  # daemonization (i.e. before chdir, etc).
  # 通过注释我们可以知晓 `wrapped_app`方法是在启动守护进程之前就加载了 `config.ru`配置文件来创建好最终的应用程序
  wrapped_app

  server.run wrapped_app, options, &amp;blk
end

-------------------------------------------------------------------------
# 首先查看 `Rack::Server#server`中传入的参数
[10] pry(main)&gt; $ Rack::Server#wrapped_app

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 353:
Owner: Rack::Server
Visibility: private
Number of lines: 3

# 继续调用 `build_app`方法 以及 `app`方法
def wrapped_app
  @wrapped_app ||= build_app app
end


</code></pre>

<p><code>wrapped_app</code>方法实际上需要继续调用两个方法: <code>build_app</code> 、 <code>app</code>.</p>

<p><code>Rack::Server#app</code>方法调用栈比较复杂:</p>

<p><img src="" alt="Rack::Server#app" /></p>

<pre><code class="language-ruby">[11] pry(main)&gt; $ Rack::Server#app

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 218:
Owner: Rack::Server
Visibility: public
Number of lines: 3

def app
  # 由于我们使用的是默认参数, 因此 `options[:builder]`为nil
  # 继续调用 `build_app_and_options_from_config`
  @app ||= options[:builder] ? build_app_from_string : build_app_and_options_from_config
end

-------------------------------------------------------------------------
[12] pry(main)&gt; $ Rack::Server#build_app_and_options_from_config

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 314:
Owner: Rack::Server
Visibility: private
Number of lines: 9

def build_app_and_options_from_config
  if !::File.exist? options[:config]
    abort "configuration #{options[:config]} not found"
  end

  # `parse_file`传入我们的配置文件 `config.ru`
  app, options = Rack::Builder.parse_file(self.options[:config], opt_parser)
  @options.merge!(options) { |key, old, new| old }
  app
end

-------------------------------------------------------------------------
[13] pry(main)&gt; $ Rack::Builder.parse_file

From: **/gems/rack-2.0.3/lib/rack/builder.rb @ line 32:
Owner: #&lt;Class:Rack::Builder&gt;
Visibility: public
Number of lines: 15

def self.parse_file(config, opts = Server::Options.new)
  options = {}
  if config =~ /\.ru$/
    cfgfile = ::File.read(config)
    if cfgfile[/^#\\(.*)/] &amp;&amp; opts
      options = opts.parse! $1.split(/\s+/)
    end
    cfgfile.sub!(/^__END__\n.*\Z/m, '')
    # 最终我们的程序去调用 `new_from_string`, 参数为 `File.read("config.ru")`
    app = new_from_string cfgfile, config
  else
    require config
    app = Object.const_get(::File.basename(config, '.rb').split('_').map(&amp;:capitalize).join(''))
  end
  return app, options
end

-------------------------------------------------------------------------
[14] pry(main)&gt; $ Rack::Builder.new_from_string

From: **/gems/rack-2.0.3/lib/rack/builder.rb @ line 48:
Owner: #&lt;Class:Rack::Builder&gt;
Visibility: public
Number of lines: 4

def self.new_from_string(builder_script, file="(rackup)")
  eval "Rack::Builder.new {\n" + builder_script + "\n}.to_app",
    TOPLEVEL_BINDING, file, 0
end
</code></pre>

<p>通过<code>Ruby</code>元编程中常用的 <code>eval</code>方法, 将配置文件<code>config.ru</code>的全部内容和两端的字符串拼接起来, 相当于执行下列代码:</p>

<pre><code class="language-ruby">Rack::Builder.new {
  use WrapWithHtml
  use WrapWithRedP
  use ToUpper
  run Hello.new
}.to_app
</code></pre>

<p>是不是是曾相识? 我们在<code>Rack协议及其应用(一)</code>中就手动实现过<code>Rack::Builder</code>类. 上述代码就是存储了所有的中间件以及原始的<code>Rack应用程序</code>, 最后通过<code>#to_app</code>方法返回了一个<code>Rack</code>应用. 稍后我们会分析<code>Rack::Builder</code>的源码</p>

<p>在这之后会使用<code>Rack::Builder#build_app</code>方法将所有的中间件都包括在<code>Rack</code>应用周围.所有的中间件都是一个遵循协议的<code>App</code>, 只不过中间件和<code>App</code>的唯一区别就是中间件会调用初始化时传入的<code>Rack App</code>.</p>

<pre><code class="language-ruby">[15] pry(main)&gt; $ Rack::Server#build_app

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 343:
Owner: Rack::Server
Visibility: private
Number of lines: 9

def build_app(app)
  middleware[options[:environment]].reverse_each do |middleware|
    middleware = middleware.call(self) if middleware.respond_to?(:call)
    next unless middleware
    klass, *args = middleware
    app = klass.new(app, *args)
  end
  app
end
</code></pre>

<p>经过上述方法, 我们在一个<code>Rack</code> 应用周围一层一层包装上了所有的中间件, 最后调用的中间件在整个调用栈的最外层, 当包装后的应用接收来自外部的请求时, 会按照如下方式运行:</p>

<p><img src="" alt="WRAPPED APP" /></p>

<p><strong>FBI Warning</strong></p>

<p>请求进来 -&gt; 从最外层的中间件进入, 每个中间件都会处理<code>request</code>, 在<code>#call</code>方法内部调用另外一个中间件或者应用. 当<code>request</code>进入到最初的<code>Rack应用程序</code>后, 程序返回<code>response</code>, 在经过一层一层的中间件处理, 最后返回 <code>HTTP响应</code></p>

<h4 id="中间件的实现分析">中间件的实现分析</h4>

<p>在<code>Rack</code>中, 中间件是由两部分代码共同处理的:</p>

<ul>
  <li>Rack::Builder: 包含能够在<code>config.ru</code>文件中能够使用的<code>DSL</code>方法.</li>
  <li>Rack::Server: 启动 <code>Web Server</code></li>
</ul>

<p>当我们使用<code>eval</code>执行<code>config.ru</code>文件中的代码时, 会先初始化一个<code>Builder</code>实例, 然后执行<code>instance_eval</code>运行代码中的所有内容:</p>

<pre><code class="language-ruby">[16] pry(main)&gt; $ Rack::Builder#initialize

From: **/gems/rack-2.0.3/lib/rack/builder.rb @ line 53:
Owner: Rack::Builder
Visibility: private
Number of lines: 4

def initialize(default_app = nil, &amp;block)
  @use, @map, @run, @warmup = [], nil, default_app, nil
  instance_eval(&amp;block) if block_given?
end
</code></pre>

<p>通过调用<code>instance_eval </code>, <code>config.ru</code>文件中的代码会在当前实例环境下运行, 文件中的<code>#use</code>和<code>#run</code>方法在调用时就会执行<code>Rack::Builder</code>的实例方法:</p>

<pre><code class="language-ruby">[17] pry(main)&gt; $ Rack::Builder#use

From: **/gems/rack-2.0.3/lib/rack/builder.rb @ line 81:
Owner: Rack::Builder
Visibility: public
Number of lines: 7

def use(middleware, *args, &amp;block)
  if @map
    mapping, @map = @map, nil
    @use &lt;&lt; proc { |app| generate_map app, mapping }
  end
  @use &lt;&lt; proc { |app| middleware.new(app, *args, &amp;block) }
end

def run(app)
  @run = app
end

def to_app
  app = @map ? generate_map(@run, @map) : @run
  fail "missing run or map statement" unless app
  app = @use.reverse.inject(app) { |a,e| e[a] }
  @warmup.call(app) if @warmup
  app
end

</code></pre>

<p><code>Rack::Builder#use</code>方法会将传入的参数组合成一个接收<code>app</code>作为参数的<code>Proc</code>对象, 然后加入到<code>@use</code>数组中存储起来.</p>

<p><code>Rack::Builder#run</code>方法是存储最原始的<code>Rack应用程序</code>, 将其保存到<code>@run</code>实例变量中.</p>

<p>最后如果我们想要获取当前的<code>Rack::Builder</code>生成的应用, 只需要调用<code>Rack::Builder#to_app</code>方法.值得一提的是<code>to_app</code>代码实现中使用了一个技巧, 可以使用<code>[]</code>来调用 <code>proc/lambda</code>.</p>

<pre><code class="language-ruby"># `app = @use.reverse.inject(app) { |a,e| e[a] }`等价于下列代码
app = @run
@use.reverse.each do |middleware|
  app = middleware.new(app)
end
app

e = proc {|app| puts "call: arguments is #{app}"}
a = 'app'
e[a]
# call: arguments is app
</code></pre>

<p>关于<code>inject</code>:</p>

<blockquote>
  <p>Combines all elements of enum by applying a binary operation, specified by a block or a symbol that names a method or operator. If you specify a block, then for each element in enum the block is passed an accumulator value (memo) and the element. If you specify a symbol instead, then each element in the collection will be passed to the named method of memo. In either case, the result becomes the new value for memo. At the end of the iteration, the final value of memo is the return value for the method. If you do not explicitly specify an initial value for memo, then the first element of collection is used as the initial value of memo.</p>
</blockquote>

<p>关于 <code>block</code>:</p>

<blockquote>
  <p>prc[params,…] Invokes the block, setting the block’s parameters to the values in params using something close to method calling semantics. Generates a warning if multiple values are passed to a proc that expects just one (previously this silently converted the parameters to an array). Note that prc.() invokes prc.call() with the parameters given. It’s a syntax sugar to hide “call”.</p>
</blockquote>

<p><code>@use.reverse.inject(app) { |a,e| e[a] }</code>运行过程中, 前一轮的<code>e[a]</code>被存储到内存中, 并加载了下一轮的<code>a</code>变量中, 因为 <code>e</code>和<code>a</code>都是<code>proc</code>, 所以<code> e[a]</code>本质上是调用这个代码块. 在这个过程中, 最原始的那个<code>Rack应用程序</code>会被放在最底层, 而<code>middleware</code>会一层一层地套在上面.生成的实例类似于下面的表示:</p>

<pre><code class="language-ruby">use WrapWithHtml
use WrapWithRedP
use ToUpper
run Hello.new

# WrapWithHtml.new(WrapWithRedP.new(ToUpper.new(Hello.new)))
@use = [WrapWithHtml.new, WrapWithRedP, ToUpper.new]
@run = Hello.new
app = @use.reverse.inject(app) { |a,e| e[a] }

# `inject` 中, `e`相当于数组的依次传入的值, `a`相当于每一次迭代返回的值
# `inject`传入的参数 `app`赋给 `a`
# 1.1
a = app = @run = Hello.new
e =  proc { |app| ToUpper.new(app, *args, &amp;block) }
result1 = e[a] = proc { |app| ToUpper.new(app, *args, &amp;block) }.call(a)
       = ToUpper.new(Hello.new, *args, &amp;block)
       = ToUpper.new(Hello.new)

# 1.2
a = result = ToUpper.new(Hello.new)
e = proc {|app| WrapWithRedP.new(app, *args, &amp;block)}
result2 = e[a] = proc {|app| WrapWithRedP.new(app, *args, &amp;block)}.call(a)
       = WrapWithRedP.new(ToUpper.new(Hello.new))

# 1.3
a = result = WrapWithRedP.new(ToUpper.new(Hello.new))
e = proc {|app| WrapWithHtml.new(app, *args, &amp;block)}
result3 = e[a] = proc {|app| WrapWithHtml.new(app, *args, &amp;block)}.call(a)
       = WrapWithHtml.new(WrapWithRedP.new(ToUpper.new(Hello.new)))

</code></pre>

<p><strong>Rack::Builder</strong> 类其实就是将非常晦涩的代码, 利用<code>Ruby</code>元编程能力变成清晰可读的<code>DSL</code>, 最终返回了一个最终应用对象.</p>

<p>当一个请求到来时, 我们的Web Server<code>就会</code>call<code>我们的</code>Rack应用,传入环境变量<code>env</code>作为参数.</p>

<p><code>env</code>变量首先进入最外层的中间件处理, 通过处理之后传入下一层的中间件, 如此层层递进, 最终进入我们的<code>原始应用程序</code>.</p>

<p>原始应用程序接收传入的<code>env</code>, 然后根据内部逻辑处理之后, 返回一个三元数组</p>

<pre><code class="language-ruby">[status, header, [body]]
</code></pre>

<p>此三元数组继续传递给倒数第一个中间件, 经过其处理之后,再将处理过后的中间件传递给上一层.经过层层传递, 我们的三元数组经过最外层的中间件处理之后就返回 <code>response</code>给我们的<code>Web Server</code>.</p>

<p><code>Web Server</code>将我们应用框架返回的<code>response</code>包装成<code>HTTP响应</code>, 发给客户端.</p>

<p>通过<code>Rack::Builder#to_app</code>生成最终应用将被作为参数传给 <code>Rack::Builder#build_app</code>中. 此方法根据环境选择合适的中间件继续包裹到这个链式调用中:</p>

<pre><code class="language-ruby">[18] pry(main)&gt; $ Rack::Server#build_app

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 343:
Owner: Rack::Server
Visibility: private
Number of lines: 9

def build_app(app)
  middleware[options[:environment]].reverse_each do |middleware|
    middleware = middleware.call(self) if middleware.respond_to?(:call)
    next unless middleware
    klass, *args = middleware
    # 继续包裹 `Rack`默认的一些中间件
    app = klass.new(app, *args)
  end
  app
end

-------------------------------------------------------------------------

def middleware
  self.class.middleware
end

-------------------------------------------------------------------------

def middleware
  default_middleware_by_environment
end

[19] pry(main)&gt; $ Rack::Server.default_middleware_by_environment

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 229:
Owner: #&lt;Class:Rack::Server&gt;
Visibility: public
Number of lines: 19

def default_middleware_by_environment
  m = Hash.new {|h,k| h[k] = []}
  m["deployment"] = [
    [Rack::ContentLength],
    [Rack::Chunked],
    logging_middleware,
    [Rack::TempfileReaper]
  ]
  m["development"] = [
    [Rack::ContentLength],
    [Rack::Chunked],
    logging_middleware,
    [Rack::ShowExceptions],
    [Rack::Lint],
    [Rack::TempfileReaper]
  ]

  m
end
</code></pre>

<p>最终会根据<code>Rack::Server.default_middleware_by_environment</code>中包含了不同环境下默认应该使用的中间件, <code>Rack::Server#build_app</code>会根据情况加载中间件.</p>

<h4 id="选择-web-server">选择 Web Server</h4>

<p>在<code>Rack::Server#start</code>方法中, 我们通过<code>Rack::Server#wrapped_app</code>方法将应用和中间件打包到一起. 然后执行<code>server.run wrapped_app, options, &amp;blk</code> 来选择合适的 <code>Web Server</code>并启动之.</p>

<pre><code class="language-ruby">[2] pry(main)&gt; $ Rack::Server#server

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 300:
Owner: Rack::Server
Visibility: public
Number of lines: 12

def server
  @_server ||= Rack::Handler.get(options[:server])
  unless @_server
    @_server = Rack::Handler.default
    # We already speak FastCGI
    @ignore_options = [:File, :Port] if @_server.to_s == 'Rack::Handler::FastCGI'
  end
  @_server
end
</code></pre>

<p>我们在运行<code>rackup</code>命令时, 如果传入了 <code>server</code>选项, 比如:</p>

<pre><code class="language-shell">$ rackup -server Puma
</code></pre>

<p>就会使用传入的<code>Web Server</code>, 否则就选择默认的<code>Rack::Handler</code></p>

<pre><code class="language-ruby">[5] pry(main)&gt; $ Rack::Handler.default

From: **/gems/rack-2.0.3/lib/rack/handler.rb @ line 46:
Owner: #&lt;Class:Rack::Handler&gt;
Visibility: public
Number of lines: 12

def self.default
  # Guess.
  if ENV.include?("PHP_FCGI_CHILDREN")
    Rack::Handler::FastCGI
  elsif ENV.include?(REQUEST_METHOD)
    Rack::Handler::CGI
  elsif ENV.include?("RACK_HANDLER")
    self.get(ENV["RACK_HANDLER"])
  else
    pick ['puma', 'thin', 'webrick']
  end
end
</code></pre>

<p>默认选择最终会调用<code>pick</code>方法, 在<code>pick</code>方法中通过传入的数据尝试对其进行加载 :</p>

<pre><code class="language-ruby">[6] pry(main)&gt; $ Rack::Handler.pick

From: **/gems/rack-2.0.3/lib/rack/handler.rb @ line 34:
Owner: #&lt;Class:Rack::Handler&gt;
Visibility: public
Number of lines: 11
# server_names = ['puma', 'thin', 'webrick']
def self.pick(server_names)
  server_names = Array(server_names)
  server_names.each do |server_name|
    begin
      return get(server_name.to_s)
    rescue LoadError, NameError
    end
  end

  raise LoadError, "Couldn't find handler for: #{server_names.join(', ')}."
end

def self.get(server)
  return unless server
  server = server.to_s

  unless @handlers.include? server
    load_error = try_require('rack/handler', server)
  end

  if klass = @handlers[server]
    klass.split("::").inject(Object) { |o, x| o.const_get(x) }
  else
    const_get(server, false)
  end

rescue NameError =&gt; name_error
  raise load_error || name_error
end
</code></pre>

<p>​	<code>Rack::Handler.get</code>方法会通过命名规范从对应的文件目录下加载相应的常量. 一部分常量时预先定义在<code>handler.rb</code>文件中, 另外一部分是由各个<code>Web Server</code>的开发者自己定义或者遵循一定的命名规范加载的.</p>

<h4 id="终于启动了">终于启动了</h4>

<p>当<code>Rack</code> 已经使用中间件对应用进行包装并且选择了对应的<code>WebServer</code>之后, 我们就可以将包装好的应用作为参数传入<code>Rack::Handler::WEBrick.run</code>方法了:</p>

<pre><code class="language-ruby">#这里直接采用最简单的 WEBrick进行分析
[8] pry(main)&gt; $ Rack::Handler::WEBrick

From: **/gems/rack-2.0.3/lib/rack/handler/webrick.rb @ line 24:
Class name: Rack::Handler::WEBrick
Number of lines: 95

class WEBrick &lt; ::WEBrick::HTTPServlet::AbstractServlet
  def self.run(app, options={})
    environment  = ENV['RACK_ENV'] || 'development'
    default_host = environment == 'development' ? 'localhost' : nil

    options[:BindAddress] = options.delete(:Host) || default_host
    options[:Port] ||= 8080
    @server = ::WEBrick::HTTPServer.new(options)
    @server.mount "/", Rack::Handler::WEBrick, app
    yield @server  if block_given?
    @server.start
  end
end
</code></pre>

<p>所有遵循<code>Rack协议</code>的<code>Web Server</code>都会实现类似于<code>WEBrick</code>的<code>run</code>方法, 此方法接收三个参数:</p>

<ul>
  <li>app: 包装好的<code>Rack应用程序</code></li>
  <li>options: 参数</li>
  <li>block:  代码块</li>
</ul>

<p><code>run</code>方法启动一个一个进程来专门处理所有来自用户的<code>HTTP请求</code>. 请求到这一步, 就需要每个<code>Web Server</code> 自己处理了. 后续的文章我会对常见的<code>Web Server</code>分析.</p>

<p>以上主要从<code>rackup</code>命令开始, 研究<code>Rack</code>源码, 从初始化配置、包裹中间件、中间件实现, 到选择<code>Web Server</code>,  最后启动<code>Web Server</code>. 我觉得研究源码一定要过滤掉一些不重要的代码(比如说参数处理, 异常处理)等.另外一点就是可以手动实现源码的一些类或者模块, 这样能够对源码有更深的认识.</p>

<h2 id="再论中间件">再论中间件</h2>

<p>上面主要是从<code>rackup	</code>命令一步一步研究源码,  对中间件的实现和使用都有所了解. 我们可以在<code>config.ru</code>中配置中间件, 这对<code>Ruby on Rails</code>、<code>Sinatra</code>等框架都是通用的.</p>

<ul>
  <li><code>Ruby on Rails</code>通过<code>config.middleware</code>来配置中间件, 可以在<code>application.rb</code>或者<code>enviroment/&lt;enviroment&gt;.rb</code>文件中进行配置</li>
  <li><code>Sinatra</code>配置中间件很简单, 直接在<code>Rack</code> 应用中使用<code>use</code>配置</li>
</ul>

<p><strong>在<code>config.ru</code>中配置的中间件处在<code>中间件栈</code>的上层, 在<code>Web 框架</code>中配置的中间件在<code>中间件栈</code>下层</strong>.</p>

<p>用户的请求自上而下通过<code>中间件栈</code>,任何一个中间件都可以终止用户请求而不向下传递.</p>

<p>下面来分析<code>Rack</code>自带的两个中间件: <code>Auth</code>以及 <code>Session</code></p>

<h3 id="auth">Auth</h3>

<p><code>Auth</code>中间件可以用来做<code>HTTP鉴权(authentication and authorization)</code>. 我们拿 <code>Sidekiq Web</code> 鉴权为例</p>

<pre><code class="language-ruby"># route.rb
Sidekiq::Web.use(Rack::Auth::Basic) do |user, password|
  [user, password] == [ENV['SIDEKIQ_NAME'], ENV['SIDEKIQ_PASS']]
end
</code></pre>

<p><code>Auth</code>作为<code>Rack</code>自带的中间件, <code>Rack::Auth::Basic</code>本身的实现就在<code>rack</code>的源码中, 因此可以直接使用.</p>

<p>配置了中间件后, <code>Sidekiq Web</code>不需要做任何修改就被保护起来. 这个认证中间件实现起来也很简单, 如果我们以后要自己完成一个中间件的话, 可以参考一下<code>Auth</code>的实现.</p>

<p><code>Auth</code>的源码主要由以下几个模块构成:</p>

<pre><code class="language-ruby">module Rack
  module Auth
    class Basic &lt; AbstractHandler

      def call(env)
      #...
      end

      class Request &lt; Auth::AbstractRequest
      end
    end

    class AbstractHandler

      def initialize(app, realm = nil, &amp;authenticator)
      #...
      end
    end

    class AbstractRequest
    end
  end
end
</code></pre>

<p><code>Rack::Auth::Basic</code>作为一个中间件, 肯定会实现 <code>initialize</code>方法以及<code>call</code>方法</p>

<ul>
  <li>initialize: 接收一个<code>app</code>应用程序作为参数, 一般来说<code>app</code>也是符合规范的<code>Rack中间件</code>.</li>
  <li>call: 接收<code>env(环境参数)</code>, 处理之后交给下一个中间件继续处理</li>
</ul>

<p>我们还是采用<code>pry</code>来一步一步研究<code>Auth</code>的源码</p>

<pre><code class="language-ruby">[1] pry(main)&gt; $ Rack::Auth::Basic#initialize

From: **/gems/rack-2.0.3/lib/rack/auth/abstract/handler.rb @ line 11:
Owner: Rack::Auth::AbstractHandler
Visibility: private
Number of lines: 3

def initialize(app, realm=nil, &amp;authenticator)
  @app, @realm, @authenticator = app, realm, authenticator
end
</code></pre>

<p><code>initialize</code>接收三个参数:</p>

<ul>
  <li>app: 符合规范的一个<code>Rack</code>中间件或者应用程序</li>
  <li>realm: 鉴权领域</li>
  <li>authenticator: 代码块, 里面包含我们对用户输入的<code>username</code>以及<code>password</code>处理逻辑</li>
</ul>

<pre><code class="language-ruby">[1] pry(main)&gt; $ Rack::Auth::Basic#call

From: **/gems/rack-2.0.3/lib/rack/auth/basic.rb @ line 15:
Owner: Rack::Auth::Basic
Visibility: public
Number of lines: 15

def call(env)
  auth = Basic::Request.new(env)
  return unauthorized unless auth.provided?
  return bad_request unless auth.basic?
  if valid?(auth)
    env['REMOTE_USER'] = auth.username
    return @app.call(env)
  end
  unauthorized
end
</code></pre>

<p><code>Rack::Auth::Basic#call</code>方法调用, 首先创建了一个 <code>Rack::Auth::Basic::Request</code>实例</p>

<pre><code class="language-ruby"># return unauthorized unless auth.provided?
[3] pry(main)&gt; $ Rack::Auth::Basic::Request#initialize

From: **/gems/rack-2.0.3/lib/rack/auth/abstract/request.rb @ line 7:
Owner: Rack::Auth::AbstractRequest
Visibility: private
Number of lines: 3

def initialize(env)
  @env = env
end

</code></pre>

<p>我们采用<code>http</code>工具从命令行请求:</p>

<pre><code class="language-powershell">λ http http://localhost:3000/sidekiq
HTTP/1.1 401 Unauthorized
Cache-Control: no-cache
Content-Length: 0
Content-Type: text/plain
Set-Cookie: rack.session=BAh7xOD**0d983cc; path=/; HttpOnly
Set-Cookie: _arc_warden_session=U3FMN3**216a9; path=/; HttpOnly
Vary: Origin
WWW-Authenticate: Basic realm=""
X-Content-Type-Options: nosniff
X-Request-Id: c2d9eccd-0ba5-4bb7-9777-ef664e7da88f
X-Runtime: 0.007275

</code></pre>

<p>由于没有携带任何<code>Auth</code>认证, 因此服务器返回<code>401</code>.</p>

<p>从返回的信息中我们还可以发现<code>realm</code>. 由于我们设置<code>Sidekiq Web</code>时没有添加<code>realm</code>, 所以返回时<code>realm=""</code></p>

<pre><code class="language-ruby">WWW-Authenticate: Basic realm=""
</code></pre>

<blockquote>
  <p>realm 用来描述进行保护的区域，或者指代保护的范围。它可以是类似于 “Access to the staging site” 的消息，这样用户就可以知道他们正在试图访问哪一空间。</p>
</blockquote>

<p><code>Rack::Auth::Basic</code>根据客户的传来的信息头判断是否携带了<code>Basic Auth</code>. 如果用户的请求<code>request</code> 中没有我们规定的<code>Auth</code>, 就会返回<code>unauthorized</code></p>

<pre><code class="language-ruby"># return bad_request unless auth.basic?
[4] pry(main)&gt; $ Rack::Auth::Basic::Request#provided?

From: **/gems/rack-2.0.3/lib/rack/auth/abstract/request.rb @ line 15:
Owner: Rack::Auth::AbstractRequest
Visibility: public
Number of lines: 3

def provided?
  !authorization_key.nil? &amp;&amp; valid?
end

# 按照CGI的方式，HTTP客户端请求的header都会被冠以“HTTP_”前缀、全部大写、保存在env里，
# 因此Authorization就成了HTTP_AUTHORIZATION
AUTHORIZATION_KEYS = ['HTTP_AUTHORIZATION', 'X-HTTP_AUTHORIZATION', 'X_HTTP_AUTHORIZATION']

def authorization_key
  @authorization_key ||= AUTHORIZATION_KEYS.detect { |key| @env.has_key?(key) }
end

def valid?
  !@env[authorization_key].nil?
end

--------------------------------------------------------------------------
[5] pry(main)&gt; $ Rack::Auth::Basic#unauthorized

From: **/gems/rack-2.0.3/lib/rack/auth/abstract/handler.rb @ line 18:
Owner: Rack::Auth::AbstractHandler
Visibility: private
Number of lines: 8

# HTTP server通过通过WWW-Authenticate header指定Auth的方法
def unauthorized(www_authenticate = challenge)
  return [ 401,
    { CONTENT_TYPE =&gt; 'text/plain',
      CONTENT_LENGTH =&gt; '0',
      'WWW-Authenticate' =&gt; www_authenticate.to_s },
    []
  ]
end

def challenge
  'Basic realm="%s"' % realm
end
</code></pre>

<p>接下来判断客户端传来的认证方式是否为<code>Basic Auth</code></p>

<pre><code class="language-ruby">[6] pry(main)&gt; $ Rack::Auth::Basic::Request#basic?

From: **/gems/rack-2.0.3/lib/rack/auth/basic.rb @ line 43:
Owner: Rack::Auth::Basic::Request
Visibility: public
Number of lines: 3

def basic?
  "basic" == scheme
end

def scheme
  @scheme ||= parts.first &amp;&amp; parts.first.downcase
end

# Authorization: Basic m************
def parts
  @parts ||= @env[authorization_key].split(' ', 2)
end
</code></pre>

<p>如果前两步的验证都通过的话, 就需要处理我们传入的<code>block</code>逻辑部分了:</p>

<pre><code class="language-ruby">[7] pry(main)&gt; $ Rack::Auth::Basic#valid?

From: **/gems/rack-2.0.3/lib/rack/auth/basic.rb @ line 38:
Owner: Rack::Auth::Basic
Visibility: private
Number of lines: 3

def valid?(auth)
  @authenticator.call(*auth.credentials)
end

# 解析得到 username password
def credentials
  @credentials ||= params.unpack("m*").first.split(/:/, 2)
end

def params
  @params ||= parts.last
end

# Authorization: Basic m************
def parts
  @parts ||= @env[authorization_key].split(' ', 2)
end
</code></pre>

<p>至此一个简单的<code>Basic Auth</code>已经完成.</p>

<p>我们可以通过<code>http</code>工具验证一下:</p>

<pre><code class="language-shell">λ http :3000/sidekiq --auth username:password
HTTP/1.1 200 OK
Cache-Control: no-cache
Content-Language: en
Content-Length: 8101
Content-Type: text/html
Set-Cookie: rack.session=BAh7CEkiD3**0ab564cc1e76c; path=/; HttpOnly
Set-Cookie: _arc_warden_session=aE41bldqOH**a1f7f8d; path=/; HttpOnly
Vary: Origin
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
X-Request-Id: 0b19d49c-422d-4d26-ad21-847b78d36e40
X-Runtime: 1.467317
X-XSS-Protection: 1; mode=block
</code></pre>

  ]]></description>
</item>

<item>
  <title>Ruby Rack 协议及其应用(一)</title>
  <link>//rack-start</link>
  <author>nju520</author>
  <pubDate>2017-08-17T00:00:00+08:00</pubDate>
  <guid>//rack-start</guid>
  <description><![CDATA[
  <h2 id="rack协议">Rack协议</h2>

<h3 id="什么是rack">什么是Rack</h3>

<p>Rack是Ruby Web服务器和Rack应用程序之间的一个接口</p>

<p><img src="https//img.nju520/me/2018-03-03-rack.png" alt="Rack接口" /></p>

<p>上图给出了一个简单的图示. 当用户的请求抵达Web服务器时, Web服务器就会调用(call)Rack, Rack对请求进行包装, 然后调用Rack应用程序(一般是一个封装好的框架). Rack程序可以方便地利用Rack提供的各种API, 分析请求(request), 进行处理, 返回响应(response).</p>

<h3 id="为什么是rack">为什么是Rack</h3>

<p>Rack提供了一种标准的接口, 便于应用程序和Web服务器之间进行交互. 一个Rack应用程序可以被任何和Rack兼容的Web服务器调用.</p>

<p>目前几乎所有的主流Ruby服务器都支持Rack接口. Rack通过一种被称作句柄(Handler)的机制实现对Web服务器的支持.</p>

<p>另一方面, 几乎所有的主流Web框架都支持Rack接口. 这就意味着使用这些框架编写的应用程序都是标准的Rack应用程序.</p>

<p>Rack还有一个杀手锏:Rack中间件. Rack利用中间件(Middleware)实现最大程度的模块化编程. Rack中间件对Ruby Web框架也有很深的影响:</p>

<ul>
  <li>不同的Web框架之间可以重用中间件,这意味着你编写的一个中间件可以在几乎所有的主流框架中使用</li>
  <li>可以通过不同的中间件组合组装出同一个Web框架的不同变种, 以适应不同的应用场合.</li>
  <li>可以组合多个不同的Web应用框架为同一个更大的系统服务</li>
</ul>

<h3 id="rack的使用">Rack的使用</h3>

<p>Rack协议将Rack应用描述成一个可以响应call方法的Ruby对象, 它接收一个来自外界的参数(env),然后返回一个只包含三个值的数组.</p>

<blockquote>
  <p>A Rack application is an Ruby Object(not a class) that responds to call. It tasks exactly one argument, the enviroment and returns an Array of exactly three values: the status,  the headers, and the body.</p>
</blockquote>

<p>一个Rack应用程序就是一个Ruby对象, 只要这个对象能够响应call. Ruby中能够响应call方法的对象很多, 包括:</p>

<ul>
  <li>一个 Proc 对象</li>
  <li>一个 lambda 对象</li>
  <li>一个 method 对象</li>
  <li>任何一个对象, 它的类的实例方法中包含一个 call 方法</li>
</ul>

<p>Rack应用对象接收一个环境(env)参数, 然后返回一个三元数组:</p>

<ul>
  <li>一个状态码(status), 即HTTP协议定义的状态码</li>
  <li>一个头(headers), 是一个Hash, 包含了所有的HTTP header</li>
  <li>一个响应体(body), 它是一个字符串数组</li>
</ul>

<p>Rack在Web Server 和应用程序之间提供了最小的API接口, 如果Web Server都遵循Rack提供的这套规则, 那么所有的框架都能通过Rack协议使用Web Server.</p>

<p>所有的Web Server只需要在Rack::Handler模块中实现一个 run方法的类即可:</p>

<pre><code class="language-ruby"># Rack 内置的 Web Server:  WEBrick
module Rack
  module Handler
    class WEBrick &lt; ::WEBrick::HTTPServlet::AbstractServlet
      def self.run(app, options = {})
        environment  = ENV['RACK_ENV'] || 'development'
        default_host = environment == 'development' ? 'localhost' : nil

        options[:BindAddress] = options.delete(:Host) || default_host
        options[:Port] ||= 8080
        @server = ::WEBrick::HTTPServer.new(options)
        @server.mount '/', Rack::Handler::WEBrick, app
        yield @server if block_given?
        @server.start
      end
    end
  end
end
</code></pre>

<p>这个类方法接收两个参数: Rack应用对象和包含各种参数的options 字典. 所有应用程序对象在接受到一个#call方法传来的env时, 都会返回一个三元组:</p>

<pre><code class="language-ruby">[status, headers, body]
</code></pre>

<p>最后的body响应体是一个由多个响应内容组成的数组, Rack使用的Web Server会将body中几个部分连接到一起最后拼成一个完整的HTTP响应后返回.</p>

<p><strong>我们可以任务当一个请求来临时, <code>Rack</code>应用会调用<code>call</code>方法, 参数为<code>env</code>, 经过应用的处理之后, 返回我们构造好的 <code>response</code></strong></p>

<p>我们可以使用Pry在 console中尝试使用Rack:</p>

<pre><code class="language-shell">$ pry
[7] pry(main)&gt; require 'rack'
=&gt; false
[8] pry(main)&gt; app = -&gt; (env) {[200, {}, ["Hello World"]]}
=&gt; #&lt;Proc:0x00007fc1644f62d0@(pry):8 (lambda)&gt;
[9] pry(main)&gt; Rack::Handler::WEBrick.run app, Port: 3000

[2018-03-03 10:45:59] INFO  WEBrick 1.3.1
[2018-03-03 10:45:59] INFO  ruby 2.4.2 (2017-09-14) [x86_64-darwin17]
[2018-03-03 10:45:59] INFO  WEBrick::HTTPServer#start: pid=32799 port=3000

::1 - - [03/Mar/2018:10:46:23 CST] "GET /admin HTTP/1.1" 200 11
- -&gt; /admin
::1 - - [03/Mar/2018:10:46:25 CST] "GET / HTTP/1.1" 200 11
- -&gt; /
::1 - - [03/Mar/2018:10:46:26 CST] "GET /favicon.ico HTTP/1.1" 200 11
http://localhost:3000/ -&gt; /favicon.ico

</code></pre>

<p>在浏览器中输入 <code>http://localhost:3000</code>, 就会出现<code>Hello World</code>.</p>

<p>除了使用 lambda外,我们的应用程序还可以使用method对象:</p>

<pre><code class="language-ruby">[10] pry(main)&gt; def my_method(env)
[10] pry(main)*   [200, {}, ['Hello World']]
[10] pry(main)* end
=&gt; :my_method

[11] pry(main)&gt; rack_app = method(:my_method)
=&gt; #&lt;Method: Object#my_method&gt;
[12] pry(main)&gt; rack_app.call({})
=&gt; [200, {}, ["Hello World"]]
[13] pry(main)&gt;

# 此处我们使用另外一个Web Server Thin
[14] pry(main)&gt; Rack::Handler::Thin.run rack_app, Port: 3000
Thin web server (v1.7.2 codename Bachmanity)
Maximum connections set to 1024
Listening on localhost:3000, CTRL+C to stop
</code></pre>

<p>一个合法的Rack程序也可以是任何对象, 只要它的类定义了call方法:</p>

<pre><code class="language-ruby">[15] pry(main)&gt; class MyRackApp
[15] pry(main)*   def call(env)
[15] pry(main)*     [200, {}, ['Hello from MyRackApp']]
[15] pry(main)*   end
[15] pry(main)* end
=&gt; :call
[16] pry(main)&gt; rack_app = MyRackApp.new
=&gt; #&lt;MyRackApp:0x00007f8e6aecd880&gt;
[17] pry(main)&gt;
</code></pre>

<p>以上几种方式都是在 console中启动的Web Server 来处理浏览器的请求, 实际应用中一般是将代码统一放在 config.ru 文件中:</p>

<pre><code class="language-ruby"># config.ru
run Proc.new { |env| ['200', {'Content-Type' =&gt; 'text/html'}, ['Hello World']] }
</code></pre>

<p>在同一目录下使用 backup 命令就可以启动一个 Web Server 进程:</p>

<pre><code class="language-shell"># 如果文件名恰好为 config.ru, 我们可以省略配置文件直接运行 rackup
$ rackup config.ru

Puma starting in single mode...
* Version 3.11.2 (ruby 2.4.2-p198), codename: Love Song
* Min threads: 0, max threads: 16
* Environment: development
* Listening on tcp://localhost:9292
Use Ctrl-C to stop

</code></pre>

<blockquote>
  <p>我们可以使用  httpie 工具代替 curl 在命令行中发出 HTTP请求, 这样可以直接在命令行中获取我们需要的诸多信息.</p>
</blockquote>

<p>使用 http 工具发出请求:</p>

<pre><code class="language-shell">http http:localhost:9292

HTTP/1.1 200 OK
Content-Type: text/html
Transfer-Encoding: chunked

Hello World
</code></pre>

<p>从上述请求返回的响应中可以看出, Puma 按照 config.ru文件中的代码对HTTP请求进行了处理</p>

<h2 id="rack初探">Rack初探</h2>

<p>本节探究一下Rack为Rack应用程序提供的几个基础接口和概念, 对Rack源码也解读一下.</p>

<h4 id="环境变量env">环境变量(env)</h4>

<p>Rack用一个环境参数(env)来调调用Rack应用程序, 它是一个<code>Hash</code>实例,它包含了全部的HTTP请求信息.</p>

<p>首先将env对应的 key =&gt; value 打印出来:</p>

<pre><code class="language-ruby"># !/usr/bin/env ruby
require 'rack'

app = lambda do |env|
  env.to_a.sort.each {|key, value| puts "#{key} =&gt; #{value}"}
  [200, {}, ['Hello World']]
end

Rack::Handler::Thin.run app, Port: 3000
</code></pre>

<p>这个简单的Rack应用程序会把env的内容都打印出来. 采用 http 发出请求 <code>http :3000/admin/?name=hwbnju</code>可以看到如下输出:</p>

<pre><code class="language-shell">GATEWAY_INTERFACE =&gt; CGI/1.2
HTTP_ACCEPT =&gt; */*
HTTP_ACCEPT_ENCODING =&gt; gzip, deflate
HTTP_CONNECTION =&gt; keep-alive
HTTP_HOST =&gt; localhost:8080
HTTP_USER_AGENT =&gt; HTTPie/0.9.9
HTTP_VERSION =&gt; HTTP/1.1
PATH_INFO =&gt; /admin
QUERY_STRING =&gt; name=hwbnju
REMOTE_ADDR =&gt; ::1
REQUEST_METHOD =&gt; GET
REQUEST_PATH =&gt; /
REQUEST_URI =&gt; /?name=hwbnju
SCRIPT_NAME =&gt;
SERVER_NAME =&gt; localhost
SERVER_PORT =&gt; 3000
SERVER_PROTOCOL =&gt; HTTP/1.1
SERVER_SOFTWARE =&gt; thin 1.7.2 codename Bachmanity
async.callback =&gt; #&lt;Method: Thin::Connection#post_process&gt;
async.close =&gt; #&lt;EventMachine::DefaultDeferrable:0x00007ffe978b6030&gt;
rack.errors =&gt; #&lt;IO:0x00007ffe950a27d8&gt;
rack.input =&gt; #&lt;StringIO:0x00007ffe978b67d8&gt;
rack.multiprocess =&gt; false
rack.multithread =&gt; false
rack.run_once =&gt; false
rack.url_scheme =&gt; http
rack.version =&gt; [1, 0]
</code></pre>

<p>环境变量大致可以分为两类:</p>

<ul>
  <li>
    <p>CGI变量:</p>

    <ul>
      <li>REQUEST_METHOD: HTTP请求的方法, 可以是 GET POST</li>
      <li>PATH_INFO: 访问的路径, 此处为 <code>/admin</code></li>
      <li>QUERY_STRING: 查询字符串, 此处为 <code>name=hwbnju</code></li>
    </ul>
  </li>
  <li>
    <p>rack特定的变量: <code>rack.**</code></p>

    <ul>
      <li>
        <p>rack.input: 一个IO对象, 可以读取 raw HTTP request</p>
      </li>
      <li>
        <p>rack,errors: 一个IO对象, 用于错误输出. Web服务器会把它输出到服务器日志文件. 它也是Rack::Logger以及 Rack::CommenLogger的输出对象</p>
      </li>
      <li>
        <p>rack.hijack, rack.hijack? rack.hijack_to: 实现 websocket</p>
      </li>
      <li>
        <p>rack.multiprocess, rack.multithread: 这两个对象知识了Rack应用的运行环境是否是多进程、多线程.</p>

        <p>这里着重说明一下: Rack 服务器可以根据负载情况同时启动Rack应用的多个实例.一般来说,多进程方式比较安全: 如果要使用多线程, 不但要保证Rack应用程序是线程安全, 还需要保证Rack中间件是线程安全.</p>

        <ul>
          <li>即有可能通过多进程(每个进程是一个实例) Unicorn</li>
          <li>通过多线程(一个进程, 多个线程, 每个线程一个实例) Thin</li>
          <li>将二者结合起来(多进程, 同时每个进程内多个线程实例) Puma Passeger</li>
        </ul>
      </li>
      <li>
        <p>rack.run_once: 服务器是否只运行Rack应用实例一次就把它释放掉. 这意味着服务器会对每个HTTP请求构造一个新的Rack应用实例(包括所有的中间件的初始化工作). 一般来说只有CGI服务器会这么做.</p>
      </li>
      <li>
        <p>rack.url_scheme: http or https</p>
      </li>
      <li>
        <p>rack.verison: rack spec 的版本</p>
      </li>
    </ul>
  </li>
</ul>

<p><strong>Rack env 不但可以从Web Server向Rack应用程序和中间件传递这些信息, 还用于在Rack中间件中间或者中间件与应用程序之间传递消息</strong></p>

<p><img src="http://img.nju520.me/2018-03-03-rack-env.png" alt="rack env" /></p>

<p>现在可以想象我们自己编写一个Rack程序, 我可以直接判断用户请求的方法、路径名、查询参数等信息, 然后直接调用对应的处理程序, 非常高效地实现各种丰富多彩的功能.</p>

<p>但是直接存取环境虽然直接高效, 但却需要手工处理很多麻烦的事情. 比如解析查询的参数, 维护用户的会话信息, 处理浏览器不支持PUT的情况, 在响应时添加合适的HTTP头等等.</p>

<p>Rack提供了丰富的API可以帮助我们快速方便地编写灵活的应用逻辑. 我们从两个最重要的类开始研究: Request 和 Response</p>

<h4 id="rackrequest">Rack::Request</h4>

<p>我们可以将传入Rack应用程序的环境变量(env)是包含一次HTTP请求的所有参数信息.  在Rack内部是将 env 转换成一个 request对象进行操作. <code>Rack::Request</code>为存取 env 提供了方便的接口.</p>

<blockquote>
  <p>Rack::Request provides a convenient interface to a Rack environment.  It is stateless, the environment +env+ passed to the constructor will be directly modified.
  req = Rack::Request.new(env)
  req.post?
  req.params[“data”]</p>
</blockquote>

<pre><code class="language-ruby">request = Rack::Request.new
</code></pre>

<p>新创建的<code>request</code>对象直接持有传入的env对象并在需要的时候对它进行修改, 它自己没有任何状态.</p>

<p>我们可以通过Hash的形式取得用户请求的参数, 比如:</p>

<pre><code class="language-ruby">request.params[:somekey]
</code></pre>

<p>下面的程序就是让用户猜测我们最喜欢的浏览器. 用户可以输入 http://localhost:3000/guess?client=XXX 这样的 url</p>

<pre><code class="language-ruby">#! /usr/bin/env ruby
require 'rack'

app = -&gt; (env) do
  request = Rack::Request.new(env)
  if request.path_info == '/guess'
    client = request['client']
    if client == 'chrome'
      [200, {}, ['Google Chrome']]
    else
      [200, {}, ['Please choose another browser']]
    end
  else
    [200, {}, ['you need guess something']]
  end
end

Rack::Handler::WEBrick.run app, :Port =&gt; 3000

</code></pre>

<p>当用户请求的 <code>path_info</code> 不是 <code>/guess</code>, 我们就返回<code>you need guess something</code>. 当用户输入的查询参数不包括 <code>client=chrome</code>时,我们则要求用户更换另外的浏览器名字.</p>

<p>我们直接用Hash存取用户的请求参数在很大程度上方便我们程序的实现.</p>

<p><code>Rack::Request</code>提供了询问当前HTTP请求类型的简洁方法</p>

<ul>
  <li>request_method: 请求的HTTP方法, 包含 GET POST PUT DELETE HEAD</li>
  <li>get? : HTTP请求是否为 GET</li>
  <li>head? : HTTP请求是否为 HEAD</li>
  <li>post? : HTTP请求是否为 POST</li>
  <li>puts? : HTTP请求是否为 PUT</li>
  <li>xhr? : HTTP请求是否为 XMLHttpRequest请求(即Ajax请求)</li>
</ul>

<h5 id="源码解读">源码解读:</h5>

<pre><code class="language-ruby"># rack/lib/request.rb
# request 类比较简单, 主要是对 env 进行处理
# Rack::Request 本身是无状态的,  env 传入 Request对象的构造方法中, 它可以直接被修改
# 以下代码为节选, 完整代码请参考:
# 重点说明一下 super 方法的使用
# 1. super       调用时, 将沿着继承链调用祖先类/模块的方法, 并携带传递给当前调用对象的全部方法参数
# 2. super()     调用时, 则不会传递调用者任何参数
# 3. super(a, b) 调用时, 则传递部分参数a, b

require 'rack/utils'
require 'rack/media_type'

module Rack
  class Request
    def initialize(env)
      @params = nil
      super(env)
    end

    def params
      @params ||= super
    end

    def update_param(k, v)
      super
      @params = nil
    end

    def delete_param(k)
      v = super
      @params = nil
      v  
    end

    # 对 header 进行操作的 helper
    module Env
      # the enviroment of the request
      attr_reader :env

      # env is an instance of Hash
      def initialize(env)
        @env = env
        super()
      end

      def has_header?(name)
        @env.key? name
      end

      def fetch_header(name, &amp;block)
      end

      def set_header(name, v)
      end

      def add_header(key, v)
      end

      def delete_header(name)
      end

      def initialize_copy(other)
        @env = other.env.dup
      end
    end

    # 一些辅助方法, 用来解析 env
    module Helpers

	  def body;  			get_header(RACK_INPUT); end
      def path_info;    	get_header(PATH_INFO); end
      def request_method;	get_header(REQUEST_METHOD); end

      # 判断请求的方法类型
      def get?;				request_method == GET; end
      def trace?;			request_method == TRACE; end
    end

    # 将上述两个模块 include 加入 Request类的继承链中
    # Rack::Request.ancestors
    #[Env, Helpers, ...]
    include Env
    include Helpers
  end
end
</code></pre>

<h4 id="rackresponse">Rack::Response</h4>

<p>前面的例子中我们都是手动构造返回数组, 但是在一个复杂的应用程序中, 我么可能需要对响应做更多的控制. 例如设置各种各样的HTTP响应头, 处理 cookie 等工作.</p>

<p><code>Rack::Response</code>提供了对响应的状态、HTTP头和内容进行处理的方便接口</p>

<h5 id="响应体">响应体</h5>

<p><code>Request</code>提供了两种方式来生成响应体:</p>

<ul>
  <li>直接设置 <code>response.body</code>. 此时必须手动设置 <code>Content-Length</code> 的值</li>
  <li>采用 <code>response.write</code> 增量写入内容, 自动填充 <code>Content-Length</code>的值</li>
</ul>

<p>不管采用哪种方式, 最后都得采用<code>response.finish</code> 完成 <code>response</code>的构建. 除了一些必要的检查外, <code>finish</code> 将装配出符合Rack规范的一个三元数组,也就是之前手动返回的那个数组: [status, heades, body]</p>

<p>采用第一种形式构造 body:</p>
<pre><code class="language-ruby">#! /usr/bin/env ruby
require 'rack'
require_relative 'decorator'

app = -&gt; (env) do
 request = Rack::Request.new(env)
 response = Rack::Response.new

 body = "===========header==========&lt;br/&gt;"
 if request.path_info == "/hello"
   body &lt;&lt; "you say hello"
   client = request['client']
   body &lt;&lt; " from #{client}" if client
 else
   body &lt;&lt; "you need provide some client information"
 end

 body &lt;&lt; "&lt;br/&gt;===========footer=========="
 response.body = [body]
 response.headers['Content-Length'] = body.bytesize.to_s
 response.headers['Content-type'] = 'text/html'
 response.finish
end

Rack::Handler::WEBrick.run app, :Port =&gt; 3000

</code></pre>

<p>采用第二种形式构造 body:</p>

<pre><code class="language-ruby">
#! /usr/bin/env ruby
require 'rack'
require_relative 'decorator'

app = -&gt; (env) do
  request = Rack::Request.new(env)
  response = Rack::Response.new

  response.write("===========header==========&lt;br/&gt;")
  if request.path_info == '/hello'
    response.write("You say hello")
    client = request['client']
    response.write(" from #{client}") if client
  else
    response.write("You need provide some client information")
  end
  response.write"&lt;br/&gt;===========footer=========="
  response.headers['Content-type'] = 'text/html'  
  response.finish
end

# use Decorator
# run app
Rack::Handler::WEBrick.run app, :Port =&gt; 3000

</code></pre>

<h5 id="响应码">响应码</h5>

<p>我们可以直接存取<code>Response</code>的对象来改变状态码. 如果没有任何设置, 状态码就为200.</p>

<p>Response还提供了一个 <code>redirect</code>方法直接进行重定向:</p>

<pre><code class="language-ruby">redirect(target, status = 302)
</code></pre>

<h3 id="响应头">响应头</h3>

<p>我们还可以直接写入 <code>Response</code>的头信息 <code>headers</code>, 这是一个<code>Hash</code></p>

<pre><code class="language-ruby">response.headers['Content-Type'] = 'text/plain'
</code></pre>

<h5 id="源码解读-1">源码解读</h5>

<pre><code class="language-ruby">require 'rack/request'
require 'rack/utils'
require 'rack/body_proxy'
require 'rack/media_type'
require 'time'

module Rack
  # Rack::Response 为创建 Rack response提供了简介的接口.
  # 它允许设置响应头(header) cookies
  # 我们可以使用 write 增量不断地写入响应内容, 直到调用 finish 结束

  class Response
  	attr_accessor :length, :status, :body
    attr_reader :header
    alias headers haeder

    def	initialize(body = [], status = [], header = [])
      @status = status.to_i
      @header = Utils::HeaderHash.new.merge(header)

      @writer = lambda {|x| @body &lt;&lt; x} # 后续调用 @writer.call(x) 向body中添加内容
      @block = nil
      @length = 0
      @body = []
      if body.respond_to? :to_str
      	write body.to_str
      elsif body.respond_to? :each
      	body.each {|part| write part.to_s}
      else
      	raise TypeError, 'stringable or iterable required'
      end

      yield self if block_given?
    end

    def	finish(&amp;block)
      @block = block

      if [204, 304].include?(status.to_i)
      	delete_header CONTENT_TYPE
      	delete_header CONETENT_LENGTH
      	close
      	[status.to_i, header, []]
      else
        [status, header, BodyProxy.new(self){}]
      end
    end

    # 向body后插入数据
    def write(str)
      s = str.to_s
      @length += s.bytesize unless chunked
      @writer.call s

      set_header(CONTENT_LENGTH, @length.to_s) unless chunked?
      str
    end

    # 关闭
    def close
      body.close if body.respond_to?(:close)
    end


  end
end
</code></pre>

<h2 id="rack中间件">Rack中间件</h2>

<p>什么是中间件? 简单讲中间件就是在Ruby Web Server和Rack应用程序之间执行的代码.</p>

<p>Rack协议和中间件是Rack能达到今天地位不可或缺的两个特性. Rack协议规定了 WebServer 和 Rack 应用程序之间应该如何通信, 而Rack中间件能够在上层改变HTTP的响应或者请求, 在不改变应用的基础上为Rack应用增加新的功能.</p>

<h3 id="一个简单的中间件">一个简单的中间件</h3>

<p>前面一节中介绍<code>Rack::Response</code>时,我们在程序输出的前后分别添加了头信息和尾信息. 我们可以尝试把实际的程序输出和包装的过程剥离开来. 首先去掉头信息和尾信息的输出:</p>

<pre><code class="language-ruby">#! /usr/bin/env ruby
require 'rack'
require_relative 'decorator'

app = -&gt; (env) do
  request = Rack::Request.new(env)
  response = Rack::Response.new

  if request.path_info == '/hello'
    response.write("You say hello")
    client = request['client']
    response.write(" from #{client}") if client
  else
    response.write("You need provide some client information")
  end
  response.headers['Content-type'] = 'text/html'
  # response.finish 返回的正是 response 本身.
  response.finish
end

# use Decorator
# run app
Rack::Handler::WEBrick.run Decorator.new(app), :Port =&gt; 3000

</code></pre>

<p>最后一行我们采用的是</p>

<pre><code class="language-ruby">Rack::Handler::WEBrick.run Decorator.new(app), Port: 3000

# 相当于调用了
# (Decorator.new(app)).call(env)
# decorator.call(env)
# 上述方法内部先调用 @app的 call(env)
# 再对返回的三元数组进行处理之后, 返回新的三元数组
</code></pre>

<p>接下来我们就要定义一个 Decorator类, 创建 Decorator实例时传入原始的 rack_app 作为其参数. 这个实例也能够被Rack的Handler调用–显然这个实例也是合法的Rack应用程序. 因此 Decorator类需要一个call方法.</p>

<pre><code class="language-ruby"># decorator.rb
class Decorator
  # 初始化方法接收一个标准的Rack应用程序参数, 并且可以传入 代码块
  def initialize(app, &amp;block)
    @app = app
    @block = @block
  end

  def call(env)
    status, headers, body = @app.call(env)
    new_body = "===========header==========&lt;br/&gt;"
    # 这里的body实际上是一个 response实例, 它能够响应`each`方法
    body.each {|str| new_body &lt;&lt; str}
    new_body &lt;&lt; "&lt;br/&gt;===========footer=========="
    headers['Content-Length'] = new_body.bytesize.to_s

    # 最后返回加上头尾信息的新的三元数组
    [status, headers, [new_body]]
  end
end
</code></pre>

<p>运行程序, 我们可以在命令行中得到和之前一样的结果:</p>

<pre><code class="language-shell">$ http http://localhost:3000/hello
===========header==========
You say hello
===========footer==========
</code></pre>

<h3 id="rack响应的标准">Rack响应的标准</h3>

<p><strong>任何中间件本身必须是一个合法的Rack应该程序</strong></p>

<p>Rack协议要求Rack应用程序的call方法返回一个数组, 包含三个成员</p>

<ul>
  <li>status(状态码): 这是一个HTTP状态, 不一定是整数, 但是必须能够响应<code>to_i</code>方法并返回一个整数</li>
  <li>headers(响应头): 这个头必须能够响应<code>each</code>放啊, 并且每次产生一个key和value.</li>
  <li>body(响应体): 必须能够响应<code>each</code>方法, 而且每次必须产生一个字符串.  Rack::Response的实例是合法的响应体, 应为它能够正确响应<code>each</code>方法.所以body不一定非得是数组, 只要能响应<code>each</code>方法即可.</li>
</ul>

<p>中间件可以实现 通用逻辑和业务逻辑分离, 这些通用的逻辑可以被应用到各种各样不同的业务逻辑.</p>

<p>比如说我们实现了一个用于身份认证的中间件, 那么这个中间件就可以应用到任何Rack应用程序中.</p>

<p>由于几乎所有的Ruby Web框架编写的应用程序都是Rack应用, 因此任何Web应用程序都可以不加修改地使用我们编写的身份认证中间件来实现用户身份认证.</p>

<p><img src="" alt="中间件架构" /></p>

<p>Web框架的作者可以用中间件的形式实现整个框架. 由于中间件本身也是合法的Rack应用程序, 这就意味着中间件外面还可以包装中间件. 原先需要单片实现的整个框架被分割成多个中间件, 每个中间件只关系自己需要实现的功能. 这样的好处显而易见:</p>

<ul>
  <li>每个中间件独立开发, 甚至可以被独立地替换</li>
  <li>我们可以用不同方式去组合中间件, 最大程度低满足不同应用程序的需要</li>
</ul>

<h3 id="装配中间件">装配中间件</h3>

<p>我们往往需要在一个应用程序里面装载很多中间件, 最直接的方式是采用 <code>new</code> 方法.</p>

<pre><code class="language-ruby"># 两个中间件 Middleware1 Middleware2, 一个应用程序 rack_app
Rack::Handler::Thin.run(Middleware1.new(Middleware2.new(rack_app, options2), options1))
</code></pre>

<p>如果我们要使用很多中间件, 上述代码肯定会越来越繁琐.在Ruby中,我们可以使用<code>DSL</code>来优雅地装配中间件:</p>

<pre><code class="language-ruby">class Builder
  # 加入中间件
  def use
  end

  # 加入应用程序
  def run
  end
end

# Builder生成一个最终程序
app = Builder.new {
    use Middleware1
    use Middleware2
    run RackApplication
}.to_app
# 启动Web Server来运行此app
Rack::Handler::XXX.run app
</code></pre>

<p><code>use</code>  和 <code>run</code>  作为DSL中的动词. 这些DSL使用的范围通常是一个 <code>block</code></p>

<ul>
  <li>use: 使用一个中间件</li>
  <li>run: 运行原始的rack程序(在Rack源代码中run也仅仅是将原始的rack程序加入中间件栈中, 并没有运行)</li>
</ul>

<p>前述例子中<code>Decorator</code> 只必须得在生成新的响应体 <code>new_body</code>以后设置新的 <code>Content-Type</code>:</p>

<pre><code class="language-ruby">headers['Content-Type'] = new_body.bytesize.to_s
</code></pre>

<p>Rack自带了很多中间件, 其中一个中间件就是 <code>Rack::ContentLength</code>, 它可以自动设置响应中的<code>Content-Length. 我们可以使用如下方式使用 </code>Rack` 自带的中间件:</p>

<pre><code class="language-ruby">#! usr/bin/env ruby
require 'rack'
require 'decorator'

app = Builder.new {
    use Rack::ContentLength
    use Decorator
    run lambda {|env| [200, {"Content-Type" =&gt; "text/html"}, ["Hello World"]]}
}.to_app

Rack::Handler::WEBrick.run app, Port: 3000

</code></pre>

<pre><code class="language-ruby"># decorator.rb
class Decorator
  def initialize(app, &amp;block)
    @app = app
    @block = @block
  end

  def call(env)
    status, headers, body = @app.call(env)
    new_body = ""
    new_body &lt;&lt; "===========header==========&lt;br/&gt;"
    body.each {|str| new_body &lt;&lt; str}
    new_body &lt;&lt; "&lt;br/&gt;===========footer=========="
    # 注释掉下面一行, 采用Rack自带的中间件自动添加头部信息: Content-Length
    # headers['Content-Length'] = new_body.bytesize.to_s

    # 最后返回加上头尾信息的新的三元数组
    [status, headers, [new_body]]
  end
end
</code></pre>

<p>万事俱备, 只欠东风. 现在我们还是思考如何实现<code>Builder</code>.</p>

<p>根据上面的模板, 我们对 <code>Builder</code>几个方法要求如下:</p>

<ul>
  <li>initialize: 签名应该是 initialize(&amp;block). 为了能够让 <code>use</code>、<code>run</code>这些方法称为DSL语言的<strong>动词</strong>,initialize应该 <code>initialize_eval</code>当前实例</li>
  <li>use: 签名应该是 `use(middleware_class, options, &amp;block). 它应该记录需要创建的中间件以及它们的顺序. 同时还可以保存传入中间件时携带的参数和代码块</li>
  <li>run: 签名应该为 <code>run(rack_app)</code>. 记录原始的<code>rack应该程序</code></li>
  <li>to_app: 根据<code>use</code>和<code>run</code>记录的信息创建出最终的应用程序</li>
</ul>

<h4 id="简单实现">简单实现</h4>

<p>我们首先通过传统方法来实现<code>Builder</code>, 用数组记录所有需要创建的中间件信息, 最后<code>to_app</code>时候把它们创建出来</p>

<pre><code class="language-ruby">#Rack应用构造类
class Builder
  def initialize(&amp;block)
    @middlewares = []
    self.instance_eval(&amp;block)
  end

  def use(middleware)
    @middlewares &lt;&lt; middleware
  end

  def run(app)
    @app = app
  end

  def to_app
    @middlewares.reverse.inject(@app) {|app, middleware| middleware.new(app)}
  end

end
</code></pre>

<p><code>Builder</code>类中<code>to_app</code>的实现,首先对加入的<code>middlewares</code>进行了<code>reverse</code>,这是因为对所有使用的中间件, 我们必须持有它们的顺序信息. 第一个被<code>use</code>的中间件包在最外面一层, 第二个被<code>use</code>的中间件在第二层, 依次类推, 直至包含了原始的<code>Rack应用程序</code>.</p>

<h4 id="更ruby化的实现">更<code>Ruby</code>化的实现</h4>

<p>上面传统的方法有一定的局限性. 例如如果我们需要在<code>use</code>中间件的过程中带上一些选项, 甚至执行某些代码. <code>use</code>描述的是中间件创建的过程, 创建过程需要携带自动的参数, 需要执行某些代码–但是这个创建过程并不是在现在就要被执行, 而是在<code>to_app</code>时候被执行.</p>

<p><strong>对那些需要在以后执行的代码, Ruby给出了最好的解决答案就是<code>lambda</code></strong>.</p>

<pre><code class="language-ruby">class Builder
  def initialize(&amp;block)
    @middlewares = []
    self.instance_eval(&amp;block)
  end

  def use(middleware_class, *options, &amp;block)
    @middlewares &lt;&lt; lambda {|app| middleware_class.new(app, *options, &amp;block)}
  end

  def run(app)
    @app = app
  end

  def to_app
    @middlewares.reverse.inject(@app) {|app, middleware| middleware.call(app)}
  end
end

</code></pre>

<p><code>use</code>方法把中间件的创建过程以<code>lambda</code>的方式保存在<code>@middlewares</code>数组中, 而中间件的创建过程就是以<code>app</code>为参数创建一个最终版的<code>app</code>.</p>

<p>我们可以修改之前的<code>Decorator</code>, 为其加上参数配置和代码块.</p>

<pre><code class="language-ruby">#! /usr/bin/env ruby
require 'rack'

class Decorator

  def initialize(app, *options, &amp;block)
    @app = app
    @options = (options[0] || {})
    @block = block
  end

  def call(env)
    # body is an instance of Array
    status, headers, body = @app.call(env)
    @block.call if @block

    new_body = ""
    new_body &lt;&lt; (@options[:header] || "===========header==========&lt;br/&gt;")
    body.each {|str| new_body &lt;&lt; str}
    new_body &lt;&lt; (@options[:footer] || "&lt;br/&gt;===========footer==========")
    [status, headers, [new_body]]
  end
end

</code></pre>

<p>最后修改一下我们的运行程序, 为<code>Decorator</code>添加参数和代码块</p>

<pre><code class="language-ruby"># my_app.rb
# !/usr/bin/env ruby

require 'rack'
require_relative 'builder'
require_relative 'decorator'

app = Builder.new {
  use Rack::ContentLength
  use Decorator, header: '************* header ****************&lt;br/&gt;'
  run lambda { |env| [200, {'Content-Type' =&gt; 'text/html'}, ['Hello World']] }
}.to_app

Rack::Handler::WEBrick.run app, Port: 3000

</code></pre>

<p>运行程序, 我们可以看到如下输出:</p>

<pre><code class="language-shell">$ ./my_app.rb
λ ruby my_app.rb
[2018-03-04 09:57:04] INFO  WEBrick 1.3.1
[2018-03-04 09:57:04] INFO  ruby 2.4.2 (2017-09-14) [x86_64-darwin17]
[2018-03-04 09:57:04] INFO  WEBrick::HTTPServer#start: pid=32569 port=3000
::1 - - [04/Mar/2018:09:57:07 CST] "GET /hello HTTP/1.1" 200 85
- -&gt; /hello
::1 - - [04/Mar/2018:09:58:59 CST] "GET /hello HTTP/1.1" 200 85
- -&gt; /hello
::1 - - [04/Mar/2018:09:58:59 CST] "GET /favicon.ico HTTP/1.1" 200 85
http://localhost:3000/hello -&gt; /favicon.ico


************* header ****************
Hello World
===========footer==========
</code></pre>

<h4 id="configru-配置文件">config.ru 配置文件</h4>

<p>以上两种方式是我们手动实现的中间件装载过程, 实际使用过程中我们可以把装载过程写在<code>config.ru</code>配置文件中, 然后运行命令 <code>rackup config.ru</code>即可完成中间件的加载和 Web Server的启动</p>

<pre><code class="language-ruby"># config.ru
require_relative 'decorator'

use Rack::ContentLength
use Decorator, header: "******** header **********&lt;/br&gt;"
run lambda { |env| [200, {'Content-Type' =&gt; 'text/html'}, ['Hello World']] }
</code></pre>

<pre><code class="language-shell">$ rackup
Puma starting in single mode...
* Version 3.11.2 (ruby 2.4.2-p198), codename: Love Song
* Min threads: 0, max threads: 16
* Environment: development
* Listening on tcp://localhost:9292
Use Ctrl-C to stop
</code></pre>

<p>以上主要对<code>Rack</code>进行了简单的介绍, 并且自行实现了中间件的构造和装载代码.</p>

<p>下一篇着重研究<code>Rack</code>源码, 以及Web Server的启动过程</p>

  ]]></description>
</item>


  </channel>
</rss>
