---
layout: post
toc: true
permalink: /rack-principle
title: Ruby Rack 协议及其应用(二)
tags: Rack系列  rack  ruby  rails  server
desc:  Rack是Ruby应用服务器和Rack应用程序之间的一个接口,用于两者之间的交互. 不仅仅是大名鼎鼎的Ruby on Rails ,几乎所有的Ruby Web 框架都是一个Rack应用. 除了Web框架之外, Rack同样支持很多Ruby Web服务器. 本系列文章就深入探讨Rack协议的原理以及实现.
---

## Rack实现原理

### 创建应用程序

要分析`Rack`的源码, 我们首先创建一个简单的`Rack应用程序`

~~~ruby
#config.ru
# 将 body 标签的内容转换为全大写.
class ToUpper
  def initialize(app)
    @app = app
  end
  def call(env)
    status, head, body = @app.call(env)
    upcased_body = body.map{|chunk| chunk.upcase }
    [status, head, upcased_body]
  end
end
# 将 body 内容置于标签, 设置字体颜色为红色, 并指明返回的内容为 text/html.
class WrapWithRedP
  def initialize(app)
    @app = app
  end
  def call(env)
    status, head, body = @app.call(env)
    red_body = body.map{|chunk| "<p style='color:red;'>#{chunk}</p>" }
    head['Content-type'] = 'text/html'
    [status, head, red_body]
  end
end

# 将 body 内容放置到 HTML 文档中.
class WrapWithHtml
  def initialize(app)
    @app = app
  end

  def call(env)
    status, head, body = @app.call(env)
    wrap_html = <<-EOF
       <!DOCTYPE html>
       <html>
         <head>
         <title>hello</title>
         <body>
         #{body[0]}
         </body>
       </html>
    EOF
    [status, head, [wrap_html]]
  end
end

# 起始点, 只返回一行字符的 rack app.
class Hello
  def initialize
    super
  end
  def call(env)
    [200, {'Content-Type' => 'text/plain'}, ["hello, this is a test."]]
  end
end
use WrapWithHtml
use WrapWithRedP
use ToUpper
run Hello.new
~~~



### rackup 命令

在 `terminal`下输入命令 `rackup`, 就会启动一个`Web服务`

~~~shell
$ rackup

Puma starting in single mode...
* Version 3.11.2 (ruby 2.4.2-p198), codename: Love Song
* Min threads: 0, max threads: 16
* Environment: development
* Listening on tcp://localhost:9292
Use Ctrl-C to stop
~~~

`rackup` 来自于哪里? 如何加载`config.ru`文件并生成项目?



首先我们可以通过 `where`命令来查找当前`rackup`指令的执行路径并打印文件代码:

~~~shell
$ where rackup
/Users/bobo/.rvm/gems/ruby-2.4.2/bin/rackup

$ cat /Users/bobo/.rvm/gems/ruby-2.4.2/bin/rackup
#!/usr/bin/env ruby
#
# This file was generated by RubyGems.
#
# The application 'rack' is installed as part of a gem, and
# this file is here to facilitate running it.
#

require 'rubygems'

version = ">= 0.a"

if ARGV.first
  str = ARGV.first
  str = str.dup.force_encoding("BINARY") if str.respond_to? :force_encoding
  if str =~ /\A_(.*)_\z/ and Gem::Version.correct?($1) then
    version = $1
    ARGV.shift
  end
end

if Gem.respond_to?(:activate_bin_path)
  load Gem.activate_bin_path('rack', 'rackup', version)
else
  gem "rack", version
  load Gem.bin_path("rack", "rackup", version)
end
~~~

从 `rackup`文件中我们可以看出当前文件是由`RubyGems`自动生成, 在文件最后通过`load`方法加载对应文件中的代码, 从而启动服务. 我们可以在 `pry`中找到要加载的文件及其代码.

~~~shell
λ gem list "^rack$"

*** LOCAL GEMS ***

rack (2.0.3, 2.0.1, 1.6.8)

λ pry
[1] pry(main)> Gem.activate_bin_path('rack', 'rackup', '2.0.3')
=> "/Users/bobo/.rvm/gems/ruby-2.4.2/gems/rack-2.0.3/bin/rackup"
[2] pry(main)> exit

λ cat /Users/bobo/.rvm/gems/ruby-2.4.2/gems/rack-2.0.3/bin/rackup
#!/usr/bin/env ruby

require "rack"
Rack::Server.start

~~~



> `rackup`命令定义在 `rack`工程的 `bin/rackup`文件中. 通过 `rubygems`安装后会生成另外一个加载该文件的可执行文件.

最后我们找到了加载的文件. `.activate_bin_path`方法会查找对应的`gem`当前生效的版本, 并返回文件的路径. 在这个可执行文件中, 只是简单的两行代码

~~~ruby
#!/usr/bin/env ruby

require 'rack'

# 启动一个Web Server
Rack::Server.start
~~~



### 启动 Web Server

从这里开始, 我们就已经从`	rakcup`命令的执行进入了`rack` 的源码.  当前`Rack::Server`类初始化一个新的实例后, 在新对象上执行了`#start`方法.

~~~ruby
[1] pry(main)> require 'rack'
=> true
[2] pry(main)> $ Rack::Server.start

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 147:
Owner: #<Class:Rack::Server>
Visibility: public
Number of lines: 3

def self.start(options = nil)
  new(options).start
end
~~~



#### 初始化和配置

在`Rack::Server`启动过程中初始化一个新的对象, 初始化的过程就包含了整个服务器的配置过程:

~~~ruby
[3] pry(main)> $ Rack::Server#initialize

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 185:
Owner: Rack::Server
Visibility: private
Number of lines: 13

def initialize(options = nil)
  @ignore_options = []

  # 直接运行`rackup`时没有传入任何参数, 因此代码跳转到 `else`部分
  if options
    @use_default_options = false
    @options = options
    @app = options[:app] if options[:app]
  else
    argv = defined?(SPEC_ARGV) ? SPEC_ARGV : ARGV
    @use_default_options = true
    @options = parse_options(argv)
  end
end
~~~

解析参数部分:

~~~ruby
[4] pry(main)> $ Rack::Server#parse_options

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 328:
Owner: Rack::Server
Visibility: private
Number of lines: 10

#传入的参数 args == [], 因此`opt_parser.parse!(args)`直接返回 {}
def parse_options(args)
  # Don't evaluate CGI ISINDEX parameters.
  # http://www.meb.uni-bonn.de/docs/cgi/cl.html
  args.clear if ENV.include?(REQUEST_METHOD)

  # @options = {}
  @options = opt_parser.parse!(args)
  
  # `options`为 `Rack::Server`类中定义的一个实例方法
  # `@options[:config] = 'config.ru'
  @options[:config] = ::File.expand_path(options[:config])
  ENV["RACK_ENV"] = options[:environment]
  @options
end

-------------------------------------------------------------------------
[5] pry(main)> $ Rack::Server#opt_parser

From: /Users/bobo/.rvm/gems/ruby-2.4.2/gems/rack-2.0.3/lib/rack/server.rb @ line 339:
Owner: Rack::Server
Visibility: private
Number of lines: 3

def opt_parser
  Options.new
end

-------------------------------------------------------------------------
[6] pry(main)> $ Rack::Server::Options#parse!

From: /Users/bobo/.rvm/gems/ruby-2.4.2/gems/rack-2.0.3/lib/rack/server.rb @ line 10:
Owner: Rack::Server::Options
Visibility: public
Number of lines: 96

def parse!(args)
  options = {}
  opt_parser = OptionParser.new("", 24, '  ') do |opts|
  opts.banner = "Usage: rackup [ruby options] [rack options] [rackup config]"

  opts.separator ""
  opts.separator "Ruby options:"
  # ...
  options[:config] = args.last if args.last && !args.last.empty?
  options
end
  
-------------------------------------------------------------------------
[7] pry(main)> $ Rack::Server#options

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 199:
Owner: Rack::Server
Visibility: public
Number of lines: 4

# 由于我们运行`rackup`指令时没有传入任何参数, 因此 `@use_default_options = true`.
#`options`中方法中继续调用`default_options`
def options
  merged_options = @use_default_options ? default_options.merge(@options) : @options
  merged_options.reject { |k, v| @ignore_options.include?(k) }
end
 
-------------------------------------------------------------------------    
[8] pry(main)> $ Rack::Server#default_options

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 204:
Owner: Rack::Server
Visibility: public
Number of lines: 13

# `default_options`会处理对象本身定义的一些参数, 比如默认的端口号、默认的`config`文件
# `config`文件就是`rackup`接收的一个文件参数, 文件中的内容就是用来配置`Rack`服务器的代码.
# 默认情况下名为`config.ru`, 也就是我们在前面写好的那个配置文件
def default_options
  environment  = ENV['RACK_ENV'] || 'development'
  default_host = environment == 'development' ? 'localhost' : '0.0.0.0'

  {
    :environment => environment,
    :pid         => nil,
    :Port        => 9292,
    :Host        => default_host,
    :AccessLog   => [],
    :config      => "config.ru"
  }
end
  
~~~

#### 包装应用

当我们执行了 `initialize`方法初始化了一个新的实例后, 接下来就会进入`#start`实例方法启动一个 	`WebServer`来处理`config.ru`中定义的应用了:

~~~ruby
[9] pry(main)> $ Rack::Server#start

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 258:
Owner: Rack::Server
Visibility: public
Number of lines: 41

def start &blk
  # 删除了多余不重要的代码
    
  # Touch the wrapped app, so that the config.ru is loaded before
  # daemonization (i.e. before chdir, etc).
  # 通过注释我们可以知晓 `wrapped_app`方法是在启动守护进程之前就加载了 `config.ru`配置文件来创建好最终的应用程序
  wrapped_app

  server.run wrapped_app, options, &blk
end

-------------------------------------------------------------------------
# 首先查看 `Rack::Server#server`中传入的参数
[10] pry(main)> $ Rack::Server#wrapped_app

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 353:
Owner: Rack::Server
Visibility: private
Number of lines: 3

# 继续调用 `build_app`方法 以及 `app`方法
def wrapped_app
  @wrapped_app ||= build_app app
end


~~~



`wrapped_app`方法实际上需要继续调用两个方法: `build_app` 、 `app`.

`Rack::Server#app`方法调用栈比较复杂:



![Rack::Server#app]()



~~~ruby
[11] pry(main)> $ Rack::Server#app

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 218:
Owner: Rack::Server
Visibility: public
Number of lines: 3

def app
  # 由于我们使用的是默认参数, 因此 `options[:builder]`为nil
  # 继续调用 `build_app_and_options_from_config`
  @app ||= options[:builder] ? build_app_from_string : build_app_and_options_from_config
end

-------------------------------------------------------------------------
[12] pry(main)> $ Rack::Server#build_app_and_options_from_config

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 314:
Owner: Rack::Server
Visibility: private
Number of lines: 9

def build_app_and_options_from_config
  if !::File.exist? options[:config]
    abort "configuration #{options[:config]} not found"
  end

  # `parse_file`传入我们的配置文件 `config.ru`
  app, options = Rack::Builder.parse_file(self.options[:config], opt_parser)
  @options.merge!(options) { |key, old, new| old }
  app
end

-------------------------------------------------------------------------
[13] pry(main)> $ Rack::Builder.parse_file

From: **/gems/rack-2.0.3/lib/rack/builder.rb @ line 32:
Owner: #<Class:Rack::Builder>
Visibility: public
Number of lines: 15

def self.parse_file(config, opts = Server::Options.new)
  options = {}
  if config =~ /\.ru$/
    cfgfile = ::File.read(config)
    if cfgfile[/^#\\(.*)/] && opts
      options = opts.parse! $1.split(/\s+/)
    end
    cfgfile.sub!(/^__END__\n.*\Z/m, '')
    # 最终我们的程序去调用 `new_from_string`, 参数为 `File.read("config.ru")`
    app = new_from_string cfgfile, config
  else
    require config
    app = Object.const_get(::File.basename(config, '.rb').split('_').map(&:capitalize).join(''))
  end
  return app, options
end

-------------------------------------------------------------------------
[14] pry(main)> $ Rack::Builder.new_from_string

From: **/gems/rack-2.0.3/lib/rack/builder.rb @ line 48:
Owner: #<Class:Rack::Builder>
Visibility: public
Number of lines: 4

def self.new_from_string(builder_script, file="(rackup)")
  eval "Rack::Builder.new {\n" + builder_script + "\n}.to_app",
    TOPLEVEL_BINDING, file, 0
end
~~~

通过`Ruby`元编程中常用的 `eval`方法, 将配置文件`config.ru`的全部内容和两端的字符串拼接起来, 相当于执行下列代码:

~~~ruby
Rack::Builder.new {
  use WrapWithHtml
  use WrapWithRedP
  use ToUpper
  run Hello.new
}.to_app
~~~

是不是是曾相识? 我们在`Rack协议及其应用(一)`中就手动实现过`Rack::Builder`类. 上述代码就是存储了所有的中间件以及原始的`Rack应用程序`, 最后通过`#to_app`方法返回了一个`Rack`应用. 稍后我们会分析`Rack::Builder`的源码

在这之后会使用`Rack::Builder#build_app`方法将所有的中间件都包括在`Rack`应用周围.所有的中间件都是一个遵循协议的`App`, 只不过中间件和`App`的唯一区别就是中间件会调用初始化时传入的`Rack App`.

~~~ruby
[15] pry(main)> $ Rack::Server#build_app

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 343:
Owner: Rack::Server
Visibility: private
Number of lines: 9

def build_app(app)
  middleware[options[:environment]].reverse_each do |middleware|
    middleware = middleware.call(self) if middleware.respond_to?(:call)
    next unless middleware
    klass, *args = middleware
    app = klass.new(app, *args)
  end
  app
end
~~~

经过上述方法, 我们在一个`Rack` 应用周围一层一层包装上了所有的中间件, 最后调用的中间件在整个调用栈的最外层, 当包装后的应用接收来自外部的请求时, 会按照如下方式运行:

![WRAPPED APP]()



请求进来 -> 从最外层的中间件进入, 每个中间件都会处理`request`, 在`#call`方法内部调用另外一个中间件或者应用. 当`request`进入到最初的`Rack应用程序`后, 程序返回`response`, 在经过一层一层的中间件处理, 最后返回 `HTTP响应`



#### 中间件的实现分析

在`Rack`中, 中间件是由两部分代码共同处理的:

* Rack::Builder: 包含能够在`config.ru`文件中能够使用的`DSL`方法. 
* Rack::Server: 启动 `Web Server`



当我们使用`eval`执行`config.ru`文件中的代码时, 会先初始化一个`Builder`实例, 然后执行`instance_eval`运行代码中的所有内容:

~~~ruby
[16] pry(main)> $ Rack::Builder#initialize

From: **/gems/rack-2.0.3/lib/rack/builder.rb @ line 53:
Owner: Rack::Builder
Visibility: private
Number of lines: 4

def initialize(default_app = nil, &block)
  @use, @map, @run, @warmup = [], nil, default_app, nil
  instance_eval(&block) if block_given?
end
~~~

通过调用`instance_eval `, `config.ru`文件中的代码会在当前实例环境下运行, 文件中的`#use`和`#run`方法在调用时就会执行`Rack::Builder`的实例方法:

~~~ruby
[17] pry(main)> $ Rack::Builder#use

From: **/gems/rack-2.0.3/lib/rack/builder.rb @ line 81:
Owner: Rack::Builder
Visibility: public
Number of lines: 7

def use(middleware, *args, &block)
  if @map
    mapping, @map = @map, nil
    @use << proc { |app| generate_map app, mapping }
  end
  @use << proc { |app| middleware.new(app, *args, &block) }
end
      
def run(app)
  @run = app
end
      
def to_app
  app = @map ? generate_map(@run, @map) : @run
  fail "missing run or map statement" unless app
  app = @use.reverse.inject(app) { |a,e| e[a] }
  @warmup.call(app) if @warmup
  app
end
      
~~~

`Rack::Builder#use`方法会将传入的参数组合成一个接收`app`作为参数的`Proc`对象, 然后加入到`@use`数组中存储起来.  



`Rack::Builder#run`方法是存储最原始的`Rack应用程序`, 将其保存到`@run`实例变量中.



最后如果我们想要获取当前的`Rack::Builder`生成的应用, 只需要调用`Rack::Builder#to_app`方法.值得一提的是`to_app`代码实现中使用了一个技巧, 可以使用`[]`来调用 `proc/lambda`.

~~~ruby
# `app = @use.reverse.inject(app) { |a,e| e[a] }`等价于下列代码
app = @run
@use.reverse.each do |middleware|
  app = middleware.new(app)
end
app

e = proc {|app| puts "call: arguments is #{app}"}
a = 'app'
e[a]
# call: arguments is app
~~~



关于`inject`:

> Combines all elements of enum by applying a binary operation, specified by a block or a symbol that names a method or operator. If you specify a block, then for each element in enum the block is passed an accumulator value (memo) and the element. If you specify a symbol instead, then each element in the collection will be passed to the named method of memo. In either case, the result becomes the new value for memo. At the end of the iteration, the final value of memo is the return value for the method. If you do not explicitly specify an initial value for memo, then the first element of collection is used as the initial value of memo.

关于 `block`:

> prc[params,...] Invokes the block, setting the block’s parameters to the values in params using something close to method calling semantics. Generates a warning if multiple values are passed to a proc that expects just one (previously this silently converted the parameters to an array). Note that prc.() invokes prc.call() with the parameters given. It’s a syntax sugar to hide “call”.



`@use.reverse.inject(app) { |a,e| e[a] }`运行过程中, 前一轮的`e[a]`被存储到内存中, 并加载了下一轮的`a`变量中, 因为 `e`和`a`都是`proc`, 所以` e[a]`本质上是调用这个代码块. 在这个过程中, 最原始的那个`Rack应用程序`会被放在最底层, 而`middleware`会一层一层地套在上面.生成的实例类似于下面的表示:

~~~ruby
use WrapWithHtml
use WrapWithRedP
use ToUpper
run Hello.new

# WrapWithHtml.new(WrapWithRedP.new(ToUpper.new(Hello.new)))
@use = [WrapWithHtml.new, WrapWithRedP, ToUpper.new]
@run = Hello.new
app = @use.reverse.inject(app) { |a,e| e[a] }

# `inject` 中, `e`相当于数组的依次传入的值, `a`相当于每一次迭代返回的值
# `inject`传入的参数 `app`赋给 `a`
# 1.1
a = app = @run = Hello.new
e =  proc { |app| ToUpper.new(app, *args, &block) }
result = e[a] = proc { |app| ToUpper.new(app, *args, &block) }.call(a)
       = ToUpper.new(Hello.new, *args, &block)
       = ToUpper.new(Hello.new)

# 1.2
a = result = ToUpper.new(Hello.new)
e = proc {|app| WrapWithRedP.new(app, *args, &block)}
result = e[a] = proc {|app| WrapWithRedP.new(app, *args, &block)}.call(a)
       = WrapWithRedP.new(ToUpper.new(Hello.new))

# 1.3
a = result = WrapWithRedP.new(ToUpper.new(Hello.new))
e = proc {|app| WrapWithHtml.new(app, *args, &block)}
result = e[a] = proc {|app| WrapWithHtml.new(app, *args, &block)}.call(a)
       = WrapWithHtml.new(WrapWithRedP.new(ToUpper.new(Hello.new)))

~~~

**Rack::Builder**类其实就是将非常晦涩的代码, 利用`Ruby`元编程能力变成清晰可读的`DSL`, 最终返回了一个最终应用对象.



通过`Rack::Builder#to_app`生成最终应用将被作为参数传给 `Rack::Builder#build_app`中. 此方法根据环境选择合适的中间件继续包裹到这个链式调用中:

~~~ruby
[18] pry(main)> $ Rack::Server#build_app

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 343:
Owner: Rack::Server
Visibility: private
Number of lines: 9

def build_app(app)
  middleware[options[:environment]].reverse_each do |middleware|
    middleware = middleware.call(self) if middleware.respond_to?(:call)
    next unless middleware
    klass, *args = middleware
    # 继续包裹 `Rack`默认的一些中间件
    app = klass.new(app, *args)
  end
  app
end

-------------------------------------------------------------------------

def middleware
  self.class.middleware
end

-------------------------------------------------------------------------
    
def middleware
  default_middleware_by_environment
end

[19] pry(main)> $ Rack::Server.default_middleware_by_environment

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 229:
Owner: #<Class:Rack::Server>
Visibility: public
Number of lines: 19

def default_middleware_by_environment
  m = Hash.new {|h,k| h[k] = []}
  m["deployment"] = [
    [Rack::ContentLength],
    [Rack::Chunked],
    logging_middleware,
    [Rack::TempfileReaper]
  ]
  m["development"] = [
    [Rack::ContentLength],
    [Rack::Chunked],
    logging_middleware,
    [Rack::ShowExceptions],
    [Rack::Lint],
    [Rack::TempfileReaper]
  ]

  m
end
~~~

最终会根据`Rack::Server.default_middleware_by_environment`中包含了不同环境下默认应该使用的中间件, `Rack::Server#build_app`会根据情况加载中间件.



#### 选择 Web Server

在`Rack::Server#start`方法中, 我们通过`Rack::Server#wrapped_app`方法将应用和中间件打包到一起. 然后执行`server.run wrapped_app, options, &blk` 来选择合适的 `Web Server`并启动之. 

~~~ruby
[2] pry(main)> $ Rack::Server#server

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 300:
Owner: Rack::Server
Visibility: public
Number of lines: 12

def server
  @_server ||= Rack::Handler.get(options[:server])
  unless @_server
    @_server = Rack::Handler.default
    # We already speak FastCGI
    @ignore_options = [:File, :Port] if @_server.to_s == 'Rack::Handler::FastCGI'
  end
  @_server
end
~~~

我们在运行`rackup`命令时, 如果传入了 `server`选项, 比如:

~~~shell
$ rackup -server Puma
~~~

就会使用传入的`Web Server`, 否则就选择默认的`Rack::Handler`

~~~ruby
[5] pry(main)> $ Rack::Handler.default

From: **/gems/rack-2.0.3/lib/rack/handler.rb @ line 46:
Owner: #<Class:Rack::Handler>
Visibility: public
Number of lines: 12

def self.default
  # Guess.
  if ENV.include?("PHP_FCGI_CHILDREN")
    Rack::Handler::FastCGI
  elsif ENV.include?(REQUEST_METHOD)
    Rack::Handler::CGI
  elsif ENV.include?("RACK_HANDLER")
    self.get(ENV["RACK_HANDLER"])
  else
    pick ['puma', 'thin', 'webrick']
  end
end
~~~

默认选择最终会调用`pick`方法, 在`pick`方法中通过传入的数据尝试对其进行加载 :

~~~ruby
[6] pry(main)> $ Rack::Handler.pick

From: **/gems/rack-2.0.3/lib/rack/handler.rb @ line 34:
Owner: #<Class:Rack::Handler>
Visibility: public
Number of lines: 11
# server_names = ['puma', 'thin', 'webrick']
def self.pick(server_names)
  server_names = Array(server_names)
  server_names.each do |server_name|
    begin
      return get(server_name.to_s)
    rescue LoadError, NameError
    end
  end

  raise LoadError, "Couldn't find handler for: #{server_names.join(', ')}."
end

def self.get(server)
  return unless server
  server = server.to_s

  unless @handlers.include? server
    load_error = try_require('rack/handler', server)
  end

  if klass = @handlers[server]
    klass.split("::").inject(Object) { |o, x| o.const_get(x) }
  else
    const_get(server, false)
  end

rescue NameError => name_error
  raise load_error || name_error
end
~~~

​	`Rack::Handler.get`方法会通过命名规范从对应的文件目录下加载相应的常量. 一部分常量时预先定义在`handler.rb`文件中, 另外一部分是由各个`Web Server`的开发者自己定义或者遵循一定的命名规范加载的.



#### 终于启动了

当`Rack` 已经使用中间件对应用进行包装并且选择了对应的`WebServer`之后, 我们就可以将包装好的应用作为参数传入`Rack::Handler::WEBrick.run`方法了:

~~~ruby
#这里直接采用最简单的 WEBrick进行分析
[8] pry(main)> $ Rack::Handler::WEBrick

From: /Users/bobo/.rvm/gems/ruby-2.4.2/gems/rack-2.0.3/lib/rack/handler/webrick.rb @ line 24:
Class name: Rack::Handler::WEBrick
Number of lines: 95

class WEBrick < ::WEBrick::HTTPServlet::AbstractServlet
  def self.run(app, options={})
    environment  = ENV['RACK_ENV'] || 'development'
    default_host = environment == 'development' ? 'localhost' : nil

    options[:BindAddress] = options.delete(:Host) || default_host
    options[:Port] ||= 8080
    @server = ::WEBrick::HTTPServer.new(options)
    @server.mount "/", Rack::Handler::WEBrick, app
    yield @server  if block_given?
    @server.start
  end
~~~



所有遵循`Rack协议`的`Web Server`都会实现类似于`WEBrick`的`run`方法, 此方法接收三个参数: 

* app: 包装好的`Rack应用程序`
* options: 参数
* block:  代码块

`run`方法启动一个一个进程来专门处理所有来自用户的`HTTP请求`. 请求到这一步, 就需要每个`Web Server` 自己处理了. 后续的文章我会对常见的`Web Server`分析.





##再论中间件

### Authenticate

### Cookie