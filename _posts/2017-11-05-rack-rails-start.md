---
layout: post
toc: true
permalink: /rack-rails
title: Ruby Rack 协议及其应用(三)
tags: Rack系列  rack  ruby  rails  server
desc:  Rack是Ruby应用服务器和Rack应用程序之间的一个接口,用于两者之间的交互. 不仅仅是大名鼎鼎的Ruby on Rails ,几乎所有的Ruby Web 框架都是一个Rack应用. 除了Web框架之外, Rack同样支持很多Ruby Web服务器. 本篇文章着重讲述 `Ruby on Rails`框架的启动过程.
---

## Ruby on Rails 启动流程

我们从 `rails server` 这个指令开始来解读`Ruby on Rails`的启动流程.


### 源码阅读前的准备

#### Pry Use

#### Ruby File Operation

阅读源码时需要用到文件路径的几个方法, 先在这里总结一下.


1. `__FILE__` 是一个常量, 返回一个带文件后缀的文件名.

2. `File.dirname` 返回当前文件的相对路径
> Returns all components of the filename given in file_name except the last one. The filename can be formed using both File::SEPARATOR and File::ALT_SEPARATOR as the separator when File::ALT_SEPARATOR is not nil.

~~~ruby
File.dirname("/home/gumby/work/ruby.rb")
# => "/home/gumby/work"
~~~

3. `File.expand_path`, 将路径名转换为绝对路径返回.
> Converts a pathname to an absolute pathname. Relative paths are referenced from the current working directory of the process unless dir_string is given, in which case it will be used as the starting point. The given pathname may start with a “~”, which expands to the process owner’s home directory (the environment variable HOME must be set correctly). “~user” expands to the named user’s home directory.

~~~ruby
File.expand_path('.')
# => return current absolute path
~~~


~~~test.rb
puts "__FILE__ is #{__FILE__}"
puts "File.dirname(__FILE__) is #{File.dirname(__FILE__)}"
puts "File.expand_path(File.dirname(__FILE__)) is #{File.expand_path(File.dirname(__FILE__))}"
~~~

输出结果如下:

~~~shell
__FILE__ is hehe.rb
File.dirname(__FILE__) is .
File.expand_path(File.dirname(__FILE__)) is /Users/bobo/Tool/hehe

~~~

### Railtie类 -> Ruby On Rails 内部引擎



### Rails Applciation API Guide

熟悉`Ruby on Rails`的同学可以知道, 我们可以通过`rails console` 或者 `rails server` 命令启动`Rails`应用.

在`Rails API`文档中(5.2.0), 关于`Application`这个类的介绍写到了一个`Rails Application`的启动流程:

~~~ruby
1)  require "config/boot.rb" to setup load paths
2)  require railties and engines
3)  Define Rails.application as "class MyApp::Application < Rails::Application"
4)  Run config.before_configuration callbacks
5)  Load config/environments/ENV.rb
6)  Run config.before_initialize callbacks
7)  Run Railtie#initializer defined by railties, engines and application.
    One by one, each engine sets up its load paths, routes and runs its config/initializers/* files.
8)  Custom Railtie#initializers added by railties, engines and applications are executed
9)  Build the middleware stack and run to_prepare callbacks
10) Run config.before_eager_load and eager_load! if eager_load is true
11) Run config.after_initialize callbacks
~~~

我们就参照上面的启动流程开启`Ruby on Rails`的启动流程解读.



### Server 的启动

我们直接从`rails server`这条命令开始定位`Server.start`

##### railties/exe/rails

在某个Rails项目的命令行中运行如下指令可以定位我们使用的`rails`

~~~shell
where rails
# => /Users/bobo/.rvm/gems/ruby-2.4.2/bin/rails
~~~

`rails server` 命令中的 `rails` 就位于上述的一个`Ruby`可执行文件. 文件内容如下:

~~~ruby
λ cat /Users/bobo/.rvm/gems/ruby-2.4.2/bin/rails
#!/usr/bin/env ruby
#
# This file was generated by RubyGems.
#
# The application 'railties' is installed as part of a gem, and
# this file is here to facilitate running it.
#

require 'rubygems'

version = ">= 0.a"

if ARGV.first
  str = ARGV.first
  str = str.dup.force_encoding("BINARY") if str.respond_to? :force_encoding
  if str =~ /\A_(.*)_\z/ and Gem::Version.correct?($1) then
    version = $1
    ARGV.shift
  end
end

if Gem.respond_to?(:activate_bin_path)
  load Gem.activate_bin_path('railties', 'rails', version)
else
  gem "railties", version
  load Gem.bin_path("railties", "rails", version)
end

~~~

在 `Rails Console`中运行上述代码, 我们可以看到加载的文件如下:

~~~shell
"/Users/bobo/.rvm/gems/ruby-2.4.2/gems/railties-5.1.6/exe/rails"
~~~

让我们来看一下这个文件的内容:
~~~ruby
#!/usr/bin/env ruby

git_path = File.expand_path("../../../.git", __FILE__)
# => /Users/bobo/.rvm/gems/ruby-2.4.2/gems/.git

if File.exist?(git_path)
  railties_path = File.expand_path("../../lib", __FILE__)
  $:.unshift(railties_path)
end

# 关键代码
require "rails/cli"
~~~

关键代码就是最后一行, 加载 `rails/cli` 文件.

~~~ruby
# frozen_string_literal: true

require "rails/app_loader"

# If we are inside a Rails application this method performs an exec and thus
# the rest of this script is not run.
Rails::AppLoader.exec_app

require "rails/ruby_version_check"
Signal.trap("INT") { puts; exit(1) }

require "rails/command"

if ARGV.first == "plugin"
  ARGV.shift
  Rails::Command.invoke :plugin, ARGV
else
  Rails::Command.invoke :application, ARGV
end
~~~

##### railties/lib/rails/app_loader.rb

查看文件 `railties/lib/rails/app_loader.rb`:


~~~ruby

RUBY = Gem.ruby
# "/Users/bobo/.rvm/rubies/ruby-2.4.2/bin/ruby"
EXECUTABLES = ["bin/rails", "script/rails"]

def exec_app
  original_cwd = Dir.pwd

  loop do
    if exe = find_executable
      contents = File.read(exe)

      if contents =~ /(APP|ENGINE)_PATH/
        exec RUBY, exe, *ARGV
        break # non reachable, hack to be able to stub exec in the test suite
      elsif exe.end_with?("bin/rails") && contents.include?("This file was generated by Bundler")
        # 以下情况只有在 bin/rails 中没有 APP_PATH 或者 ENGINE_PATH时才会设置
        $stderr.puts(BUNDLER_WARNING)
        # 设置 APP_PATH 常量
        Object.const_set(:APP_PATH, File.expand_path("config/application", Dir.pwd))
        # 加载 config/root.rb
        require File.expand_path("../boot", APP_PATH)
        # 加载 rails/commands
        require "rails/commands"
        break
      end
    end

    # If we exhaust the search there is no executable, this could be a
    # call to generate a new application, so restore the original cwd.
    Dir.chdir(original_cwd) && return if Pathname.new(Dir.pwd).root?

    # Otherwise keep moving upwards in search of an executable.
    Dir.chdir("..")
  end
end

def find_executable
  EXECUTABLES.find { |exe| File.file?(exe) }
end
~~~

`exec_app`方法的主要作用是执行应用中的`bin/rails`文件.
如果在当前文件夹未找到`bin/rails`文件, 就会继续在上层文件夹中查找, 直到找到为止. 因此, 我们可以在一个`Rails`应用中的任何位置执行`rails 命令`.

执行 `rails server` 实际上就相当于执行 **`exec ruby bin/rails server`**

##### bin/rails 文件

~~~ruby
#!/usr/bin/env ruby
begin
  load File.expand_path('../spring', __FILE__)
rescue LoadError => e
  raise unless e.message.include?('spring')
end

APP_PATH = File.expand_path('../config/application', __dir__)
# => "/Users/bobo/bobo/risewinter/Project/AW/config/application"

require_relative '../config/boot'
# boot 用于加载并设置 Bundler

require 'rails/commands'
# 加载 commands 文件
# 用来响应 rails server 这条指令

~~~




PS: 程序执行到`app_loader.rb`还未加载 `config/application.rb`.



##### rails/commands.rb

`bin/rails`文件中执行 `config/boot.rb`文件的代码之后, 下一步就是要加载`rails/commands`,作用就是扩展命令别名.
我们在命令行中输入`rails server`, ARGV 数组只包含将要传递的`server`命令:

~~~ruby
# frozen_string_literal: true

require "rails/command"

aliases = {
  "g"  => "generate",
  "d"  => "destroy",
  "c"  => "console",
  "s"  => "server",
  "db" => "dbconsole",
  "r"  => "runner",
  "t"  => "test"
}

command = ARGV.shift
command = aliases[command] || command

# rails server 命令执行时, 会调用下面一行代码
# command => server
# ARGV => 命令行参数
Rails::Command.invoke command, ARGV

~~~

##### rails/command.rb

~~~ruby
# namespace = server

# Receives a namespace, arguments and the behavior to invoke the command.
def invoke(full_namespace, args = [], **config)
  namespace = full_namespace = full_namespace.to_s

  if char = namespace =~ /:(\w+)$/
    command_name, namespace = $1, namespace.slice(0, char)
  else
    command_name = namespace
  end

  command_name, namespace = "help", "help" if command_name.blank? || HELP_MAPPINGS.include?(command_name)
  command_name, namespace = "version", "version" if %w( -v --version ).include?(command_name)

  command = find_by_namespace(namespace, command_name)
  if command && command.all_commands[command_name]
    command.perform(command_name, args, config)
  else
    find_by_namespace("rake").perform(full_namespace, args, config)
  end
end
~~~

当我们输入`Rails`命令时, `invoke`尝试查找指定命名空间的命令, 如果找到就执行那个命令.
如果找不到, `Rails`委托`rake`执行同名任务.

我们输入的`rails server`命令, 因此`Rails`会进一步运行下面的代码:

~~~ruby
module Rails
  module Command
    class ServerCommand < Base
      def perform
        set_application_directory!
        prepare_restart

        # 关键点(一)
        Rails::Server.new(server_options).tap do |server|
          # Require application after server sets environment to propagate
          # the --environment option.
          # config/application.rb
          # 关键点(二)
          require APP_PATH
          Dir.chdir(Rails.application.root)

          if server.serveable?
            print_boot_information(server.server, server.served_url)
            after_stop_callback = -> { say "Exiting" unless options[:daemon] }
            # 关键点(三)
            server.start(after_stop_callback) # 启动服务器
          else
            say rack_server_suggestion(using)
          end
        end
      end

    end
  end
end
~~~



上述三个关键点分别对应三个重要环节:

* 初始化 `server`
* 加载 `APP_PATH`
* 启动 `server`



#### 初始化 server

##### rails/commands/server/server_command.rb

此文件中定义了`Rails::Server`类, 它继承自`Rack::Server`类.
当调用`Rails::Server.new`方法时, 会调用此文件中定义的`initialize`方法.

~~~ruby
def initialize
  super
  set_enviroment
end
~~~

`super`关键字会调用`Rack::Server`类的`initialize`方法.



##### Rack: lib/rack/server.rb

又回到了我们之前讲述过的`Rack`了.`Rack::Server`类负责所有基于`Rack`的应用(包括Rails)提供通用服务器接口.
`Rack::Server`类的`initialize`方法作用主要是设置几个变量.

当`super`方法完成`Rack::Server`类的`initialize`方法的调用时, 程序执行流程会重新回到`rails/commands/server/server_command.rb`文件中,
继续调用`set_enviroment`方法. 此方法主要用来配置一些基本的参数, 暂且不表.

`initialize`方法运行完成之后, 程序执行流程就会跳回`server`命令, 加载之前设置的 `APP_PATH`.



#### 加载 `APP_PATH`

#### config/application.rb

执行`require APP_PATH`时, 会加载`config/application.rb`文件.

在`require APP_PATH`时, 实际上对应API文档中的流程 1--4.

~~~ruby
1) require "config/boot.rb" to setup load paths
2) require railties and engines
3) Define Rails.application as "class MyApp::Application < Rails::Application"
4) Run config.before_configuration callbacks
~~~





~~~ruby
# config/application.rb
require_relative 'boot'

require 'rails/all'

# Require the gems listed in Gemfile, including any gems
# you've limited to :test, :development, or :production.
Bundler.require(*Rails.groups)

ENV.update YAML.load_file('config/application.yml')[Rails.env] rescue {}

module MyApp
  class Application < Rails::Application
    config.load_defaults 5.1
	config.time_zone = 'Beijing'
  end

end
~~~

###### 加载 boot

~~~ruby
# config/boot.rb
ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../Gemfile', __dir__)
# 设置 环境变量: BUNDLE_GEMFILE

require 'bundler/setup' # Set up gems listed in the Gemfile.
~~~

标准的Rails应用中包含`Gemfile`文件, 用于声明应用的所有依赖关系. `config/boot.rb`文件会把`ENV['BUNDLE_GEMFILE']`设置为`Gemfile`文件的路径.



##### 加载 railties and engines

这个其实是在`boot.rb`中进行的 `bunlder/setup`.`Bundler`通过它设置`Gemfile`中依赖关系的加载路径.

就相当于把`Gemfile`中使用的一些`gem`(这些Gem包含各种Engine或者Railtie)都加载到`load_path`中



##### Define Rails.application as `class MyApp::Application < Rails::Application`

在`config/application.rb`文件中, 我们在`MyApp`中定义了一个类继承`Rails::Application`

~~~ruby
module MyApp
  class Application < Rails::Application
    config.load_defaults 5.1
	config.time_zone = 'Beijing'
  end

end
~~~



当`Rails::Application`被继承时, 会执行下面的一个`callback`:

~~~ruby
module Rails
  class Application < Engine
    class << self
      #当 Rails::Application被继承时, 会调用这个 callback
      def inherited(base)
        super # Engine
        Rails.app_class = base
        add_lib_to_load_path!(find_root(base.called_from))
        ActiveSupport.run_load_hooks(:before_configuration, base)
      end

    end
  end
end
~~~

* 设置 Rails.application -> MyApp::Application
* 加载 lib 目录到 load_path
* 执行 `config.before_configuration callbacks`



#### server 启动

`server`的启动其实是根据参数来选择一个符合`rack`规范的具体的`server`, 比如`thin` `webrick`.

`config/application.rb`文件加载完毕之后, 就会调用`server.start`方法.

~~~ruby

def start
  print_boot_information # 打印启动信息
  trap(:INT) { exit }
  create_tmp_directories # 创建 tmp 目录
  setup_dev_caching
  log_to_stdout if options[:log_stdout] #是否打印 log 到标准输出

  super # Rack::Server.start
  ...
end

private
  def print_boot_information
    ...
    puts "=> Run `rails server -h` for more startup options"
  end

  def create_tmp_directories
    %w(cache pids sockets).each do |dir_to_make|
      FileUtils.mkdir_p(File.join(Rails.root, 'tmp', dir_to_make))
    end
  end

  def setup_dev_caching
    if options[:environment] == "development"
      Rails::DevCaching.enable_by_argument(options[:caching])
    end
  end

  def log_to_stdout
    wrapped_app # 对应用执行 touch 操作，以便设置记录器

    console = ActiveSupport::Logger.new(STDOUT)
    console.formatter = Rails.logger.formatter
    console.level = Rails.logger.level

    unless ActiveSupport::Logger.logger_outputs_to?(Rails.logger, STDOUT)
    Rails.logger.extend(ActiveSupport::Logger.broadcast(console))
  end
~~~

这是`Rails`初始化过程中第一次输出信息. `start`方法为`INT`信号创建了一个陷阱, 只要在服务器运行时按下`CTRL+C`, 服务器进程就会退出.
上述代码还会创建`tmp/cache` `tmp/pids` `tmp/sockets`文件夹, 用于存放 `socket`.

最后调用`wrapped_app`方法, 作用就是先创建一个`Rack应用`, 然后创建`ActiveSupport::Logger`实例.

在`Rack应用(二)` 中我们曾研究过`wrapped_app`以及`server.start`方法:

~~~ruby
# rack/lib/rack/server.rb
def start &blk

  # 关键点(一)
  wrapped_app

  # 关键点(二)
  server.run wrapped_app, options, &blk
end

def wrapped_app
  @wrapped_app ||= build_app app
end
~~~

* wrapped_app: 构建一个完成的 app.
  * 其中 `app`就是执行 `config.ru`文件, 最终得到一个应用APP
  * build_ap 作用就是在得到的app的上层包装上`server`的`middleware`
* server.run: 最终启动 server

 在执行`config.ru`文件的过程中, 又涉及到了`rails`启动过程中的步骤 5 - 11.



~~~ruby
# config.ru
# This file is used by Rack-based servers to start the application.

require_relative 'config/environment'

run Rails.application

~~~

`Rails`初始化过程中的大部分工作都是在这一步中完成.
** `rails server` 指令可以使用 `rackup config.ru` 代替 **

在 `config.ru`文件中, 加载 `config/environment.rb`文件中的第一行代码先被执行:

~~~ruby
require_relative 'config/environment'
~~~

##### config/environment.rb

`config.ru`文件和 `passenger`都需要加载此文件.这两种运行服务器的方式到此才有了交集, 此前的一切工作都是围绕`Rack`以及`Rails`配置进行的.
此文件首先加载`config/application.rb`文件:
~~~ruby
# Load the Rails application.
require_relative 'application'

# Initialize the Rails application.
Rails.application.initialize!

~~~

#### config/application.rb

此文件会加载`config/boot.rb`文件:

~~~ruby
ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../Gemfile', __dir__)

require 'bundler/setup' # Set up gems listed in the Gemfile.
~~~

对于`rails server`这种启动方式, 之前并为加载`config/boot.rb`文件, 因此这里会加载该文件; 像`passenger`之前已经加载过该文件, 这里就不会重复加载了.



### 加载 Rails

`config/application.rb`文件的下一行就是:
~~~ruby
require 'rails/all'
~~~

我们可以查看`rails/all`的源码:

~~~ruby

require "rails"

%w(
  active_record/railtie
  action_controller/railtie
  action_view/railtie
  action_mailer/railtie
  active_job/railtie
  action_cable/engine
  rails/test_unit/railtie
  sprockets/railtie
).each do |railtie|
  begin
    require railtie
  rescue LoadError
  end
end
~~~

此文件负责加载`Rails`中所有独立的框架.
这些框架加载完成之后, 就可以在`Rails`应用中使用了.

##### 回到 config/environment.rb 文件

config/application.rb 文件的其余部分定义了 Rails::Application 的配置，当应用的初始化全部完成后就会使用这些配置。当 config/application.rb 文件完成了 Rails 的加载和应用命名空间的定义后，程序执行流程再次回到 config/environment.rb 文件。在这里会通过 rails/application.rb 文件中定义的 Rails.application.initialize! 方法完成应用的初始化。

##### railties/lib/rails/application.rb

~~~ruby
# rails/railties/lib/rails/application.rb
def initialize!(group=:default) #:nodoc:
  raise "Application has been already initialized." if @initialized
  run_initializers(group, self) # 执行所有的注册的 initializers
  @initialized = true
  self
end
~~~
我们可以看到一个应用只能被初始化一次. `railties/lib/rails/initializable.rb`文件中定义的`run_initializers`方法负责运行初始化程序:

~~~ruby
# rails/railties/lib/rails/initializable.rb
def run_initializers(group=:default, *args)
  return if instance_variable_defined?(:@ran)
  # initializers 在 rails/application.rb文件中被覆写
  initializers.tsort_each do |initializer|
    initializer.run(*args) if initializer.belongs_to?(group)
  end
  @ran = true
end

# rails/railties/lib/rails/application.rb
def initializers #:nodoc:
  Bootstrap.initializers_for(self) +
  railties_initializers(super) +
  Finisher.initializers_for(self)
end

~~~

run_initializers 方法的代码比较复杂，Rails 会遍历所有类的祖先，以查找能够响应 initializers 方法的类。对于找到的类，首先按名称排序，然后依次调用 initializers 方法。例如，Engine 类通过为所有的引擎提供 initializers 方法而使它们可用。

在Rails中的`initializer`分为以下三类:

* Bootstrap 的 initializer
* Application, Engine, Railtie 注册的 initializer
* Finisher的 initializer

railties/lib/rails/application.rb 文件中定义的 Rails::Application 类，定义了 bootstrap、railtie 和 finisher 初始化程序。bootstrap 初始化程序负责完成应用初始化的准备工作（例如初始化记录器），而 finisher 初始化程序（例如创建中间件栈）总是最后运行。railtie 初始化程序在 Rails::Application 类自身中定义，在 bootstrap 之后、finishers 之前运行。

启动流程中的步骤 5 -- 11 都是一些特定的initializer来执行.



##### 步骤5: Load config/enviroments/ENV.rb

~~~ruby
# rails/railties/lib/rails/engine.rb
# 这个就是启动流程中的 5) Load config/environments/ENV.rb, 特别注意这里用了before
initializer :load_environment_config, before: :load_environment_hook, group: :all do
  paths["config/environments"].existent.each do |environment|
    require environment
  end
end
~~~



##### 步骤6: Run config.before_initialize callbacks



~~~ruby
# rails/railties/lib/rails/application/bootstrap.rb
initializer :bootstrap_hook, group: :all do |app|
  ActiveSupport.run_load_hooks(:before_initialize, app)
end
~~~



##### Rails应用config目录下的initializers执行的源码位置:

~~~ruby
# rails/railties/lib/rails/engine.rb
# 这里就是config目录下的initializers执行的位置
initializer :load_config_initializers do
  config.paths["config/initializers"].existent.sort.each do |initializer|
    load_config_initializer(initializer)
  end
end
~~~



##### 步骤9: Build the middleware stack and run to_prepare callbacks
build_middleware_stack，该方法alias到app方法，这个方法是个重要的方法，这里就是把所有middleware都一层一层嵌套然后得到最终的app。

~~~ruby
# rails/railties/lib/rails/application/finisher.rb
initializer :build_middleware_stack do
  build_middleware_stack
end
~~~

This needs to happen before eager load so it happens

in exactly the same point regardless of config.cache_classes

#####  9) run to_prepare callbacks

initializer :run_prepare_callbacks do
  ActionDispatch::Reloader.prepare!
end

##### 步骤10: Run config.before_eager_load and eager_load! if eager_load is true

~~~ruby
# rails/railties/lib/rails/application/finisher.rb
initializer :eager_load! do
  if config.eager_load
    ActiveSupport.run_load_hooks(:before_eager_load, self)
    config.eager_load_namespaces.each(&:eager_load!)
  end
end
~~~

##### 步骤11: Run config.after_initialize callbacks

~~~ruby
# rails/railties/lib/rails/application/finisher.rb
# All initialization is done, including eager loading in production
initializer :finisher_hook do
  ActiveSupport.run_load_hooks(:after_initialize, self)
end

~~~
应用初始化完成后，程序执行流程再次回到 Rack::Server 类。

#### Rack: lib/rack/server.rb

程序执行流程上一次离开此文件是定义`app`方法时:
~~~ruby
def app
  @app ||= options[:builder] ? build_app_from_string : build_app_and_options_from_config
end
...
private
def build_app_and_options_from_config
  if !::File.exist? options[:config]
    abort "configuration #{options[:config]} not found"
  end

  app, options = Rack::Builder.parse_file(self.options[:config], opt_parser)
  self.options.merge! options
  app
end

def build_app_from_string
  Rack::Builder.new_from_string(self.options[:builder])
end
~~~

此时，app 就是 Rails 应用本身（一个中间件），接下来 Rack 会调用所有已提供的中间件：
~~~ruby

def build_app(app)
  middleware[options[:environment]].reverse_each do |middleware|
    middleware = middleware.call(self) if middleware.respond_to?(:call)
    next unless middleware
    klass = middleware.shift
    app = klass.new(app, *middleware)
  end
  app
end
~~~

在 Server#start 方法定义的最后一行代码中，通过 wrapped_app 方法调用了 build_app 方法。让我们回顾一下这行代码：
~~~ruby

server.run wrapped_app, options, &blk

~~~

server.run 方法的实现方式取决于我们所使用的服务器。例如，如果使用的是 Puma，run 方法的实现方式如下：
~~~ruby
...
DEFAULT_OPTIONS = {
  :Host => '0.0.0.0',
  :Port => 8080,
  :Threads => '0:16',
  :Verbose => false
}

def self.run(app, options = {})
  options = DEFAULT_OPTIONS.merge(options)

  if options[:Verbose]
    app = Rack::CommonLogger.new(app, STDOUT)
  end

  if options[:environment]
    ENV['RACK_ENV'] = options[:environment].to_s
  end

  server   = ::Puma::Server.new(app)
  min, max = options[:Threads].split(':', 2)

  puts "Puma #{::Puma::Const::PUMA_VERSION} starting..."
  puts "* Min threads: #{min}, max threads: #{max}"
  puts "* Environment: #{ENV['RACK_ENV']}"
  puts "* Listening on tcp://#{options[:Host]}:#{options[:Port]}"

  server.add_tcp_listener options[:Host], options[:Port]
  server.min_threads = min
  server.max_threads = max
  yield server if block_given?

  begin
    server.run.join
  rescue Interrupt
    puts "* Gracefully stopping, waiting for requests to finish"
    server.stop(true)
    puts "* Goodbye!"
  end

end
~~~

上面就是 Rails 初始化过程的最后一步了。
