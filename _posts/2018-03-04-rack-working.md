---
layout: post
toc: true
permalink: /rack-working
title: Ruby Rack 协议及其应用(二)
tags: Rack系列  rack  ruby  rails  server
desc:  Rack是Ruby应用服务器和Rack应用程序之间的一个接口,用于两者之间的交互. 不仅仅是大名鼎鼎的Ruby on Rails ,几乎所有的Ruby Web 框架都是一个Rack应用. 除了Web框架之外, Rack同样支持很多Ruby Web服务器. 本系列文章就深入探讨Rack协议的原理以及实现.
---

## Rack实现分析

### 创建应用程序

要分析`Rack`的源码, 我们首先创建一个简单的`Rack应用程序`

~~~ruby
#config.ru
# 将 body 标签的内容转换为全大写.
class ToUpper
  def initialize(app)
    @app = app
  end
  def call(env)
    status, head, body = @app.call(env)
    upcased_body = body.map{|chunk| chunk.upcase }
    [status, head, upcased_body]
  end
end
# 将 body 内容置于标签, 设置字体颜色为红色, 并指明返回的内容为 text/html.
class WrapWithRedP
  def initialize(app)
    @app = app
  end
  def call(env)
    status, head, body = @app.call(env)
    red_body = body.map{|chunk| "<p style='color:red;'>#{chunk}</p>" }
    head['Content-type'] = 'text/html'
    [status, head, red_body]
  end
end

# 将 body 内容放置到 HTML 文档中.
class WrapWithHtml
  def initialize(app)
    @app = app
  end

  def call(env)
    status, head, body = @app.call(env)
    wrap_html = <<-EOF
       <!DOCTYPE html>
       <html>
         <head>
         <title>hello</title>
         <body>
         #{body[0]}
         </body>
       </html>
    EOF
    [status, head, [wrap_html]]
  end
end

# 起始点, 只返回一行字符的 rack app.
class Hello
  def initialize
    super
  end
  def call(env)
    [200, {'Content-Type' => 'text/plain'}, ["hello, this is a test."]]
  end
end
use WrapWithHtml
use WrapWithRedP
use ToUpper
run Hello.new
~~~



### rackup 命令

在 `terminal`下输入命令 `rackup`, 就会启动一个`Web服务`

~~~shell
$ rackup

Puma starting in single mode...
* Version 3.11.2 (ruby 2.4.2-p198), codename: Love Song
* Min threads: 0, max threads: 16
* Environment: development
* Listening on tcp://localhost:9292
Use Ctrl-C to stop
~~~

`rackup` 来自于哪里? 如何加载`config.ru`文件并生成项目?



首先我们可以通过 `where`命令来查找当前`rackup`指令的执行路径并打印文件代码:

~~~ruby
$ where rackup
/Users/bobo/.rvm/gems/ruby-2.4.2/bin/rackup

$ cat /Users/bobo/.rvm/gems/ruby-2.4.2/bin/rackup
#!/usr/bin/env ruby
#
# This file was generated by RubyGems.
#
# The application 'rack' is installed as part of a gem, and
# this file is here to facilitate running it.
#

require 'rubygems'

version = ">= 0.a"

if ARGV.first
  str = ARGV.first
  str = str.dup.force_encoding("BINARY") if str.respond_to? :force_encoding
  if str =~ /\A_(.*)_\z/ and Gem::Version.correct?($1) then
    version = $1
    ARGV.shift
  end
end

if Gem.respond_to?(:activate_bin_path)
  load Gem.activate_bin_path('rack', 'rackup', version)
else
  gem "rack", version
  load Gem.bin_path("rack", "rackup", version)
end
~~~

从 `rackup`文件中我们可以看出当前文件是由`RubyGems`自动生成, 在文件最后通过`load`方法加载对应文件中的代码, 从而启动服务. 我们可以在 `pry`中找到要加载的文件及其代码.

~~~shell
λ gem list "^rack$"

*** LOCAL GEMS ***

rack (2.0.3, 2.0.1, 1.6.8)

λ pry
[1] pry(main)> Gem.activate_bin_path('rack', 'rackup', '2.0.3')
=> "/Users/bobo/.rvm/gems/ruby-2.4.2/gems/rack-2.0.3/bin/rackup"
[2] pry(main)> exit

λ cat /Users/bobo/.rvm/gems/ruby-2.4.2/gems/rack-2.0.3/bin/rackup
#!/usr/bin/env ruby

require "rack"
Rack::Server.start

~~~



> `rackup`命令定义在 `rack`工程的 `bin/rackup`文件中. 通过 `rubygems`安装后会生成另外一个加载该文件的可执行文件.

最后我们找到了加载的文件. `.activate_bin_path`方法会查找对应的`gem`当前生效的版本, 并返回文件的路径. 在这个可执行文件中, 只是简单的两行代码

~~~ruby
#!/usr/bin/env ruby

require 'rack'

# 启动一个Web Server
Rack::Server.start
~~~



### 启动 Web Server

从这里开始, 我们就已经从`	rakcup`命令的执行进入了`rack` 的源码.  当前`Rack::Server`类初始化一个新的实例后, 在新对象上执行了`#start`方法.

~~~ruby
[1] pry(main)> require 'rack'
=> true
[2] pry(main)> $ Rack::Server.start

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 147:
Owner: #<Class:Rack::Server>
Visibility: public
Number of lines: 3

def self.start(options = nil)
  new(options).start
end
~~~



#### 初始化和配置

在`Rack::Server`启动过程中初始化一个新的对象, 初始化的过程就包含了整个服务器的配置过程:

~~~ruby
[3] pry(main)> $ Rack::Server#initialize

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 185:
Owner: Rack::Server
Visibility: private
Number of lines: 13

def initialize(options = nil)
  @ignore_options = []

  # 直接运行`rackup`时没有传入任何参数, 因此代码跳转到 `else`部分
  if options
    @use_default_options = false
    @options = options
    @app = options[:app] if options[:app]
  else
    argv = defined?(SPEC_ARGV) ? SPEC_ARGV : ARGV
    @use_default_options = true
    @options = parse_options(argv)
  end
end
~~~

解析参数部分:

~~~ruby
[4] pry(main)> $ Rack::Server#parse_options

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 328:
Owner: Rack::Server
Visibility: private
Number of lines: 10

#传入的参数 args == [], 因此`opt_parser.parse!(args)`直接返回 {}
def parse_options(args)
  # Don't evaluate CGI ISINDEX parameters.
  # http://www.meb.uni-bonn.de/docs/cgi/cl.html
  args.clear if ENV.include?(REQUEST_METHOD)

  # @options = {}
  @options = opt_parser.parse!(args)
  
  # `options`为 `Rack::Server`类中定义的一个实例方法
  # `@options[:config] = 'config.ru'
  @options[:config] = ::File.expand_path(options[:config])
  ENV["RACK_ENV"] = options[:environment]
  @options
end

-------------------------------------------------------------------------
[5] pry(main)> $ Rack::Server#opt_parser

From: /Users/bobo/.rvm/gems/ruby-2.4.2/gems/rack-2.0.3/lib/rack/server.rb @ line 339:
Owner: Rack::Server
Visibility: private
Number of lines: 3

def opt_parser
  Options.new
end

-------------------------------------------------------------------------
[6] pry(main)> $ Rack::Server::Options#parse!

From: /Users/bobo/.rvm/gems/ruby-2.4.2/gems/rack-2.0.3/lib/rack/server.rb @ line 10:
Owner: Rack::Server::Options
Visibility: public
Number of lines: 96

def parse!(args)
  options = {}
  opt_parser = OptionParser.new("", 24, '  ') do |opts|
  opts.banner = "Usage: rackup [ruby options] [rack options] [rackup config]"

  opts.separator ""
  opts.separator "Ruby options:"
  # ...
  options[:config] = args.last if args.last && !args.last.empty?
  options
end
  
-------------------------------------------------------------------------
[7] pry(main)> $ Rack::Server#options

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 199:
Owner: Rack::Server
Visibility: public
Number of lines: 4

# 由于我们运行`rackup`指令时没有传入任何参数, 因此 `@use_default_options = true`.
#`options`中方法中继续调用`default_options`
def options
  merged_options = @use_default_options ? default_options.merge(@options) : @options
  merged_options.reject { |k, v| @ignore_options.include?(k) }
end
 
-------------------------------------------------------------------------    
[8] pry(main)> $ Rack::Server#default_options

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 204:
Owner: Rack::Server
Visibility: public
Number of lines: 13

# `default_options`会处理对象本身定义的一些参数, 比如默认的端口号、默认的`config`文件
# `config`文件就是`rackup`接收的一个文件参数, 文件中的内容就是用来配置`Rack`服务器的代码.
# 默认情况下名为`config.ru`, 也就是我们在前面写好的那个配置文件
def default_options
  environment  = ENV['RACK_ENV'] || 'development'
  default_host = environment == 'development' ? 'localhost' : '0.0.0.0'

  {
    :environment => environment,
    :pid         => nil,
    :Port        => 9292,
    :Host        => default_host,
    :AccessLog   => [],
    :config      => "config.ru"
  }
end
  
~~~

#### 包装应用

当我们执行了 `initialize`方法初始化了一个新的实例后, 接下来就会进入`#start`实例方法启动一个 	`WebServer`来处理`config.ru`中定义的应用了:

~~~ruby
[9] pry(main)> $ Rack::Server#start

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 258:
Owner: Rack::Server
Visibility: public
Number of lines: 41

def start &blk
  # 删除了多余不重要的代码
    
  # Touch the wrapped app, so that the config.ru is loaded before
  # daemonization (i.e. before chdir, etc).
  # 通过注释我们可以知晓 `wrapped_app`方法是在启动守护进程之前就加载了 `config.ru`配置文件来创建好最终的应用程序
  wrapped_app

  server.run wrapped_app, options, &blk
end

-------------------------------------------------------------------------
# 首先查看 `Rack::Server#server`中传入的参数
[10] pry(main)> $ Rack::Server#wrapped_app

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 353:
Owner: Rack::Server
Visibility: private
Number of lines: 3

# 继续调用 `build_app`方法 以及 `app`方法
def wrapped_app
  @wrapped_app ||= build_app app
end


~~~



`wrapped_app`方法实际上需要继续调用两个方法: `build_app` 、 `app`.

`Rack::Server#app`方法调用栈比较复杂:



![Rack::Server#app]()



~~~ruby
[11] pry(main)> $ Rack::Server#app

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 218:
Owner: Rack::Server
Visibility: public
Number of lines: 3

def app
  # 由于我们使用的是默认参数, 因此 `options[:builder]`为nil
  # 继续调用 `build_app_and_options_from_config`
  @app ||= options[:builder] ? build_app_from_string : build_app_and_options_from_config
end

-------------------------------------------------------------------------
[12] pry(main)> $ Rack::Server#build_app_and_options_from_config

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 314:
Owner: Rack::Server
Visibility: private
Number of lines: 9

def build_app_and_options_from_config
  if !::File.exist? options[:config]
    abort "configuration #{options[:config]} not found"
  end

  # `parse_file`传入我们的配置文件 `config.ru`
  app, options = Rack::Builder.parse_file(self.options[:config], opt_parser)
  @options.merge!(options) { |key, old, new| old }
  app
end

-------------------------------------------------------------------------
[13] pry(main)> $ Rack::Builder.parse_file

From: **/gems/rack-2.0.3/lib/rack/builder.rb @ line 32:
Owner: #<Class:Rack::Builder>
Visibility: public
Number of lines: 15

def self.parse_file(config, opts = Server::Options.new)
  options = {}
  if config =~ /\.ru$/
    cfgfile = ::File.read(config)
    if cfgfile[/^#\\(.*)/] && opts
      options = opts.parse! $1.split(/\s+/)
    end
    cfgfile.sub!(/^__END__\n.*\Z/m, '')
    # 最终我们的程序去调用 `new_from_string`, 参数为 `File.read("config.ru")`
    app = new_from_string cfgfile, config
  else
    require config
    app = Object.const_get(::File.basename(config, '.rb').split('_').map(&:capitalize).join(''))
  end
  return app, options
end

-------------------------------------------------------------------------
[14] pry(main)> $ Rack::Builder.new_from_string

From: **/gems/rack-2.0.3/lib/rack/builder.rb @ line 48:
Owner: #<Class:Rack::Builder>
Visibility: public
Number of lines: 4

def self.new_from_string(builder_script, file="(rackup)")
  eval "Rack::Builder.new {\n" + builder_script + "\n}.to_app",
    TOPLEVEL_BINDING, file, 0
end
~~~

通过`Ruby`元编程中常用的 `eval`方法, 将配置文件`config.ru`的全部内容和两端的字符串拼接起来, 相当于执行下列代码:

~~~ruby
Rack::Builder.new {
  use WrapWithHtml
  use WrapWithRedP
  use ToUpper
  run Hello.new
}.to_app
~~~

是不是是曾相识? 我们在`Rack协议及其应用(一)`中就手动实现过`Rack::Builder`类. 上述代码就是存储了所有的中间件以及原始的`Rack应用程序`, 最后通过`#to_app`方法返回了一个`Rack`应用. 稍后我们会分析`Rack::Builder`的源码

在这之后会使用`Rack::Builder#build_app`方法将所有的中间件都包括在`Rack`应用周围.所有的中间件都是一个遵循协议的`App`, 只不过中间件和`App`的唯一区别就是中间件会调用初始化时传入的`Rack App`.

~~~ruby
[15] pry(main)> $ Rack::Server#build_app

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 343:
Owner: Rack::Server
Visibility: private
Number of lines: 9

def build_app(app)
  middleware[options[:environment]].reverse_each do |middleware|
    middleware = middleware.call(self) if middleware.respond_to?(:call)
    next unless middleware
    klass, *args = middleware
    app = klass.new(app, *args)
  end
  app
end
~~~

经过上述方法, 我们在一个`Rack` 应用周围一层一层包装上了所有的中间件, 最后调用的中间件在整个调用栈的最外层, 当包装后的应用接收来自外部的请求时, 会按照如下方式运行:

![WRAPPED APP]()



请求进来 -> 从最外层的中间件进入, 每个中间件都会处理`request`, 在`#call`方法内部调用另外一个中间件或者应用. 当`request`进入到最初的`Rack应用程序`后, 程序返回`response`, 在经过一层一层的中间件处理, 最后返回 `HTTP响应`



#### 中间件的实现分析

在`Rack`中, 中间件是由两部分代码共同处理的:

* Rack::Builder: 包含能够在`config.ru`文件中能够使用的`DSL`方法. 
* Rack::Server: 启动 `Web Server`



当我们使用`eval`执行`config.ru`文件中的代码时, 会先初始化一个`Builder`实例, 然后执行`instance_eval`运行代码中的所有内容:

~~~ruby
[16] pry(main)> $ Rack::Builder#initialize

From: **/gems/rack-2.0.3/lib/rack/builder.rb @ line 53:
Owner: Rack::Builder
Visibility: private
Number of lines: 4

def initialize(default_app = nil, &block)
  @use, @map, @run, @warmup = [], nil, default_app, nil
  instance_eval(&block) if block_given?
end
~~~

通过调用`instance_eval `, `config.ru`文件中的代码会在当前实例环境下运行, 文件中的`#use`和`#run`方法在调用时就会执行`Rack::Builder`的实例方法:

~~~ruby
[17] pry(main)> $ Rack::Builder#use

From: **/gems/rack-2.0.3/lib/rack/builder.rb @ line 81:
Owner: Rack::Builder
Visibility: public
Number of lines: 7

def use(middleware, *args, &block)
  if @map
    mapping, @map = @map, nil
    @use << proc { |app| generate_map app, mapping }
  end
  @use << proc { |app| middleware.new(app, *args, &block) }
end
      
def run(app)
  @run = app
end
      
def to_app
  app = @map ? generate_map(@run, @map) : @run
  fail "missing run or map statement" unless app
  app = @use.reverse.inject(app) { |a,e| e[a] }
  @warmup.call(app) if @warmup
  app
end
      
~~~

`Rack::Builder#use`方法会将传入的参数组合成一个接收`app`作为参数的`Proc`对象, 然后加入到`@use`数组中存储起来.  



`Rack::Builder#run`方法是存储最原始的`Rack应用程序`, 将其保存到`@run`实例变量中.



最后如果我们想要获取当前的`Rack::Builder`生成的应用, 只需要调用`Rack::Builder#to_app`方法.值得一提的是`to_app`代码实现中使用了一个技巧, 可以使用`[]`来调用 `proc/lambda`.

~~~ruby
# `app = @use.reverse.inject(app) { |a,e| e[a] }`等价于下列代码
app = @run
@use.reverse.each do |middleware|
  app = middleware.new(app)
end
app

e = proc {|app| puts "call: arguments is #{app}"}
a = 'app'
e[a]
# call: arguments is app
~~~



关于`inject`:

> Combines all elements of enum by applying a binary operation, specified by a block or a symbol that names a method or operator. If you specify a block, then for each element in enum the block is passed an accumulator value (memo) and the element. If you specify a symbol instead, then each element in the collection will be passed to the named method of memo. In either case, the result becomes the new value for memo. At the end of the iteration, the final value of memo is the return value for the method. If you do not explicitly specify an initial value for memo, then the first element of collection is used as the initial value of memo.

关于 `block`:

> prc[params,...] Invokes the block, setting the block’s parameters to the values in params using something close to method calling semantics. Generates a warning if multiple values are passed to a proc that expects just one (previously this silently converted the parameters to an array). Note that prc.() invokes prc.call() with the parameters given. It’s a syntax sugar to hide “call”.



`@use.reverse.inject(app) { |a,e| e[a] }`运行过程中, 前一轮的`e[a]`被存储到内存中, 并加载了下一轮的`a`变量中, 因为 `e`和`a`都是`proc`, 所以` e[a]`本质上是调用这个代码块. 在这个过程中, 最原始的那个`Rack应用程序`会被放在最底层, 而`middleware`会一层一层地套在上面.生成的实例类似于下面的表示:

~~~ruby
use WrapWithHtml
use WrapWithRedP
use ToUpper
run Hello.new

# WrapWithHtml.new(WrapWithRedP.new(ToUpper.new(Hello.new)))
@use = [WrapWithHtml.new, WrapWithRedP, ToUpper.new]
@run = Hello.new
app = @use.reverse.inject(app) { |a,e| e[a] }

# `inject` 中, `e`相当于数组的依次传入的值, `a`相当于每一次迭代返回的值
# `inject`传入的参数 `app`赋给 `a`
# 1.1
a = app = @run = Hello.new
e =  proc { |app| ToUpper.new(app, *args, &block) }
result1 = e[a] = proc { |app| ToUpper.new(app, *args, &block) }.call(a)
       = ToUpper.new(Hello.new, *args, &block)
       = ToUpper.new(Hello.new)

# 1.2
a = result = ToUpper.new(Hello.new)
e = proc {|app| WrapWithRedP.new(app, *args, &block)}
result2 = e[a] = proc {|app| WrapWithRedP.new(app, *args, &block)}.call(a)
       = WrapWithRedP.new(ToUpper.new(Hello.new))

# 1.3
a = result = WrapWithRedP.new(ToUpper.new(Hello.new))
e = proc {|app| WrapWithHtml.new(app, *args, &block)}
result3 = e[a] = proc {|app| WrapWithHtml.new(app, *args, &block)}.call(a)
       = WrapWithHtml.new(WrapWithRedP.new(ToUpper.new(Hello.new)))

~~~

**Rack::Builder**类其实就是将非常晦涩的代码, 利用`Ruby`元编程能力变成清晰可读的`DSL`, 最终返回了一个最终应用对象.



当一个请求到来时, 我们的Web Server`就会`call`我们的`Rack应用,传入环境变量`env`作为参数.

`env`变量首先进入最外层的中间件处理, 通过处理之后传入下一层的中间件, 如此层层递进, 最终进入我们的`原始应用程序`. 

原始应用程序接收传入的`env`, 然后根据内部逻辑处理之后, 返回一个三元数组

~~~ruby
[status, header, [body]]
~~~

此三元数组继续传递给倒数第一个中间件, 经过其处理之后,再将处理过后的中间件传递给上一层.经过层层传递, 我们的三元数组经过最外层的中间件处理之后就返回 `response`给我们的`Web Server`.

`Web Server`将我们应用框架返回的`response`包装成`HTTP响应`, 发给客户端.





通过`Rack::Builder#to_app`生成最终应用将被作为参数传给 `Rack::Builder#build_app`中. 此方法根据环境选择合适的中间件继续包裹到这个链式调用中:

~~~ruby
[18] pry(main)> $ Rack::Server#build_app

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 343:
Owner: Rack::Server
Visibility: private
Number of lines: 9

def build_app(app)
  middleware[options[:environment]].reverse_each do |middleware|
    middleware = middleware.call(self) if middleware.respond_to?(:call)
    next unless middleware
    klass, *args = middleware
    # 继续包裹 `Rack`默认的一些中间件
    app = klass.new(app, *args)
  end
  app
end

-------------------------------------------------------------------------

def middleware
  self.class.middleware
end

-------------------------------------------------------------------------
    
def middleware
  default_middleware_by_environment
end

[19] pry(main)> $ Rack::Server.default_middleware_by_environment

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 229:
Owner: #<Class:Rack::Server>
Visibility: public
Number of lines: 19

def default_middleware_by_environment
  m = Hash.new {|h,k| h[k] = []}
  m["deployment"] = [
    [Rack::ContentLength],
    [Rack::Chunked],
    logging_middleware,
    [Rack::TempfileReaper]
  ]
  m["development"] = [
    [Rack::ContentLength],
    [Rack::Chunked],
    logging_middleware,
    [Rack::ShowExceptions],
    [Rack::Lint],
    [Rack::TempfileReaper]
  ]

  m
end
~~~

最终会根据`Rack::Server.default_middleware_by_environment`中包含了不同环境下默认应该使用的中间件, `Rack::Server#build_app`会根据情况加载中间件.



#### 选择 Web Server

在`Rack::Server#start`方法中, 我们通过`Rack::Server#wrapped_app`方法将应用和中间件打包到一起. 然后执行`server.run wrapped_app, options, &blk` 来选择合适的 `Web Server`并启动之. 

~~~ruby
[2] pry(main)> $ Rack::Server#server

From: **/gems/rack-2.0.3/lib/rack/server.rb @ line 300:
Owner: Rack::Server
Visibility: public
Number of lines: 12

def server
  @_server ||= Rack::Handler.get(options[:server])
  unless @_server
    @_server = Rack::Handler.default
    # We already speak FastCGI
    @ignore_options = [:File, :Port] if @_server.to_s == 'Rack::Handler::FastCGI'
  end
  @_server
end
~~~

我们在运行`rackup`命令时, 如果传入了 `server`选项, 比如:

~~~shell
$ rackup -server Puma
~~~

就会使用传入的`Web Server`, 否则就选择默认的`Rack::Handler`

~~~ruby
[5] pry(main)> $ Rack::Handler.default

From: **/gems/rack-2.0.3/lib/rack/handler.rb @ line 46:
Owner: #<Class:Rack::Handler>
Visibility: public
Number of lines: 12

def self.default
  # Guess.
  if ENV.include?("PHP_FCGI_CHILDREN")
    Rack::Handler::FastCGI
  elsif ENV.include?(REQUEST_METHOD)
    Rack::Handler::CGI
  elsif ENV.include?("RACK_HANDLER")
    self.get(ENV["RACK_HANDLER"])
  else
    pick ['puma', 'thin', 'webrick']
  end
end
~~~

默认选择最终会调用`pick`方法, 在`pick`方法中通过传入的数据尝试对其进行加载 :

~~~ruby
[6] pry(main)> $ Rack::Handler.pick

From: **/gems/rack-2.0.3/lib/rack/handler.rb @ line 34:
Owner: #<Class:Rack::Handler>
Visibility: public
Number of lines: 11
# server_names = ['puma', 'thin', 'webrick']
def self.pick(server_names)
  server_names = Array(server_names)
  server_names.each do |server_name|
    begin
      return get(server_name.to_s)
    rescue LoadError, NameError
    end
  end

  raise LoadError, "Couldn't find handler for: #{server_names.join(', ')}."
end

def self.get(server)
  return unless server
  server = server.to_s

  unless @handlers.include? server
    load_error = try_require('rack/handler', server)
  end

  if klass = @handlers[server]
    klass.split("::").inject(Object) { |o, x| o.const_get(x) }
  else
    const_get(server, false)
  end

rescue NameError => name_error
  raise load_error || name_error
end
~~~

​	`Rack::Handler.get`方法会通过命名规范从对应的文件目录下加载相应的常量. 一部分常量时预先定义在`handler.rb`文件中, 另外一部分是由各个`Web Server`的开发者自己定义或者遵循一定的命名规范加载的.



#### 终于启动了

当`Rack` 已经使用中间件对应用进行包装并且选择了对应的`WebServer`之后, 我们就可以将包装好的应用作为参数传入`Rack::Handler::WEBrick.run`方法了:

~~~ruby
#这里直接采用最简单的 WEBrick进行分析
[8] pry(main)> $ Rack::Handler::WEBrick

From: **/gems/rack-2.0.3/lib/rack/handler/webrick.rb @ line 24:
Class name: Rack::Handler::WEBrick
Number of lines: 95

class WEBrick < ::WEBrick::HTTPServlet::AbstractServlet
  def self.run(app, options={})
    environment  = ENV['RACK_ENV'] || 'development'
    default_host = environment == 'development' ? 'localhost' : nil

    options[:BindAddress] = options.delete(:Host) || default_host
    options[:Port] ||= 8080
    @server = ::WEBrick::HTTPServer.new(options)
    @server.mount "/", Rack::Handler::WEBrick, app
    yield @server  if block_given?
    @server.start
  end
end
~~~



所有遵循`Rack协议`的`Web Server`都会实现类似于`WEBrick`的`run`方法, 此方法接收三个参数: 

* app: 包装好的`Rack应用程序`
* options: 参数
* block:  代码块

`run`方法启动一个一个进程来专门处理所有来自用户的`HTTP请求`. 请求到这一步, 就需要每个`Web Server` 自己处理了. 后续的文章我会对常见的`Web Server`分析.



以上主要从`rackup`命令开始, 研究`Rack`源码, 从初始化配置、包裹中间件、中间件实现, 到选择`Web Server`,  最后启动`Web Server`. 我觉得研究源码一定要过滤掉一些不重要的代码(比如说参数处理, 异常处理)等.另外一点就是可以手动实现源码的一些类或者模块, 这样能够对源码有更深的认识.





## 再论中间件

上面主要是从`rackup	`命令一步一步研究源码,  对中间件的实现和使用都有所了解. 我们可以在`config.ru`中配置中间件, 这对`Ruby on Rails`、`Sinatra`等框架都是通用的. 

* `Ruby on Rails`通过`config.middleware`来配置中间件, 可以在`application.rb`或者`enviroment/<enviroment>.rb`文件中进行配置
* `Sinatra`配置中间件很简单, 直接在`Rack` 应用中使用`use`配置

**在`config.ru`中配置的中间件处在`中间件栈`的上层, 在`Web 框架`中配置的中间件在`中间件栈`下层**. 

用户的请求自上而下通过`中间件栈`,任何一个中间件都可以终止用户请求而不向下传递.



下面来分析`Rack`自带的两个中间件: `Auth`以及 `Session`

### Auth

`Auth`中间件可以用来做`HTTP鉴权(authentication and authorization)`. 我们拿 `Sidekiq Web` 鉴权为例

~~~ruby
# route.rb
Sidekiq::Web.use(Rack::Auth::Basic) do |user, password|
  [user, password] == [ENV['SIDEKIQ_NAME'], ENV['SIDEKIQ_PASS']]
end
~~~

`Auth`作为`Rack`自带的中间件, `Rack::Auth::Basic`本身的实现就在`rack`的源码中, 因此可以直接使用.

配置了中间件后, `Sidekiq Web`不需要做任何修改就被保护起来. 这个认证中间件实现起来也很简单, 如果我们以后要自己完成一个中间件的话, 可以参考一下`Auth`的实现.



`Auth`的源码主要由以下几个模块构成:

~~~ruby
module Rack
  module Auth
    class Basic < AbstractHandler
    
      def call(env)
      #...
      end
      
      class Request < Auth::AbstractRequest
      end
    end
    
    class AbstractHandler
    
      def initialize(app, realm = nil, &authenticator)
      #...
      end
    end
    
    class AbstractRequest
    end
  end
end
~~~



`Rack::Auth::Basic`作为一个中间件, 肯定会实现 `initialize`方法以及`call`方法

* initialize: 接收一个`app`应用程序作为参数, 一般来说`app`也是符合规范的`Rack中间件`. 
* call: 接收`env(环境参数)`, 处理之后交给下一个中间件继续处理

我们还是采用`pry`来一步一步研究`Auth`的源码

~~~ruby
[1] pry(main)> $ Rack::Auth::Basic#initialize

From: **/gems/rack-2.0.3/lib/rack/auth/abstract/handler.rb @ line 11:
Owner: Rack::Auth::AbstractHandler
Visibility: private
Number of lines: 3

def initialize(app, realm=nil, &authenticator)
  @app, @realm, @authenticator = app, realm, authenticator
end
~~~

`initialize`接收三个参数:

* app: 符合规范的一个`Rack`中间件或者应用程序
* realm: 鉴权领域
* authenticator: 代码块, 里面包含我们对用户输入的`username`以及`password`处理逻辑

~~~ruby
[1] pry(main)> $ Rack::Auth::Basic#call

From: **/gems/rack-2.0.3/lib/rack/auth/basic.rb @ line 15:
Owner: Rack::Auth::Basic
Visibility: public
Number of lines: 15

def call(env)
  auth = Basic::Request.new(env)
  return unauthorized unless auth.provided?
  return bad_request unless auth.basic?
  if valid?(auth)
    env['REMOTE_USER'] = auth.username
    return @app.call(env)
  end
  unauthorized
end
~~~

`Rack::Auth::Basic#call`方法调用, 首先创建了一个 `Rack::Auth::Basic::Request`实例

~~~ruby
# return unauthorized unless auth.provided?
[3] pry(main)> $ Rack::Auth::Basic::Request#initialize

From: **/gems/rack-2.0.3/lib/rack/auth/abstract/request.rb @ line 7:
Owner: Rack::Auth::AbstractRequest
Visibility: private
Number of lines: 3

def initialize(env)
  @env = env
end

~~~



我们采用`http`工具从命令行请求:

~~~powershell
λ http http://localhost:3000/sidekiq
HTTP/1.1 401 Unauthorized
Cache-Control: no-cache
Content-Length: 0
Content-Type: text/plain
Set-Cookie: rack.session=BAh7xOD**0d983cc; path=/; HttpOnly
Set-Cookie: _arc_warden_session=U3FMN3**216a9; path=/; HttpOnly
Vary: Origin
WWW-Authenticate: Basic realm=""
X-Content-Type-Options: nosniff
X-Request-Id: c2d9eccd-0ba5-4bb7-9777-ef664e7da88f
X-Runtime: 0.007275

~~~

由于没有携带任何`Auth`认证, 因此服务器返回`401`.

从返回的信息中我们还可以发现`realm`. 由于我们设置`Sidekiq Web`时没有添加`realm`, 所以返回时`realm=""`

~~~ruby
WWW-Authenticate: Basic realm=""
~~~

> realm 用来描述进行保护的区域，或者指代保护的范围。它可以是类似于 "Access to the staging site" 的消息，这样用户就可以知道他们正在试图访问哪一空间。



`Rack::Auth::Basic`根据客户的传来的信息头判断是否携带了`Basic Auth`. 如果用户的请求`request` 中没有我们规定的`Auth`, 就会返回`unauthorized`

~~~ruby
# return bad_request unless auth.basic?
[4] pry(main)> $ Rack::Auth::Basic::Request#provided?

From: **/gems/rack-2.0.3/lib/rack/auth/abstract/request.rb @ line 15:
Owner: Rack::Auth::AbstractRequest
Visibility: public
Number of lines: 3

def provided?
  !authorization_key.nil? && valid?
end

# 按照CGI的方式，HTTP客户端请求的header都会被冠以“HTTP_”前缀、全部大写、保存在env里，
# 因此Authorization就成了HTTP_AUTHORIZATION
AUTHORIZATION_KEYS = ['HTTP_AUTHORIZATION', 'X-HTTP_AUTHORIZATION', 'X_HTTP_AUTHORIZATION']

def authorization_key
  @authorization_key ||= AUTHORIZATION_KEYS.detect { |key| @env.has_key?(key) }
end

def valid?
  !@env[authorization_key].nil?
end

--------------------------------------------------------------------------
[5] pry(main)> $ Rack::Auth::Basic#unauthorized

From: **/gems/rack-2.0.3/lib/rack/auth/abstract/handler.rb @ line 18:
Owner: Rack::Auth::AbstractHandler
Visibility: private
Number of lines: 8

# HTTP server通过通过WWW-Authenticate header指定Auth的方法
def unauthorized(www_authenticate = challenge)
  return [ 401,
    { CONTENT_TYPE => 'text/plain',
      CONTENT_LENGTH => '0',
      'WWW-Authenticate' => www_authenticate.to_s },
    []
  ]
end

def challenge
  'Basic realm="%s"' % realm
end
~~~



接下来判断客户端传来的认证方式是否为`Basic Auth`

~~~ruby
[6] pry(main)> $ Rack::Auth::Basic::Request#basic?

From: **/gems/rack-2.0.3/lib/rack/auth/basic.rb @ line 43:
Owner: Rack::Auth::Basic::Request
Visibility: public
Number of lines: 3

def basic?
  "basic" == scheme
end

def scheme
  @scheme ||= parts.first && parts.first.downcase
end

# Authorization: Basic m************
def parts
  @parts ||= @env[authorization_key].split(' ', 2)
end
~~~

如果前两步的验证都通过的话, 就需要处理我们传入的`block`逻辑部分了:

~~~ruby
[7] pry(main)> $ Rack::Auth::Basic#valid?

From: **/gems/rack-2.0.3/lib/rack/auth/basic.rb @ line 38:
Owner: Rack::Auth::Basic
Visibility: private
Number of lines: 3

def valid?(auth)
  @authenticator.call(*auth.credentials)
end

# 解析得到 username password
def credentials
  @credentials ||= params.unpack("m*").first.split(/:/, 2)
end

def params
  @params ||= parts.last
end

# Authorization: Basic m************
def parts
  @parts ||= @env[authorization_key].split(' ', 2)
end
~~~

至此一个简单的`Basic Auth`已经完成.

我们可以通过`http`工具验证一下:

~~~shell
λ http :3000/sidekiq --auth username:password
HTTP/1.1 200 OK
Cache-Control: no-cache
Content-Language: en
Content-Length: 8101
Content-Type: text/html
Set-Cookie: rack.session=BAh7CEkiD3**0ab564cc1e76c; path=/; HttpOnly
Set-Cookie: _arc_warden_session=aE41bldqOH**a1f7f8d; path=/; HttpOnly
Vary: Origin
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
X-Request-Id: 0b19d49c-422d-4d26-ad21-847b78d36e40
X-Runtime: 1.467317
X-XSS-Protection: 1; mode=block
~~~