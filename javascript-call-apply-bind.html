<!DOCTYPE html>
<html>
  <head>
    <!-- [[! Document Settings ]] -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- [[! Page Meta ]] -->
    <title>
      
        妙用JavaScript中的apply/call/bind
      
    </title>
    
    <meta name="description" content="JavaScript中, call和apply主要用途是为了扩充函数赖以生存的作用域. 通俗讲, 就是为了动态改变函数体内部的this指向. bind方法虽然用法和call和apply有差异, 但是作用也是改变函数体内的this指向." />
    

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="/assets/images/favicon.ico" >

    <!-- [[! Styles'n'Scripts ]] -->
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css"
      href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />

    <link rel="stylesheet" type="text/css" href="/assets/css/prism.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/toc.css" />

    <!-- [[! Ghost outputs important style and meta data with this tag ]] -->
    <link rel="canonical" href="/" />
<meta name="referrer" content="origin" />
<link rel="next" href="/page2/" />

<meta property="og:site_name" content="雄关漫道真如铁" />
<meta property="og:type" content="website" />
<meta property="og:title" content="妙用JavaScript中的apply/call/bind" />

<meta property="og:description" content="JavaScript中, call和apply主要用途是为了扩充函数赖以生存的作用域. 通俗讲, 就是为了动态改变函数体内部的this指向. bind方法虽然用法和call和apply有差异, 但是作用也是改变函数体内的this指向." />

<meta property="og:url" content="http://hwbnju.com/javascript-call-apply-bind" />
<meta property="og:image" content="" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="妙用JavaScript中的apply/call/bind" />

<meta name="twitter:description" content="JavaScript中, call和apply主要用途是为了扩充函数赖以生存的作用域. 通俗讲, 就是为了动态改变函数体内部的this指向. bind方法虽然用法和call和apply有差异, 但是作用也是改变函数体内的this指向." />

<meta name="twitter:url" content="http://hwbnju.com/javascript-call-apply-bind" />
<meta name="twitter:image:src" content="" />

<script type="application/ld+json">
  {
  "@context": "http://schema.org",
  "@type": "Website",
  "publisher": "nju520",
  "url": "http://hwbnju.com/javascript-call-apply-bind",
  "image": "",
  "description": "JavaScript中, call和apply主要用途是为了扩充函数赖以生存的作用域. 通俗讲, 就是为了动态改变函数体内部的this指向. bind方法虽然用法和call和apply有差异, 但是作用也是改变函数体内的this指向."
  }
</script>

<meta name="generator" content="Jekyll 3.0.0" />
<link rel="alternate" type="application/rss+xml" title="雄关漫道真如铁" href="/feed.xml" />

    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
<script>
 (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
 })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

 ga('create', 'UA-114647632-1', 'auto');
 ga('send', 'pageview', location.pathname);

</script>

<!-- Baidu Analytics  Manager -->
<script>
 var _hmt = _hmt || [];
 (function() {
   var hm = document.createElement("script");
   hm.src = "https://hm.baidu.com/hm.js?e9208862845c46a0f79e7828f495e407";
   var s = document.getElementsByTagName("script")[0];
   s.parentNode.insertBefore(hm, s);
 })();
</script>

<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-PWFC85B');</script>
  <!-- End Google Tag Manager -->


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-114647632-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-114647632-1');
</script>

  </head>
  <body class=" post-template nav-closed">
    <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PWFC85B"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->


    <div class="nav">
  <h3 class="nav-title">Home</h3>
  <a href="#" class="nav-close">
    <span class="hidden">Close</span>
  </a>
  <ul>
    <li class="nav-home " role="presentation"><a href="/">Home</a></li>
    <li class="nav-ruby " role="presentation"><a href="/tag/ruby">Ruby</a></li>
    <li class="nav-javascript  nav-current" role="presentation"><a href="/tag/javascript">JavaScript</a></li>
    <li class="nav-server " role="presentation"><a href="/tag/server">Server</a></li>
    <li class="nav-database " role="presentation"><a href="/tag/database">Database</a></li>
  </ul>
  <a class="subscribe-button icon-feed" href="/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

      <!-- [[! Everything else gets inserted here ]] -->
      <!-- < default -->

<!-- The comment above "< default" means - insert everything in this file into -->
<!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head no-cover">
  <nav class="main-nav overlay clearfix">
    <a class="back-button icon-arrow-left" href="/">Home</a>
    <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
  </nav>
</header>

<main class="content" role="main">

  <article class="post">

    <header class="post-template post-header">
      <h1 class="post-title">妙用JavaScript中的apply/call/bind</h1>
      <section class="post-meta">
        <time class="post-date" datetime="2016-07-09">09 Jul 2016</time>
        <!-- <a href='/'>nju520</a> -->
        <!-- [[tags prefix=" on "]] -->
        
        
        <a href='/tag/JavaScript'>JavaScript</a>
        
        <a href='/tag/apply'>apply</a>
        
        <a href='/tag/call'>call</a>
        
        <a href='/tag/bind'>bind</a>
        
        
      </section>
    </header>

    <section class="post-content">

      <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#applycall">apply/call</a></li>
<li class="toc-entry toc-h2"><a href="#call与apply的区别">call与apply的区别</a></li>
<li class="toc-entry toc-h2"><a href="#更多示例">更多示例</a></li>
<li class="toc-entry toc-h2"><a href="#bind">bind</a></li>
<li class="toc-entry toc-h2"><a href="#apply-call-bind-的比较">apply call bind 的比较</a></li>
</ul><h2 id="applycall">
<a id="applycall" class="anchor" href="#applycall" aria-hidden="true"><span class="octicon octicon-link"></span></a>apply/call</h2>
<p><strong>call和apply都是为了改变某个函数运行时的上下文(context)而存在的.换句话说, 就是为了改变函数体内部的this指向.</strong></p>

<blockquote>
  <p>JavaScript的一大特点就是, 函数存在 定义时上下文/运行时上下文/上下文可以动态改变 这样的概念 –</p>
</blockquote>

<pre><code class="language-javascript">function Fruits() {}
// Fruits.prototype = {
//   color: 'red',
//   sayColor: function() {
//   console.log('My color is ' + this.color);
//   }
// }
Fruits.prototype.color = 'red'
Fruits.prototype.sayColor = function() {
  console.log('My color is ' + this.color);
}
var apple = new Fruits();
apple.sayColor();// My color is red
</code></pre>
<p>但是如果我们与一个对象 banana = {color: ‘yellow’}, 我并不想重新为它定义sayColor方法,那么我就可以使用call或者apply来调用apple的sayColor方法</p>
<pre><code class="language-javascript">var banana = {color: 'yellow'}
apple.sayColor.apply(banana);// My color is yellow
apple.sayColor.call(banana); // My color is yellow

</code></pre>
<p>从上面的示例可以看出, call或者apply是为了动态改变this而出现的,当一个object没有某个方法, 但是其他对象已经定义了实现某个功能的方法, 我就可以借助call或apply让此object调用指定对象的方法.</p>

<h2 id="call与apply的区别">
<a id="call与apply的区别" class="anchor" href="#call%E4%B8%8Eapply%E7%9A%84%E5%8C%BA%E5%88%AB" aria-hidden="true"><span class="octicon octicon-link"></span></a>call与apply的区别</h2>
<p>唯一区别就是接收的参数形式不太一样.
call  需要把参数按照顺序传递进去
apply 把参数放到一个数组(也包括类数组)中传入  array apply !!</p>
<pre><code class="language-javascript">var func = function(arg1, arg2) {

};
func.call(this, arg1, arg2);
func.apply(this, [arg1, arg2]);

</code></pre>
<p>其中this是我想要指定的上下文, 它可以是任何一个javascript对象</p>

<ul>
  <li>使用情景:
    <ul>
      <li>JavaScript中, 如果某个函数的参数数量是不固定的, 所以当我的参数是明确的, 就使用call, 而不确定参数数量的话 就使用apply, 然后把参数push进数组中</li>
      <li>当参数数量不确定时, 函数内部也可以通过arguments这个类数组对象来遍历所有的参数.</li>
    </ul>
  </li>
</ul>

<h2 id="更多示例">
<a id="更多示例" class="anchor" href="#%E6%9B%B4%E5%A4%9A%E7%A4%BA%E4%BE%8B" aria-hidden="true"><span class="octicon octicon-link"></span></a>更多示例</h2>

<ol>
  <li>数组之间追加
    <pre><code class="language-javascript">var array1 = [12 , "foo" , {name "Joe"} , -2458];
var array2 = ["Doe" , 555 , 100];
// array1.push("Doe", 555, 100); // 正常调用
Array.prototype.push.apply(array1, array2);
/* array1 值为  [12 , "foo" , {name "Joe"} , -2458 , "Doe" , 555 , 100] */
</code></pre>
  </li>
  <li>获取数组中的最大值和最小值
    <pre><code class="language-javascript">var  numbers = [5, 458 , 120 , -215 ];
var max = Math.max.apply(Math, numbers);//458
// var max = Math.max(5,458,120,-215);//正常调用
var min = Math.min.apply(Math, numbers);//-215
// var min = Math.min(5,458,120,-215);//正常调用
//数组numbers本身没有max方法, 我可以借助apply使用Math中的max方法
</code></pre>
  </li>
  <li>验证对象是否是数组(前提是toString方法没有被重写)
    <pre><code class="language-javascript">function isArray(obj) {
  return Object.prototype.toString.call(obj) === '[object Array]'
}
</code></pre>
  </li>
</ol>

<p>4 类数组使用数组方法(比较常见的就是函数参数对象arguments)
Javascript中存在一种名为伪数组的对象结构。比较特别的是 arguments 对象，还有像调用 getElementsByTagName , document.childNodes 之类的，它们返回NodeList对象都属于伪数组, 不能应用 Array下的push, pop等方法。
但是我们能通过 Array.prototype.slice.call 转换为真正的数组的带有length属性的对象，这样domNodes就可以应用Array下的所有方法了。</p>
<pre><code class="language-javascript">var domNodes = Array.prototype.slice.call(document.getElementsByTagName('*'));
var domNodes = [].slice.call(document.getElementsByTagName('*'));

// 我还可以通过bind进行简化
var unboundSlice = Array.prototype.slice;
var slice = Function.prototype.call.bind(unboundSlice);
//这里function原型中的call方法绑定unboundSlice对象, 调用返回的函数就等价于 绑定对象unboundSlice调用Function下面的call方法
// 这与调用 [].slice.call(arguments) 是一样的.
// call方法是Function.prototype中的一个方法
var domNodes = slice(document.getElementsByTagName('*'));

</code></pre>
<p>5.一道面试题
定义一个log方法,让它可以代理console.log方法</p>
<pre><code class="language-javascript">function log(msg) {
  console.log(msg);
};
log(1);//1
log(1,2,3,);//1
</code></pre>
<p>当传入多个参数给上面的log方法时, 就要考虑使用apply或者call方法了, 注意这里传入的参数是不确定的,所以最好的选择是apply</p>
<pre><code class="language-javascript">function log() {
  console.log.apply(console, arguments);
}
log(1);//1
log(1,2,3);//1,2,3
</code></pre>
<p>接下来的要求是给每一个log消息添加一个(app)的前缀, 比如</p>
<pre><code class="language-javascript">log('hello world'); //(app)hello world
</code></pre>
<p>该怎么做才比较优雅呢?
函数参数对象arguments是类数组, 我可以通过上面的类数组转换为数组的方法, 再使用数组的方法unshift在数组的头部添加’(app)’</p>
<pre><code class="language-javascript">function log() {
  // var args = [].slice.apply(arguments); //arguments是类数组,所以这里也可以使用apply
  var args = [].slice.call(arguments);
  args.unshift('(app)');
  console.log.apply(console, args);
}
</code></pre>

<h2 id="bind">
<a id="bind" class="anchor" href="#bind" aria-hidden="true"><span class="octicon octicon-link"></span></a>bind</h2>
<p>bind()方法与apply和call类似, 也是可以改变函数体内的this的指向.
MDN的解释:
<strong>bind()方法会创建一个新函数,称为绑定函数, 当调用这个绑定函数时,
绑定函数会以创建它时传入的bind()方法第一个参数作为this,
传入bind()方法第二个以及以后的参数+绑定函数运行时传入的参数,按照顺序作为原函数的参数来调用原函数</strong>
示例:</p>
<ol>
  <li>在常见的单体模式下, 我们通常会使用self等保存this, 这样我们可以在改变了上下文之后继续引用到它
    <pre><code class="language-javascript">var foo = {
  bar: 1,
  eventBind: function() {
 var self = this;
 $('.calss').on('click', function(event) {
   //Act on the event
   console.log(self.bar);//1
 });
  }
}
</code></pre>
    <p>由于 Javascript特有的机制，上下文环境在 eventBind:function(){ } 过渡到$(‘.class’).on(‘click’, function(event) {})发生了改变，上述使用变量保存this这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题：</p>
  </li>
</ol>

<pre><code class="language-javascript">var foo = {
  bar: 1,
  eventBind: function() {
    $('.class').on('click', function(event) {
      console.log(this.bar).bind(this);//匿名函数的绑定
    })
  }
}
</code></pre>
<p>上述代码中, bind()创建了一个函数,当这个click事件绑定在被调用的时候, 它的this关键词会被设置成传入的值, 因此这样我传入了想要的上下文this(其实就是foo)到bind方法中. 当回调函数被执行的时候, this便指向foo对象</p>

<ol>
  <li>分离函数（Partial Functions）
  bind()的另一个最简单的用法是使一个函数拥有预设的初始参数。这些参数（如果有的话）作为bind()的第二个参数跟在this（或其他对象）后面，之后它们会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们的后面。
```javascript
function list() {
  return Array.prototype.slice.call(arguments);
}</li>
</ol>

<p>var list1 = list(1, 2, 3); // [1, 2, 3]
// Create a function with a preset leading argument
var leadingThirtysevenList = list.bind(undefined, 37);
var list2 = leadingThirtysevenList(); // [37]
var list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]</p>
<pre><code>有个有趣的问题，如果连续 bind() 两次，亦或者是连续 bind() 三次那么输出的值是什么呢？
```javascript
var bar = function(){
    console.log(this.x);
}
var foo = {
    x:3
}
var sed = {
    x:4
}
var func = bar.bind(foo).bind(sed);
func(); //?

var fiv = {
    x:5
}
var func = bar.bind(foo).bind(sed).bind(fiv);
func(); //?
</code></pre>
<p>答案是两次输出都是3.
原因是在javascript中多次绑定bind是无效的.更深层的原因是, bind()方法的实现, 相当于使用函数内部包了一个call/apply, 此时的this已经确定了.第二次bind()相当于再包住第一次的bind(), 所以第二次的之后的bind()是无效的</p>

<ol>
  <li>实现currying
  除了第一个实参外，传入bind()的实参也会绑定到 this,这个应用就是一种常见的编程技术，柯里化
```javascript
function curry(fn) {
  var args = Array.prototype.slice.call(arguments, 1); //获取第一个参数之后的所有参数!!!
  return function() {
 var innerArgs = Array.prototype.slice.call(arguments);
 var finalArgs = args.concat(innerArgs); // 内部函数中innerArgs保存了传入的参数
 return fn.apply(null, finalArgs);
  }
}</li>
</ol>

<p>function add(num1, num2) {
  return num1 + num2;
}
var curriedAdd = curry(add, 5);
curriedAdd(3); //8</p>

<pre><code>
```javascript
var sum = function(y, z) {return this.x + y + z }
var obj = {x:100}
var g = sum.bind(obj, 2)
g(3);//=&gt;6 this.x 绑定到100， y绑定到2， z绑定到3
</code></pre>
<ol>
  <li>手动实现bind方法
    <pre><code class="language-javascript">if(!Function.prototype.bind) {
  Function.prototype.bind = function(obj) {
 var self = this;//self就是要绑定指定对象的函数
 var boundArgs = arguments;
 return function() {
   var args = [];
   var i;
   // for(i = 1; i &lt; boundArgs.length; i++) args.push(boundArgs[i]);
   // for(i = 0; i &lt; arguments.length; i++) args.push(boundArgs[i]);
   //将self作为obj的方法来调用， 传入整合之后的实参
   // return self.apply(obj, args);

   var outArgs = Array.prototype.slice.call(arguments, 1);
   F = function() {};
   functionToBind = this;
   fBound = functionToBind.apply(this, outArgs.concat(Array.prototype.slice.call(arguments)))
   F.prototype = this.prototype;
   functionToBind.prototype = new F();
   return functionToBind;
 }
  }
}
</code></pre>
    <h2 id="apply-call-bind-的比较">
<a id="apply-call-bind-的比较" class="anchor" href="#apply-call-bind-%E7%9A%84%E6%AF%94%E8%BE%83" aria-hidden="true"><span class="octicon octicon-link"></span></a>apply call bind 的比较</h2>
    <p>```javascript
var obj = {
 x: 81,
};</p>
  </li>
</ol>

<p>var foo = {
    getX: function() {
        return this.x;
    }
}</p>

<p>console.log(foo.getX.bind(obj)());  //81
console.log(foo.getX.call(obj));    //81
console.log(foo.getX.apply(obj));   //81
```
三个输出的都是81，但是注意看使用 bind() 方法的，他后面多了对括号。
也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。
而 apply/call 则会立即执行函数。</p>

<hr>
<ul>
  <li>再次总结一下:
    <ul>
      <li>apply call bind 三者都是用来改变函数的this对象的指向的</li>
      <li>apply call bind 三者的第一个参数都是this要指向的对象, 也就是想要指定的上下文</li>
      <li>apply call bind 三者都可以利用后续参数传参</li>
      <li>bind 返回的是一个函数, 便于稍后调用; apply call 则是立即调用</li>
    </ul>
  </li>
</ul>


      <h3>关于图片和转载</h3>

      <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可。

      转载时请注明原文链接，图片在使用时请保留图片中的全部内容，可适当缩放并在引用处附上图片所在的文章链接，图片使用 Sketch 进行绘制。

      <h3>关于评论和留言</h3>

      如果对本文 <a href="/javascript-call-apply-bind">妙用JavaScript中的apply/call/bind</a> 的内容有疑问，请在下面的评论系统中留言，谢谢。

      <blockquote>
        <p>原文链接：<a href="/javascript-call-apply-bind">妙用JavaScript中的apply/call/bind · 雄关漫道真如铁</a></p>

        <p>Follow: <a href="https://github.com/nju520">nju520 · GitHub</a></p>
      </blockquote>

    </section>

    <footer class="post-footer">

      <!-- Everything inside the #author tags pulls data from the author -->
      <!-- #author-->

      
      <figure class="author-image">
        <a class="img" href="https://github.com/nju520" style="background-image: url(/assets/images/hacker.png)"><span class="hidden">'s Picture</span></a>
      </figure>
      

      <section class="author">
        <h4><a href="https://github.com/nju520">nju520</a></h4>

        
        <p> Ruby / Python / JS</p>
        
        <div class="author-meta">
          <span class="author-location icon-location"> Hangzhou, China</span>
          <span class="author-link icon-link"><a href="http://hwbnju.com"> hwbnju.com</a></span>
        </div>
      </section>

      <!-- /author  -->

      <section class="share">
        <h4>Share this post</h4>
        <a class="icon-twitter" href="http://twitter.com/share?text=妙用JavaScript中的apply/call/bind&amp;url=http://hwbnju.comjavascript-call-apply-bind"
          onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
          <span class="hidden">Twitter</span>
        </a>
        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://hwbnju.comjavascript-call-apply-bind"
          onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
          <span class="hidden">Facebook</span>
        </a>
        <a class="icon-google-plus" href="https://plus.google.com/share?url=http://hwbnju.comjavascript-call-apply-bind"
          onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
          <span class="hidden">Google+</span>
        </a>
      </section>

      <div id="gitalk-container"></div>
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
      <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
      <script>
       const gitalk = new Gitalk({
         clientID: 'e552ed507a5a4581d8a1',
         clientSecret: '0abbd4193a0f9b2700936214ff6fda088c665a73',
         repo: 'bobo-comments',
         owner: 'nju520',
         admin: ['nju520'],
         // labels: ['Gitalk', 'gitment'].concat(["JavaScript","apply","call","bind"]),
         // id: location.origin + location.pathname,
         id: "http://hwbnju.com/javascript-call-apply-bind",
         distractionFreeMode: false
       });

       gitalk.render('gitalk-container')
      </script>

    </footer>

  </article>

</main>

<aside class="read-next">

  <!-- [[! next_post ]] -->
  
  <a class="read-next-story no-cover" href="javascript-event">
    <section class="post">
      <h2>JavaScript 与 事件</h2>
      <p>## 事件机制 与浏览器进行交互的时候浏览器就会触发各种事件。比如当我们打开某一个网页的时候，浏览器加载完成了这个网页，就会触发一个 load 事件；当我们点击页面中的某一个“地方”，浏览器就会在那个“地方”触发一个 click 事件。 这样，我们就可以编写 JavaScript，通过监听某一个事件，来实现某些功能扩展。例如监听 load 事件，显示欢迎信息，那么当浏览器加载完一个网页之后，就会显示欢迎信息。 JavaScript 与 HTML 之间的交互式通过事件实现的....</p>
    </section>
  </a>
  
  <!-- [[! /next_post ]] -->
  <!-- [[! prev_post ]] -->
  
  <a class="read-next-story prev no-cover" href="rails-concern">
    <section class="post">
      <h2>Rails Concern 的使用以及源码解读</h2>
      <p>使用 ActiveSupport::Concern 熟悉 Ruby on Rails 的同学肯定使用过Concern来让Rails类包含模块的同时获得实例方法和类方法. 举个例子: require 'active_support' module ConcernA extend ActiveSupport::Concern included...</p>
    </section>
  </a>
  
  <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


      <footer class="site-footer clearfix">
        <section class="copyright"><a href="/">雄关漫道真如铁</a> &copy; 2018</section>
        <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/biomadeira/jasper">Jasper</a></section>
      </footer>
    </div>
    <!-- [[! Ghost outputs important scripts and data with this tag ]] -->
    <script type="text/javascript" src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
    <!-- [[! The main JavaScript file for Casper ]] -->
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="/assets/js/index.js"></script>
    <script type="text/javascript" src="/assets/js/prism.js"></script>
    <script type="text/javascript" src="/assets/js/toc.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  </body>
</html>
