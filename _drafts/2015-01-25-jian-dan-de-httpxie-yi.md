---
layout: post
title: 简单的HTTP协议
date: 2015-01-25 05:59:11.000000000 +08:00
permalink: /:title
---


##HTTP协议

`HTTP`协议主要用于客户端和服务端之间的通信, 应用HTTP协议时必须是一端担任客户端角色, 一端担任服务端角色

* 客户端发送HTTP请求
* 服务端进行响应回复

##请求报文

	请求报文 = 请求方法 + URI + 协议版本 + (请求首部) + (内容实体)
	
	GET /index.htm HTTP/1.1
	HOST: DeltaX.me

* `GET`表示访问服务器的类型, 也就是`Method`
* `/index.htm`指明请求的资源对象, 也叫`URI`
* `HTTP/1.1`为`HTTP`的版本号
* 这段请求的意思是访问HTTP服务器上的`/index.htm`资源


##响应报文

	请求报文 = 协议版本 + 状态码 + 原因短语 + (响应首部字段) + 实体主体
	
	HTTP/1.1 200 OK
	Date: Sat, 23 January 2014 22:07:00 GMT
	Content-Length: 500
	Content-Type: text/html
	
	<html>.....
	
	
* 状态码表示请求的处理结果
* 原因短语用于解释状态码

##无状态协议和Cookie

`HTTP`协议自身不对请求和响应之间的通信状态进行保存, 对于发送过的请求和响应**不做持久化处理**. 由于不必保存状态, 自然可以减轻服务器的CPU以及内存资源的销号, 但是要解决状态的问题, 引入了`Cookie`技术.

Cookie会根据从服务器端发送的响应豹纹的`Set-Cookie`的首部字段信息, 通知客户端保存`Cookie`. 当下次客户端向服务器发送通信时, 客户端后自动在请求报文中加入`Cookie`值后发送出去, 服务端接收`Cookie`值之后, 会对比服务器上的记录, 得到之前的状态信息.


##持久连接和管线化

为了解决`TCP`连接的问题, `HTTP/1.1`和一部分`HTTP/1.0`实现了*持久连接*(HTTP keep-alive)方法

* 只要任意一端没有明确提出断开连接, 则保持`TCP`连接状态
* `HTTP/1.1`中所有的连接默认都是持久连接, 这样可以减轻服务器负担, 减少了`TCP`连接的重复建立和断开造成的额外开销.


*管线化*及同时并行发送多个请求, 不需要依次等待相应.
