---
layout: post
toc: true
permalink: /pusher
title: pusher websocket 推送
tags: Pusher Websocket
desc: Pusher是一个基于 WebSocket的实时消息推送服务。
---

当浏览器刷新页面时，会向服务器发起一个请求。服务器收到这个请求之后，会返回一个不带数据的纯HTML空模板。然后客户端渲染模板之后， 再次通过Restful API向服务器请求项目的真实数据（JSON），最后由客户端对数据对处理并呈现， 得到用户真正看到的页面。

之后`Pusher`服务器建立一条`WebSocket`的长连接，接收推送消息。 当服务端有任何更新的时候，会发送消息到`Pusher`服务器，再由`Pusher`服务器传输到客户端浏览器，页面同时得到更新。



## 信道(Channel)

`Pusher Channel` 提供服务器和APP之间的长连接。`Pusher Channel`可以用来提供实时通知、聊天、在线游戏、网页的异步更新等服务。

当服务端的数据发生变化时，`Pusher`会通知APP、Web Page等设备更新。

当APP端事件`Event`被触发时，其他订阅同一个`Channel`的APP和服务器就会得到通知。

比如说`Bitcoin`的价格发生变动时，系统可以通知所有的APP端和Web端更新`Bitcoin`的价格。



`Pusher Channel`	采用`Publish/Subscribe`模式。

一个手机APP对当前`Bitcoin`的价格感兴趣，它就可以`Subscribe`(订阅)名为`bitcoin`的`channel`.

当`Bitcoin`的价格发生变化时，服务端就会`Publish`( 发布)新的价格到名为`bitcoin`的`channel`.

所有订阅`bitcoin`的订阅者都会收到更新。

除了公开的(Public)地发布信息，我们还可以使用`private-`信道来推送一些敏感的数据。

APPs需要首先获得`private channel`的订阅权限。比如我们可以限制`private-user-bobo`这个信道只有用户`bobo`才可以订阅，其余的用户均无法订阅。

除了`Public Channel`和`Private Channel`之外，还有一种`Presence Channel`.

顾名思义， `Presence Channel`就是暂时当前在线的用户。Apps可以使用`Presence Channel`来展示好友列表中`在线/离线`状态。当Bob's APP 订阅了一个`Presence Channel`, App会提供`user id`为`Bob`.Alice's App 同样可以订阅`Presence Channel`,并且给`Alice`展现`Bob`在线。





## JavaScript起步

~~~js
#1. 在Pusher中创建一个账户，申请得到app_id, key, secret, cluster(集群)

#2. 将 `puser-js`进入到 script中
<script src="https://js.pusher.com/4.3/pusher.min.js"></script>

#3. 开启一个连接
var pusher = new Pusher(APP_KEY, {
    cluster: APP_CLUSTER
})

#4. 订阅信道
# APP首先需要订阅一个信道，才可以收到信息发布的消息
var channel = pusher.subscribe('my-first-channel')

#5. 监听信道发布的消息(绑定)
channel.bind('my-first-event', function(data) {
    console.log("An event was triggered with message: " + data.message)
})

#6. 服务器端发送消息到指定`event`

# gem install pusher
require 'pusher'
pusher_client = Pusher::Client.new(
	app_id: ENV['APP_ID'],
    key: ENV['KEY'],
    secret: ENV['SECRET'],
    cluster: ENV['CLUSTER']
)

class HelloWorldController < ApplicationController
  def hello_world
    pusher_client.trigger('my-first-channel', 'my-first-event', {message: 'hehe'})
  end                         
end
~~~





## Client API



### Connection

Connecting to Channels

~~~js
var pusher = new Pusher('APP_KEY', options)
~~~

创建`pusher`实例对象时可传入的参数:

~~~json
{
    cluster: 'APP_CLUSTER',
    encrypted: true,
    auth: {
        params: {
            param1: 'value1'
        },
        headers: {
            header1: 'value1'
        }
    }
}
~~~

我们来逐一解释.

#### Encrypting Connections

信道订阅的客户端可以配置信道的连接为SSL连接。

一个使用SSL协议的应用可以保证它的连接是加密的。

也就是采用的是`HTTPS`协议

~~~js
var pusher = new Pusher('APP_KEY', { encrypted: true })
~~~



#### AuthEndpoint

认证端点`Authendpoint`是在服务端定义的一个API，如果认证通过， 返回的是一个签名过的供`private channel`以及`presence channel`使用的字符串。

~~~ruby
# 采用 grape 开发的 authendpoint
before do
  authenticate! # 登陆用户的认证
end
# 1. get push auth
params do
  # 这里的 channel_name形式为: private-member_sn
  requires :channel_name, type: String, allow_blank: false
  requires :socket_id, type: String, allow_blank: false
end
result = authenticate_channel

def authenticate_channel
  sn = params[:channel_name].split('-', 2).last
  raise Errors::Users::InvalidClientError unless sn.present? && current_user.sn == sn
  Pusher.authenticate(params[:channel_name], params[:socket_id])
end

# 只有传入的 channel-name 为当前登陆用户sn对应的才会认证成功，并返回 signature

{
 "auth":"278d425bdf160c739803:a99e78e7cd4b6cd3c085764229fd40b39ce92c39af33e"
}
~~~

返回的`auth`信息其实是经过`HMAC SHA256`签名之后的字符串：

~~~ruby
#the auth string should look like:
#<pusher-key>:<signature>

#the signature is a HMAC SHA256 hex digest.This is generated by signing the following strign with Channels secret:
#<socket_id>:<channel_name>

require "openssl"

key = '278d425bdf160c739803'
secret = '7ad3773142a6692b25b8'

digest = OpenSSL::Digest::SHA256.new
secret = "7ad3773142a6692b25b8"
string_to_sign = "1234.1234:private-foobar"

puts signature = OpenSSL::HMAC.hexdigest(digest, secret, string_to_sign)
# => 58df8b0c36d6982b82c3ecf6b4662e34fe8c25bba48f5369f135bf843651c3a4


# the auth response should be a JSON string with an auth property with a value composed of the application `app_key` and the authentication signature separated by a `:`

#{"auth":"278d425bdf160c739803:58df8b0c36d6982b82c3ecf6b4662e34fe8c25bba48f5369f135bf843651c3a4"}
~~~



##### Auth Endpoint for a presence channel

认证一个`presence channel`和上面的`private-channel`类似，只不过返回的`response`中必须包含`channel_data`:包含我们想给当前订阅的用户返回的其他订阅者的信息

~~~ruby
class PusherController < ApplicationController

  def auth
    if current_user
      response = pusher_client.authenticate(params[:channel_name], params[:socket_id], {
        user_id: current_user.id, # => required
        user_info: { # => optional - for example
          name: current_user.name,
          email: current_user.email
        }
      })
      render json: response
    else
      render text: 'Forbidden', status: '403'
    end
  end
end
~~~



~~~ruby
# Presence Channels requires extra user data to be passed back to the client along with the auth string. 
# These data need to be part of the signature as a valid JSON string
# <socket_id>:<channel_name>:<JSOn encoded user data>

require "json"
require "openssl"

json_user_data = JSON.generate({
  :user_id => 10,
  :user_info => {:name => "Mr. Channels"}
})

# NB: written as double-escaped JSON!
# => "{\"user_id\":10,\"user_info\":{\"name\":\"Mr. Channels\"}}"

digest = OpenSSL::Digest::SHA256.new

secret = "7ad3773142a6692b25b8"
string_to_sign = "1234.1234:presence-foobar:#{json_user_data}"

puts signature = OpenSSL::HMAC.hexdigest(digest, secret, string_to_sign)
# => afaed3695da2ffd16931f457e338e6c9f2921fa133ce7dac49f529792be6304c
~~~



#### Auth

我们可以在`auth`参数中添加一些额外的认证信息,比如`Rails`中常见的`CSRF_TOKEN`

~~~js
var pusher = new Pusher('app_key', {
    auth: {
        params: {
            CSRFToken: 'some_csrf_token'
        }
    }
})
~~~

 

#### Cluster(集群)

集群代表了服务器伺服的物理位置。

比如`ap1`代表了新加坡的`Pusher`	服务器。当你创建一个`Channel APP`,你应该选择一个可用的`Cluster`.



- `mt1` in N. Virginia
- `us2` in Ohio
- `eu` in Ireland
- `ap1` in Singapore
- `ap2` in Mumbai



#### wsHost, wsPort, wssPort, httpHost, httpPort, httpsPort



#### Binding to Event

Each Channels instance now has a `connection` object which manages the current state of the Channels connection and allows binding to state changes:

```js
var pusher = new Pusher('_APP_KEY');

pusher.connection.bind('connected', function() {
  $('div#status').text('Realtime is go!');
});
```

It is also possible bind to the `connecting_in` event. This will give you the time until the next connection attempt.

```js
pusher.connection.bind('connecting_in', function(delay) {
  alert("I haven't been able to establish a connection for this feature.  " +
        "I will try again in " + delay + " seconds.")
});
```

*Note: this isn’t a countdown, and is not fired every second.*

Binding to all state changes](https://pusher.com/docs/client_api_guide/client_connect#binding-to-all-state-changes)

There’s an extra `state_change` utility event that fires for all state changes:

```
pusher.connection.bind('state_change', function(states) {
  // states = {previous: 'oldState', current: 'newState'}
  $('div#status').text("Channels current state is " + states.current);
});
```



Querying the connection state](https://pusher.com/docs/client_api_guide/client_connect#querying-the-connection-state)

- [JavaScript](https://pusher.com/docs/client_api_guide/client_connect#query_connection_state_js)

```
var state = pusher.connection.state;
```



### Channels

channel type:

* Public Channels: 公开信道。每个应用均可以订阅(channel_name)
* Private Channels: 私有信道。订阅之前需要认证(private-)
* Presence Channels: 存在信道。让订阅用户获取其他订阅用户的在线信息(presence-)





#### Access Channels

进入信道:

~~~js
var channel = pusher.channel(channel_name)
~~~



####订阅信道

~~~js
var channel = puhser.subscribe(channel_name)
~~~



#### 取消订阅

~~~js
pusher.unsubsribe(channel_name)
~~~



#### 事件绑定(Event Bind)

事件一般是用来作为`Client Side`端的路由键，我们最好不要将其用来信息过滤中

事件可以被客户端直接绑定，这意味着当一个信息发送到指定`route_key`时，客户端就会收到一个事件

~~~js
var pusher = new Pusher('APP_KEY')
var channel = pusher.subscribe('APPL')
channel.bind('new-price', function(data) {
    // add new price into the APPL widget
})
~~~



##### Binding on the Client

我们可以直接绑定事件而不管信道是哪个，使用`pusher.bind()`方法替代`channel.bind()`

~~~js
var pusher = new Pusher('APP_KEY')
var channel1 = pusher.subscribe('my-channel-1')
var channel2 = pusher.subscribe('my-channel-2')
var channel3 = pusher.subscribe('my-channel-3')

var eventName = 'new-comment'
var callback = function(data) {
    // add comment into data
}
pusher.bind(eventName, callback)
~~~



##### Unbind

~~~js
var pusher = new Pusher('APP_KEY')
var channel = pusher.subscribe('APPL')
var callback = function(data) {}
channel.bind('new-price', callback)

// remove just handler for the `new-price` event
channel.unbind('new-price', handler)

// remove all handlers for the `new-price` event
channel.unbind('new-price')

// remove all handlers on `channel`
channel.unbind()
~~~



##### Channels channel events

~~~js
#1. pusher.subscription_succeeded
# 当客户端成功绑定到 `channel`时，会收到订阅成功这个事件
# 客户端可以根据绑定成功的事件来 `trigger`后续的操作
# 这个特别适合 `private channel`  以及 `presence channel`的绑定
channel.bind('pusher.subscription_succeeded', function() {
    //balabala
})

#2. pusher.subscription_error
channel.bind('pusher.subscription_error', function(status) {
    // deal with status code
})
~~~



#### Triggering Client Events

一个订阅信道的客户端端发送事件的时候，其余订阅信道的客户端均可以收到此事件

- **Client events must be enabled for the application**. You can do this in the *Settings* tab for your app within the Channels dashboard
- The user must be subscribed to the channel that the event is being triggered on
- Client events can only be triggered on [private](https://pusher.com/docs/private_channels) and [presence](https://pusher.com/docs/presence) channels because they require authentication
- Client events must be prefixed by `client-`. Events with any other prefix will be rejected by the Channels server, as will events sent to channels to which the client is not subscribed.
- You can only trigger a client event once a subscription has been successfully registered with Channels. You can ensure this is the case using the [`pusher:subscription_succeeded` event](https://pusher.com/docs/client_api_guide/client_events#subscription_succeeded).
- Client events are not delivered to the originator of the event. For more information see [Message Routing](https://pusher.com/docs/client_api_guide/client_events#message_routing).
- Publish no more than 10 messages per second per client (connection). Any events triggered above this rate limit will be rejected by our API. See [Rate limit your events](https://pusher.com/docs/client_api_guide/client_events#rate_limit).




~~~js
var pusher = new Pusher('APP_KEY')
var channel = pusher.subscribe('private-channel')
channel.bind('pusher.subscription_succeeded', function() {
    var triggered = channel.trigger('client-someevent', {your: data})
}) 
~~~



#### Public Channel

公开信道用于一些不需要授权就可以订阅的信道。

~~~js
var channel = pusher.subscribe(channelName)

pusher.unsubcribe(channelName)
~~~





#### Private Channel

`private channel`是只有通过授权才可以订阅的信道。

在JavaScript客户端端中我们采用`Ajax`的方式来获取`private channel`的认证

~~~js
var privateChannel = pusher.subscribe(privateChannelName)

pusher.unsubcribe(privateChannelName)
~~~



#### Encrypted Channel

加密信道：和`private channel`一样，订阅信道之前需要先获取认证。除此之外，加密信道还可以保证发送的数据是加密过的。



认证环节和`private channel Authenticating User`一样。

加密环节需要在初始化服务器的时候加上一个`EncryptMasterKey`

~~~go
client := pusher.Client{
    APPid: appID,
    Key: key,
    Secret: secret,
    Secure: secure,
    EncryptionMasterKey: 'a-thirty-two-character-long-key!s'
}
~~~



This `encryption_master_key` is never sent to pusher and should be something difficult to guess. We suggest using something like the `openssl` command below to generate a random key and keeping it somewhere secure.



~~~js
var encryptedChannel = pusher.subscribe(encryptedChannelName)
// encryptedChannelName with begin with `private-encrypted-`
~~~

当一个`encrypted channel`被订阅时，就会触发`user authentication process`。除了提供`auth token`之外，`user authentication process`还会提供一个`encryped/decryped key`,它们被客户端用来加密和解密订阅的信息。



#### Presence Channels

> Presence channels build on the security of Private channels and expose the additional feature of an **awareness of who is subscribed to that channel**. 

通过`presence channels`我们可以很方便的构建`who is oninle`功能。

`Presence Channels`和`Private Channels`认证方式基本一致，除此之外，它还可以携带额外的用户信息供订阅者使用。

~~~js
var presenceChannel = pusher.subscribe('presence-somechannel')

// memnbers.count how many memebrs are subscirbed to the presence channel
var count = presenceChannel.members.count

// members.each(function) 
presenceChannel.members.each(function(member) {
    var userId = member.id
    var userInfo = member.info
})

// members.get(UserId)
var user = presenceChannel.members.get('some_user_id')

// members.me
var me = presenceChannel.members.me
// the me prooperty represents a member object and has an id and info preperty

var pusher = new Pusher('app_key');
var presenceChannel = pusher.subscribe('presence-example');
presenceChannel.bind('pusher:subscription_succeeded', function() {
  var me = presenceChannel.members.me;
  var userId = me.id;
  var userInfo = me.info;
});
~~~

##### Presence Channel Events

~~~js
//1. pusher:subscription_succeeded
var channel = pusher.subscribe('presence-meeting-11');

channel.bind('pusher:subscription_succeeded', function(members) {
  // for example
  update_member_count(members.count);

  members.each(function(member) {
    // for example:
    add_member(member.id, member.info);
  });
})

//2. pusher:member_added
channel.bind('pusher:member_added', function(member) {
  // for example:
  add_member(member.id, member.info);
});

//3. pusher:member_removed
channel.bind('pusher:member_removed', function(member) {
    remove_member(member.id, member.info)
})
~~~



### Events

Events are the primary method of packaging messages in the Channels system. they form the basis of all communication.

They are essentially ‘named messages’ which means you can set up ‘handlers’ in your client code to deal with the various types. As such they are used for ‘client-side’ routing, and should not be used as filters (channels can do this much more efficiently on the server side).

Events can be seen as a notification of something happening on your system, and they are often named in the past tense. For example: `message-created`, `todo-finished`.



### Global Configuration

~~~js
//1. Pusher.host

//2. Pusher.channel_auth_endpoint
default is 'pusher/auth'

//3. Pusher.channel_auth_transport
* ajax
* jsonp

//4. Pusher.log

Pusher.log = function(message) {
	if(window.console && window.console.log) {
		window.console.log(message)
	}
}
~~~





## Server Channel API

#### Server API Overview

~~~ruby
# gem install pusher
require 'pusher'
pusher_client = Pusher::Client.new(
  app_id: 'APP_ID',
  key: 'APP_KEY',
  secret: 'APP_SECRET',
  cluster: 'APP_CLUSTER'
)

class HelloWorldController < ApplicationController
  def hello_world
    pusher_client.trigger('my-channel', 'my-event', {message: 'hello world'})
  end
end
~~~



#### Interacting With Our HTTP API

~~~ruby
# trigger

require 'pusher'

pusher_client = Pusher::Client.new(
  app_id: 'APP_ID',
  key: 'APP_KEY',
  secret: 'APP_SECRET',
  cluster: 'APP_CLUSTER'
)

pusher_client.trigger(channels, event, data)

#1. publish an event on a single channel
pusher_client.trigger('my-channel', 'my-event', {:message => 'hello world'})

#2. publish an event on multiple channels
my_channels = ['my-channel-1', 'my-channel-2', 'my-channel-3']
pusher_client.trigger(my_channels, 'my-event', {message: 'hello world'})

#3. publish batches of events
pusher_client.trigger_each([
    {channel: 'my-channel-1', name: 'my-event-1', data: {foo: 'bar'}},
    {channel: 'my-channel-2', name: 'my-event-2', data: {hello: 'world'}}
    ])
~~~

the parameters passed to the `trigger` function are:

* channels: either a single channel named as a string or an array of channel names 
* event: the name of event to be triggered
* data: the data to be sent with the event.
* socket_id: Optional. the socket ID of a client to be exclued from receiving the event



除此之外，我们还可以直接调用`Push API`,但是并不推荐这么做。

上述的`trigger`实际上就是调用`Pusher HTTP API`来完成消息的推送。



### Webhooks

> Webhooks allow your server to be notified about events occurring with Channels.



我们可以在 `pusher web_hooks`项目页面添加`webhook`:

* Channel Existenace
* Presence
* Client Event



~~~ruby
# channel existence example
class PusherController < ApplicationController

  def webhook
    webhook = Pusher::WebHook.new(request)
    if webhook.valid?
      webhook.events.each do |event|
        case event["name"]
        when 'channel_occupied'
          puts "Channel occupied: #{event["channel"]}"
        when 'channel_vacated'
          puts "Channel vacated: #{event["channel"]}"
        end
      end
      render text: 'ok'
    else
      render text: 'invalid', status: 401
    end
  end

end
~~~



### Authenticating Users

信道提供认证机制来保证用户是否有权限订阅某个信道。

* Private Channel
* Presence Channel




## Slanger





### 本地启动`Slanger`

~~~shell
slanger --app_key your_app_key 
		--secret your_secret 
		-a 0.0.0.0:4567 
		-w 0.0.0.0:13456 
		--verbose
~~~

~~~
-k or --app_key This is the Pusher app key you want to use. This is a required argument on command line or in optional config file

-s or --secret This is your Pusher secret. This is a required argument on command line or in optional config file

-C or --config_file Path to Yaml file that can contain all or some of the configuration options, including required arguments

-r or --redis_address An address where there is a Redis server running. This is an optional argument and defaults to redis://127.0.0.1:6379/0

-a or --api_host This is the address that Slanger will bind the HTTP REST API part of the service to. This is an optional argument and defaults to 0.0.0.0:4567

-w or --websocket_host This is the address that Slanger will bind the WebSocket part of the service to. This is an optional argument and defaults to 0.0.0.0:8080

-i or --require Require an additional file before starting Slanger to tune it to your needs. This is an optional argument

-p or --private_key_file Private key file for SSL support. This argument is optional, if given, SSL will be enabled

-b or --webhook_url URL for webhooks. This argument is optional, if given webhook callbacks will be made http://pusher.com/docs/webhooks

-c or --cert_file Certificate file for SSL support. This argument is optional, if given, SSL will be enabled

-v or --[no-]verbose This makes Slanger run verbosely, meaning WebSocket frames will be echoed to STDOUT. Useful for debugging

--pid_file  The path to a file you want slanger to write it's PID to. Optional.
~~~



HTML片段

~~~html
<!DOCTYPE html>
<head>
  <title>Pusher Test</title>
  <script src="https://js.pusher.com/4.3/pusher.min.js"></script>
  <script>

    // Enable pusher logging - don't include this in production
    Pusher.logToConsole = true;

    var pusher = new Pusher('eb8381005e3dc215081b', {
      authEndpoint: 'http://localhost:3000/api/v3/stream/pusher/auth',
      httpHost: '0.0.0.0',
      httpPort: 4567,
      wsHost: '0.0.0.0',
      wsPort: 13456,
      cluster: 'ap1'
    });

    var channel = pusher.subscribe('my-channel');
    channel.bind('my-event', function(data) {
      console.log(">>>> my-event data: " + JSON.stringify(data));
    });

    // private channel
    // pusher will call authEndpoint to authenticate before binding events
    var private_channel = pusher.subscribe('private-COIN56VKYZZGX');
    private_channel.bind('members', function(data) {
      console.log('>>> member update info: ' + JSON.stringify(data))
    })

  </script>
</head>
<body>
  <h1>Pusher Test</h1>
  <p>
    Try publishing an event to channel <code>my-channel</code>
    with event name <code>my-event</code>.
  </p>
</body>

~~~

后台任务中，我们需要指定`channel`、`events`、`data`

~~~ruby
def sync_update
    messages = { type: 'update', id: id, attributes: changes_attributes_as_json }
    ::Pusher["private-#{sn}"].trigger_async('members', messages)
    # ::Pusher.trigger_async("private-#{sn}", 'members', messages)
  end
~~~

上面的推送我们采用的异步方式`async`:

* In a web application where the response from the Pusher Channels HTTP API is not used, but you'd like to avoid a blocking call in the request-response cycle
* Your application is running in an event loop and you need to avoid blocking the reactor

Asynchronous calls are supported either by using an event loop (eventmachine, preferred), or via a thread.



The following methods are available (in each case the calling interface matches the non-async version):

- `channels_client.get_async`
- `channels_client.post_async`
- `channels_client.trigger_async`

It is of course also possible to make calls to the Pusher Channels HTTP API via a job queue. This approach is recommended if you're sending a large number of events.