---
layout: post
toc: true
permalink: /rack-rails
title: Ruby Rack 协议及其应用(三)
tags: Rack系列  rack  ruby  rails  server
desc:  Rack是Ruby应用服务器和Rack应用程序之间的一个接口,用于两者之间的交互. 不仅仅是大名鼎鼎的Ruby on Rails ,几乎所有的Ruby Web 框架都是一个Rack应用. 除了Web框架之外, Rack同样支持很多Ruby Web服务器. 本篇文章着重讲述 `Ruby on Rails`框架的启动过程.
---

## Ruby on Rails 启动流程

我们从 `rails server` 这个指令开始来解读`Ruby on Rails`的启动流程.


### 源码阅读前的准备

#### Pry Use

#### Ruby File Operation

阅读源码时需要用到文件路径的几个方法, 先在这里总结一下.


1. `__FILE__` 是一个常量, 返回一个带文件后缀的文件名.

2. `File.dirname` 返回当前文件的相对路径
> Returns all components of the filename given in file_name except the last one. The filename can be formed using both File::SEPARATOR and File::ALT_SEPARATOR as the separator when File::ALT_SEPARATOR is not nil.

~~~ruby
File.dirname("/home/gumby/work/ruby.rb")
# => "/home/gumby/work"
~~~

3. `File.expand_path`, 将路径名转换为绝对路径返回.
> Converts a pathname to an absolute pathname. Relative paths are referenced from the current working directory of the process unless dir_string is given, in which case it will be used as the starting point. The given pathname may start with a “~”, which expands to the process owner’s home directory (the environment variable HOME must be set correctly). “~user” expands to the named user’s home directory.

~~~ruby
File.expand_path('.')
# => return current absolute path
~~~


~~~test.rb
puts "__FILE__ is #{__FILE__}"
puts "File.dirname(__FILE__) is #{File.dirname(__FILE__)}"
puts "File.expand_path(File.dirname(__FILE__)) is #{File.expand_path(File.dirname(__FILE__))}"
~~~

输出结果如下:

~~~shell
__FILE__ is hehe.rb
File.dirname(__FILE__) is .
File.expand_path(File.dirname(__FILE__)) is /Users/bobo/Tool/hehe

~~~


### Railtie类 -> Ruby On Rails 内部引擎


### 启动

熟悉`Ruby on Rails`的同学可以知道, 我们可以通过`rails console` 或者 `rails server` 命令启动`Rails`应用.

#### railties/exe/rails
在某个Rails项目的命令行中运行如下指令可以定位我们使用的`rails`

~~~shell
where rails
# => /Users/bobo/.rvm/gems/ruby-2.4.2/bin/rails
~~~

`rails server` 命令中的 `rails` 就位于上述的一个`Ruby`可执行文件. 文件内容如下:

~~~ruby
λ cat /Users/bobo/.rvm/gems/ruby-2.4.2/bin/rails
#!/usr/bin/env ruby
#
# This file was generated by RubyGems.
#
# The application 'railties' is installed as part of a gem, and
# this file is here to facilitate running it.
#

require 'rubygems'

version = ">= 0.a"

if ARGV.first
  str = ARGV.first
  str = str.dup.force_encoding("BINARY") if str.respond_to? :force_encoding
  if str =~ /\A_(.*)_\z/ and Gem::Version.correct?($1) then
    version = $1
    ARGV.shift
  end
end

if Gem.respond_to?(:activate_bin_path)
  load Gem.activate_bin_path('railties', 'rails', version)
else
  gem "railties", version
  load Gem.bin_path("railties", "rails", version)
end

~~~

在 `Rails Console`中运行上述代码, 我们可以看到加载的文件如下:

~~~shell
"/Users/bobo/.rvm/gems/ruby-2.4.2/gems/railties-5.1.6/exe/rails"
~~~

让我们来看一下这个文件的内容:
~~~ruby
#!/usr/bin/env ruby

git_path = File.expand_path("../../../.git", __FILE__)
# => /Users/bobo/.rvm/gems/ruby-2.4.2/gems/.git

if File.exist?(git_path)
  railties_path = File.expand_path("../../lib", __FILE__)
  $:.unshift(railties_path)
end

require "rails/cli"
~~~

关键代码就是最后一行, 加载 `rails/cli` 文件.

~~~ruby
# frozen_string_literal: true

require "rails/app_loader"

# If we are inside a Rails application this method performs an exec and thus
# the rest of this script is not run.
Rails::AppLoader.exec_app

require "rails/ruby_version_check"
Signal.trap("INT") { puts; exit(1) }

require "rails/command"

if ARGV.first == "plugin"
  ARGV.shift
  Rails::Command.invoke :plugin, ARGV
else
  Rails::Command.invoke :application, ARGV
end
~~~

#### railties/lib/rails/app_loader.rb

查看文件 `railties/lib/rails/app_loader.rb`:


~~~ruby

RUBY = Gem.ruby
# "/Users/bobo/.rvm/rubies/ruby-2.4.2/bin/ruby"
EXECUTABLES = ["bin/rails", "script/rails"]

def exec_app
  original_cwd = Dir.pwd

  loop do
    if exe = find_executable
      contents = File.read(exe)

      if contents =~ /(APP|ENGINE)_PATH/
        exec RUBY, exe, *ARGV
        break # non reachable, hack to be able to stub exec in the test suite
      elsif exe.end_with?("bin/rails") && contents.include?("This file was generated by Bundler")
        $stderr.puts(BUNDLER_WARNING)
        # 设置 APP_PATH 常量
        Object.const_set(:APP_PATH, File.expand_path("config/application", Dir.pwd))
        # 加载 config/root.rb
        require File.expand_path("../boot", APP_PATH)
        # 加载 rails/commands
        require "rails/commands"
        break
      end
    end

    # If we exhaust the search there is no executable, this could be a
    # call to generate a new application, so restore the original cwd.
    Dir.chdir(original_cwd) && return if Pathname.new(Dir.pwd).root?

    # Otherwise keep moving upwards in search of an executable.
    Dir.chdir("..")
  end
end

def find_executable
  EXECUTABLES.find { |exe| File.file?(exe) }
end
~~~

`exec_app`方法的主要作用是执行应用中的`bin/rails`文件.
如果在当前文件夹未找到`bin/rails`文件, 就会继续在上层文件夹中查找, 直到找到为止. 因此, 我们可以在一个`Rails`应用中的任何位置执行`rails 命令`.

执行 `rails server` 实际上就相当于执行 `exec ruby bin/rails server`


#### bin/rails 文件

~~~ruby
#!/usr/bin/env ruby
begin
  load File.expand_path('../spring', __FILE__)
rescue LoadError => e
  raise unless e.message.include?('spring')
end

APP_PATH = File.expand_path('../config/application', __dir__)
# => "/Users/bobo/bobo/risewinter/Project/AW/config/application"

require_relative '../config/boot'
# boot 用于加载并设置 Bundler

require 'rails/commands'
# 加载 commands 文件

~~~

#### config/boot.rb

~~~ruby
ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../Gemfile', __dir__)
# 设置 环境变量: BUNDLE_GEMFILE

require 'bundler/setup' # Set up gems listed in the Gemfile.
~~~

标准的Rails应用中包含`Gemfile`文件, 用于声明应用的所有依赖关系. `config/boot.rb`文件会把`ENV['BUNDLE_GEMFILE']`设置为`Gemfile`文件的路径.
如果`Gemfile`文件存在, 就会加载`bundler/setup`, `Bundler`通过它设置`Gemfile`中依赖关系的加载路径.


#### rails/commands.rb

`bin/rails`文件中执行 `config/boot.rb`文件的代码之后, 下一步就是要加载`rails/commands`,作用就是扩展命令别名.
我们在命令行中输入`rails server`, ARGV 数组只包含将要传递的`server`命令:

~~~ruby
# frozen_string_literal: true

require "rails/command"

aliases = {
  "g"  => "generate",
  "d"  => "destroy",
  "c"  => "console",
  "s"  => "server",
  "db" => "dbconsole",
  "r"  => "runner",
  "t"  => "test"
}

command = ARGV.shift
command = aliases[command] || command

Rails::Command.invoke command, ARGV

~~~

#### rails/command.rb

~~~ruby
# namespace = server

# Receives a namespace, arguments and the behavior to invoke the command.
def invoke(full_namespace, args = [], **config)
  namespace = full_namespace = full_namespace.to_s

  if char = namespace =~ /:(\w+)$/
    command_name, namespace = $1, namespace.slice(0, char)
  else
    command_name = namespace
  end

  command_name, namespace = "help", "help" if command_name.blank? || HELP_MAPPINGS.include?(command_name)
  command_name, namespace = "version", "version" if %w( -v --version ).include?(command_name)

  command = find_by_namespace(namespace, command_name)
  if command && command.all_commands[command_name]
    command.perform(command_name, args, config)
  else
    find_by_namespace("rake").perform(full_namespace, args, config)
  end
end
~~~

当我们输入`Rails`命令时, `invoke`尝试查找指定命名空间的命令, 如果找到就执行那个命令.
如果找不到, `Rails`委托`rake`执行同名任务.

我们输入的`rails server`命令, 因此`Rails`会进一步运行下面的代码:

~~~ruby
module Rails
  module Command
    class ServerCommand < Base
      def perform
        set_application_directory!
        prepare_restart

        Rails::Server.new(server_options).tap do |server|
          # Require application after server sets environment to propagate
          # the --environment option.
          # config/application.rb
          require APP_PATH
          Dir.chdir(Rails.application.root)

          if server.serveable?
            print_boot_information(server.server, server.served_url)
            after_stop_callback = -> { say "Exiting" unless options[:daemon] }
            server.start(after_stop_callback) # 启动服务器
          else
            say rack_server_suggestion(using)
          end
        end
      end

    end
  end
end
~~~

切换到`Rails 根目录`, 然后运行 `server.start` 方法

#### rails/commands/server/server_command.rb

此文件中定义了`Rails::Server`类, 它继承自`Rack::Server`类.
当调用`Rails::Server.new`方法时, 会调用此文件中定义的`initialize`方法.

~~~ruby
def initialize
  super
  set_enviroment
end
~~~

`super`关键字会调用`Rack::Server`类的`initialize`方法.

#### Rack: lib/rack/server.rb

又回到了我们之前讲述过的`Rack`了.`Rack::Server`类负责所有基于`Rack`的应用(包括Rails)提供通用服务器接口.
`Rack::Server`类的`initialize`方法作用主要是设置几个变量.


### 加载 Rails
