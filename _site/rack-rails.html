<!DOCTYPE html>
<html>
  <head>
    <!-- [[! Document Settings ]] -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- [[! Page Meta ]] -->
    <title>
      
        Ruby Rack 协议及其应用(三)
      
    </title>
    
    <meta name="description" content="Rack是Ruby应用服务器和Rack应用程序之间的一个接口,用于两者之间的交互. 不仅仅是大名鼎鼎的Ruby on Rails ,几乎所有的Ruby Web 框架都是一个Rack应用. 除了Web框架之外, Rack同样支持很多Ruby Web服务器. 本篇文章着重讲述 `Ruby on Rails`框架的启动过程." />
    

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="/assets/images/favicon.ico" >

    <!-- [[! Styles'n'Scripts ]] -->
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css"
      href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />

    <link rel="stylesheet" type="text/css" href="/assets/css/prism.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/toc.css" />

    <!-- [[! Ghost outputs important style and meta data with this tag ]] -->
    <link rel="canonical" href="/" />
<meta name="referrer" content="origin" />
<link rel="next" href="/page2/" />

<meta property="og:site_name" content="雄关漫道真如铁" />
<meta property="og:type" content="website" />
<meta property="og:title" content="Ruby Rack 协议及其应用(三)" />

<meta property="og:description" content="Rack是Ruby应用服务器和Rack应用程序之间的一个接口,用于两者之间的交互. 不仅仅是大名鼎鼎的Ruby on Rails ,几乎所有的Ruby Web 框架都是一个Rack应用. 除了Web框架之外, Rack同样支持很多Ruby Web服务器. 本篇文章着重讲述 `Ruby on Rails`框架的启动过程." />

<meta property="og:url" content="http://localhost:4000/rack-rails" />
<meta property="og:image" content="" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Ruby Rack 协议及其应用(三)" />

<meta name="twitter:description" content="Rack是Ruby应用服务器和Rack应用程序之间的一个接口,用于两者之间的交互. 不仅仅是大名鼎鼎的Ruby on Rails ,几乎所有的Ruby Web 框架都是一个Rack应用. 除了Web框架之外, Rack同样支持很多Ruby Web服务器. 本篇文章着重讲述 `Ruby on Rails`框架的启动过程." />

<meta name="twitter:url" content="http://localhost:4000/rack-rails" />
<meta name="twitter:image:src" content="" />

<script type="application/ld+json">
  {
  "@context": "http://schema.org",
  "@type": "Website",
  "publisher": "nju520",
  "url": "http://localhost:4000/rack-rails",
  "image": "",
  "description": "Rack是Ruby应用服务器和Rack应用程序之间的一个接口,用于两者之间的交互. 不仅仅是大名鼎鼎的Ruby on Rails ,几乎所有的Ruby Web 框架都是一个Rack应用. 除了Web框架之外, Rack同样支持很多Ruby Web服务器. 本篇文章着重讲述 `Ruby on Rails`框架的启动过程."
  }
</script>

<meta name="generator" content="Jekyll 3.0.0" />
<link rel="alternate" type="application/rss+xml" title="雄关漫道真如铁" href="/feed.xml" />

    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
<script>
 (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
 })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

 ga('create', 'UA-114647632-1', 'auto');
 ga('send', 'pageview', location.pathname);

</script>

<!-- Baidu Analytics  Manager -->
<script>
 var _hmt = _hmt || [];
 (function() {
   var hm = document.createElement("script");
   hm.src = "https://hm.baidu.com/hm.js?e9208862845c46a0f79e7828f495e407";
   var s = document.getElementsByTagName("script")[0];
   s.parentNode.insertBefore(hm, s);
 })();
</script>

<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-PWFC85B');</script>
  <!-- End Google Tag Manager -->


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-114647632-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-114647632-1');
</script>

  </head>
  <body class=" post-template nav-closed">
    <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PWFC85B"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->


    <div class="nav">
  <h3 class="nav-title">Home</h3>
  <a href="#" class="nav-close">
    <span class="hidden">Close</span>
  </a>
  <ul>
    <li class="nav-home " role="presentation"><a href="/">Home</a></li>
    <li class="nav-ruby " role="presentation"><a href="/tag/ruby">Ruby</a></li>
    <li class="nav-javascript " role="presentation"><a href="/tag/javascript">JavaScript</a></li>
    <li class="nav-server " role="presentation"><a href="/tag/server">Server</a></li>
    <li class="nav-database " role="presentation"><a href="/tag/database">Database</a></li>
  </ul>
  <a class="subscribe-button icon-feed" href="/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

      <!-- [[! Everything else gets inserted here ]] -->
      <!-- < default -->

<!-- The comment above "< default" means - insert everything in this file into -->
<!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head no-cover">
  <nav class="main-nav overlay clearfix">
    <a class="back-button icon-arrow-left" href="/">Home</a>
    <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
  </nav>
</header>

<main class="content" role="main">

  <article class="post">

    <header class="post-template post-header">
      <h1 class="post-title">Ruby Rack 协议及其应用(三)</h1>
      <section class="post-meta">
        <time class="post-date" datetime="2017-11-05">05 Nov 2017</time>
        <!-- <a href='/'>nju520</a> -->
        <!-- [[tags prefix=" on "]] -->
        
        
        <a href='/tag/Rack系列'>Rack系列</a>
        
        <a href='/tag/rack'>rack</a>
        
        <a href='/tag/ruby'>ruby</a>
        
        <a href='/tag/rails'>rails</a>
        
        <a href='/tag/server'>server</a>
        
        
      </section>
    </header>

    <section class="post-content">

      <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#ruby-on-rails-启动流程">Ruby on Rails 启动流程</a>
<ul>
<li class="toc-entry toc-h3"><a href="#源码阅读前的准备">源码阅读前的准备</a>
<ul>
<li class="toc-entry toc-h4"><a href="#pry-use">Pry Use</a></li>
<li class="toc-entry toc-h4"><a href="#ruby-file-operation">Ruby File Operation</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#railtie类---ruby-on-rails-内部引擎">Railtie类 -> Ruby On Rails 内部引擎</a></li>
<li class="toc-entry toc-h3"><a href="#rails-applciation-api-guide">Rails Applciation API Guide</a></li>
<li class="toc-entry toc-h3"><a href="#server-的启动">Server 的启动</a>
<ul>
<li class="toc-entry toc-h5"><a href="#railtiesexerails">railties/exe/rails</a></li>
<li class="toc-entry toc-h5"><a href="#railtieslibrailsapp_loaderrb">railties/lib/rails/app_loader.rb</a></li>
<li class="toc-entry toc-h5"><a href="#binrails-文件">bin/rails 文件</a></li>
<li class="toc-entry toc-h5"><a href="#railscommandsrb">rails/commands.rb</a></li>
<li class="toc-entry toc-h5"><a href="#railscommandrb">rails/command.rb</a></li>
<li class="toc-entry toc-h4"><a href="#初始化-server">初始化 server</a>
<ul>
<li class="toc-entry toc-h5"><a href="#railscommandsserverserver_commandrb">rails/commands/server/server_command.rb</a></li>
<li class="toc-entry toc-h5"><a href="#rack-librackserverrb">Rack: lib/rack/server.rb</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#加载-app_path">加载 APP_PATH</a></li>
<li class="toc-entry toc-h4"><a href="#configapplicationrb">config/application.rb</a>
<ul>
<li class="toc-entry toc-h6"><a href="#加载-boot">加载 boot</a></li>
<li class="toc-entry toc-h5"><a href="#加载-railties-and-engines">加载 railties and engines</a></li>
<li class="toc-entry toc-h5"><a href="#define-railsapplication-as-class-myappapplication--railsapplication">Define Rails.application as class MyApp::Application < Rails::Application</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#server-启动">server 启动</a>
<ul>
<li class="toc-entry toc-h5"><a href="#configenvironmentrb">config/environment.rb</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#configapplicationrb-1">config/application.rb</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#加载-rails">加载 Rails</a>
<ul>
<li class="toc-entry toc-h5"><a href="#回到-configenvironmentrb-文件">回到 config/environment.rb 文件</a></li>
<li class="toc-entry toc-h5"><a href="#railtieslibrailsapplicationrb">railties/lib/rails/application.rb</a></li>
<li class="toc-entry toc-h5"><a href="#步骤5-load-configenviromentsenvrb">步骤5: Load config/enviroments/ENV.rb</a></li>
<li class="toc-entry toc-h5"><a href="#步骤6-run-configbefore_initialize-callbacks">步骤6: Run config.before_initialize callbacks</a></li>
<li class="toc-entry toc-h5"><a href="#rails应用config目录下的initializers执行的源码位置">Rails应用config目录下的initializers执行的源码位置:</a></li>
<li class="toc-entry toc-h5"><a href="#步骤9-build-the-middleware-stack-and-run-to_prepare-callbacks">步骤9: Build the middleware stack and run to_prepare callbacks</a></li>
<li class="toc-entry toc-h5"><a href="#9-run-to_prepare-callbacks">9) run to_prepare callbacks</a></li>
<li class="toc-entry toc-h5"><a href="#步骤10-run-configbefore_eager_load-and-eager_load-if-eager_load-is-true">步骤10: Run config.before_eager_load and eager_load! if eager_load is true</a></li>
<li class="toc-entry toc-h5"><a href="#步骤11-run-configafter_initialize-callbacks">步骤11: Run config.after_initialize callbacks</a></li>
<li class="toc-entry toc-h4"><a href="#rack-librackserverrb-1">Rack: lib/rack/server.rb</a></li>
</ul>
</li>
</ul>
</li>
</ul><h2 id="ruby-on-rails-启动流程">
<a id="ruby-on-rails-启动流程" class="anchor" href="#ruby-on-rails-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ruby on Rails 启动流程</h2>

<p>我们从 <code>rails server</code> 这个指令开始来解读<code>Ruby on Rails</code>的启动流程.</p>

<h3 id="源码阅读前的准备">
<a id="源码阅读前的准备" class="anchor" href="#%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87" aria-hidden="true"><span class="octicon octicon-link"></span></a>源码阅读前的准备</h3>

<h4 id="pry-use">
<a id="pry-use" class="anchor" href="#pry-use" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pry Use</h4>

<h4 id="ruby-file-operation">
<a id="ruby-file-operation" class="anchor" href="#ruby-file-operation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ruby File Operation</h4>

<p>阅读源码时需要用到文件路径的几个方法, 先在这里总结一下.</p>

<ol>
  <li>
    <p><code>__FILE__</code> 是一个常量, 返回一个带文件后缀的文件名.</p>
  </li>
  <li>
    <p><code>File.dirname</code> 返回当前文件的相对路径</p>
    <blockquote>
      <p>Returns all components of the filename given in file_name except the last one. The filename can be formed using both File::SEPARATOR and File::ALT_SEPARATOR as the separator when File::ALT_SEPARATOR is not nil.</p>
    </blockquote>
  </li>
</ol>

<pre><code class="language-ruby">File.dirname("/home/gumby/work/ruby.rb")
# =&gt; "/home/gumby/work"
</code></pre>

<ol>
  <li>
<code>File.expand_path</code>, 将路径名转换为绝对路径返回.
    <blockquote>
      <p>Converts a pathname to an absolute pathname. Relative paths are referenced from the current working directory of the process unless dir_string is given, in which case it will be used as the starting point. The given pathname may start with a “~”, which expands to the process owner’s home directory (the environment variable HOME must be set correctly). “~user” expands to the named user’s home directory.</p>
    </blockquote>
  </li>
</ol>

<pre><code class="language-ruby">File.expand_path('.')
# =&gt; return current absolute path
</code></pre>

<pre><code class="language-test.rb">puts "__FILE__ is #{__FILE__}"
puts "File.dirname(__FILE__) is #{File.dirname(__FILE__)}"
puts "File.expand_path(File.dirname(__FILE__)) is #{File.expand_path(File.dirname(__FILE__))}"
</code></pre>

<p>输出结果如下:</p>

<pre><code class="language-shell">__FILE__ is hehe.rb
File.dirname(__FILE__) is .
File.expand_path(File.dirname(__FILE__)) is /Users/bobo/Tool/hehe

</code></pre>

<h3 id="railtie类---ruby-on-rails-内部引擎">
<a id="railtie类---ruby-on-rails-内部引擎" class="anchor" href="#railtie%E7%B1%BB---ruby-on-rails-%E5%86%85%E9%83%A8%E5%BC%95%E6%93%8E" aria-hidden="true"><span class="octicon octicon-link"></span></a>Railtie类 -&gt; Ruby On Rails 内部引擎</h3>

<h3 id="rails-applciation-api-guide">
<a id="rails-applciation-api-guide" class="anchor" href="#rails-applciation-api-guide" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rails Applciation API Guide</h3>

<p>熟悉<code>Ruby on Rails</code>的同学可以知道, 我们可以通过<code>rails console</code> 或者 <code>rails server</code> 命令启动<code>Rails</code>应用.</p>

<p>在<code>Rails API</code>文档中(5.2.0), 关于<code>Application</code>这个类的介绍写到了一个<code>Rails Application</code>的启动流程:</p>

<pre><code class="language-ruby">1)  require "config/boot.rb" to setup load paths
2)  require railties and engines
3)  Define Rails.application as "class MyApp::Application &lt; Rails::Application"
4)  Run config.before_configuration callbacks
5)  Load config/environments/ENV.rb
6)  Run config.before_initialize callbacks
7)  Run Railtie#initializer defined by railties, engines and application.
    One by one, each engine sets up its load paths, routes and runs its config/initializers/* files.
8)  Custom Railtie#initializers added by railties, engines and applications are executed
9)  Build the middleware stack and run to_prepare callbacks
10) Run config.before_eager_load and eager_load! if eager_load is true
11) Run config.after_initialize callbacks
</code></pre>

<p>我们就参照上面的启动流程开启<code>Ruby on Rails</code>的启动流程解读.</p>

<h3 id="server-的启动">
<a id="server-的启动" class="anchor" href="#server-%E7%9A%84%E5%90%AF%E5%8A%A8" aria-hidden="true"><span class="octicon octicon-link"></span></a>Server 的启动</h3>

<p>我们直接从<code>rails server</code>这条命令开始定位<code>Server.start</code></p>

<h5 id="railtiesexerails">
<a id="railtiesexerails" class="anchor" href="#railtiesexerails" aria-hidden="true"><span class="octicon octicon-link"></span></a>railties/exe/rails</h5>

<p>在某个Rails项目的命令行中运行如下指令可以定位我们使用的<code>rails</code></p>

<pre><code class="language-shell">where rails
# =&gt; /Users/bobo/.rvm/gems/ruby-2.4.2/bin/rails
</code></pre>

<p><code>rails server</code> 命令中的 <code>rails</code> 就位于上述的一个<code>Ruby</code>可执行文件. 文件内容如下:</p>

<pre><code class="language-ruby">λ cat /Users/bobo/.rvm/gems/ruby-2.4.2/bin/rails
#!/usr/bin/env ruby
#
# This file was generated by RubyGems.
#
# The application 'railties' is installed as part of a gem, and
# this file is here to facilitate running it.
#

require 'rubygems'

version = "&gt;= 0.a"

if ARGV.first
  str = ARGV.first
  str = str.dup.force_encoding("BINARY") if str.respond_to? :force_encoding
  if str =~ /\A_(.*)_\z/ and Gem::Version.correct?($1) then
    version = $1
    ARGV.shift
  end
end

if Gem.respond_to?(:activate_bin_path)
  load Gem.activate_bin_path('railties', 'rails', version)
else
  gem "railties", version
  load Gem.bin_path("railties", "rails", version)
end

</code></pre>

<p>在 <code>Rails Console</code>中运行上述代码, 我们可以看到加载的文件如下:</p>

<pre><code class="language-shell">"/Users/bobo/.rvm/gems/ruby-2.4.2/gems/railties-5.1.6/exe/rails"
</code></pre>

<p>让我们来看一下这个文件的内容:</p>
<pre><code class="language-ruby">#!/usr/bin/env ruby

git_path = File.expand_path("../../../.git", __FILE__)
# =&gt; /Users/bobo/.rvm/gems/ruby-2.4.2/gems/.git

if File.exist?(git_path)
  railties_path = File.expand_path("../../lib", __FILE__)
  $:.unshift(railties_path)
end

# 关键代码
require "rails/cli"
</code></pre>

<p>关键代码就是最后一行, 加载 <code>rails/cli</code> 文件.</p>

<pre><code class="language-ruby"># frozen_string_literal: true

require "rails/app_loader"

# If we are inside a Rails application this method performs an exec and thus
# the rest of this script is not run.
Rails::AppLoader.exec_app

require "rails/ruby_version_check"
Signal.trap("INT") { puts; exit(1) }

require "rails/command"

if ARGV.first == "plugin"
  ARGV.shift
  Rails::Command.invoke :plugin, ARGV
else
  Rails::Command.invoke :application, ARGV
end
</code></pre>

<h5 id="railtieslibrailsapp_loaderrb">
<a id="railtieslibrailsapp_loaderrb" class="anchor" href="#railtieslibrailsapp_loaderrb" aria-hidden="true"><span class="octicon octicon-link"></span></a>railties/lib/rails/app_loader.rb</h5>

<p>查看文件 <code>railties/lib/rails/app_loader.rb</code>:</p>

<pre><code class="language-ruby">
RUBY = Gem.ruby
# "/Users/bobo/.rvm/rubies/ruby-2.4.2/bin/ruby"
EXECUTABLES = ["bin/rails", "script/rails"]

def exec_app
  original_cwd = Dir.pwd

  loop do
    if exe = find_executable
      contents = File.read(exe)

      if contents =~ /(APP|ENGINE)_PATH/
        exec RUBY, exe, *ARGV
        break # non reachable, hack to be able to stub exec in the test suite
      elsif exe.end_with?("bin/rails") &amp;&amp; contents.include?("This file was generated by Bundler")
        # 以下情况只有在 bin/rails 中没有 APP_PATH 或者 ENGINE_PATH时才会设置
        $stderr.puts(BUNDLER_WARNING)
        # 设置 APP_PATH 常量
        Object.const_set(:APP_PATH, File.expand_path("config/application", Dir.pwd))
        # 加载 config/root.rb
        require File.expand_path("../boot", APP_PATH)
        # 加载 rails/commands
        require "rails/commands"
        break
      end
    end

    # If we exhaust the search there is no executable, this could be a
    # call to generate a new application, so restore the original cwd.
    Dir.chdir(original_cwd) &amp;&amp; return if Pathname.new(Dir.pwd).root?

    # Otherwise keep moving upwards in search of an executable.
    Dir.chdir("..")
  end
end

def find_executable
  EXECUTABLES.find { |exe| File.file?(exe) }
end
</code></pre>

<p><code>exec_app</code>方法的主要作用是执行应用中的<code>bin/rails</code>文件.
如果在当前文件夹未找到<code>bin/rails</code>文件, 就会继续在上层文件夹中查找, 直到找到为止. 因此, 我们可以在一个<code>Rails</code>应用中的任何位置执行<code>rails 命令</code>.</p>

<p>执行 <code>rails server</code> 实际上就相当于执行 <strong><code>exec ruby bin/rails server</code></strong></p>

<h5 id="binrails-文件">
<a id="binrails-文件" class="anchor" href="#binrails-%E6%96%87%E4%BB%B6" aria-hidden="true"><span class="octicon octicon-link"></span></a>bin/rails 文件</h5>

<pre><code class="language-ruby">#!/usr/bin/env ruby
begin
  load File.expand_path('../spring', __FILE__)
rescue LoadError =&gt; e
  raise unless e.message.include?('spring')
end

APP_PATH = File.expand_path('../config/application', __dir__)
# =&gt; "/Users/bobo/bobo/risewinter/Project/AW/config/application"

require_relative '../config/boot'
# boot 用于加载并设置 Bundler

require 'rails/commands'
# 加载 commands 文件
# 用来响应 rails server 这条指令

</code></pre>

<p>PS: 程序执行到<code>app_loader.rb</code>还未加载 <code>config/application.rb</code>.</p>

<h5 id="railscommandsrb">
<a id="railscommandsrb" class="anchor" href="#railscommandsrb" aria-hidden="true"><span class="octicon octicon-link"></span></a>rails/commands.rb</h5>

<p><code>bin/rails</code>文件中执行 <code>config/boot.rb</code>文件的代码之后, 下一步就是要加载<code>rails/commands</code>,作用就是扩展命令别名.
我们在命令行中输入<code>rails server</code>, ARGV 数组只包含将要传递的<code>server</code>命令:</p>

<pre><code class="language-ruby"># frozen_string_literal: true

require "rails/command"

aliases = {
  "g"  =&gt; "generate",
  "d"  =&gt; "destroy",
  "c"  =&gt; "console",
  "s"  =&gt; "server",
  "db" =&gt; "dbconsole",
  "r"  =&gt; "runner",
  "t"  =&gt; "test"
}

command = ARGV.shift
command = aliases[command] || command

# rails server 命令执行时, 会调用下面一行代码
# command =&gt; server
# ARGV =&gt; 命令行参数
Rails::Command.invoke command, ARGV

</code></pre>

<h5 id="railscommandrb">
<a id="railscommandrb" class="anchor" href="#railscommandrb" aria-hidden="true"><span class="octicon octicon-link"></span></a>rails/command.rb</h5>

<pre><code class="language-ruby"># namespace = server

# Receives a namespace, arguments and the behavior to invoke the command.
def invoke(full_namespace, args = [], **config)
  namespace = full_namespace = full_namespace.to_s

  if char = namespace =~ /:(\w+)$/
    command_name, namespace = $1, namespace.slice(0, char)
  else
    command_name = namespace
  end

  command_name, namespace = "help", "help" if command_name.blank? || HELP_MAPPINGS.include?(command_name)
  command_name, namespace = "version", "version" if %w( -v --version ).include?(command_name)

  command = find_by_namespace(namespace, command_name)
  if command &amp;&amp; command.all_commands[command_name]
    command.perform(command_name, args, config)
  else
    find_by_namespace("rake").perform(full_namespace, args, config)
  end
end
</code></pre>

<p>当我们输入<code>Rails</code>命令时, <code>invoke</code>尝试查找指定命名空间的命令, 如果找到就执行那个命令.
如果找不到, <code>Rails</code>委托<code>rake</code>执行同名任务.</p>

<p>我们输入的<code>rails server</code>命令, 因此<code>Rails</code>会进一步运行下面的代码:</p>

<pre><code class="language-ruby">module Rails
  module Command
    class ServerCommand &lt; Base
      def perform
        set_application_directory!
        prepare_restart

        # 关键点(一)
        Rails::Server.new(server_options).tap do |server|
          # Require application after server sets environment to propagate
          # the --environment option.
          # config/application.rb
          # 关键点(二)
          require APP_PATH
          Dir.chdir(Rails.application.root)

          if server.serveable?
            print_boot_information(server.server, server.served_url)
            after_stop_callback = -&gt; { say "Exiting" unless options[:daemon] }
            # 关键点(三)
            server.start(after_stop_callback) # 启动服务器
          else
            say rack_server_suggestion(using)
          end
        end
      end

    end
  end
end
</code></pre>

<p>上述三个关键点分别对应三个重要环节:</p>

<ul>
  <li>初始化 <code>server</code>
</li>
  <li>加载 <code>APP_PATH</code>
</li>
  <li>启动 <code>server</code>
</li>
</ul>

<h4 id="初始化-server">
<a id="初始化-server" class="anchor" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-server" aria-hidden="true"><span class="octicon octicon-link"></span></a>初始化 server</h4>

<h5 id="railscommandsserverserver_commandrb">
<a id="railscommandsserverserver_commandrb" class="anchor" href="#railscommandsserverserver_commandrb" aria-hidden="true"><span class="octicon octicon-link"></span></a>rails/commands/server/server_command.rb</h5>

<p>此文件中定义了<code>Rails::Server</code>类, 它继承自<code>Rack::Server</code>类.
当调用<code>Rails::Server.new</code>方法时, 会调用此文件中定义的<code>initialize</code>方法.</p>

<pre><code class="language-ruby">def initialize
  super
  set_enviroment
end
</code></pre>

<p><code>super</code>关键字会调用<code>Rack::Server</code>类的<code>initialize</code>方法.</p>

<h5 id="rack-librackserverrb">
<a id="rack-librackserverrb" class="anchor" href="#rack-librackserverrb" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rack: lib/rack/server.rb</h5>

<p>又回到了我们之前讲述过的<code>Rack</code>了.<code>Rack::Server</code>类负责所有基于<code>Rack</code>的应用(包括Rails)提供通用服务器接口.
<code>Rack::Server</code>类的<code>initialize</code>方法作用主要是设置几个变量.</p>

<p>当<code>super</code>方法完成<code>Rack::Server</code>类的<code>initialize</code>方法的调用时, 程序执行流程会重新回到<code>rails/commands/server/server_command.rb</code>文件中,
继续调用<code>set_enviroment</code>方法. 此方法主要用来配置一些基本的参数, 暂且不表.</p>

<p><code>initialize</code>方法运行完成之后, 程序执行流程就会跳回<code>server</code>命令, 加载之前设置的 <code>APP_PATH</code>.</p>

<h4 id="加载-app_path">
<a id="加载-app_path" class="anchor" href="#%E5%8A%A0%E8%BD%BD-app_path" aria-hidden="true"><span class="octicon octicon-link"></span></a>加载 <code>APP_PATH</code>
</h4>

<h4 id="configapplicationrb">
<a id="configapplicationrb" class="anchor" href="#configapplicationrb" aria-hidden="true"><span class="octicon octicon-link"></span></a>config/application.rb</h4>

<p>执行<code>require APP_PATH</code>时, 会加载<code>config/application.rb</code>文件.</p>

<p>在<code>require APP_PATH</code>时, 实际上对应API文档中的流程 1–4.</p>

<pre><code class="language-ruby">1) require "config/boot.rb" to setup load paths
2) require railties and engines
3) Define Rails.application as "class MyApp::Application &lt; Rails::Application"
4) Run config.before_configuration callbacks
</code></pre>

<pre><code class="language-ruby"># config/application.rb
require_relative 'boot'

require 'rails/all'

# Require the gems listed in Gemfile, including any gems
# you've limited to :test, :development, or :production.
Bundler.require(*Rails.groups)

ENV.update YAML.load_file('config/application.yml')[Rails.env] rescue {}

module MyApp
  class Application &lt; Rails::Application
    config.load_defaults 5.1
	config.time_zone = 'Beijing'
  end

end
</code></pre>

<h6 id="加载-boot">
<a id="加载-boot" class="anchor" href="#%E5%8A%A0%E8%BD%BD-boot" aria-hidden="true"><span class="octicon octicon-link"></span></a>加载 boot</h6>

<pre><code class="language-ruby"># config/boot.rb
ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../Gemfile', __dir__)
# 设置 环境变量: BUNDLE_GEMFILE

require 'bundler/setup' # Set up gems listed in the Gemfile.
</code></pre>

<p>标准的Rails应用中包含<code>Gemfile</code>文件, 用于声明应用的所有依赖关系. <code>config/boot.rb</code>文件会把<code>ENV['BUNDLE_GEMFILE']</code>设置为<code>Gemfile</code>文件的路径.</p>

<h5 id="加载-railties-and-engines">
<a id="加载-railties-and-engines" class="anchor" href="#%E5%8A%A0%E8%BD%BD-railties-and-engines" aria-hidden="true"><span class="octicon octicon-link"></span></a>加载 railties and engines</h5>

<p>这个其实是在<code>boot.rb</code>中进行的 <code>bunlder/setup</code>.<code>Bundler</code>通过它设置<code>Gemfile</code>中依赖关系的加载路径.</p>

<p>就相当于把<code>Gemfile</code>中使用的一些<code>gem</code>(这些Gem包含各种Engine或者Railtie)都加载到<code>load_path</code>中</p>

<h5 id="define-railsapplication-as-class-myappapplication--railsapplication">
<a id="define-railsapplication-as-class-myappapplication--railsapplication" class="anchor" href="#define-railsapplication-as-class-myappapplication--railsapplication" aria-hidden="true"><span class="octicon octicon-link"></span></a>Define Rails.application as <code>class MyApp::Application &lt; Rails::Application</code>
</h5>

<p>在<code>config/application.rb</code>文件中, 我们在<code>MyApp</code>中定义了一个类继承<code>Rails::Application</code></p>

<pre><code class="language-ruby">module MyApp
  class Application &lt; Rails::Application
    config.load_defaults 5.1
	config.time_zone = 'Beijing'
  end

end
</code></pre>

<p>当<code>Rails::Application</code>被继承时, 会执行下面的一个<code>callback</code>:</p>

<pre><code class="language-ruby">module Rails
  class Application &lt; Engine
    class &lt;&lt; self
      #当 Rails::Application被继承时, 会调用这个 callback
      def inherited(base)
        super # Engine
        Rails.app_class = base
        add_lib_to_load_path!(find_root(base.called_from))
        ActiveSupport.run_load_hooks(:before_configuration, base)
      end

    end
  end
end
</code></pre>

<ul>
  <li>设置 Rails.application -&gt; MyApp::Application</li>
  <li>加载 lib 目录到 load_path</li>
  <li>执行 <code>config.before_configuration callbacks</code>
</li>
</ul>

<h4 id="server-启动">
<a id="server-启动" class="anchor" href="#server-%E5%90%AF%E5%8A%A8" aria-hidden="true"><span class="octicon octicon-link"></span></a>server 启动</h4>

<p><code>server</code>的启动其实是根据参数来选择一个符合<code>rack</code>规范的具体的<code>server</code>, 比如<code>thin</code> <code>webrick</code>.</p>

<p><code>config/application.rb</code>文件加载完毕之后, 就会调用<code>server.start</code>方法.</p>

<pre><code class="language-ruby">
def start
  print_boot_information # 打印启动信息
  trap(:INT) { exit }
  create_tmp_directories # 创建 tmp 目录
  setup_dev_caching
  log_to_stdout if options[:log_stdout] #是否打印 log 到标准输出

  super # Rack::Server.start
  ...
end

private
  def print_boot_information
    ...
    puts "=&gt; Run `rails server -h` for more startup options"
  end

  def create_tmp_directories
    %w(cache pids sockets).each do |dir_to_make|
      FileUtils.mkdir_p(File.join(Rails.root, 'tmp', dir_to_make))
    end
  end

  def setup_dev_caching
    if options[:environment] == "development"
      Rails::DevCaching.enable_by_argument(options[:caching])
    end
  end

  def log_to_stdout
    wrapped_app # 对应用执行 touch 操作，以便设置记录器

    console = ActiveSupport::Logger.new(STDOUT)
    console.formatter = Rails.logger.formatter
    console.level = Rails.logger.level

    unless ActiveSupport::Logger.logger_outputs_to?(Rails.logger, STDOUT)
    Rails.logger.extend(ActiveSupport::Logger.broadcast(console))
  end
</code></pre>

<p>这是<code>Rails</code>初始化过程中第一次输出信息. <code>start</code>方法为<code>INT</code>信号创建了一个陷阱, 只要在服务器运行时按下<code>CTRL+C</code>, 服务器进程就会退出.
上述代码还会创建<code>tmp/cache</code> <code>tmp/pids</code> <code>tmp/sockets</code>文件夹, 用于存放 <code>socket</code>.</p>

<p>最后调用<code>wrapped_app</code>方法, 作用就是先创建一个<code>Rack应用</code>, 然后创建<code>ActiveSupport::Logger</code>实例.</p>

<p>在<code>Rack应用(二)</code> 中我们曾研究过<code>wrapped_app</code>以及<code>server.start</code>方法:</p>

<pre><code class="language-ruby"># rack/lib/rack/server.rb
def start &amp;blk

  # 关键点(一)
  wrapped_app

  # 关键点(二)
  server.run wrapped_app, options, &amp;blk
end

def wrapped_app
  @wrapped_app ||= build_app app
end
</code></pre>

<ul>
  <li>wrapped_app: 构建一个完成的 app.
    <ul>
      <li>其中 <code>app</code>就是执行 <code>config.ru</code>文件, 最终得到一个应用APP</li>
      <li>build_ap 作用就是在得到的app的上层包装上<code>server</code>的<code>middleware</code>
</li>
    </ul>
  </li>
  <li>server.run: 最终启动 server</li>
</ul>

<p>在执行<code>config.ru</code>文件的过程中, 又涉及到了<code>rails</code>启动过程中的步骤 5 - 11.</p>

<pre><code class="language-ruby"># config.ru
# This file is used by Rack-based servers to start the application.

require_relative 'config/environment'

run Rails.application

</code></pre>

<p><code>Rails</code>初始化过程中的大部分工作都是在这一步中完成.
** <code>rails server</code> 指令可以使用 <code>rackup config.ru</code> 代替 **</p>

<p>在 <code>config.ru</code>文件中, 加载 <code>config/environment.rb</code>文件中的第一行代码先被执行:</p>

<pre><code class="language-ruby">require_relative 'config/environment'
</code></pre>

<h5 id="configenvironmentrb">
<a id="configenvironmentrb" class="anchor" href="#configenvironmentrb" aria-hidden="true"><span class="octicon octicon-link"></span></a>config/environment.rb</h5>

<p><code>config.ru</code>文件和 <code>passenger</code>都需要加载此文件.这两种运行服务器的方式到此才有了交集, 此前的一切工作都是围绕<code>Rack</code>以及<code>Rails</code>配置进行的.
此文件首先加载<code>config/application.rb</code>文件:</p>
<pre><code class="language-ruby"># Load the Rails application.
require_relative 'application'

# Initialize the Rails application.
Rails.application.initialize!

</code></pre>

<h4 id="configapplicationrb-1">
<a id="configapplicationrb-1" class="anchor" href="#configapplicationrb-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>config/application.rb</h4>

<p>此文件会加载<code>config/boot.rb</code>文件:</p>

<pre><code class="language-ruby">ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../Gemfile', __dir__)

require 'bundler/setup' # Set up gems listed in the Gemfile.
</code></pre>

<p>对于<code>rails server</code>这种启动方式, 之前并为加载<code>config/boot.rb</code>文件, 因此这里会加载该文件; 像<code>passenger</code>之前已经加载过该文件, 这里就不会重复加载了.</p>

<h3 id="加载-rails">
<a id="加载-rails" class="anchor" href="#%E5%8A%A0%E8%BD%BD-rails" aria-hidden="true"><span class="octicon octicon-link"></span></a>加载 Rails</h3>

<p><code>config/application.rb</code>文件的下一行就是:</p>
<pre><code class="language-ruby">require 'rails/all'
</code></pre>

<p>我们可以查看<code>rails/all</code>的源码:</p>

<pre><code class="language-ruby">
require "rails"

%w(
  active_record/railtie
  action_controller/railtie
  action_view/railtie
  action_mailer/railtie
  active_job/railtie
  action_cable/engine
  rails/test_unit/railtie
  sprockets/railtie
).each do |railtie|
  begin
    require railtie
  rescue LoadError
  end
end
</code></pre>

<p>此文件负责加载<code>Rails</code>中所有独立的框架.
这些框架加载完成之后, 就可以在<code>Rails</code>应用中使用了.</p>

<h5 id="回到-configenvironmentrb-文件">
<a id="回到-configenvironmentrb-文件" class="anchor" href="#%E5%9B%9E%E5%88%B0-configenvironmentrb-%E6%96%87%E4%BB%B6" aria-hidden="true"><span class="octicon octicon-link"></span></a>回到 config/environment.rb 文件</h5>

<p>config/application.rb 文件的其余部分定义了 Rails::Application 的配置，当应用的初始化全部完成后就会使用这些配置。当 config/application.rb 文件完成了 Rails 的加载和应用命名空间的定义后，程序执行流程再次回到 config/environment.rb 文件。在这里会通过 rails/application.rb 文件中定义的 Rails.application.initialize! 方法完成应用的初始化。</p>

<h5 id="railtieslibrailsapplicationrb">
<a id="railtieslibrailsapplicationrb" class="anchor" href="#railtieslibrailsapplicationrb" aria-hidden="true"><span class="octicon octicon-link"></span></a>railties/lib/rails/application.rb</h5>

<pre><code class="language-ruby"># rails/railties/lib/rails/application.rb
def initialize!(group=:default) #:nodoc:
  raise "Application has been already initialized." if @initialized
  run_initializers(group, self) # 执行所有的注册的 initializers
  @initialized = true
  self
end
</code></pre>
<p>我们可以看到一个应用只能被初始化一次. <code>railties/lib/rails/initializable.rb</code>文件中定义的<code>run_initializers</code>方法负责运行初始化程序:</p>

<pre><code class="language-ruby"># rails/railties/lib/rails/initializable.rb
def run_initializers(group=:default, *args)
  return if instance_variable_defined?(:@ran)
  # initializers 在 rails/application.rb文件中被覆写
  initializers.tsort_each do |initializer|
    initializer.run(*args) if initializer.belongs_to?(group)
  end
  @ran = true
end

# rails/railties/lib/rails/application.rb
def initializers #:nodoc:
  Bootstrap.initializers_for(self) +
  railties_initializers(super) +
  Finisher.initializers_for(self)
end

</code></pre>

<p>run_initializers 方法的代码比较复杂，Rails 会遍历所有类的祖先，以查找能够响应 initializers 方法的类。对于找到的类，首先按名称排序，然后依次调用 initializers 方法。例如，Engine 类通过为所有的引擎提供 initializers 方法而使它们可用。</p>

<p>在Rails中的<code>initializer</code>分为以下三类:</p>

<ul>
  <li>Bootstrap 的 initializer</li>
  <li>Application, Engine, Railtie 注册的 initializer</li>
  <li>Finisher的 initializer</li>
</ul>

<p>railties/lib/rails/application.rb 文件中定义的 Rails::Application 类，定义了 bootstrap、railtie 和 finisher 初始化程序。bootstrap 初始化程序负责完成应用初始化的准备工作（例如初始化记录器），而 finisher 初始化程序（例如创建中间件栈）总是最后运行。railtie 初始化程序在 Rails::Application 类自身中定义，在 bootstrap 之后、finishers 之前运行。</p>

<p>启动流程中的步骤 5 – 11 都是一些特定的initializer来执行.</p>

<h5 id="步骤5-load-configenviromentsenvrb">
<a id="步骤5-load-configenviromentsenvrb" class="anchor" href="#%E6%AD%A5%E9%AA%A45-load-configenviromentsenvrb" aria-hidden="true"><span class="octicon octicon-link"></span></a>步骤5: Load config/enviroments/ENV.rb</h5>

<pre><code class="language-ruby"># rails/railties/lib/rails/engine.rb
# 这个就是启动流程中的 5) Load config/environments/ENV.rb, 特别注意这里用了before
initializer :load_environment_config, before: :load_environment_hook, group: :all do
  paths["config/environments"].existent.each do |environment|
    require environment
  end
end
</code></pre>

<h5 id="步骤6-run-configbefore_initialize-callbacks">
<a id="步骤6-run-configbefore_initialize-callbacks" class="anchor" href="#%E6%AD%A5%E9%AA%A46-run-configbefore_initialize-callbacks" aria-hidden="true"><span class="octicon octicon-link"></span></a>步骤6: Run config.before_initialize callbacks</h5>

<pre><code class="language-ruby"># rails/railties/lib/rails/application/bootstrap.rb
initializer :bootstrap_hook, group: :all do |app|
  ActiveSupport.run_load_hooks(:before_initialize, app)
end
</code></pre>

<h5 id="rails应用config目录下的initializers执行的源码位置">
<a id="rails应用config目录下的initializers执行的源码位置" class="anchor" href="#rails%E5%BA%94%E7%94%A8config%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84initializers%E6%89%A7%E8%A1%8C%E7%9A%84%E6%BA%90%E7%A0%81%E4%BD%8D%E7%BD%AE" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rails应用config目录下的initializers执行的源码位置:</h5>

<pre><code class="language-ruby"># rails/railties/lib/rails/engine.rb
# 这里就是config目录下的initializers执行的位置
initializer :load_config_initializers do
  config.paths["config/initializers"].existent.sort.each do |initializer|
    load_config_initializer(initializer)
  end
end
</code></pre>

<h5 id="步骤9-build-the-middleware-stack-and-run-to_prepare-callbacks">
<a id="步骤9-build-the-middleware-stack-and-run-to_prepare-callbacks" class="anchor" href="#%E6%AD%A5%E9%AA%A49-build-the-middleware-stack-and-run-to_prepare-callbacks" aria-hidden="true"><span class="octicon octicon-link"></span></a>步骤9: Build the middleware stack and run to_prepare callbacks</h5>
<p>build_middleware_stack，该方法alias到app方法，这个方法是个重要的方法，这里就是把所有middleware都一层一层嵌套然后得到最终的app。</p>

<pre><code class="language-ruby"># rails/railties/lib/rails/application/finisher.rb
initializer :build_middleware_stack do
  build_middleware_stack
end
</code></pre>

<p>This needs to happen before eager load so it happens</p>

<p>in exactly the same point regardless of config.cache_classes</p>

<h5 id="9-run-to_prepare-callbacks">
<a id="9-run-to_prepare-callbacks" class="anchor" href="#9-run-to_prepare-callbacks" aria-hidden="true"><span class="octicon octicon-link"></span></a>9) run to_prepare callbacks</h5>

<p>initializer :run_prepare_callbacks do
  ActionDispatch::Reloader.prepare!
end</p>

<h5 id="步骤10-run-configbefore_eager_load-and-eager_load-if-eager_load-is-true">
<a id="步骤10-run-configbefore_eager_load-and-eager_load-if-eager_load-is-true" class="anchor" href="#%E6%AD%A5%E9%AA%A410-run-configbefore_eager_load-and-eager_load-if-eager_load-is-true" aria-hidden="true"><span class="octicon octicon-link"></span></a>步骤10: Run config.before_eager_load and eager_load! if eager_load is true</h5>

<pre><code class="language-ruby"># rails/railties/lib/rails/application/finisher.rb
initializer :eager_load! do
  if config.eager_load
    ActiveSupport.run_load_hooks(:before_eager_load, self)
    config.eager_load_namespaces.each(&amp;:eager_load!)
  end
end
</code></pre>

<h5 id="步骤11-run-configafter_initialize-callbacks">
<a id="步骤11-run-configafter_initialize-callbacks" class="anchor" href="#%E6%AD%A5%E9%AA%A411-run-configafter_initialize-callbacks" aria-hidden="true"><span class="octicon octicon-link"></span></a>步骤11: Run config.after_initialize callbacks</h5>

<pre><code class="language-ruby"># rails/railties/lib/rails/application/finisher.rb
# All initialization is done, including eager loading in production
initializer :finisher_hook do
  ActiveSupport.run_load_hooks(:after_initialize, self)
end

</code></pre>
<p>应用初始化完成后，程序执行流程再次回到 Rack::Server 类。</p>

<h4 id="rack-librackserverrb-1">
<a id="rack-librackserverrb-1" class="anchor" href="#rack-librackserverrb-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rack: lib/rack/server.rb</h4>

<p>程序执行流程上一次离开此文件是定义<code>app</code>方法时:</p>
<pre><code class="language-ruby">def app
  @app ||= options[:builder] ? build_app_from_string : build_app_and_options_from_config
end
...
private
def build_app_and_options_from_config
  if !::File.exist? options[:config]
    abort "configuration #{options[:config]} not found"
  end

  app, options = Rack::Builder.parse_file(self.options[:config], opt_parser)
  self.options.merge! options
  app
end

def build_app_from_string
  Rack::Builder.new_from_string(self.options[:builder])
end
</code></pre>

<p>此时，app 就是 Rails 应用本身（一个中间件），接下来 Rack 会调用所有已提供的中间件：</p>
<pre><code class="language-ruby">
def build_app(app)
  middleware[options[:environment]].reverse_each do |middleware|
    middleware = middleware.call(self) if middleware.respond_to?(:call)
    next unless middleware
    klass = middleware.shift
    app = klass.new(app, *middleware)
  end
  app
end
</code></pre>

<p>在 Server#start 方法定义的最后一行代码中，通过 wrapped_app 方法调用了 build_app 方法。让我们回顾一下这行代码：</p>
<pre><code class="language-ruby">
server.run wrapped_app, options, &amp;blk

</code></pre>

<p>server.run 方法的实现方式取决于我们所使用的服务器。例如，如果使用的是 Puma，run 方法的实现方式如下：</p>
<pre><code class="language-ruby">...
DEFAULT_OPTIONS = {
  :Host =&gt; '0.0.0.0',
  :Port =&gt; 8080,
  :Threads =&gt; '0:16',
  :Verbose =&gt; false
}

def self.run(app, options = {})
  options = DEFAULT_OPTIONS.merge(options)

  if options[:Verbose]
    app = Rack::CommonLogger.new(app, STDOUT)
  end

  if options[:environment]
    ENV['RACK_ENV'] = options[:environment].to_s
  end

  server   = ::Puma::Server.new(app)
  min, max = options[:Threads].split(':', 2)

  puts "Puma #{::Puma::Const::PUMA_VERSION} starting..."
  puts "* Min threads: #{min}, max threads: #{max}"
  puts "* Environment: #{ENV['RACK_ENV']}"
  puts "* Listening on tcp://#{options[:Host]}:#{options[:Port]}"

  server.add_tcp_listener options[:Host], options[:Port]
  server.min_threads = min
  server.max_threads = max
  yield server if block_given?

  begin
    server.run.join
  rescue Interrupt
    puts "* Gracefully stopping, waiting for requests to finish"
    server.stop(true)
    puts "* Goodbye!"
  end

end
</code></pre>

<p>上面就是 Rails 初始化过程的最后一步了。</p>


      <h3>关于图片和转载</h3>

      <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可。

      转载时请注明原文链接，图片在使用时请保留图片中的全部内容，可适当缩放并在引用处附上图片所在的文章链接，图片使用 Sketch 进行绘制。

      <h3>关于评论和留言</h3>

      如果对本文 <a href="/rack-rails">Ruby Rack 协议及其应用(三)</a> 的内容有疑问，请在下面的评论系统中留言，谢谢。

      <blockquote>
        <p>原文链接：<a href="/rack-rails">Ruby Rack 协议及其应用(三) · 雄关漫道真如铁</a></p>

        <p>Follow: <a href="https://github.com/nju520">nju520 · GitHub</a></p>
      </blockquote>

    </section>

    <footer class="post-footer">

      <!-- Everything inside the #author tags pulls data from the author -->
      <!-- #author-->

      
      <figure class="author-image">
        <a class="img" href="https://github.com/nju520" style="background-image: url(/assets/images/hacker.png)"><span class="hidden">'s Picture</span></a>
      </figure>
      

      <section class="author">
        <h4><a href="https://github.com/nju520">nju520</a></h4>

        
        <p> Ruby / Go / JS</p>
        
        <div class="author-meta">
          <span class="author-location icon-location"> Hangzhou, China</span>
          <span class="author-link icon-link"><a href="http://localhost:4000"> hwbnju.com</a></span>
        </div>
      </section>

      <!-- /author  -->

      <section class="share">
        <h4>Share this post</h4>
        <a class="icon-twitter" href="http://twitter.com/share?text=Ruby Rack 协议及其应用(三)&amp;url=http://localhost:4000rack-rails"
          onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
          <span class="hidden">Twitter</span>
        </a>
        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000rack-rails"
          onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
          <span class="hidden">Facebook</span>
        </a>
        <a class="icon-google-plus" href="https://plus.google.com/share?url=http://localhost:4000rack-rails"
          onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
          <span class="hidden">Google+</span>
        </a>
      </section>

      <div id="gitalk-container"></div>
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
      <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
      <script>
       const gitalk = new Gitalk({
         clientID: 'e552ed507a5a4581d8a1',
         clientSecret: '0abbd4193a0f9b2700936214ff6fda088c665a73',
         repo: 'bobo-comments',
         owner: 'nju520',
         admin: ['nju520'],
         // labels: ['Gitalk', 'gitment'].concat(["Rack系列","rack","ruby","rails","server"]),
         // id: location.origin + location.pathname,
         id: "http://hwbnju.com/rack-rails",
         distractionFreeMode: false
       });

       gitalk.render('gitalk-container')
      </script>

    </footer>

  </article>

</main>

<aside class="read-next">

  <!-- [[! next_post ]] -->
  
  <a class="read-next-story no-cover" href="how-rails-session-work">
    <section class="post">
      <h2>Rails Sessions 原理</h2>
      <p>如果 Rails 不能告诉你谁在访问你的网站？如果你不知道同一个人在访问2个不同的页面？ 如果所有的数据在你返回 response 之前都消失的话？ 对于一个静态网站来说也许没有问题。但是大多数应用程序需要存储一个用户的数据的。可能是一个 用户 id 或者 选择的语言偏好，或者他们通过 iPad 访问你的网站，想看看桌面的版本。 session 是一个非常好的地方来放置这些数据。一般是存储一些不止一个请求需要用的数据。...</p>
    </section>
  </a>
  
  <!-- [[! /next_post ]] -->
  <!-- [[! prev_post ]] -->
  
  <a class="read-next-story prev no-cover" href="tcp-scokets-no-block">
    <section class="post">
      <h2>TCP Socket 编程 -- 非阻塞式 IO</h2>
      <p>非阻塞式读操作 还记得我们之前学过的Socket#read吗? 它会一直保持阻塞, 直到接收到EOF或者获得指定的最小字节数为止. 如果客户端没有发送EOF, 就可能会导致阻塞. 这种情况虽然可以通过readpartial暂时解决, readpartial会立刻返回所有的可用数据. 但是如果没有数据可用, 那么readpartial也会陷入阻塞状态. 我们可以使用read_nonblock来实现非阻塞式读操作. 和readpartial 非常类似, read_nonblock需要一个整数的参数, 指定需要读取的最大字节数....</p>
    </section>
  </a>
  
  <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


      <footer class="site-footer clearfix">
        <section class="copyright"><a href="/">雄关漫道真如铁</a> &copy; 2019</section>
        <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/biomadeira/jasper">Jasper</a></section>
      </footer>
    </div>
    <!-- [[! Ghost outputs important scripts and data with this tag ]] -->
    <script type="text/javascript" src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
    <!-- [[! The main JavaScript file for Casper ]] -->
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="/assets/js/index.js"></script>
    <script type="text/javascript" src="/assets/js/prism.js"></script>
    <script type="text/javascript" src="/assets/js/toc.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  </body>
</html>
